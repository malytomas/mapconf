/*!
 * Copyright (c) 2017 Melown Technologies SE
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * *  Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 */
var vts =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 183);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PJD_3PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return PJD_7PARAM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return PJD_WGS84; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return PJD_NODATUM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return SEC_TO_RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HALF_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return SIXTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return RA4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return RA6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return EPSLN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return D2R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return R2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FORTPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TWO_PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SPI; });
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;
var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return vec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return vec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return mat4; });


var vec2 = {};


vec2.create = function (a) {
    var b = new Array(2);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
    }
    return b;
};


var vec4 = {};


vec4.create = function (a) {
    var b = new Array(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};


vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};


vec4.dot2 = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3];
};


vec4.dot3 = function (a, b, i, x, y, z) {
    return a[0] * (b[i]-x) + a[1] * (b[i+1]-y) + a[2] * (b[i+2]-z) + a[3];
};


var vec3 = {};


vec3.create = function (a) {
    var b = new Array(3);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
    }
    return b;
};


vec3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    return b;
};


vec3.add = function (a, b, c) {
    if (!c || a == c) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
        return a;
    }
    c[0] = a[0] + b[0];
    c[1] = a[1] + b[1];
    c[2] = a[2] + b[2];
    return c;
};


vec3.subtract = function (a, b, c) {
    if (!c || a == c) {
        a[0] -= b[0];
        a[1] -= b[1];
        a[2] -= b[2];
        return a;
    }
    c[0] = a[0] - b[0];
    c[1] = a[1] - b[1];
    c[2] = a[2] - b[2];
    return c;
};


vec3.negate = function (a, b) {
    b || (b = a);
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    return b;
};


vec3.scale = function (a, b, c) {
    if (!c || a == c) {
        a[0] *= b;
        a[1] *= b;
        a[2] *= b;
        return a;
    }
    c[0] = a[0] * b;
    c[1] = a[1] * b;
    c[2] = a[2] * b;
    return c;
};


vec3.normalize = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return b;
};


vec3.normalize2 = function (a, i, b) {
    var c = a[i],
        d = a[i+1],
        e = a[i+2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
};


vec3.normalize3 = function (a, i, b, j) {
    var c = a[i],
        d = a[i+1],
        e = a[i+2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[j] = c;
            b[j+1] = d;
            b[j+2] = e;
            return b;
        }
    } else {
        b[j] = 0;
        b[j+1] = 0;
        b[j+2] = 0;
        return b;
    }
    g = 1 / g;
    b[j] = c * g;
    b[j+1] = d * g;
    b[j+2] = e * g;
};


vec3.normalize4 = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = Math.sqrt(c * c + d * d + e * e);
    if (g) {
        if (g == 1) {
            b[0] = c;
            b[1] = d;
            b[2] = e;
            return b;
        }
    } else {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        return b;
    }
    var dd = g;
    g = 1 / g;
    b[0] = c * g;
    b[1] = d * g;
    b[2] = e * g;
    return dd;
};


vec3.cross = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1];
    a = a[2];
    var g = b[0],
        f = b[1];
    b = b[2];
    c[0] = e * b - a * f;
    c[1] = a * g - d * b;
    c[2] = d * f - e * g;
    return c;
};


vec3.length = function (a) {
    var b = a[0],
        c = a[1];
    a = a[2];
    return Math.sqrt(b * b + c * c + a * a);
};


vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};


vec3.dot2 = function (a, b, i) {
    return a[0] * b[i] + a[1] * b[i+1] + a[2] * b[i+2];
};


vec3.dot3 = function (a, i, b, j) {
    return a[i] * b[j] + a[i+1] * b[j+1] + a[i+2] * b[j+2];
};


vec3.squareDistance = function (a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    var dz = b[2] - a[2];
    return dx*dx + dy*dy + dz*dz;
};


vec3.direction = function (a, b, c) {
    c || (c = a);
    var d = a[0] - b[0],
        e = a[1] - b[1];
    a = a[2] - b[2];
    b = Math.sqrt(d * d + e * e + a * a);
    if (!b) {
        c[0] = 0;
        c[1] = 0;
        c[2] = 0;
        return c;
    }
    b = 1 / b;
    c[0] = d * b;
    c[1] = e * b;
    c[2] = a * b;
    return c;
};


vec3.lerp = function (a, b, c, d) {
    d || (d = a);
    d[0] = a[0] + c * (b[0] - a[0]);
    d[1] = a[1] + c * (b[1] - a[1]);
    d[2] = a[2] + c * (b[2] - a[2]);
    return d;
};


vec3.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ']';
};


var mat3 = {};


mat3.create = function (a) {
    var b = new Array(9);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
    }
    return b;
};


mat3.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    return b;
};


mat3.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 1;
    a[5] = 0;
    a[6] = 0;
    a[7] = 0;
    a[8] = 1;
    return a;
};


mat3.transpose = function (a, b) {
    if (!b || a == b) {
        var c = a[1],
            d = a[2],
            e = a[5];
        a[1] = a[3];
        a[2] = a[6];
        a[3] = c;
        a[5] = a[7];
        a[6] = d;
        a[7] = e;
        return a;
    }
    b[0] = a[0];
    b[1] = a[3];
    b[2] = a[6];
    b[3] = a[1];
    b[4] = a[4];
    b[5] = a[7];
    b[6] = a[2];
    b[7] = a[5];
    b[8] = a[8];
    return b;
};


mat3.toMat4 = function (a, b) {
    b || (b = mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = 0;
    b[4] = a[3];
    b[5] = a[4];
    b[6] = a[5];
    b[7] = 0;
    b[8] = a[6];
    b[9] = a[7];
    b[10] = a[8];
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};

mat3.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1];
    b = b[2];
    c[0] = a[0] * d + a[3] * e + a[6] * b;
    c[1] = a[1] * d + a[4] * e + a[7] * b;
    c[2] = a[2] * d + a[5] * e + a[8] * b;
    return c;
};


mat3.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ']';
};


var mat4 = {};


mat4.create = function (a) {
    var b = new Array(16);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        b[9] = a[9];
        b[10] = a[10];
        b[11] = a[11];
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        b[15] = a[15];
    }
    return b;
};


mat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    b[15] = a[15];
    return b;
};


mat4.identity = function (a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = 1;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 1;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return a;
};


mat4.transpose = function (a, b) {
    if (!b || a == b) {
        var c = a[1],
            d = a[2],
            e = a[3],
            g = a[6],
            f = a[7],
            h = a[11];
        a[1] = a[4];
        a[2] = a[8];
        a[3] = a[12];
        a[4] = c;
        a[6] = a[9];
        a[7] = a[13];
        a[8] = d;
        a[9] = g;
        a[11] = a[14];
        a[12] = e;
        a[13] = f;
        a[14] = h;
        return a;
    }
    b[0] = a[0];
    b[1] = a[4];
    b[2] = a[8];
    b[3] = a[12];
    b[4] = a[1];
    b[5] = a[5];
    b[6] = a[9];
    b[7] = a[13];
    b[8] = a[2];
    b[9] = a[6];
    b[10] = a[10];
    b[11] = a[14];
    b[12] = a[3];
    b[13] = a[7];
    b[14] = a[11];
    b[15] = a[15];
    return b;
};


mat4.determinant = function (a) {
    var b = a[0],
        c = a[1],
        d = a[2],
        e = a[3],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[7],
        j = a[8],
        k = a[9],
        l = a[10],
        o = a[11],
        m = a[12],
        n = a[13],
        p = a[14];
    a = a[15];
    return m * k * h * e - j * n * h * e - m * f * l * e + g * n * l * e + j * f * p * e - g * k * p * e - m * k * d * i + j * n * d * i + m * c * l * i - b * n * l * i - j * c * p * i + b * k * p * i + m * f * d * o - g * n * d * o - m * c * h * o + b * n * h * o + g * c * p * o - b * f * p * o - j * f * d * a + g * k * d * a + j * c * h * a - b * k * h * a - g * c * l * a + b * f * l * a;
};


mat4.inverse = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = a[4],
        h = a[5],
        i = a[6],
        j = a[7],
        k = a[8],
        l = a[9],
        o = a[10],
        m = a[11],
        n = a[12],
        p = a[13],
        r = a[14],
        s = a[15],
        A = c * h - d * f,
        B = c * i - e * f,
        t = c * j - g * f,
        u = d * i - e * h,
        v = d * j - g * h,
        w = e * j - g * i,
        x = k * p - l * n,
        y = k * r - o * n,
        z = k * s - m * n,
        C = l * r - o * p,
        D = l * s - m * p,
        E = o * s - m * r,
        q = 1 / (A * E - B * D + t * C + u * z - v * y + w * x);
    b[0] = (h * E - i * D + j * C) * q;
    b[1] = (-d * E + e * D - g * C) * q;
    b[2] = (p * w - r * v + s * u) * q;
    b[3] = (-l * w + o * v - m * u) * q;
    b[4] = (-f * E + i * z - j * y) * q;
    b[5] = (c * E - e * z + g * y) * q;
    b[6] = (-n * w + r * t - s * B) * q;
    b[7] = (k * w - o * t + m * B) * q;
    b[8] = (f * D - h * z + j * x) * q;
    b[9] = (-c * D + d * z - g * x) * q;
    b[10] = (n * v - p * t + s * A) * q;
    b[11] = (-k * v + l * t - m * A) * q;
    b[12] = (-f * C + h * y - i * x) * q;
    b[13] = (c * C - d * y + e * x) * q;
    b[14] = (-n * u + p * B - r * A) * q;
    b[15] = (k * u - l * B + o * A) * q;
    return b;
};


mat4.toRotationMat = function (a, b) {
    b || (b = mat4.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};


mat4.toMat3 = function (a, b) {
    b || (b = mat3.create());
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[4];
    b[4] = a[5];
    b[5] = a[6];
    b[6] = a[8];
    b[7] = a[9];
    b[8] = a[10];
    return b;
};


mat4.toInverseMat3 = function (a, b) {
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[4],
        f = a[5],
        h = a[6],
        i = a[8],
        j = a[9],
        k = a[10],
        l = k * f - h * j,
        o = -k * g + h * i,
        m = j * g - f * i,
        n = c * l + d * o + e * m;
    if (!n) return null;
    n = 1 / n;
    b || (b = mat3.create());
    b[0] = l * n;
    b[1] = (-k * d + e * j) * n;
    b[2] = (h * d - e * f) * n;
    b[3] = o * n;
    b[4] = (k * c - e * i) * n;
    b[5] = (-h * c + e * g) * n;
    b[6] = m * n;
    b[7] = (-j * c + d * i) * n;
    b[8] = (f * c - d * g) * n;
    return b;
};


mat4.multiply = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1],
        g = a[2],
        f = a[3],
        h = a[4],
        i = a[5],
        j = a[6],
        k = a[7],
        l = a[8],
        o = a[9],
        m = a[10],
        n = a[11],
        p = a[12],
        r = a[13],
        s = a[14];
    a = a[15];
    var A = b[0],
        B = b[1],
        t = b[2],
        u = b[3],
        v = b[4],
        w = b[5],
        x = b[6],
        y = b[7],
        z = b[8],
        C = b[9],
        D = b[10],
        E = b[11],
        q = b[12],
        F = b[13],
        G = b[14];
    b = b[15];
    c[0] = A * d + B * h + t * l + u * p;
    c[1] = A * e + B * i + t * o + u * r;
    c[2] = A * g + B * j + t * m + u * s;
    c[3] = A * f + B * k + t * n + u * a;
    c[4] = v * d + w * h + x * l + y * p;
    c[5] = v * e + w * i + x * o + y * r;
    c[6] = v * g + w * j + x * m + y * s;
    c[7] = v * f + w * k + x * n + y * a;
    c[8] = z * d + C * h + D * l + E * p;
    c[9] = z * e + C * i + D * o + E * r;
    c[10] = z *
        g + C * j + D * m + E * s;
    c[11] = z * f + C * k + D * n + E * a;
    c[12] = q * d + F * h + G * l + b * p;
    c[13] = q * e + F * i + G * o + b * r;
    c[14] = q * g + F * j + G * m + b * s;
    c[15] = q * f + F * k + G * n + b * a;
    return c;
};


mat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1];
    b = b[2];
    c[0] = a[0] * d + a[4] * e + a[8] * b + a[12];
    c[1] = a[1] * d + a[5] * e + a[9] * b + a[13];
    c[2] = a[2] * d + a[6] * e + a[10] * b + a[14];
    return c;
};


mat4.multiplyVec4 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1],
        g = b[2];
    b = b[3];
    c[0] = a[0] * d + a[4] * e + a[8] * g + a[12] * b;
    c[1] = a[1] * d + a[5] * e + a[9] * g + a[13] * b;
    c[2] = a[2] * d + a[6] * e + a[10] * g + a[14] * b;
    c[3] = a[3] * d + a[7] * e + a[11] * g + a[15] * b;
    return c;
};


mat4.translate = function (a, b, c) {
    var d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[12] = a[0] * d + a[4] * e + a[8] * b + a[12];
        a[13] = a[1] * d + a[5] * e + a[9] * b + a[13];
        a[14] = a[2] * d + a[6] * e + a[10] * b + a[14];
        a[15] = a[3] * d + a[7] * e + a[11] * b + a[15];
        return a;
    }
    var g = a[0],
        f = a[1],
        h = a[2],
        i = a[3],
        j = a[4],
        k = a[5],
        l = a[6],
        o = a[7],
        m = a[8],
        n = a[9],
        p = a[10],
        r = a[11];
    c[0] = g;
    c[1] = f;
    c[2] = h;
    c[3] = i;
    c[4] = j;
    c[5] = k;
    c[6] = l;
    c[7] = o;
    c[8] = m;
    c[9] = n;
    c[10] = p;
    c[11] = r;
    c[12] = g * d + j * e + m * b + a[12];
    c[13] = f * d + k * e + n * b + a[13];
    c[14] = h * d + l * e + p * b + a[14];
    c[15] = i * d + o * e + r * b + a[15];
    return c;
};


mat4.scale = function (a, b, c) {
    var d = b[0],
        e = b[1];
    b = b[2];
    if (!c || a == c) {
        a[0] *= d;
        a[1] *= d;
        a[2] *= d;
        a[3] *= d;
        a[4] *= e;
        a[5] *= e;
        a[6] *= e;
        a[7] *= e;
        a[8] *= b;
        a[9] *= b;
        a[10] *= b;
        a[11] *= b;
        return a;
    }
    c[0] = a[0] * d;
    c[1] = a[1] * d;
    c[2] = a[2] * d;
    c[3] = a[3] * d;
    c[4] = a[4] * e;
    c[5] = a[5] * e;
    c[6] = a[6] * e;
    c[7] = a[7] * e;
    c[8] = a[8] * b;
    c[9] = a[9] * b;
    c[10] = a[10] * b;
    c[11] = a[11] * b;
    c[12] = a[12];
    c[13] = a[13];
    c[14] = a[14];
    c[15] = a[15];
    return c;
};


mat4.rotate = function (a, b, c, d) {
    var e = c[0],
        g = c[1];
    c = c[2];
    var f = Math.sqrt(e * e + g * g + c * c);
    if (!f) return null;
    if (f != 1) {
        f = 1 / f;
        e *= f;
        g *= f;
        c *= f;
    }
    var h = Math.sin(b),
        i = Math.cos(b),
        j = 1 - i;
    b = a[0];
    f = a[1];
    var k = a[2],
        l = a[3],
        o = a[4],
        m = a[5],
        n = a[6],
        p = a[7],
        r = a[8],
        s = a[9],
        A = a[10],
        B = a[11],
        t = e * e * j + i,
        u = g * e * j + c * h,
        v = c * e * j - g * h,
        w = e * g * j - c * h,
        x = g * g * j + i,
        y = c * g * j + e * h,
        z = e * c * j + g * h;
    e = g * c * j - e * h;
    g = c * c * j + i;
    if (d) {
        if (a != d) {
            d[12] = a[12];
            d[13] = a[13];
            d[14] = a[14];
            d[15] = a[15];
        }
    } else d = a;
    d[0] = b * t + o * u + r * v;
    d[1] = f * t + m * u + s * v;
    d[2] = k * t + n * u + A * v;
    d[3] = l * t + p * u + B *
        v;
    d[4] = b * w + o * x + r * y;
    d[5] = f * w + m * x + s * y;
    d[6] = k * w + n * x + A * y;
    d[7] = l * w + p * x + B * y;
    d[8] = b * z + o * e + r * g;
    d[9] = f * z + m * e + s * g;
    d[10] = k * z + n * e + A * g;
    d[11] = l * z + p * e + B * g;
    return d;
};


mat4.rotateX = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[4],
        g = a[5],
        f = a[6],
        h = a[7],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[0] = a[0];
            c[1] = a[1];
            c[2] = a[2];
            c[3] = a[3];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[4] = e * b + i * d;
    c[5] = g * b + j * d;
    c[6] = f * b + k * d;
    c[7] = h * b + l * d;
    c[8] = e * -d + i * b;
    c[9] = g * -d + j * b;
    c[10] = f * -d + k * b;
    c[11] = h * -d + l * b;
    return c;
};


mat4.rotateY = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[8],
        j = a[9],
        k = a[10],
        l = a[11];
    if (c) {
        if (a != c) {
            c[4] = a[4];
            c[5] = a[5];
            c[6] = a[6];
            c[7] = a[7];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * -d;
    c[1] = g * b + j * -d;
    c[2] = f * b + k * -d;
    c[3] = h * b + l * -d;
    c[8] = e * d + i * b;
    c[9] = g * d + j * b;
    c[10] = f * d + k * b;
    c[11] = h * d + l * b;
    return c;
};


mat4.rotateZ = function (a, b, c) {
    var d = Math.sin(b);
    b = Math.cos(b);
    var e = a[0],
        g = a[1],
        f = a[2],
        h = a[3],
        i = a[4],
        j = a[5],
        k = a[6],
        l = a[7];
    if (c) {
        if (a != c) {
            c[8] = a[8];
            c[9] = a[9];
            c[10] = a[10];
            c[11] = a[11];
            c[12] = a[12];
            c[13] = a[13];
            c[14] = a[14];
            c[15] = a[15];
        }
    } else c = a;
    c[0] = e * b + i * d;
    c[1] = g * b + j * d;
    c[2] = f * b + k * d;
    c[3] = h * b + l * d;
    c[4] = e * -d + i * b;
    c[5] = g * -d + j * b;
    c[6] = f * -d + k * b;
    c[7] = h * -d + l * b;
    return c;
};


mat4.frustum = function (a, b, c, d, e, g, f) {
    f || (f = mat4.create());
    var h = b - a,
        i = d - c,
        j = g - e;
    f[0] = e * 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = e * 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = (b + a) / h;
    f[9] = (d + c) / i;
    f[10] = -(g + e) / j;
    f[11] = -1;
    f[12] = 0;
    f[13] = 0;
    f[14] = -(g * e * 2) / j;
    f[15] = 0;
    return f;
};


mat4.perspective = function (a, b, c, d, e) {
    a = c * Math.tan(a * Math.PI / 360);
    b = a * b;
    return mat4.frustum(-b, b, -a, a, c, d, e);
};


mat4.ortho = function (a, b, c, d, e, g, f) {
    f || (f = mat4.create());
    var h = b - a,
        i = d - c,
        j = g - e;
    f[0] = 2 / h;
    f[1] = 0;
    f[2] = 0;
    f[3] = 0;
    f[4] = 0;
    f[5] = 2 / i;
    f[6] = 0;
    f[7] = 0;
    f[8] = 0;
    f[9] = 0;
    f[10] = -2 / j;
    f[11] = 0;
    f[12] = -(a + b) / h;
    f[13] = -(d + c) / i;
    f[14] = -(g + e) / j;
    f[15] = 1;
    return f;
};


mat4.lookAt = function (a, b, c, d) {
    d || (d = mat4.create());
    var e = a[0],
        g = a[1];
    a = a[2];
    var f = c[0],
        h = c[1],
        i = c[2];
    c = b[1];
    var j = b[2];
    if (e == b[0] && g == c && a == j) return mat4.identity(d);
    var k, l, o, m;
    c = e - b[0];
    j = g - b[1];
    b = a - b[2];
    m = 1 / Math.sqrt(c * c + j * j + b * b);
    c *= m;
    j *= m;
    b *= m;
    k = h * b - i * j;
    i = i * c - f * b;
    f = f * j - h * c;
    m = Math.sqrt(k * k + i * i + f * f);
    if (m) {
        m = 1 / m;
        k *= m;
        i *= m;
        f *= m;
    } else f = i = k = 0;
    h = j * f - b * i;
    l = b * k - c * f;
    o = c * i - j * k;
    m = Math.sqrt(h * h + l * l + o * o);
    if (m) {
        m = 1 / m;
        h *= m;
        l *= m;
        o *= m;
    } else o = l = h = 0;
    d[0] = k;
    d[1] = h;
    d[2] = c;
    d[3] = 0;
    d[4] = i;
    d[5] = l;
    d[6] = j;
    d[7] = 0;
    d[8] = f;
    d[9] =
        o;
    d[10] = b;
    d[11] = 0;
    d[12] = -(k * e + i * g + f * a);
    d[13] = -(h * e + l * g + o * a);
    d[14] = -(c * e + j * g + b * a);
    d[15] = 1;
    return d;
};


mat4.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ']';
};


var quat4 = {};


quat4.create = function (a) {
    var b = new Array(4);
    if (a) {
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
    }
    return b;
};


quat4.set = function (a, b) {
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    return b;
};


quat4.calculateW = function (a, b) {
    var c = a[0],
        d = a[1],
        e = a[2];
    if (!b || a == b) {
        a[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
        return a;
    }
    b[0] = c;
    b[1] = d;
    b[2] = e;
    b[3] = -Math.sqrt(Math.abs(1 - c * c - d * d - e * e));
    return b;
};


quat4.inverse = function (a, b) {
    if (!b || a == b) {
        a[0] *= 1;
        a[1] *= 1;
        a[2] *= 1;
        return a;
    }
    b[0] = -a[0];
    b[1] = -a[1];
    b[2] = -a[2];
    b[3] = a[3];
    return b;
};


quat4.length = function (a) {
    var b = a[0],
        c = a[1],
        d = a[2];
    a = a[3];
    return Math.sqrt(b * b + c * c + d * d + a * a);
};


quat4.normalize = function (a, b) {
    b || (b = a);
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = Math.sqrt(c * c + d * d + e * e + g * g);
    if (f == 0) {
        b[0] = 0;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        return b;
    }
    f = 1 / f;
    b[0] = c * f;
    b[1] = d * f;
    b[2] = e * f;
    b[3] = g * f;
    return b;
};


quat4.multiply = function (a, b, c) {
    c || (c = a);
    var d = a[0],
        e = a[1],
        g = a[2];
    a = a[3];
    var f = b[0],
        h = b[1],
        i = b[2];
    b = b[3];
    c[0] = d * b + a * f + e * i - g * h;
    c[1] = e * b + a * h + g * f - d * i;
    c[2] = g * b + a * i + d * h - e * f;
    c[3] = a * b - d * f - e * h - g * i;
    return c;
};


quat4.multiplyVec3 = function (a, b, c) {
    c || (c = b);
    var d = b[0],
        e = b[1],
        g = b[2];
    b = a[0];
    var f = a[1],
        h = a[2];
    a = a[3];
    var i = a * d + f * g - h * e,
        j = a * e + h * d - b * g,
        k = a * g + b * e - f * d;
    d = -b * d - f * e - h * g;
    c[0] = i * a + d * -b + j * -h - k * -f;
    c[1] = j * a + d * -f + k * -b - i * -h;
    c[2] = k * a + d * -h + i * -f - j * -b;
    return c;
};


quat4.toMat3 = function (a, b) {
    b || (b = mat3.create());
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    var l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = k + g;
    b[4] = 1 - (j + e);
    b[5] = d - f;
    b[6] = c - h;
    b[7] = d + f;
    b[8] = 1 - (j + l);
    return b;
};


quat4.toMat4 = function (a, b) {
    b || (b = mat4.create());
    var c = a[0],
        d = a[1],
        e = a[2],
        g = a[3],
        f = c + c,
        h = d + d,
        i = e + e,
        j = c * f,
        k = c * h;
    c = c * i;
    var l = d * h;
    d = d * i;
    e = e * i;
    f = g * f;
    h = g * h;
    g = g * i;
    b[0] = 1 - (l + e);
    b[1] = k - g;
    b[2] = c + h;
    b[3] = 0;
    b[4] = k + g;
    b[5] = 1 - (j + e);
    b[6] = d - f;
    b[7] = 0;
    b[8] = c - h;
    b[9] = d + f;
    b[10] = 1 - (j + l);
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return b;
};


quat4.slerp = function (a, b, c, d) {
    d || (d = a);
    var e = c;
    if (a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3] < 0) e = -1 * c;
    d[0] = 1 - c * a[0] + e * b[0];
    d[1] = 1 - c * a[1] + e * b[1];
    d[2] = 1 - c * a[2] + e * b[2];
    d[3] = 1 - c * a[3] + e * b[3];
    return d;
};


quat4.str = function (a) {
    return '[' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ']';
};





/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__url__ = __webpack_require__(12);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utils; });




//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_0__math__["a" /* math */];
var utilsUrl = __WEBPACK_IMPORTED_MODULE_1__url__["a" /* utilsUrl */];


var utils = {};
utils.useCredentials = false;
utils.instanceCounter = 0;


utils.validateBool = function(value, defaultValue) {
    if (typeof value === 'boolean') {
        return value;
    } else {
        return defaultValue;
    }
};


utils.validateNumber = function(value, minValue, maxValue, defaultValue) {
    if (typeof value === 'number') {
        return math.clamp(value, minValue, maxValue);
    } else {
        return defaultValue;
    }
};


utils.validateNumberArray = function(array, arraySize, minValues, maxValues, defaultValues) {
    if (Array.isArray(array) && array.length == arraySize) {
        for (var i = 0; i < arraySize; i++) {
            array[i] = math.clamp(array[i], minValues[i], maxValues[i]);
        }
        return array;
    } else {
        return defaultValues;
    }
};


utils.validateString = function(value, defaultValue) {
    if (typeof value === 'string') {
        return value;
    } else {
        return defaultValue;
    }
};


utils.padNumber = function(n, width) {
    var z = '0';

    if (n < 0) {
        n = (-n) + '';
        width--;     //7
        return n.length >= width ? ('-' + n) : '-' + (new Array(width - n.length + 1).join(z) + n);
    } else {
        n = n + '';
        return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    }
};


utils.decodeFloat16 = function(binary) {
    var exponent = (binary & 0x7C00) >> 10;
    var fraction = binary & 0x03FF;
    return (binary >> 15 ? -1 : 1) * (
        exponent ?
        (
            exponent === 0x1F ?
            fraction ? NaN : Infinity :
            Math.pow(2, exponent - 15) * (1 + fraction / 0x400)
        ) :
        6.103515625e-5 * (fraction / 0x400)
    );
};


utils.simpleFmtObj = (function obj(str, obj) {
    if (!str || str == '') {
        return '';
    }

    return str.replace(/\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : s);
    });
});


utils.simpleWikiLinks = (function obj(str, plain) {
    if (!str || str == '') {
        return '';
    }

    var str2 = utils.simpleFmtObj(str, {'copy':'&copy;', 'Y': (new Date().getFullYear())}); 
    
    return str2.replace(/\[([^\]]*)\]/g, function(s, match) {
        match  = match.trim();
        var urls = match.split(' ');//, 1);
        
        if (urls[0].indexOf('//') != -1) {
            if (plain) {
                if (urls.length > 1) {
                    return '' + match.substring(urls[0].length);
                } else {
                    return '' + urls[0];
                }
            } else {
                if (urls.length > 1) {
                    return '<a href=' + urls[0] + ' target="blank">' + match.substring(urls[0].length)+'</a>';
                } else {
                    return '<a href=' + urls[0] + ' target="blank">' + urls[0]+'</a>';
                }
            }
        }
        
        return match;
    });
});


utils.simpleFmtObjOrCall = (function obj(str, obj, call) {
    if (!str || str == '') {
        return '';
    }

    return str.replace(/\{([$a-zA-Z(-9][$a-zA-Z(-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : call(match));
    });
});


utils.getABGRFromHexaCode = (function(code) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(code);

    return result ?
    [ parseInt(result[4], 16),
        parseInt(result[3], 16),
        parseInt(result[2], 16),
        parseInt(result[1], 16)]
    : [0,0,0,255];
});


utils.stringifyFunction = (function(fn) {
    // Stringify the code
    return '(' + fn + ').call(self);';
});


utils.isPowerOfTwo = (function(value) {
    return (value & (value - 1)) === 0 && value !== 0;
});


utils.nearestPowerOfTwo = (function(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
});   


utils.fitToPowerOfTwo = (function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
});   


utils.getHash = function(str) {
    if (!str || str.length === 0) {
        return 0;    
    }

    var hash = 0, c;
    for (var i = 0, li = str.length; i < li; i++) {
        c   = str.charCodeAt(i);
        hash  = ((hash << 5) - hash) + c;
        hash |= 0; // Convert to 32bit integer
    }

    return hash;
};


utils.convertRGB2YCbCr = function(r, g, b) {
  return [( .299 * r + .587 * g  +  0.114 * b) + 0,
          ( -.169 * r + -.331 * g +  0.500 * b) + 128,
          ( .500 * r + -.419 * g +  -0.081 * b) + 128];
};


utils.convertYCbCr2RGB = function(y, cb, cr) {
  return [1 * y +  0 * (cb-128)      +  1.4 * (cr-128),
          1 * y +  -.343 * (cb-128)  +  -.711 * (cr-128),
          1 * y +  1.765 * (cb-128)  +  0 * (cr-128)];
};


utils.convertHSL2RGB = function(h, s, l){
   var r, g, b, m, c, x;

    h /= 60;
    if (h < 0) h = 6 - (-h % 6);
    h %= 6;

    s = Math.max(0, Math.min(1, s / 100));
    l = Math.max(0, Math.min(1, l / 100));

    c = (1 - Math.abs((2 * l) - 1)) * s;
    x = c * (1 - Math.abs((h % 2) - 1));

    if (h < 1) {
        r = c, g = x, b = 0;
    } else if (h < 2) {
        r = x, g = c, b = 0;
    } else if (h < 3) {
        r = 0, g = c, b = x;
    } else if (h < 4) {
        r = 0, g = x, b = c;
    } else if (h < 5) {
        r = x, g = 0, b = c;
    } else {
        r = c, g = 0, b = x;
    }

    m = l - c / 2
    
    return [(r + m),
            (g + m),
            (b + m)];
}


utils.getHashColor = function(str) {
    var h = utils.getHash(str);
    var c = utils.convertRGB2YCbCr(h&255,(h>>8)&255,(h>>16)&255);
    c[0] = math.clamp(c[0], 50, 200);
    return utils.convertRGB2YCbCr(c[0],c[1],c[2]);
};


utils.getHashColor2 = function(counter) {
    var h = Math.floor(counter / 18);
    var l = 50;

    if (h >= 1) {
        if (h % 2) {
            l = 50 + ((l * 10) % 30);
        } else {
            l = 50 - (((l-1) * 10) % 30);
        }
     }

    h = (counter % 18) * 20;

    return utils.convertHSL2RGB(h,100,l);
};


utils.loadText = function(path, onLoaded, onError, withCredentials, xhrParams) {
    utils.loadJSON(path, onLoaded, onError, true, withCredentials, xhrParams);
};


utils.loadXML = function(path, onLoaded, onError, withCredentials, xhrParams) {
    var onLoaded2 = (function(data){
        var parser = new DOMParser();
        data = parser.parseFromString(data, 'text/xml');
        if (onLoaded) {
            onLoaded(data);
        }
    });

    utils.loadJSON(path, onLoaded2, onError, true, withCredentials, xhrParams);
};


utils.loadJSON = function(path, onLoaded, onError, skipParse, withCredentials, xhrParams) {
    var xhr = new XMLHttpRequest();

    //xhr.onload  = (function() {
    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0 : // UNINITIALIZED
        case 1 : // LOADING
        case 2 : // LOADED
        case 3 : // INTERACTIVE
            break;
        case 4 : // COMPLETED
    
            if (xhr.status >= 400 || xhr.status == 0) {
                if (onError) {
                    onError(xhr.status);
                }
                break;
            }
    
            var data = xhr.response;
            var parsedData = data;
                
            if (!skipParse) {
                try {
                        //var parsedData = skipParse ? data : eval("("+data+")");
                    parsedData = JSON.parse(data);
                } catch(e) {
                    // eslint-disable-next-line
                    console.log('JSON Parse Error ('+path+'): ' + (e['message'] ? e['message'] : ''));
                        
                    if (onError ) {
                        onError(xhr.status);
                    }
                
                    return;
                }
            }
                
            if (onLoaded) {
                onLoaded(parsedData);
            }
    
            break;
        }

    }).bind(this);

    /*
    xhr.onerror  = (function() {
        if (onError) {
            onError();
        }
    }).bind(this);*/

    xhr.open('GET',  path, true);
    xhr.withCredentials = withCredentials;
    
    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    if (xhrParams && xhrParams['charset']) {
        xhr.overrideMimeType('text/xml; charset=' + xhrParams['charset']);
        //xhr.setRequestHeader('Content-type', xhrParams['Content-type']);
    }
    
    xhr.send('');
};


utils.loadBinary = function(path, onLoaded, onError, withCredentials, xhrParams, responseType) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0 : // UNINITIALIZED
        case 1 : // LOADING
        case 2 : // LOADED
        case 3 : // INTERACTIVE
            break;
        case 4 : // COMPLETED
    
            if (xhr.status >= 400 || xhr.status == 0) {
                if (onError) {
                    onError(xhr.status);
                }
                break;
            }
    
            var abuffer = xhr.response;
                    
            if (!abuffer) {
                if (onError) {
                    onError();
                }
                break;
            }
                    
                    //if (!responseType || responseType == "arraybuffer") {
                        //var data = new DataView(abuffer);
                    //} else {
                      //  var data = abuffer;
                    //}
    
            if (onLoaded) {
                onLoaded(abuffer);
            }
    
            break;
    
        default:
    
            if (onError) {
                onError();
            }
    
            break;
        }

    }).bind(this);
    
    /*
    xhr.onerror  = (function() {
        if (onError) {
            onError();
        }
    }).bind(this);*/

    xhr.open('GET', path, true);
    xhr.responseType = responseType ? responseType : 'arraybuffer';
    xhr.withCredentials = withCredentials;

    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    xhr.send('');
};


utils.headRequest = function(url, onLoaded, onError, withCredentials, xhrParams) { 
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = (function (){

        switch (xhr.readyState) {
        case 0 : // UNINITIALIZED
        case 1 : // LOADING
        case 2 : // LOADED
        case 3 : // INTERACTIVE
            break;
        case 4 : // COMPLETED
            if (onLoaded != null) {
                onLoaded(xhr.getAllResponseHeaders(), xhr.status);
                    //onLoaded(xhr.getResponseHeader("X-VE-Tile-Info"), xhr.status);
            }
            break;
    
        default:
    
            if (onError != null) {
                onError();
            }
    
            break;
        }

    }).bind(this);

    xhr.onerror  = (function() {
        if (onError != null) {
            onError();
        }
    }).bind(this);

    xhr.open('HEAD', url, true);
    //xhr.responseType = responseType ? responseType : "arraybuffer";
    xhr.withCredentials = withCredentials;

    if (xhrParams && xhrParams['token'] /*&& xhrParams["tokenHeader"]*/) {
        //xhr.setRequestHeader(xhrParams["tokenHeader"], xhrParams["token"]); //old way
        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');
    }

    xhr.send('');
};


utils.loadImage = function(url, onload, onerror, withCredentials, direct) {
    var image = new Image();
    image.onerror = onerror;
    image.onload = onload;

    if (!direct){
        image.crossOrigin = withCredentials ? 'use-credentials' : 'anonymous';
    }

    image.src = url;
    return image;
};


utils.getParamsFromUrl = function(url) {
    return utilsUrl.getParamsFromUrl(url);
};


//var textDecoderUtf8 = null; //(typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;
var textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;

utils.unint8ArrayToString = function(array) {
    if (textDecoderUtf8) {
        return textDecoderUtf8.decode(array);
    } else {
//        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));

        /*
        var buff = new Uint16Array(array.buffer, array.byteOffset, array.byteLength);
        var getChar = String.fromCharCode;
        //var buff2 = new Array(buff.length);
        var str = '';

        for (var i = 0, li = buff.length; i < li; i++) {
            //buff2[i] = getChar(buff[i]);
            str += getChar(buff[i]);
        }

        return str;
        //return buff2.join('');
        */

        var s = '';
        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        var code_points2 = new Uint8Array(array.byteLength);
        code_points2.set(array);
        var code_points = new Uint32Array(code_points2.buffer);

        for (var i = 0, li = code_points.length; i < li; ++i) {
          var cp = code_points[i];
          if (cp <= 0xFFFF) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 0x10000;
            s += String.fromCharCode((cp >> 10) + 0xD800,
                                     (cp & 0x3FF) + 0xDC00);
          }
        }
        return s;

    }
}




// only implement if no native implementation is available
/*
if (typeof Array.isArray === 'undefined') {
  Array.isArray = (function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  });
}*/


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sign__ = __webpack_require__(11);




/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (Math.abs(x) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]) ? x : (x - (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sign__["a" /* default */])(x) * __WEBPACK_IMPORTED_MODULE_0__constants_values__["e" /* TWO_PI */]));
});


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__matrix__ = __webpack_require__(1);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return math; });



//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__matrix__["e" /* mat4 */];


var math = {};


math.isEqual = function(value, value2, delta) {
    return (Math.abs(value - value2) < delta);
};


math.clamp = function(value, min, max) {
    if (value < min) value = min;
    else if (value > max) value = max;

    return value;
};


math.radians = function(degrees) {
    return degrees * Math.PI / 180;
};


math.degrees = function(radians) {
    return (radians / Math.PI) * 180;
};


math.mix = function(a, b, c) {
    return a + (b - a) * c;
};


math.frustumMatrix = function(left, right, bottom, top, near, far) {
    var w = (right - left);
    var h = (top - bottom);
    var d = (far - near);

    var m = mat4.create([2*near/w, 0, (right+left)/w, 0,
        0, 2*near/h, (top+bottom)/h, 0,
        0, 0, -(far+near)/d, -2*far*near/d,
        0, 0, -1, 0]);

    mat4.transpose(m);
    return m;
};


math.perspectiveMatrix = function(fovy, aspect, near, far) {
    var ymax = near * Math.tan(fovy * Math.PI / 180.0);
    var xmax = ymax * aspect;
    return math.frustumMatrix(-xmax, xmax, -ymax, ymax, near, far);
};


math.orthographicMatrix = function(vsize, aspect, near, far) {
    //vsize *= 0.020;
    var w = vsize* 0.5 * aspect;
    var h = vsize * 0.5;
    var d = (far - near);

    var m = mat4.create([1/w, 0, 0, 0,
        0, 1/h, 0, 0,
        0, 0, -2/d, -((far+near)/d),
        0, 0, 0, 1]);

    mat4.transpose(m);
    return m;
};


math.rotationMatrix = function(axis, angle) {
    var ca = Math.cos(angle), sa = Math.sin(angle);

    /*    var m;
    switch (axis) {
    case 0:
        m = [
            1,  0,  0, 0,
            0, ca,-sa, 0,
            0, sa, ca, 0,
            0,  0,  0, 1 ];
        break;
    case 1:
        m = [
            ca, 0,-sa, 0,
            0, 1,  0,  0,
            sa, 0, ca, 0,
            0, 0,  0, 1 ];
        break;
    default:
        m = [
            ca,-sa, 0, 0,
            sa, ca, 0, 0,
            0,  0,  1, 0,
            0,  0,  0, 1 ];
        break;
    }
    mat4.transpose(m);
    return m; */

    switch (axis) {
    case 0:
        return [
            1,   0,   0,  0,
            0,  ca,  sa,  0,
            0, -sa,  ca,  0,
            0,   0,   0,  1 ];
    case 1:
        return [
             ca,  0,  sa,  0,
              0,  1,   0,  0,
            -sa,  0,  ca,  0,
              0,  0,   0,  1 ];
    default:
        return [
             ca, sa,  0,  0,
            -sa, ca,  0,  0,
              0,  0,  1,  0,
              0,  0,  0,  1 ];
    }

};


math.scaleMatrix = function(sx, sy, sz) {
    /*var m = [
        sx,  0,  0, 0,
        0, sy,  0, 0,
        0,  0, sz, 0,
        0,  0,  0, 1 ];

    mat4.transpose(m);
    return m;*/
    return [
        sx,   0,   0,   0,
        0,   sy,   0,   0,
        0,    0,  sz,   0,
        0,    0,   0,   1 ];
};


math.scaleMatrixf = function(s) {
    return math.scaleMatrix(s, s, s);
};


math.translationMatrix = function(tx, ty, tz) {
    /*
    var m = [
        1, 0, 0, tx,
        0, 1, 0, ty,
        0, 0, 1, tz,
        0, 0, 0, 1 ];

    mat4.transpose(m);
    */

    return [
        1,   0,  0,  0,
        0,   1,  0,  0,
        0,   0,  1,  0,
        tx, ty, tz,  1 ];
};


math.translationMatrix2f = function(t) {
    return math.translationMatrix(t[0], t[1], 0);
};


math.translationMatrix3f = function(t) {
    return math.translationMatrix(t[0], t[1], t[2]);
};





/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var BBox = function(xmin, ymin, zmin, xmax, ymax, zmax) {
    this.min = [];
    this.max = [];

    this.min[0] = (xmin != null) ? xmin : Number.POSITIVE_INFINITY;
    this.min[1] = (ymin != null) ? ymin : Number.POSITIVE_INFINITY;
    this.min[2] = (zmin != null) ? zmin : Number.POSITIVE_INFINITY;

    this.max[0] = (xmax != null) ? xmax : Number.NEGATIVE_INFINITY;
    this.max[1] = (ymax != null) ? ymax : Number.NEGATIVE_INFINITY;
    this.max[2] = (zmax != null) ? zmax : Number.NEGATIVE_INFINITY;

    this.updateMaxSize();
};


BBox.prototype.clone = function() {
    return new BBox(this.min[0], this.min[1], this.min[2],
                    this.max[0], this.max[1], this.max[2]);
};


BBox.prototype.side = function(index) {
    return this.max[index] - this.min[index];
};


BBox.prototype.updateMaxSize = function() {
    this.maxSize = Math.abs(Math.max(this.max[0] - this.min[0],
                                     this.max[1] - this.min[1],
                                     this.max[2] - this.min[2]));
};


BBox.prototype.center = function(vec) {
    if (vec != null) {
        vec[0] = (this.min[0] + this.max[0])*0.5;
        vec[1] = (this.min[1] + this.max[1])*0.5;
        return vec;
    } else {
        if (!this.middle) {
            this.middle = [(this.min[0] + this.max[0])*0.5, (this.min[1] + this.max[1])*0.5, (this.min[2] + this.max[2])*0.5];

            if (isNaN(this.middle[0])) {
                this.middle[0] = 0;
            }

            if (isNaN(this.middle[1])) {
                this.middle[1] = 0;
            }

            if (isNaN(this.middle[2])) {
                this.middle[2] = 0;
            }
        } 

        return this.middle;
    }
};


BBox.prototype.translateXY = function(delta) {
    return new BBox(this.min[0] - delta[0], this.min[1] - delta[1], this.min[2],
                    this.max[0] - delta[0], this.max[1] - delta[1], this.max[2]);
};


/* harmony default export */ __webpack_exports__["a"] = (BBox);



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);



//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];

var GpuTexture = function(gpu, path, core, fileSize, direct, repeat, filter, keepImage, onLoaded, onError) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.texture = null;
    this.framebuffer = null;
    this.size = 0;
    this.fileSize = fileSize; //used for stats
    this.width = 0;
    this.height = 0;
    this.repeat = repeat || false;
    this.filter = filter || 'linear';

    this.image = null;
    this.loaded = false;
    this.trilinear = false;//true;
    this.core = core;

    if (path != null) {
        this.load(path, onLoaded, onError, direct, keepImage);
    }
};

//destructor
GpuTexture.prototype.kill = function() {
    this.gl.deleteTexture(this.texture);
    
    this.texture = null;
};

// Returns GPU RAM used, in bytes.
GpuTexture.prototype.getSize = function() {
    return this.size;
};

GpuTexture.prototype.createFromData = function(lx, ly, data, filter, repeat) {
    var gl = this.gl;

    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    if (repeat){
        repeat = gl.REPEAT;
        this.repeat = true;
    } else {
        repeat = gl.CLAMP_TO_EDGE;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);
    var mipmaps = false;

    switch (filter) {
    case 'linear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        break;
    case 'trilinear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        mipmaps = true;
        break;
    default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        break;
    }

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

    if (mipmaps) {
        gl.generateMipmap(gl.TEXTURE_2D);
    }

    gl.bindTexture(gl.TEXTURE_2D, null);

    this.width = lx;
    this.height = ly;
    this.size = lx * ly * 4;
    this.loaded = true;
};

GpuTexture.prototype.createFromImage = function(image, filter, repeat, aniso) {
    var gl = this.gl;

    //filter = 'trilinear'; aniso = null; this.gpu.anisoLevel = 0;
    var width = image.naturalWidth;
    var height = image.naturalHeight;
    var data = image;

    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    if (repeat) {
        repeat = gl.REPEAT;
        this.repeat = true;
    } else {
        repeat = gl.CLAMP_TO_EDGE;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat);
    var mipmaps = false;
    this.filter = filter;

    switch (filter) {
    case 'linear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        break;
    case 'trilinear':
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        mipmaps = true;
        break;
    default:
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        break;
    }

    //resize image to nearest power of two
    if ((this.repeat || mipmaps) && (!utils.isPowerOfTwo(width) || !utils.isPowerOfTwo(height))) {
        width = utils.nearestPowerOfTwo(width);
        height = utils.nearestPowerOfTwo(height);
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height); 
        data = canvas;
    }

    var gpu = this.gpu;

    if (gpu.anisoLevel) {
        gl.texParameterf(gl.TEXTURE_2D, gpu.anisoExt.TEXTURE_MAX_ANISOTROPY_EXT, gpu.anisoLevel);
    }

    if (gpu.noTextures !== true) { //why is it here and not at the beginig of the code?
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);

        if (mipmaps) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }

    gl.bindTexture(gl.TEXTURE_2D, null);

    this.width = width;
    this.height = height;
    this.size = width * height * 4;
    this.loaded = true;
};

GpuTexture.prototype.load = function(path, onLoaded, onError, direct, keepImage) {
    this.image = utils.loadImage(path, (function () {
        if (this.core != null && this.core.killed) {
            return;
        }

        this.createFromImage(this.image, this.filter, this.repeat);
        if (!keepImage) {
            this.image = null;
        }

        if (onLoaded) {
            onLoaded();
        } else {
            if (this.core.map && this.core.map.markDirty) {
                this.core.map.markDirty();
            }
        }

    }).bind(this), (function () {

        if (this.core != null && this.core.killed) {
            return;
        }

        if (onError) {
            onError();
        }
    }).bind(this),
     
     null, direct
     
     );

};


GpuTexture.prototype.createFramebufferFromData = function(lx, ly, data) {
    var gl = this.gl;

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    framebuffer.width = lx;
    framebuffer.height = ly;

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, lx, ly, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);



    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    this.width = lx;
    this.height = ly;
    this.size = lx * ly * 4;

    this.texture = texture;
    this.renderbuffer = renderbuffer;
    this.framebuffer = framebuffer;

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};


GpuTexture.prototype.createFramebuffer = function(lx, ly) {
    if (this.texture == null){
        return;
    }

    var gl = this.gl;

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    framebuffer.width = lx;
    framebuffer.height = ly;

    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, lx, ly);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this.framebuffer = framebuffer;
    this.renderbuffer = renderbuffer;
};


GpuTexture.prototype.readFramebufferPixels = function(x, y, lx, ly, fastMode, data) {
    if (this.texture == null) {
        return;
    }

    this.gpu.bindTexture(this);

    if (!fastMode) {
        this.gpu.setFramebuffer(this);
    }

    var gl = this.gl;

    // Read the contents of the framebuffer (data stores the pixel data)
    if (!data) {
        data = new Uint8Array(lx * ly * 4);        
    }
    gl.readPixels(x, y, lx, ly, gl.RGBA, gl.UNSIGNED_BYTE, data);

    if (!fastMode) {
        this.gpu.setFramebuffer(null);
    }

    return data;
};

/* harmony default export */ __webpack_exports__["a"] = (GpuTexture);




/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
});

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ui_element_event__ = __webpack_require__(172);



//get rid of compiler mess
var UIEvent = __WEBPACK_IMPORTED_MODULE_0__ui_element_event__["a" /* default */];


//Dom.dragging = false;
var Dom = {};

Dom.hasClass = function(element, name) {
    if (element.classList !== undefined) {
        return element.classList.contains(name);
    }
    var className = Dom.getClass(element);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
};


Dom.addClass = function(element, name) {
    if (element.classList !== undefined) {
        var classes = Dom.splitWords(name);
        for (var i = 0, li = classes.length; i < li; i++) {
            element.classList.add(classes[i]);
        }
    } else if (!Dom.hasClass(element, name)) {
        var className = Dom.getClass(element);
        Dom.setClass(element, (className ? className + ' ' : '') + name);
    }
};


Dom.removeClass = function(element, name) {
    if (element.classList !== undefined) {
        element.classList.remove(name);
    } else {
        Dom.setClass(element, ((' ' + Dom.getClass(element) + ' ').replace(' ' + name + ' ', ' ')).trim() );
    }
};


Dom.setClass = function(element, name) {
    if (element.className.baseVal === undefined) {
        element.className = name;
    } else {
        element.className.baseVal = name;
    }
};


Dom.getClass = function(element) {
    return element.className.baseVal === undefined ? element.className : element.className.baseVal;
};


Dom.preventDefault = function(e) {
    e = e instanceof UIEvent ? e.event : e;
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};


Dom.stopPropagation = function(e) {
    e = e instanceof UIEvent ? e.event : e;
    e.stopPropagation();
};


Dom.disableTextSelection = function() {
    window.addEventListener('selectstart', Dom.preventDefault);
};


Dom.enableTextSelection = function() {
    window.removeEventListener('selectstart', Dom.preventDefault);
};


Dom.disableImageDrag = function() {
    window.addEventListener('dragstart', Dom.preventDefault);
};


Dom.enableImageDrag = function() {
    window.removeEventListener('dragstart', Dom.preventDefault);
};


Dom.disableContexMenu = function(element) {
    element.addEventListener('contextmenu', Dom.preventDefault);
};


Dom.enableContexMenu = function(element) {
    element.removeEventListener('contextmenu', Dom.preventDefault);
};


Dom.getSupportedProperty = function(properties) {
    var style = document.documentElement.style;

    for (var i = 0, li = properties.length; i < li; i++) {
        if (properties[i] in style) {
            return properties[i];
        }
    }

    return false;
};


Dom.stampCounter = 0;


Dom.stamp = function(obj) {
    obj.vtsStamp = obj.vtsStamp || ++Dom.stampCounter;
    return obj.vtsStamp;
};


Dom.TRANSFORM = Dom.getSupportedProperty(
            ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


/* harmony default export */ __webpack_exports__["a"] = (Dom);


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__sign__ = __webpack_require__(11);



/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (Math.abs(x) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]) ? x : (x - (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__sign__["a" /* default */])(x) * Math.PI));
});


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return x<0 ? -1 : 1;
});

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return utilsUrl; });

var utilsUrl = {};


utilsUrl.isSameOrigin = function(url) {
    if (typeof url !== 'string') {
        return false;
    }
    var docHost = document.location.hostname;
    var parser = utilsUrl.parse(url);
    return parser['hostname'] === docHost;
};


utilsUrl.parse = function(url) {
    if (typeof url !== 'string') {
        return null;
    }

    var parser = document.createElement('a');
    parser['href'] = url;
    return parser;
};


utilsUrl.getParamsFromUrl = function(url) {
    var parser = utilsUrl.parse(url);
    var queryString = {};
    var query = parser['search'].substring(1);
    var vars = query.split('&');
    if (!(vars.length == 1 && vars[0] == '')) {
        for (var i=0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (typeof queryString[pair[0]] === 'undefined') {
                queryString[pair[0]] = pair[1];
            } else if (typeof queryString[pair[0]] === 'string') {
                var arr = [ queryString[pair[0]], pair[1] ];
                queryString[pair[0]] = arr;
            } else {
                queryString[pair[0]].push(pair[1]);
            }
        }
    }
    return queryString;
};


utilsUrl.getHost = function(url) {
    var location = document.createElement('a');
    location.href = url;
    return location.hostname; 
};


utilsUrl.getSchema = function(url) {
    //if (window.location.href.indexOf("file://") != -1) {
    if (url.indexOf('http://') != -1) {
        return 'http:';
    } else if (url.indexOf('https://') != -1) {
        return 'https:';
    } else {
        var location = document.createElement('a');
        location.href = url;
        return location.protocol;
    }
};


utilsUrl.getOrigin = function(url) {
    var location = document.createElement('a');
    location.href = url;

    if (!location.origin) {  //IE11 hack
      return location.protocol + "//" + location.hostname + (location.port ? ':' + location.port: '');
    }

    return location.origin; 
};


utilsUrl.getBase = function(url) {
    return url.split('?')[0].split('/').slice(0, -1).join('/')+'/';
};


utilsUrl.getProcessUrl = function(url, originUrl) {
    if (!url || !originUrl) {
        return url;
    }

    url = url.trim();
    originUrl= originUrl.trim();
    var baseUrl = utilsUrl.getBase(originUrl);
    var baseUrlSchema = utilsUrl.getSchema(originUrl);
    var baseUrlOrigin = utilsUrl.getOrigin(originUrl); 
   
    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return baseUrlOrigin + url;
    } else {  //relative
        return baseUrl + url; 
    }
};





/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_proj4__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__map_map__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__inspector_inspector__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_renderer__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__renderer_interface__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__map_position__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__map_interface__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_url__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_platform__ = __webpack_require__(22);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return Core; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCoreVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return checkSupport; });











//get rid of compiler mess
var Map = __WEBPACK_IMPORTED_MODULE_1__map_map__["a" /* default */];
var Inspector = __WEBPACK_IMPORTED_MODULE_2__inspector_inspector__["a" /* default */];
var Renderer = __WEBPACK_IMPORTED_MODULE_3__renderer_renderer__["a" /* default */];
var RendererInterface = __WEBPACK_IMPORTED_MODULE_4__renderer_interface__["a" /* default */];
var MapPosition = __WEBPACK_IMPORTED_MODULE_5__map_position__["a" /* default */];
var MapInterface = __WEBPACK_IMPORTED_MODULE_6__map_interface__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_7__utils_utils__["a" /* utils */];
var utilsUrl = __WEBPACK_IMPORTED_MODULE_8__utils_url__["a" /* utilsUrl */];
var platform = __WEBPACK_IMPORTED_MODULE_9__utils_platform__["a" /* platform */];


var Core = function(element, config, coreInterface) {
    var lang = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
    this.killed = false;
    this.config = {
        map : null,
        mapCache : 1100, //old value 900
        mapGPUCache : 600, //old value 500, 360
        mapMetatileCache : 60,
        mapTexelSizeFit : 1.1,
        mapMaxHiresLodLevels : 2,
        mapDownloadThreads : 20,
        mapMaxProcessingTime : 10, //1000*20,
        mapMaxGeodataProcessingTime : 10,
        mapMobileMode : false,
        mapMobileModeAutodect : true,
        mapMobileDetailDegradation : 1,
        mapNavSamplesPerViewExtent : 4,
        mapIgnoreNavtiles : false,
        mapVirtualSurfaces : true,
        mapAllowHires : true,
        mapAllowLowres : true,
        mapAllowSmartSwitching : true,
        mapDisableCulling : false,
        mapPreciseCulling : true,
        mapHeightLodBlend : true,
        mapHeightNodeBlend : true,
        mapBasicTileSequence : false,
        mapPreciseBBoxTest : false,
        mapPreciseDistanceTest : false,
        mapHeightfiledWhenUnloaded : true,
        mapForceMetatileV3 : false,
        mapSmartNodeParsing : true,
        mapLoadErrorRetryTime : 3000,
        mapLoadErrorMaxRetryCount : 3,
        mapLoadMode : 'topdown', // "topdown", "downtop", "fit", "fitonly"
        mapGeodataLoadMode : 'fit', //"fitonly"
        mapGridMode : 'linear', //"flat"
        mapGridSurrogatez : false, 
        mapGridUnderSurface: 0,
        mapGridTextureLevel: -1,
        mapGridTextureLayer: null, //"bing",
        mapXhrImageLoad : true,
        mapStoreLoadStats : false,
        mapRefreshCycles : 3,
        mapSoftViewSwitch : true,
        mapSortHysteresis : true,
        mapHysteresisWait : 0,
        mapSeparateLoader : true,
        mapGeodataBinaryLoad : true,
        mapPackLoaderEvents : true,
        mapParseMeshInWorker : true,
        mapPackGeodataEvents : true,

        mapFeatureStickMode : [1,1],

        map16bitMeshes : true,
        mapOnlyOneUVs : true,
        mapIndexBuffers : true,
        mapAsyncImageDecode : true,

        mapFeatureGridCells : 31,
        mapFeaturesPerSquareInch : 0.25, //0.6614,
        mapFeaturesSortByTop : false,

        mapFeaturesReduceMode : 'scr-count1', //have to be 'scr-count1' because of legacy https://rigel.mlwn.se/store/map-config/high-terrain/
        mapFeaturesReduceParams : null,
        mapFeaturesReduceFactor : 1,
        mapFeaturesReduceFactor2 : 1,

        mapDMapSize : 1024,
        mapDMapMode : 1,

        mapDegradeHorizon : false,
        mapDegradeHorizonParams : [1, 1500, 97500, 3500], //[1, 3000, 15000, 7000],
        mapDefaultFont : '//cdn.melown.com/libs/vtsjs/fonts/noto-basic/1.0.0/noto.fnt',
        //mapDefaultFont : '../fonts/basic.fnt',
        mapFog : true,
        mapNoTextures: false,
        mapMetricUnits : !(lang == 'en' || lang.indexOf('en-') == 0),
        mapLanguage : lang,
        mapForceFrameTime: 0,
        mapForcePipeline: 0,
        mapLogGeodataStyles: true,

        rendererAnisotropic : 0,
        rendererAntialiasing : true,
        rendererAllowScreenshots : false,
        inspector : true, 
        authorization : null, 
        mario : false
    };

    this.configStorage = {}; 
    this.element = element;
    this.coreInterface = coreInterface;
    //this.options = options;
    this.ready = false;
    this.listeners = [];
    this.listenerCounter = 0;
    this.tokenCookieHost = null;
    this.tokenIFrame = null;
    this.xhrParams = {};
    this.inspector = (Inspector != null) ? (new Inspector(this)) : null;
    this.setConfigParams(config);

    this.map = null;
    this.mapInterface = null;
    this.renderer = new Renderer(this, this.element, null, this.onResize.bind(this), this.config);
    this.rendererInterface = new RendererInterface(this.renderer);
    this.proj4 = __WEBPACK_IMPORTED_MODULE_0_proj4__["a" /* default */];
    this.contextLost = false;

    //platform detection
    platform.init();
    this.requestAnimFrame = (
               window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               window.oRequestAnimationFrame ||
               window.msRequestAnimationFrame ||
               function(callback) {
                   window.setTimeout(callback, 1000/60);
               });

    window.performance = window.performance || {};
    performance.now = (function() {
        return performance.now       ||
               performance.mozNow    ||
               performance.msNow     ||
               performance.oNow      ||
               performance.webkitNow ||
               function() { return new Date().getTime(); };
    })();

    this.loadMap(this.config.map);

    this.requestAnimFrame.call(window, this.onUpdate.bind(this));
};


Core.prototype.onResize = function() {
    if (this.map != null) {
        this.map.markDirty();
    }
};


Core.prototype.loadMap = function(path) {
    if (this.map != null) {
        this.destroyMap();
    }

    if (path == null) {
        return;
    }
    
    path = utilsUrl.getProcessUrl(path, window.location.href);

    this.tokenCookieLoaded = true;
    this.mapConfigData = null;
    this.tokenExpiration = null;
    this.tokenExpirationCallback = null;
    this.tokenExpirationLoop = false;
    this.tokenCanBeSkiped = true;
    this.mapRunnig = false;
    
    var onLoaded = (function() {
        if (!(this.tokenCookieLoaded || this.tokenCanBeSkiped) || !this.mapConfigData || this.mapRunnig) {
            return;
        }

        this.mapRunnig = true;
        var data = this.mapConfigData; 
    
        this.callListener('map-mapconfig-loaded', data);

        this.map = new Map(this, data, path, this.config, this.configStorage);
        this.mapInterface = new MapInterface(this.map);
        this.setConfigParams(this.map.browserOptions, true);
        this.setConfigParams(this.configStorage);

        if (this.config.position) {
            this.map.setPosition(this.config.position);
            this.config.position = null;
        }
    
        if (this.config.view) {
            this.map.setView(this.config.view);
            this.config.view = null;
        }
    
    }).bind(this);

    var onMapConfigLoaded = (function(data) {
        this.mapConfigData = data; 
        onLoaded();
    }).bind(this);

    var onMapConfigError = (function() {
    }).bind(this);

    //this.tokenLoaded = true;

    var onAutorizationLoaded = (function(data) {
        if (!data || (data && data['status'])) {
            if (this.tokenCanBeSkiped) {
                onLoadMapconfig(path);
            }
            return;
        }

        this.tokenLoaded = true;
        this.xhrParams['token'] = data['token'];
        this.xhrParams['tokenHeader'] = data['header'];
        this.tokenExpiration = data['expires'] * 1000;
        this.tokenExpirationCallback = (function(){
            //this.tokenLoaded = false;
            //this.tokenCookieLoaded = false;
            this.tokenExpiration = null;
            this.tokenExpirationLoop = true;
            if (typeof this.config.authorization === 'string') {
                utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);
            } else {
                this.config.authorization(onAutorizationLoaded);
            }
        }).bind(this);
        
        if (!this.tokenExpirationLoop) {
            onLoadMapconfig(path);
        }
        
        if (typeof this.config.authorization === 'string') {
            onLoadImageCookie(data['cookieInjector'], this.config.authorization);
        } else {
            onLoadImageCookie(data['cookieInjector'], path);
        }

    }).bind(this);

    var onAutorizationError = (function() {
        // eslint-disable-next-line
        console.log('auth token not loaded');
        
        if (this.tokenCanBeSkiped) {
            onLoadMapconfig(path);
        }
    }).bind(this);

    var onImageCookieLoaded = (function() {
        document.body.removeChild(this.tokenIFrame);
        this.tokenIFrame = null;   
        this.tokenCookieLoaded = true;
        onLoaded();
    }).bind(this);

    /*var onImageCookieError = (function() {
        // eslint-disable-next-line
        console.log('auth cookie not loaded');
    }).bind(this);*/

    //var baseUrl = path.split('?')[0].split('/').slice(0, -1).join('/')+'/';

    var onLoadMapconfig = (function(path) {
        utils.loadJSON(path, onMapConfigLoaded, onMapConfigError, null, utils.useCredentials, this.xhrParams);
    }).bind(this);

    var onLoadImageCookie = (function(url, originUrl) {
        url = utilsUrl.getProcessUrl(url, originUrl);
        this.tokenCookieHost = utilsUrl.getHost(url);
        //utils.loadImage(url, onImageCookieLoaded, onImageCookieError);
        var iframe = document.createElement('iframe');
        this.tokenIFrame = iframe;
        iframe.onload = onImageCookieLoaded;
        iframe.src = url;
        iframe.style.display = 'none';
        document.body.appendChild(iframe);   
    }).bind(this);

    //if (false && this.config.authorization) {
    if (this.config.authorization) {
        this.tokenCookieLoaded = false;

        if (typeof this.config.authorization === 'string') {
            utils.loadJSON(this.config.authorization, onAutorizationLoaded, onAutorizationError, null, utils.useCredentials, this.xhrParams);
        } else {
            this.config.authorization(onAutorizationLoaded);
        }
    } else {
        onLoadMapconfig(path);
    }
};


Core.prototype.destroy = function() {
    if (this.killed) {
        return;
    }

    this.destroyMap();
    if (this.renderer) {
        this.renderer.kill();
    }
    this.element = null;
    this.killed = true;
};


Core.prototype.destroyMap = function() {
    if (this.map) {
        this.map.kill();
        this.map = null;
        this.mapInterface = null;
        this.callListener('map-unloaded', {});
    }
};


Core.prototype.getMap = function() {
    return this.map;
};


Core.prototype.getMapInterface = function() {
    return this.mapInterface;
};


Core.prototype.getRenderer = function() {
    return this.renderer;
};


Core.prototype.getRendererInterface = function() {
    return this.rendererInterface;
};


Core.prototype.getProj4 = function() {
    return this.proj4;
};


Core.prototype.getOption = function(/*key, value*/) {
};


Core.prototype.setOption = function(/*key, value*/) {
};


Core.prototype.on = function(name, listener, wait, once) {
    if (this.killed) { // || this.renderer == null) {
        return;
    }

    if (listener == null) {
        return;
    }

    this.listenerCounter++;
    this.listeners.push({ name : name, listener : listener, id : this.listenerCounter, once: once, wait: wait ? wait : 0 });

    return (function(id){ this.removeListener(id); }).bind(this, this.listenerCounter);
};


Core.prototype.once = function(name, listener, wait) {
    this.on(name, listener, wait, true);
};


// private
Core.prototype.callListener = function(name, event, log) {
    for (var i = 0; i < this.listeners.length; i++) {
        if (this.listeners[i].name == name) {
            var listener = this.listeners[i];

            if (listener.wait > 0) {
                listener.wait--;
            } else {
                listener.listener(event);
                if (listener.once) {
                    this.listeners.splice(i, 1);
                    i--;
                }
            }
        }
    }
    
    if (log) {
        // eslint-disable-next-line
        console.log('event ' + name + ': ' + JSON.stringify(event));
    }
};

// private
Core.prototype.removeListener = function(id) {
    for (var i = 0; i < this.listeners.length; i++) {
        if (this.listeners[i].id == id) {
            //this.listeners[i].splice(i, 1);
            this.listeners.splice(i, 1);
            return;
        }
    }
};

Core.prototype.markDirty = function() {
    if (this.map != null) {
        this.map.markDirty();
    }
};

Core.prototype.onUpdate = function() {
    if (this.killed || this.contextLost) {
        return;
    }

    if (this.map != null) {
        if (!this.map.srsReady && this.map.isReferenceFrameReady()) {
            this.map.srsReady = true;
            this.callListener('map-loaded', { 'browserOptions':this.map.browserOptions});
        }

        this.map.update();
    }

    //TODO: detect view change
    //this.callListener("view-update", {"position": position, "orientaion":orientation,
    //                                  "fov": renderer.camera.getFov()});

    //this.callListener("render-update", { "dirty": true, "message": "DOM element does not exist" });

    this.callListener('tick', {});

    this.requestAnimFrame.call(window, this.onUpdate.bind(this));
};


Core.prototype.setConfigParams = function(params, solveStorage) {
    if (typeof params === 'object' && params !== null) {
        for (var key in params) {
            this.setConfigParam(key, params[key], solveStorage);
        }
    }
};


Core.prototype.setConfigParam = function(key, value, solveStorage) {
    switch(key) {
    case 'pos':
    case 'position':
    case 'view':

        if (this.getMap()) {
            if (key == 'view') {
                this.getMap().setView(value);
            } else {
                this.getMap().setPosition(new MapPosition(value));
            }
            if (this.configStorage[key]) {
                delete this.configStorage[key];
            }
        } else {
            this.configStorage[key] = value;
        }
        break;

    case 'map':
        this.config.map = utils.validateString(value, null); break;
    case 'mapVirtualSurfaces':
        this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;
    case 'mapForcePipeline':
        this.config.mapForcePipeline = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;
    case 'mapDMapSize':
        this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break; 
    case 'mapDMapMode':
        this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;
    case 'map16bitMeshes':
        this.config.map16bitMeshes = utils.validateBool(value, false); break;
    case 'inspector':
        this.config.inspector = utils.validateBool(value, true); break;
    case 'authorization':
        this.config.authorization = ((typeof value === 'string') || (typeof value === 'function')) ? value : null; 
         break;
    default:
        if (key.indexOf('map') == 0 || key == 'mario') {
           
            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {
                this.configStorage[key] = value;
            }

            if (this.getMap() != null) {
                this.getMap().setConfigParam(key, value);
            }
        }

        if (key.indexOf('renderer') == 0) {
            if (!solveStorage || (typeof this.configStorage[key] === 'undefined')) {
                this.configStorage[key] = value;
            }

            this.setRendererConfigParam(key, value);
        }

        if (key.indexOf('debug') == 0) {
            this.configStorage[key] = value;
            if (this.getMap() != null) {
                this.inspector.setParameter(key, value);
            }
        }

        break;            
    }

};


Core.prototype.getConfigParam = function(key) {
    if (key == 'map') {
        return this.config.map;
    } else if (key == 'inspector') {
        return this.config.inspector;
    } else {
        if (key.indexOf('map') == 0 && this.getMap() != null) {
            return this.getMap().getConfigParam(key);
        }

        if (key.indexOf('renderer') == 0) {
            return this.getRendererConfigParam(key);
        }
    }
};


Core.prototype.setRendererConfigParam = function(key, value) {
    switch (key) {
    case 'rendererAnisotropic':        this.config.rendererAnisotropic = utils.validateNumber(value, -1, 2048, 0); if (this.rederer) this.rederer.gpu.setAniso(this.config.rendererAnisotropic); break;
    case 'rendererAntialiasing':       this.config.rendererAntialiasing = utils.validateBool(value, true); break;
    case 'rendererAllowScreenshots':   this.config.rendererAllowScreenshots = utils.validateBool(value, false); break;
    }
};


Core.prototype.getRendererConfigParam = function(key) {
    switch (key) {
    case 'rendererAnisotropic':        return this.config.rendererAnisotropic;
    case 'rendererAntialiasing':       return this.config.rendererAntialiasing;
    case 'rendererAllowScreenshots':   return this.config.rendererAllowScreenshots;
    }
};

/*
string getCoreVersion()

    Returns string with VTS version
*/

function getCoreVersion(full) {
    return (full ? 'Core: ' : '') + '2.21.8';
}


/*
bool checkSupport()

    Returns true if the environment is capable of running the WebGL browser, false otherwise.
*/

function checkSupport() {
    platform.init();

    //is webgl supported
    var canvas = document.createElement('canvas');

    if (canvas == null) {
        return false;
    }

    canvas.width = 1024;
    canvas.height = 768;

    if (canvas.getContext == null) {
        return false;
    }

    var gl = null;

    try {
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    } catch(e) {
        return false;
    }

    if (!gl) {
        return false;
    }

    return true;
}





/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
});

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
});

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
});

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  return (x * x * x * (35 / 3072));
});

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
});

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);


/* harmony default export */ __webpack_exports__["a"] = (function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
});


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);


/* harmony default export */ __webpack_exports__["a"] = (function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - phi)) / con);
});


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Proj__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Point__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_toPoint__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__defs__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__transform__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_mgrs__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__version__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__projs__ = __webpack_require__(114);










__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].defaultDatum = 'WGS84'; //default datum
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].Proj = __WEBPACK_IMPORTED_MODULE_1__Proj__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].WGS84 = new __WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].Proj('WGS84');
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].Point = __WEBPACK_IMPORTED_MODULE_2__Point__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].toPoint = __WEBPACK_IMPORTED_MODULE_3__common_toPoint__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].defs = __WEBPACK_IMPORTED_MODULE_4__defs__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].transform = __WEBPACK_IMPORTED_MODULE_5__transform__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].mgrs = __WEBPACK_IMPORTED_MODULE_6_mgrs__["a" /* default */];
__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */].version = __WEBPACK_IMPORTED_MODULE_7__version__["a" /* default */];
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__projs__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */]);
/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0__core__["a" /* default */]);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return platform; });

var platform = {

    initialized : false,

    init: function () {

        var self = platform;

        self.browser = self.searchString(self.dataBrowser) || 'An unknown browser';
        self.version = self.searchVersion(navigator.userAgent.toLowerCase()) || self.searchVersion(navigator.appVersion) || 'an unknown version';
        self.OS = self.searchString(self.dataOS) || 'an unknown os: ua: ' + navigator.userAgent + ' pl: ' + navigator.platform;

        self.mobile = (self.OS == 'iphone/ipod' || self.OS == 'android' || self.OS == 'ipad' || self.OS == 'windows ce'  || self.OS == 'windows phone' || self.OS == 'kindle');
        self.mobileAndroid = (self.OS == 'android');
        self.initialized = true;
    },

    getBrowser : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.browser;
    },

    getBrowserVersion : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.browser;
    },

    getOS : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.browser;
    },

    isMobile : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.mobile;
    },
    
    isAndroid : function() {
        if(!platform.initialized) { platform.init(); }
        return platform.mobileAndroid;
    },

    searchString: function (data) {
        var self = platform;
        for (var i=0; i<data.length; i++) {
            var dataString = data[i].string;
            var dataProp = data[i].prop;
            self.versionSearchString = data[i].versionSearch || data[i].identity;

            if (dataString) {
                if (dataString.toLowerCase().indexOf(data[i].subString) != -1) {
                    if (data[i].version != null) {
                        self.version = data[i].version;
                    }
                    return data[i].identity;
                }
            } else if (dataProp) {
                return data[i].identity;
            }
        }
    },

    searchVersion: function (dataString) {
        var self = platform;
        if (self.version != null) {
            return self.version;
        }
        var index = dataString.indexOf(self.versionSearchString);
        if (index == -1) return;
        return parseFloat(dataString.substring(index+self.versionSearchString.length+1));
    },

    dataBrowser: [
        {
            string: navigator.userAgent,
            subString: 'chrome',
            identity: 'chrome'
        },
        {
            string: navigator.userAgent,
            subString: 'firefox',
            identity: 'firefox'
        },
        {
            string: navigator.vendor,
            subString: 'apple',
            identity: 'safari',
            versionSearch: 'version'
        },
        {
            prop: window.opera,
            identity: 'opera',
            versionSearch: 'version'
        },
        {
            string: navigator.vendor,
            subString: 'icab',
            identity: 'icab'
        },
        {
            string: navigator.vendor,
            subString: 'kde',
            identity: 'konqueror'
        },
        {
            string: navigator.vendor,
            subString: 'camino',
            identity: 'camino'
        },
        {       // for newer Netscapes (6+)
            string: navigator.userAgent,
            subString: 'netscape',
            identity: 'netscape'
        },
        {
            string: navigator.userAgent,
            subString: 'msie',
            identity: 'explorer',
            versionSearch: 'msie'
        },
        {
            string: navigator.userAgent,
            subString: 'trident/',
            identity: 'explorer',
            version: '11'
        },
        {
            string: navigator.userAgent,
            subString: 'edge/',
            identity: 'explorer',
            version: '12'
        },
        {   string: navigator.userAgent,
            subString: 'omniweb',
            versionSearch: 'omniweb/',
            identity: 'omniweb'
        },
        {   string: navigator.userAgent,
            subString: 'silk',
            versionSearch: 'silk/',
            identity: 'silk'
        },
        {
            string: navigator.userAgent,
            subString: 'gecko',
            identity: 'mozilla',
            versionSearch: 'rv'
        },
        {       // for older Netscapes (4-)
            string: navigator.userAgent,
            subString: 'mozilla',
            identity: 'netscape',
            versionSearch: 'mozilla'
        }
    ],

    dataOS : [
        {
            string: navigator.userAgent,
            subString: 'windows ce',
            identity: 'windows ce'
        },
        {
            string: navigator.userAgent,
            subString: 'windows phone',
            identity: 'windows phone'
        },
        {
            string: navigator.platform,
            subString: 'win',
            identity: 'windows'
        },
        {
            string: navigator.platform,
            subString: 'mac',
            identity: 'mac'
        },
        {
            string: navigator.userAgent,
            subString: 'iphone',
            identity: 'iphone/ipod'
        },
        {
            string: navigator.userAgent,
            subString: 'ipod',
            identity: 'iphone/ipod'
        },
        {
            string: navigator.userAgent,
            subString: 'ipad',
            identity: 'ipad'
        },
        {
            string: navigator.userAgent,
            subString: 'android',
            identity: 'android'
        },
        {
            string: navigator.userAgent,
            subString: 'silk',
            identity: 'kindle'
        },
        {
            string: navigator.userAgent,
            subString: 'blackberry',
            identity: 'blackberry'
        },
        {
            string: navigator.platform,
            subString: 'linux',
            identity: 'linux'
        }
    ]

};





/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Geodesic routines from GeographicLib translated to JavaScript.  See
 * https://geographiclib.sourceforge.io/html/js/
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013),
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * This file is the concatenation and compression of the JavaScript files in
 * doc/scripts/GeographicLib in the source tree for GeographicLib.
 *
 * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 *
 * Version: 1.48
 * File inventory:
 *   Math.js Geodesic.js GeodesicLine.js PolygonArea.js DMS.js
 */

(function(cb) {

/**************** Math.js ****************/
/*
 * Math.js
 * Transcription of Math.hpp, Constants.hpp, and Accumulator.hpp into
 * JavaScript.
 *
 * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

/**
 * @namespace GeographicLib
 * @description The parent namespace for the following modules:
 * - {@link module:GeographicLib/Geodesic GeographicLib/Geodesic} The main
 *   engine for solving geodesic problems via the
 *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.
 * - {@link module:GeographicLib/GeodesicLine GeographicLib/GeodesicLine}
 *   computes points along a single geodesic line via the
 *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}
 *   class.
 * - {@link module:GeographicLib/PolygonArea GeographicLib/PolygonArea}
 *   computes the area of a geodesic polygon via the
 *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}
 *   class.
 * - {@link module:GeographicLib/DMS GeographicLib/DMS} handles the decoding
 *   and encoding of angles in degree, minutes, and seconds, via static
 *   functions in this module.
 * - {@link module:GeographicLib/Constants GeographicLib/Constants} defines
 *   constants specifying the version numbers and the parameters for the WGS84
 *   ellipsoid.
 *
 * The following modules are used internally by the package:
 * - {@link module:GeographicLib/Math GeographicLib/Math} defines various
 *   mathematical functions.
 * - {@link module:GeographicLib/Accumulator GeographicLib/Accumulator}
 *   interally used by
 *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea} (via the
 *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class)
 *   for summing the contributions to the area of a polygon.
 */
"use strict";
var GeographicLib = {};
GeographicLib.Constants = {};
GeographicLib.Math = {};
GeographicLib.Accumulator = {};

(function(
  /**
   * @exports GeographicLib/Constants
   * @description Define constants defining the version and WGS84 parameters.
   */
  c) {

  /**
   * @constant
   * @summary WGS84 parameters.
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   */
  c.WGS84 = { a: 6378137, f: 1/298.257223563 };
  /**
   * @constant
   * @summary an array of version numbers.
   * @property {number} major the major version number.
   * @property {number} minor the minor version number.
   * @property {number} patch the patch number.
   */
  c.version = { major: 1, minor: 48, patch: 0 };
  /**
   * @constant
   * @summary version string
   */
  c.version_string = "1.48";
})(GeographicLib.Constants);

(function(
  /**
   * @exports GeographicLib/Math
   * @description Some useful mathematical constants and functions (mainly for
   *   internal use).
   */
  m) {

  /**
   * @summary The number of digits of precision in floating-point numbers.
   * @constant {number}
   */
  m.digits = 53;
  /**
   * @summary The machine epsilon.
   * @constant {number}
   */
  m.epsilon = Math.pow(0.5, m.digits - 1);
  /**
   * @summary The factor to convert degrees to radians.
   * @constant {number}
   */
  m.degree = Math.PI/180;

  /**
   * @summary Square a number.
   * @param {number} x the number.
   * @returns {number} the square.
   */
  m.sq = function(x) { return x * x; };

  /**
   * @summary The hypotenuse function.
   * @param {number} x the first side.
   * @param {number} y the second side.
   * @returns {number} the hypotenuse.
   */
  m.hypot = function(x, y) {
    var a, b;
    x = Math.abs(x);
    y = Math.abs(y);
    a = Math.max(x, y); b = Math.min(x, y) / (a ? a : 1);
    return a * Math.sqrt(1 + b * b);
  };

  /**
   * @summary Cube root function.
   * @param {number} x the argument.
   * @returns {number} the real cube root.
   */
  m.cbrt = function(x) {
    var y = Math.pow(Math.abs(x), 1/3);
    return x < 0 ? -y : y;
  };

  /**
   * @summary The log1p function.
   * @param {number} x the argument.
   * @returns {number} log(1 + x).
   */
  m.log1p = function(x) {
    var y = 1 + x,
        z = y - 1;
    // Here's the explanation for this magic: y = 1 + z, exactly, and z
    // approx x, thus log(y)/z (which is nearly constant near z = 0) returns
    // a good approximation to the true log(1 + x)/x.  The multiplication x *
    // (log(y)/z) introduces little additional error.
    return z === 0 ? x : x * Math.log(y) / z;
  };

  /**
   * @summary Inverse hyperbolic tangent.
   * @param {number} x the argument.
   * @returns {number} tanh<sup>&minus;1</sup> x.
   */
  m.atanh = function(x) {
    var y = Math.abs(x);          // Enforce odd parity
    y = m.log1p(2 * y/(1 - y))/2;
    return x < 0 ? -y : y;
  };

  /**
   * @summary Copy the sign.
   * @param {number} x gives the magitude of the result.
   * @param {number} y gives the sign of the result.
   * @returns {number} value with the magnitude of x and with the sign of y.
   */
  m.copysign = function(x, y) {
    return Math.abs(x) * (y < 0 || (y === 0 && 1/y < 0) ? -1 : 1);
  };

  /**
   * @summary An error-free sum.
   * @param {number} u
   * @param {number} v
   * @returns {object} sum with sum.s = round(u + v) and sum.t is u + v &minus;
   *   round(u + v)
   */
  m.sum = function(u, v) {
    var s = u + v,
        up = s - v,
        vpp = s - up,
        t;
    up -= u;
    vpp -= v;
    t = -(up + vpp);
    // u + v =       s      + t
    //       = round(u + v) + t
    return {s: s, t: t};
  };

  /**
   * @summary Evaluate a polynomial.
   * @param {integer} N the order of the polynomial.
   * @param {array} p the coefficient array (of size N + 1) (leading
   *   order coefficient first)
   * @param {number} x the variable.
   * @returns {number} the value of the polynomial.
   */
  m.polyval = function(N, p, s, x) {
    var y = N < 0 ? 0 : p[s++];
    while (--N >= 0) y = y * x + p[s++];
    return y;
  };

  /**
   * @summary Coarsen a value close to zero.
   * @param {number} x
   * @returns {number} the coarsened value.
   */
  m.AngRound = function(x) {
    // The makes the smallest gap in x = 1/16 - nextafter(1/16, 0) = 1/2^57 for
    // reals = 0.7 pm on the earth if x is an angle in degrees.  (This is about
    // 1000 times more resolution than we get with angles around 90 degrees.)
    // We use this to avoid having to deal with near singular cases when x is
    // non-zero but tiny (e.g., 1.0e-200).  This converts -0 to +0; however
    // tiny negative numbers get converted to -0.
    if (x === 0) return x;
    var z = 1/16,
        y = Math.abs(x);
    // The compiler mustn't "simplify" z - (z - y) to y
    y = y < z ? z - (z - y) : y;
    return x < 0 ? -y : y;
  };

  /**
   * @summary Normalize an angle.
   * @param {number} x the angle in degrees.
   * @returns {number} the angle reduced to the range (&minus;180&deg;,
   *   180&deg;].
   */
  m.AngNormalize = function(x) {
    // Place angle in [-180, 180).
    x = x % 360;
    return x <= -180 ? x + 360 : (x <= 180 ? x : x - 360);
  };

  /**
   * @summary Normalize a latitude.
   * @param {number} x the angle in degrees.
   * @returns {number} x if it is in the range [&minus;90&deg;, 90&deg;],
   *   otherwise return NaN.
   */
  m.LatFix = function(x) {
    // Replace angle with NaN if outside [-90, 90].
    return Math.abs(x) > 90 ? Number.NaN : x;
  };

  /**
   * @summary The exact difference of two angles reduced to (&minus;180&deg;,
   *   180&deg;]
   * @param {number} x the first angle in degrees.
   * @param {number} y the second angle in degrees.
   * @return {object} diff the exact difference, y &minus; x.
   *
   * This computes z = y &minus; x exactly, reduced to (&minus;180&deg;,
   * 180&deg;]; and then sets diff.s = d = round(z) and diff.t = e = z &minus;
   * round(z).  If d = &minus;180, then e &gt; 0; If d = 180, then e &le; 0.
   */
  m.AngDiff = function(x, y) {
    // Compute y - x and reduce to [-180,180] accurately.
    var r = m.sum(m.AngNormalize(-x), m.AngNormalize(y)),
        d = m.AngNormalize(r.s),
        t = r.t;
    return m.sum(d === 180 && t > 0 ? -180 : d, t);
  };

  /**
   * @summary Evaluate the sine and cosine function with the argument in
   *   degrees
   * @param {number} x in degrees.
   * @returns {object} r with r.s = sin(x) and r.c = cos(x).
   */
  m.sincosd = function(x) {
    // In order to minimize round-off errors, this function exactly reduces
    // the argument to the range [-45, 45] before converting it to radians.
    var r, q, s, c, sinx, cosx;
    r = x % 360;
    q = Math.floor(r / 90 + 0.5);
    r -= 90 * q;
    // now abs(r) <= 45
    r *= this.degree;
    // Possibly could call the gnu extension sincos
    s = Math.sin(r); c = Math.cos(r);
    switch (q & 3) {
      case 0:  sinx =  s; cosx =  c; break;
      case 1:  sinx =  c; cosx = -s; break;
      case 2:  sinx = -s; cosx = -c; break;
      default: sinx = -c; cosx =  s; break; // case 3
    }
    if (x) { sinx += 0; cosx += 0; }
    return {s: sinx, c: cosx};
  };

  /**
   * @summary Evaluate the atan2 function with the result in degrees
   * @param {number} y
   * @param {number} x
   * @returns atan2(y, x) in degrees, in the range (&minus;180&deg;
   *   180&deg;].
   */
  m.atan2d = function(y, x) {
    // In order to minimize round-off errors, this function rearranges the
    // arguments so that result of atan2 is in the range [-pi/4, pi/4] before
    // converting it to degrees and mapping the result to the correct
    // quadrant.
    var q = 0, t, ang;
    if (Math.abs(y) > Math.abs(x)) { t = x; x = y; y = t; q = 2; }
    if (x < 0) { x = -x; ++q; }
    // here x >= 0 and x >= abs(y), so angle is in [-pi/4, pi/4]
    ang = Math.atan2(y, x) / this.degree;
    switch (q) {
      // Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that
      // atan2d will not be called with y = -0.  If need be, include
      //
      //   case 0: ang = 0 + ang; break;
      //
      // and handle mpfr as in AngRound.
      case 1: ang = (y >= 0 ? 180 : -180) - ang; break;
      case 2: ang =  90 - ang; break;
      case 3: ang = -90 + ang; break;
    }
    return ang;
  };
})(GeographicLib.Math);

(function(
  /**
   * @exports GeographicLib/Accumulator
   * @description Accurate summation via the
   *   {@link module:GeographicLib/Accumulator.Accumulator Accumulator} class
   *   (mainly for internal use).
   */
  a, m) {

  /**
   * @class
   * @summary Accurate summation of many numbers.
   * @classdesc This allows many numbers to be added together with twice the
   *   normal precision.  In the documentation of the member functions, sum
   *   stands for the value currently held in the accumulator.
   * @param {number | Accumulator} [y = 0]  set sum = y.
   */
  a.Accumulator = function(y) {
    this.Set(y);
  };

  /**
   * @summary Set the accumulator to a number.
   * @param {number | Accumulator} [y = 0] set sum = y.
   */
  a.Accumulator.prototype.Set = function(y) {
    if (!y) y = 0;
    if (y.constructor === a.Accumulator) {
      this._s = y._s;
      this._t = y._t;
    } else {
      this._s = y;
      this._t = 0;
    }
  };

  /**
   * @summary Add a number to the accumulator.
   * @param {number} [y = 0] set sum += y.
   */
  a.Accumulator.prototype.Add = function(y) {
    // Here's Shewchuk's solution...
    // Accumulate starting at least significant end
    var u = m.sum(y, this._t),
        v = m.sum(u.s, this._s);
    u = u.t;
    this._s = v.s;
    this._t = v.t;
    // Start is _s, _t decreasing and non-adjacent.  Sum is now (s + t + u)
    // exactly with s, t, u non-adjacent and in decreasing order (except
    // for possible zeros).  The following code tries to normalize the
    // result.  Ideally, we want _s = round(s+t+u) and _u = round(s+t+u -
    // _s).  The follow does an approximate job (and maintains the
    // decreasing non-adjacent property).  Here are two "failures" using
    // 3-bit floats:
    //
    // Case 1: _s is not equal to round(s+t+u) -- off by 1 ulp
    // [12, -1] - 8 -> [4, 0, -1] -> [4, -1] = 3 should be [3, 0] = 3
    //
    // Case 2: _s+_t is not as close to s+t+u as it shold be
    // [64, 5] + 4 -> [64, 8, 1] -> [64,  8] = 72 (off by 1)
    //                    should be [80, -7] = 73 (exact)
    //
    // "Fixing" these problems is probably not worth the expense.  The
    // representation inevitably leads to small errors in the accumulated
    // values.  The additional errors illustrated here amount to 1 ulp of
    // the less significant word during each addition to the Accumulator
    // and an additional possible error of 1 ulp in the reported sum.
    //
    // Incidentally, the "ideal" representation described above is not
    // canonical, because _s = round(_s + _t) may not be true.  For
    // example, with 3-bit floats:
    //
    // [128, 16] + 1 -> [160, -16] -- 160 = round(145).
    // But [160, 0] - 16 -> [128, 16] -- 128 = round(144).
    //
    if (this._s === 0)          // This implies t == 0,
      this._s = u;              // so result is u
    else
      this._t += u;             // otherwise just accumulate u to t.
  };

  /**
   * @summary Return the result of adding a number to sum (but
   *   don't change sum).
   * @param {number} [y = 0] the number to be added to the sum.
   * @return sum + y.
   */
  a.Accumulator.prototype.Sum = function(y) {
    var b;
    if (!y)
      return this._s;
    else {
      b = new a.Accumulator(this);
      b.Add(y);
      return b._s;
    }
  };

  /**
   * @summary Set sum = &minus;sum.
   */
  a.Accumulator.prototype.Negate = function() {
    this._s *= -1;
    this._t *= -1;
  };
})(GeographicLib.Accumulator, GeographicLib.Math);

/**************** Geodesic.js ****************/
/*
 * Geodesic.js
 * Transcription of Geodesic.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER Math.js

GeographicLib.Geodesic = {};
GeographicLib.GeodesicLine = {};
GeographicLib.PolygonArea = {};

(function(
  /**
   * @exports GeographicLib/Geodesic
   * @description Solve geodesic problems via the
   *   {@link module:GeographicLib/Geodesic.Geodesic Geodesic} class.
   */
  g, l, p, m, c) {

  var GEOGRAPHICLIB_GEODESIC_ORDER = 6,
      nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER,
      nA3x_ = nA3_,
      nC3x_, nC4x_,
      maxit1_ = 20,
      maxit2_ = maxit1_ + m.digits + 10,
      tol0_ = m.epsilon,
      tol1_ = 200 * tol0_,
      tol2_ = Math.sqrt(tol0_),
      tolb_ = tol0_ * tol1_,
      xthresh_ = 1000 * tol2_,
      CAP_NONE = 0,
      CAP_ALL  = 0x1F,
      CAP_MASK = CAP_ALL,
      OUT_ALL  = 0x7F80,
      astroid,
      A1m1f_coeff, C1f_coeff, C1pf_coeff,
      A2m1f_coeff, C2f_coeff,
      A3_coeff, C3_coeff, C4_coeff;

  g.tiny_ = Math.sqrt(Number.MIN_VALUE);
  g.nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  g.nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  nC3x_ = (g.nC3_ * (g.nC3_ - 1)) / 2;
  nC4x_ = (g.nC4_ * (g.nC4_ + 1)) / 2;
  g.CAP_C1   = 1<<0;
  g.CAP_C1p  = 1<<1;
  g.CAP_C2   = 1<<2;
  g.CAP_C3   = 1<<3;
  g.CAP_C4   = 1<<4;

  g.NONE          = 0;
  g.ARC           = 1<<6;
  g.LATITUDE      = 1<<7  | CAP_NONE;
  g.LONGITUDE     = 1<<8  | g.CAP_C3;
  g.AZIMUTH       = 1<<9  | CAP_NONE;
  g.DISTANCE      = 1<<10 | g.CAP_C1;
  g.STANDARD      = g.LATITUDE | g.LONGITUDE | g.AZIMUTH | g.DISTANCE;
  g.DISTANCE_IN   = 1<<11 | g.CAP_C1 | g.CAP_C1p;
  g.REDUCEDLENGTH = 1<<12 | g.CAP_C1 | g.CAP_C2;
  g.GEODESICSCALE = 1<<13 | g.CAP_C1 | g.CAP_C2;
  g.AREA          = 1<<14 | g.CAP_C4;
  g.ALL           = OUT_ALL| CAP_ALL;
  g.LONG_UNROLL   = 1<<15;
  g.OUT_MASK      = OUT_ALL| g.LONG_UNROLL;

  g.SinCosSeries = function(sinp, sinx, cosx, c) {
    // Evaluate
    // y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :
    //            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)
    // using Clenshaw summation.  N.B. c[0] is unused for sin series
    // Approx operation count = (n + 5) mult and (2 * n + 2) add
    var k = c.length,           // Point to one beyond last element
        n = k - (sinp ? 1 : 0),
        ar = 2 * (cosx - sinx) * (cosx + sinx), // 2 * cos(2 * x)
        y0 = n & 1 ? c[--k] : 0, y1 = 0;        // accumulators for sum
    // Now n is even
    n = Math.floor(n/2);
    while (n--) {
      // Unroll loop x 2, so accumulators return to their original role
      y1 = ar * y0 - y1 + c[--k];
      y0 = ar * y1 - y0 + c[--k];
    }
    return (sinp ? 2 * sinx * cosx * y0 : // sin(2 * x) * y0
            cosx * (y0 - y1));            // cos(x) * (y0 - y1)
  };

  astroid = function(x, y) {
    // Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive
    // root k.  This solution is adapted from Geocentric::Reverse.
    var k,
        p = m.sq(x),
        q = m.sq(y),
        r = (p + q - 1) / 6,
        S, r2, r3, disc, u, T3, T, ang, v, uv, w;
    if ( !(q === 0 && r <= 0) ) {
      // Avoid possible division by zero when r = 0 by multiplying
      // equations for s and t by r^3 and r, resp.
      S = p * q / 4;            // S = r^3 * s
      r2 = m.sq(r);
      r3 = r * r2;
      // The discriminant of the quadratic equation for T3.  This is
      // zero on the evolute curve p^(1/3)+q^(1/3) = 1
      disc = S * (S + 2 * r3);
      u = r;
      if (disc >= 0) {
        T3 = S + r3;
        // Pick the sign on the sqrt to maximize abs(T3).  This
        // minimizes loss of precision due to cancellation.  The
        // result is unchanged because of the way the T is used
        // in definition of u.
        T3 += T3 < 0 ? -Math.sqrt(disc) : Math.sqrt(disc);    // T3 = (r * t)^3
        // N.B. cbrt always returns the real root.  cbrt(-8) = -2.
        T = m.cbrt(T3);     // T = r * t
        // T can be zero; but then r2 / T -> 0.
        u += T + (T !== 0 ? r2 / T : 0);
      } else {
        // T is complex, but the way u is defined the result is real.
        ang = Math.atan2(Math.sqrt(-disc), -(S + r3));
        // There are three possible cube roots.  We choose the
        // root which avoids cancellation.  Note that disc < 0
        // implies that r < 0.
        u += 2 * r * Math.cos(ang / 3);
      }
      v = Math.sqrt(m.sq(u) + q);       // guaranteed positive
      // Avoid loss of accuracy when u < 0.
      uv = u < 0 ? q / (v - u) : u + v; // u+v, guaranteed positive
      w = (uv - q) / (2 * v);           // positive?
      // Rearrange expression for k to avoid loss of accuracy due to
      // subtraction.  Division by 0 not possible because uv > 0, w >= 0.
      k = uv / (Math.sqrt(uv + m.sq(w)) + w); // guaranteed positive
    } else {                                  // q == 0 && r <= 0
      // y = 0 with |x| <= 1.  Handle this case directly.
      // for y small, positive root is k = abs(y)/sqrt(1-x^2)
      k = 0;
    }
    return k;
  };

  A1m1f_coeff = [
    // (1-eps)*A1-1, polynomial in eps2 of order 3
      +1, 4, 64, 0, 256
  ];

  // The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
  g.A1m1f = function(eps) {
    var p = Math.floor(nA1_/2),
        t = m.polyval(p, A1m1f_coeff, 0, m.sq(eps)) / A1m1f_coeff[p + 1];
    return (t + eps) / (1 - eps);
  };

  C1f_coeff = [
    // C1[1]/eps^1, polynomial in eps2 of order 2
      -1, 6, -16, 32,
    // C1[2]/eps^2, polynomial in eps2 of order 2
      -9, 64, -128, 2048,
    // C1[3]/eps^3, polynomial in eps2 of order 1
      +9, -16, 768,
    // C1[4]/eps^4, polynomial in eps2 of order 1
      +3, -5, 512,
    // C1[5]/eps^5, polynomial in eps2 of order 0
      -7, 1280,
    // C1[6]/eps^6, polynomial in eps2 of order 0
      -7, 2048
  ];

  // The coefficients C1[l] in the Fourier expansion of B1
  g.C1f = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC1_; ++l) {     // l is index of C1p[l]
      p = Math.floor((g.nC1_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C1f_coeff, o, eps2) / C1f_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  C1pf_coeff = [
    // C1p[1]/eps^1, polynomial in eps2 of order 2
      +205, -432, 768, 1536,
    // C1p[2]/eps^2, polynomial in eps2 of order 2
      +4005, -4736, 3840, 12288,
    // C1p[3]/eps^3, polynomial in eps2 of order 1
      -225, 116, 384,
    // C1p[4]/eps^4, polynomial in eps2 of order 1
      -7173, 2695, 7680,
    // C1p[5]/eps^5, polynomial in eps2 of order 0
      +3467, 7680,
    // C1p[6]/eps^6, polynomial in eps2 of order 0
      +38081, 61440
  ];

  // The coefficients C1p[l] in the Fourier expansion of B1p
  g.C1pf = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC1p_; ++l) {     // l is index of C1p[l]
      p = Math.floor((g.nC1p_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C1pf_coeff, o, eps2) / C1pf_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  A2m1f_coeff = [
    // (eps+1)*A2-1, polynomial in eps2 of order 3
      -11, -28, -192, 0, 256
  ];

  // The scale factor A2-1 = mean value of (d/dsigma)I2 - 1
  g.A2m1f = function(eps) {
    var p = Math.floor(nA2_/2),
        t = m.polyval(p, A2m1f_coeff, 0, m.sq(eps)) / A2m1f_coeff[p + 1];
    return (t - eps) / (1 + eps);
  };

  C2f_coeff = [
    // C2[1]/eps^1, polynomial in eps2 of order 2
      +1, 2, 16, 32,
    // C2[2]/eps^2, polynomial in eps2 of order 2
      +35, 64, 384, 2048,
    // C2[3]/eps^3, polynomial in eps2 of order 1
      +15, 80, 768,
    // C2[4]/eps^4, polynomial in eps2 of order 1
      +7, 35, 512,
    // C2[5]/eps^5, polynomial in eps2 of order 0
      +63, 1280,
    // C2[6]/eps^6, polynomial in eps2 of order 0
      +77, 2048
  ];

  // The coefficients C2[l] in the Fourier expansion of B2
  g.C2f = function(eps, c) {
    var eps2 = m.sq(eps),
        d = eps,
        o = 0,
        l, p;
    for (l = 1; l <= g.nC2_; ++l) {     // l is index of C2[l]
      p = Math.floor((g.nC2_ - l) / 2); // order of polynomial in eps^2
      c[l] = d * m.polyval(p, C2f_coeff, o, eps2) / C2f_coeff[o + p + 1];
      o += p + 2;
      d *= eps;
    }
  };

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @summary Initialize a Geodesic object for a specific ellipsoid.
   * @classdesc Performs geodesic calculations on an ellipsoid of revolution.
   *   The routines for solving the direct and inverse problems return an
   *   object with some of the following fields set: lat1, lon1, azi1, lat2,
   *   lon2, azi2, s12, a12, m12, M12, M21, S12.  See {@tutorial 2-interface},
   *   "The results".
   * @example
   * var GeographicLib = require("geographiclib"),
   *     geod = GeographicLib.Geodesic.WGS84;
   * var inv = geod.Inverse(1,2,3,4);
   * console.log("lat1 = " + inv.lat1 + ", lon1 = " + inv.lon1 +
   *             ", lat2 = " + inv.lat2 + ", lon2 = " + inv.lon2 +
   *             ",\nazi1 = " + inv.azi1 + ", azi2 = " + inv.azi2 +
   *             ", s12 = " + inv.s12);
   * @param {number} a the equatorial radius of the ellipsoid (meters).
   * @param {number} f the flattening of the ellipsoid.  Setting f = 0 gives
   *   a sphere (on which geodesics are great circles).  Negative f gives a
   *   prolate ellipsoid.
   * @throws an error if the parameters are illegal.
   */
  g.Geodesic = function(a, f) {
    this.a = a;
    this.f = f;
    this._f1 = 1 - this.f;
    this._e2 = this.f * (2 - this.f);
    this._ep2 = this._e2 / m.sq(this._f1); // e2 / (1 - e2)
    this._n = this.f / ( 2 - this.f);
    this._b = this.a * this._f1;
    // authalic radius squared
    this._c2 = (m.sq(this.a) + m.sq(this._b) *
                (this._e2 === 0 ? 1 :
                 (this._e2 > 0 ? m.atanh(Math.sqrt(this._e2)) :
                  Math.atan(Math.sqrt(-this._e2))) /
                 Math.sqrt(Math.abs(this._e2))))/2;
    // The sig12 threshold for "really short".  Using the auxiliary sphere
    // solution with dnm computed at (bet1 + bet2) / 2, the relative error in
    // the azimuth consistency check is sig12^2 * abs(f) * min(1, 1-f/2) / 2.
    // (Error measured for 1/100 < b/a < 100 and abs(f) >= 1/1000.  For a given
    // f and sig12, the max error occurs for lines near the pole.  If the old
    // rule for computing dnm = (dn1 + dn2)/2 is used, then the error increases
    // by a factor of 2.)  Setting this equal to epsilon gives sig12 = etol2.
    // Here 0.1 is a safety factor (error decreased by 100) and max(0.001,
    // abs(f)) stops etol2 getting too large in the nearly spherical case.
    this._etol2 = 0.1 * tol2_ /
      Math.sqrt( Math.max(0.001, Math.abs(this.f)) *
                 Math.min(1.0, 1 - this.f/2) / 2 );
    if (!(isFinite(this.a) && this.a > 0))
      throw new Error("Equatorial radius is not positive");
    if (!(isFinite(this._b) && this._b > 0))
      throw new Error("Polar semi-axis is not positive");
    this._A3x = new Array(nA3x_);
    this._C3x = new Array(nC3x_);
    this._C4x = new Array(nC4x_);
    this.A3coeff();
    this.C3coeff();
    this.C4coeff();
  };

  A3_coeff = [
    // A3, coeff of eps^5, polynomial in n of order 0
      -3, 128,
    // A3, coeff of eps^4, polynomial in n of order 1
      -2, -3, 64,
    // A3, coeff of eps^3, polynomial in n of order 2
      -1, -3, -1, 16,
    // A3, coeff of eps^2, polynomial in n of order 2
      +3, -1, -2, 8,
    // A3, coeff of eps^1, polynomial in n of order 1
      +1, -1, 2,
    // A3, coeff of eps^0, polynomial in n of order 0
      +1, 1
  ];

  // The scale factor A3 = mean value of (d/dsigma)I3
  g.Geodesic.prototype.A3coeff = function() {
    var o = 0, k = 0,
        j, p;
    for (j = nA3_ - 1; j >= 0; --j) { // coeff of eps^j
      p = Math.min(nA3_ - j - 1, j);  // order of polynomial in n
      this._A3x[k++] = m.polyval(p, A3_coeff, o, this._n) /
        A3_coeff[o + p + 1];
      o += p + 2;
    }
  };

  C3_coeff = [
    // C3[1], coeff of eps^5, polynomial in n of order 0
      +3, 128,
    // C3[1], coeff of eps^4, polynomial in n of order 1
      +2, 5, 128,
    // C3[1], coeff of eps^3, polynomial in n of order 2
      -1, 3, 3, 64,
    // C3[1], coeff of eps^2, polynomial in n of order 2
      -1, 0, 1, 8,
    // C3[1], coeff of eps^1, polynomial in n of order 1
      -1, 1, 4,
    // C3[2], coeff of eps^5, polynomial in n of order 0
      +5, 256,
    // C3[2], coeff of eps^4, polynomial in n of order 1
      +1, 3, 128,
    // C3[2], coeff of eps^3, polynomial in n of order 2
      -3, -2, 3, 64,
    // C3[2], coeff of eps^2, polynomial in n of order 2
      +1, -3, 2, 32,
    // C3[3], coeff of eps^5, polynomial in n of order 0
      +7, 512,
    // C3[3], coeff of eps^4, polynomial in n of order 1
      -10, 9, 384,
    // C3[3], coeff of eps^3, polynomial in n of order 2
      +5, -9, 5, 192,
    // C3[4], coeff of eps^5, polynomial in n of order 0
      +7, 512,
    // C3[4], coeff of eps^4, polynomial in n of order 1
      -14, 7, 512,
    // C3[5], coeff of eps^5, polynomial in n of order 0
      +21, 2560
  ];

  // The coefficients C3[l] in the Fourier expansion of B3
  g.Geodesic.prototype.C3coeff = function() {
    var o = 0, k = 0,
        l, j, p;
    for (l = 1; l < g.nC3_; ++l) {        // l is index of C3[l]
      for (j = g.nC3_ - 1; j >= l; --j) { // coeff of eps^j
        p = Math.min(g.nC3_ - j - 1, j);  // order of polynomial in n
        this._C3x[k++] = m.polyval(p, C3_coeff, o, this._n) /
          C3_coeff[o + p + 1];
        o += p + 2;
      }
    }
  };

  C4_coeff = [
    // C4[0], coeff of eps^5, polynomial in n of order 0
      +97, 15015,
    // C4[0], coeff of eps^4, polynomial in n of order 1
      +1088, 156, 45045,
    // C4[0], coeff of eps^3, polynomial in n of order 2
      -224, -4784, 1573, 45045,
    // C4[0], coeff of eps^2, polynomial in n of order 3
      -10656, 14144, -4576, -858, 45045,
    // C4[0], coeff of eps^1, polynomial in n of order 4
      +64, 624, -4576, 6864, -3003, 15015,
    // C4[0], coeff of eps^0, polynomial in n of order 5
      +100, 208, 572, 3432, -12012, 30030, 45045,
    // C4[1], coeff of eps^5, polynomial in n of order 0
      +1, 9009,
    // C4[1], coeff of eps^4, polynomial in n of order 1
      -2944, 468, 135135,
    // C4[1], coeff of eps^3, polynomial in n of order 2
      +5792, 1040, -1287, 135135,
    // C4[1], coeff of eps^2, polynomial in n of order 3
      +5952, -11648, 9152, -2574, 135135,
    // C4[1], coeff of eps^1, polynomial in n of order 4
      -64, -624, 4576, -6864, 3003, 135135,
    // C4[2], coeff of eps^5, polynomial in n of order 0
      +8, 10725,
    // C4[2], coeff of eps^4, polynomial in n of order 1
      +1856, -936, 225225,
    // C4[2], coeff of eps^3, polynomial in n of order 2
      -8448, 4992, -1144, 225225,
    // C4[2], coeff of eps^2, polynomial in n of order 3
      -1440, 4160, -4576, 1716, 225225,
    // C4[3], coeff of eps^5, polynomial in n of order 0
      -136, 63063,
    // C4[3], coeff of eps^4, polynomial in n of order 1
      +1024, -208, 105105,
    // C4[3], coeff of eps^3, polynomial in n of order 2
      +3584, -3328, 1144, 315315,
    // C4[4], coeff of eps^5, polynomial in n of order 0
      -128, 135135,
    // C4[4], coeff of eps^4, polynomial in n of order 1
      -2560, 832, 405405,
    // C4[5], coeff of eps^5, polynomial in n of order 0
      +128, 99099
  ];

  g.Geodesic.prototype.C4coeff = function() {
    var o = 0, k = 0,
        l, j, p;
    for (l = 0; l < g.nC4_; ++l) {        // l is index of C4[l]
      for (j = g.nC4_ - 1; j >= l; --j) { // coeff of eps^j
        p = g.nC4_ - j - 1;               // order of polynomial in n
        this._C4x[k++] = m.polyval(p, C4_coeff, o, this._n) /
          C4_coeff[o + p + 1];
        o += p + 2;
      }
    }
  };

  g.Geodesic.prototype.A3f = function(eps) {
    // Evaluate A3
    return m.polyval(nA3x_ - 1, this._A3x, 0, eps);
  };

  g.Geodesic.prototype.C3f = function(eps, c) {
    // Evaluate C3 coeffs
    // Elements c[1] thru c[nC3_ - 1] are set
    var mult = 1,
        o = 0,
        l, p;
    for (l = 1; l < g.nC3_; ++l) { // l is index of C3[l]
      p = g.nC3_ - l - 1;          // order of polynomial in eps
      mult *= eps;
      c[l] = mult * m.polyval(p, this._C3x, o, eps);
      o += p + 1;
    }
  };

  g.Geodesic.prototype.C4f = function(eps, c) {
    // Evaluate C4 coeffs
    // Elements c[0] thru c[g.nC4_ - 1] are set
    var mult = 1,
        o = 0,
        l, p;
    for (l = 0; l < g.nC4_; ++l) { // l is index of C4[l]
      p = g.nC4_ - l - 1;          // order of polynomial in eps
      c[l] = mult * m.polyval(p, this._C4x, o, eps);
      o += p + 1;
      mult *= eps;
    }
  };

  // return s12b, m12b, m0, M12, M21
  g.Geodesic.prototype.Lengths = function(eps, sig12,
                                          ssig1, csig1, dn1, ssig2, csig2, dn2,
                                          cbet1, cbet2, outmask,
                                          C1a, C2a) {
    // Return m12b = (reduced length)/_b; also calculate s12b =
    // distance/_b, and m0 = coefficient of secular term in
    // expression for reduced length.
    outmask &= g.OUT_MASK;
    var vals = {},
        m0x = 0, J12 = 0, A1 = 0, A2 = 0,
        B1, B2, l, csig12, t;
    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      A1 = g.A1m1f(eps);
      g.C1f(eps, C1a);
      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
        A2 = g.A2m1f(eps);
        g.C2f(eps, C2a);
        m0x = A1 - A2;
        A2 = 1 + A2;
      }
      A1 = 1 + A1;
    }
    if (outmask & g.DISTANCE) {
      B1 = g.SinCosSeries(true, ssig2, csig2, C1a) -
        g.SinCosSeries(true, ssig1, csig1, C1a);
      // Missing a factor of _b
      vals.s12b = A1 * (sig12 + B1);
      if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
        B2 = g.SinCosSeries(true, ssig2, csig2, C2a) -
          g.SinCosSeries(true, ssig1, csig1, C2a);
        J12 = m0x * sig12 + (A1 * B1 - A2 * B2);
      }
    } else if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      // Assume here that nC1_ >= nC2_
      for (l = 1; l <= g.nC2_; ++l)
        C2a[l] = A1 * C1a[l] - A2 * C2a[l];
      J12 = m0x * sig12 + (g.SinCosSeries(true, ssig2, csig2, C2a) -
                           g.SinCosSeries(true, ssig1, csig1, C2a));
    }
    if (outmask & g.REDUCEDLENGTH) {
      vals.m0 = m0x;
      // Missing a factor of _b.
      // Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure
      // accurate cancellation in the case of coincident points.
      vals.m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -
        csig1 * csig2 * J12;
    }
    if (outmask & g.GEODESICSCALE) {
      csig12 = csig1 * csig2 + ssig1 * ssig2;
      t = this._ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);
      vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;
      vals.M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;
    }
    return vals;
  };

  // return sig12, salp1, calp1, salp2, calp2, dnm
  g.Geodesic.prototype.InverseStart = function(sbet1, cbet1, dn1,
                                               sbet2, cbet2, dn2,
                                               lam12, slam12, clam12,
                                               C1a, C2a) {
    // Return a starting point for Newton's method in salp1 and calp1
    // (function value is -1).  If Newton's method doesn't need to be
    // used, return also salp2 and calp2 and function value is sig12.
    // salp2, calp2 only updated if return val >= 0.
    var vals = {},
        // bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0]
        sbet12 = sbet2 * cbet1 - cbet2 * sbet1,
        cbet12 = cbet2 * cbet1 + sbet2 * sbet1,
        sbet12a, shortline, omg12, sbetm2, somg12, comg12, t, ssig12, csig12,
        x, y, lamscale, betscale, k2, eps, cbet12a, bet12a, m12b, m0, nvals,
        k, omg12a, lam12x;
    vals.sig12 = -1;        // Return value
    // Volatile declaration needed to fix inverse cases
    // 88.202499451857 0 -88.202499451857 179.981022032992859592
    // 89.262080389218 0 -89.262080389218 179.992207982775375662
    // 89.333123580033 0 -89.333123580032997687 179.99295812360148422
    // which otherwise fail with g++ 4.4.4 x86 -O3
    sbet12a = sbet2 * cbet1;
    sbet12a += cbet2 * sbet1;

    shortline = cbet12 >= 0 && sbet12 < 0.5 && cbet2 * lam12 < 0.5;
    if (shortline) {
      sbetm2 = m.sq(sbet1 + sbet2);
      // sin((bet1+bet2)/2)^2
      // =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2)
      sbetm2 /= sbetm2 + m.sq(cbet1 + cbet2);
      vals.dnm = Math.sqrt(1 + this._ep2 * sbetm2);
      omg12 = lam12 / (this._f1 * vals.dnm);
      somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);
    } else {
      somg12 = slam12; comg12 = clam12;
    }

    vals.salp1 = cbet2 * somg12;
    vals.calp1 = comg12 >= 0 ?
      sbet12 + cbet2 * sbet1 * m.sq(somg12) / (1 + comg12) :
      sbet12a - cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);

    ssig12 = m.hypot(vals.salp1, vals.calp1);
    csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;
    if (shortline && ssig12 < this._etol2) {
      // really short lines
      vals.salp2 = cbet1 * somg12;
      vals.calp2 = sbet12 - cbet1 * sbet2 *
        (comg12 >= 0 ? m.sq(somg12) / (1 + comg12) : 1 - comg12);
      // norm(vals.salp2, vals.calp2);
      t = m.hypot(vals.salp2, vals.calp2); vals.salp2 /= t; vals.calp2 /= t;
      // Set return value
      vals.sig12 = Math.atan2(ssig12, csig12);
    } else if (Math.abs(this._n) > 0.1 || // Skip astroid calc if too eccentric
               csig12 >= 0 ||
               ssig12 >= 6 * Math.abs(this._n) * Math.PI * m.sq(cbet1)) {
      // Nothing to do, zeroth order spherical approximation is OK
    } else {
      // Scale lam12 and bet2 to x, y coordinate system where antipodal
      // point is at origin and singular point is at y = 0, x = -1.
      lam12x = Math.atan2(-slam12, -clam12); // lam12 - pi
      if (this.f >= 0) {       // In fact f == 0 does not get here
        // x = dlong, y = dlat
        k2 = m.sq(sbet1) * this._ep2;
        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
        lamscale = this.f * cbet1 * this.A3f(eps) * Math.PI;
        betscale = lamscale * cbet1;

        x = lam12x / lamscale;
        y = sbet12a / betscale;
      } else {                  // f < 0
        // x = dlat, y = dlong
        cbet12a = cbet2 * cbet1 - sbet2 * sbet1;
        bet12a = Math.atan2(sbet12a, cbet12a);
        // In the case of lon12 = 180, this repeats a calculation made
        // in Inverse.
        nvals = this.Lengths(this._n, Math.PI + bet12a,
                             sbet1, -cbet1, dn1, sbet2, cbet2, dn2,
                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
        m12b = nvals.m12b; m0 = nvals.m0;
        x = -1 + m12b / (cbet1 * cbet2 * m0 * Math.PI);
        betscale = x < -0.01 ? sbet12a / x :
          -this.f * m.sq(cbet1) * Math.PI;
        lamscale = betscale / cbet1;
        y = lam12 / lamscale;
      }

      if (y > -tol1_ && x > -1 - xthresh_) {
        // strip near cut
        if (this.f >= 0) {
          vals.salp1 = Math.min(1, -x);
          vals.calp1 = -Math.sqrt(1 - m.sq(vals.salp1));
        } else {
          vals.calp1 = Math.max(x > -tol1_ ? 0 : -1, x);
          vals.salp1 = Math.sqrt(1 - m.sq(vals.calp1));
        }
      } else {
        // Estimate alp1, by solving the astroid problem.
        //
        // Could estimate alpha1 = theta + pi/2, directly, i.e.,
        //   calp1 = y/k; salp1 = -x/(1+k);  for f >= 0
        //   calp1 = x/(1+k); salp1 = -y/k;  for f < 0 (need to check)
        //
        // However, it's better to estimate omg12 from astroid and use
        // spherical formula to compute alp1.  This reduces the mean number of
        // Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12
        // (min 0 max 5).  The changes in the number of iterations are as
        // follows:
        //
        // change percent
        //    1       5
        //    0      78
        //   -1      16
        //   -2       0.6
        //   -3       0.04
        //   -4       0.002
        //
        // The histogram of iterations is (m = number of iterations estimating
        // alp1 directly, n = number of iterations estimating via omg12, total
        // number of trials = 148605):
        //
        //  iter    m      n
        //    0   148    186
        //    1 13046  13845
        //    2 93315 102225
        //    3 36189  32341
        //    4  5396      7
        //    5   455      1
        //    6    56      0
        //
        // Because omg12 is near pi, estimate work with omg12a = pi - omg12
        k = astroid(x, y);
        omg12a = lamscale * ( this.f >= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );
        somg12 = Math.sin(omg12a); comg12 = -Math.cos(omg12a);
        // Update spherical estimate of alp1 using omg12 instead of
        // lam12
        vals.salp1 = cbet2 * somg12;
        vals.calp1 = sbet12a -
          cbet2 * sbet1 * m.sq(somg12) / (1 - comg12);
      }
    }
    // Sanity check on starting guess.  Backwards check allows NaN through.
    if (!(vals.salp1 <= 0.0)) {
      // norm(vals.salp1, vals.calp1);
      t = m.hypot(vals.salp1, vals.calp1); vals.salp1 /= t; vals.calp1 /= t;
    } else {
      vals.salp1 = 1; vals.calp1 = 0;
    }
    return vals;
  };

  // return lam12, salp2, calp2, sig12, ssig1, csig1, ssig2, csig2, eps,
  // domg12, dlam12,
  g.Geodesic.prototype.Lambda12 = function(sbet1, cbet1, dn1, sbet2, cbet2, dn2,
                                           salp1, calp1, slam120, clam120,
                                           diffp, C1a, C2a, C3a) {
    var vals = {},
        t, salp0, calp0,
        somg1, comg1, somg2, comg2, somg12, comg12, B312, eta, k2, nvals;
    if (sbet1 === 0 && calp1 === 0)
      // Break degeneracy of equatorial line.  This case has already been
      // handled.
      calp1 = -g.tiny_;

    // sin(alp1) * cos(bet1) = sin(alp0)
    salp0 = salp1 * cbet1;
    calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0

    // tan(bet1) = tan(sig1) * cos(alp1)
    // tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1)
    vals.ssig1 = sbet1; somg1 = salp0 * sbet1;
    vals.csig1 = comg1 = calp1 * cbet1;
    // norm(vals.ssig1, vals.csig1);
    t = m.hypot(vals.ssig1, vals.csig1); vals.ssig1 /= t; vals.csig1 /= t;
    // norm(somg1, comg1); -- don't need to normalize!

    // Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful
    // about this case, since this can yield singularities in the Newton
    // iteration.
    // sin(alp2) * cos(bet2) = sin(alp0)
    vals.salp2 = cbet2 !== cbet1 ? salp0 / cbet2 : salp1;
    // calp2 = sqrt(1 - sq(salp2))
    //       = sqrt(sq(calp0) - sq(sbet2)) / cbet2
    // and subst for calp0 and rearrange to give (choose positive sqrt
    // to give alp2 in [0, pi/2]).
    vals.calp2 = cbet2 !== cbet1 || Math.abs(sbet2) !== -sbet1 ?
      Math.sqrt(m.sq(calp1 * cbet1) + (cbet1 < -sbet1 ?
                                       (cbet2 - cbet1) * (cbet1 + cbet2) :
                                       (sbet1 - sbet2) * (sbet1 + sbet2))) /
      cbet2 : Math.abs(calp1);
    // tan(bet2) = tan(sig2) * cos(alp2)
    // tan(omg2) = sin(alp0) * tan(sig2).
    vals.ssig2 = sbet2; somg2 = salp0 * sbet2;
    vals.csig2 = comg2 = vals.calp2 * cbet2;
    // norm(vals.ssig2, vals.csig2);
    t = m.hypot(vals.ssig2, vals.csig2); vals.ssig2 /= t; vals.csig2 /= t;
    // norm(somg2, comg2); -- don't need to normalize!

    // sig12 = sig2 - sig1, limit to [0, pi]
    vals.sig12 = Math.atan2(Math.max(0, vals.csig1 * vals.ssig2 -
                                        vals.ssig1 * vals.csig2),
                                        vals.csig1 * vals.csig2 +
                                        vals.ssig1 * vals.ssig2);

    // omg12 = omg2 - omg1, limit to [0, pi]
    somg12 = Math.max(0, comg1 * somg2 - somg1 * comg2);
    comg12 =             comg1 * comg2 + somg1 * somg2;
    // eta = omg12 - lam120
    eta = Math.atan2(somg12 * clam120 - comg12 * slam120,
                     comg12 * clam120 + somg12 * slam120);
    k2 = m.sq(calp0) * this._ep2;
    vals.eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
    this.C3f(vals.eps, C3a);
    B312 = (g.SinCosSeries(true, vals.ssig2, vals.csig2, C3a) -
            g.SinCosSeries(true, vals.ssig1, vals.csig1, C3a));
    vals.domg12 =  -this.f * this.A3f(vals.eps) * salp0 * (vals.sig12 + B312);
    vals.lam12 = eta + vals.domg12;
    if (diffp) {
      if (vals.calp2 === 0)
        vals.dlam12 = -2 * this._f1 * dn1 / sbet1;
      else {
        nvals = this.Lengths(vals.eps, vals.sig12,
                             vals.ssig1, vals.csig1, dn1,
                             vals.ssig2, vals.csig2, dn2,
                             cbet1, cbet2, g.REDUCEDLENGTH, C1a, C2a);
        vals.dlam12 = nvals.m12b;
        vals.dlam12 *= this._f1 / (vals.calp2 * cbet2);
      }
    }
    return vals;
  };

  /**
   * @summary Solve the inverse geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} lat2 the latitude of the second point in degrees.
   * @param {number} lon2 the longitude of the second point in degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results
   * @description The lat1, lon1, lat2, lon2, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Inverse = function(lat1, lon1, lat2, lon2, outmask) {
    var r, vals;
    if (!outmask) outmask = g.STANDARD;
    if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    outmask &= g.OUT_MASK;
    r = this.InverseInt(lat1, lon1, lat2, lon2, outmask);
    vals = r.vals;
    if (outmask & g.AZIMUTH) {
      vals.azi1 = m.atan2d(r.salp1, r.calp1);
      vals.azi2 = m.atan2d(r.salp2, r.calp2);
    }
    return vals;
  };

  g.Geodesic.prototype.InverseInt = function(lat1, lon1, lat2, lon2, outmask) {
    var vals = {},
        lon12, lon12s, lonsign, t, swapp, latsign,
        sbet1, cbet1, sbet2, cbet2, s12x, m12x,
        dn1, dn2, lam12, slam12, clam12,
        sig12, calp1, salp1, calp2, salp2, C1a, C2a, C3a, meridian, nvals,
        ssig1, csig1, ssig2, csig2, eps, omg12, dnm,
        numit, salp1a, calp1a, salp1b, calp1b,
        tripn, tripb, v, dv, dalp1, sdalp1, cdalp1, nsalp1,
        lengthmask, salp0, calp0, alp12, k2, A4, C4a, B41, B42,
        somg12, comg12, domg12, dbet1, dbet2, salp12, calp12, sdomg12, cdomg12;
    // Compute longitude difference (AngDiff does this carefully).  Result is
    // in [-180, 180] but -180 is only for west-going geodesics.  180 is for
    // east-going and meridional geodesics.
    vals.lat1 = lat1 = m.LatFix(lat1); vals.lat2 = lat2 = m.LatFix(lat2);
    // If really close to the equator, treat as on equator.
    lat1 = m.AngRound(lat1);
    lat2 = m.AngRound(lat2);
    lon12 = m.AngDiff(lon1, lon2); lon12s = lon12.t; lon12 = lon12.s;
    if (outmask & g.LONG_UNROLL) {
      vals.lon1 = lon1; vals.lon2 = (lon1 + lon12) + lon12s;
    } else {
      vals.lon1 = m.AngNormalize(lon1); vals.lon2 = m.AngNormalize(lon2);
    }
    // Make longitude difference positive.
    lonsign = lon12 >= 0 ? 1 : -1;
    // If very close to being on the same half-meridian, then make it so.
    lon12 = lonsign * m.AngRound(lon12);
    lon12s = m.AngRound((180 - lon12) - lonsign * lon12s);
    lam12 = lon12 * m.degree;
    t = m.sincosd(lon12 > 90 ? lon12s : lon12);
    slam12 = t.s; clam12 = (lon12 > 90 ? -1 : 1) * t.c;

    // Swap points so that point with higher (abs) latitude is point 1
    // If one latitude is a nan, then it becomes lat1.
    swapp = Math.abs(lat1) < Math.abs(lat2) ? -1 : 1;
    if (swapp < 0) {
      lonsign *= -1;
      t = lat1;
      lat1 = lat2;
      lat2 = t;
      // swap(lat1, lat2);
    }
    // Make lat1 <= 0
    latsign = lat1 < 0 ? 1 : -1;
    lat1 *= latsign;
    lat2 *= latsign;
    // Now we have
    //
    //     0 <= lon12 <= 180
    //     -90 <= lat1 <= 0
    //     lat1 <= lat2 <= -lat1
    //
    // longsign, swapp, latsign register the transformation to bring the
    // coordinates to this canonical form.  In all cases, 1 means no change was
    // made.  We make these transformations so that there are few cases to
    // check, e.g., on verifying quadrants in atan2.  In addition, this
    // enforces some symmetries in the results returned.

    t = m.sincosd(lat1); sbet1 = this._f1 * t.s; cbet1 = t.c;
    // norm(sbet1, cbet1);
    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;
    // Ensure cbet1 = +epsilon at poles
    cbet1 = Math.max(g.tiny_, cbet1);

    t = m.sincosd(lat2); sbet2 = this._f1 * t.s; cbet2 = t.c;
    // norm(sbet2, cbet2);
    t = m.hypot(sbet2, cbet2); sbet2 /= t; cbet2 /= t;
    // Ensure cbet2 = +epsilon at poles
    cbet2 = Math.max(g.tiny_, cbet2);

    // If cbet1 < -sbet1, then cbet2 - cbet1 is a sensitive measure of the
    // |bet1| - |bet2|.  Alternatively (cbet1 >= -sbet1), abs(sbet2) + sbet1 is
    // a better measure.  This logic is used in assigning calp2 in Lambda12.
    // Sometimes these quantities vanish and in that case we force bet2 = +/-
    // bet1 exactly.  An example where is is necessary is the inverse problem
    // 48.522876735459 0 -48.52287673545898293 179.599720456223079643
    // which failed with Visual Studio 10 (Release and Debug)

    if (cbet1 < -sbet1) {
      if (cbet2 === cbet1)
        sbet2 = sbet2 < 0 ? sbet1 : -sbet1;
    } else {
      if (Math.abs(sbet2) === -sbet1)
        cbet2 = cbet1;
    }

    dn1 = Math.sqrt(1 + this._ep2 * m.sq(sbet1));
    dn2 = Math.sqrt(1 + this._ep2 * m.sq(sbet2));

    // index zero elements of these arrays are unused
    C1a = new Array(g.nC1_ + 1);
    C2a = new Array(g.nC2_ + 1);
    C3a = new Array(g.nC3_);

    meridian = lat1 === -90 || slam12 === 0;
    if (meridian) {

      // Endpoints are on a single full meridian, so the geodesic might
      // lie on a meridian.

      calp1 = clam12; salp1 = slam12; // Head to the target longitude
      calp2 = 1; salp2 = 0;           // At the target we're heading north

      // tan(bet) = tan(sig) * cos(alp)
      ssig1 = sbet1; csig1 = calp1 * cbet1;
      ssig2 = sbet2; csig2 = calp2 * cbet2;

      // sig12 = sig2 - sig1
      sig12 = Math.atan2(Math.max(0, csig1 * ssig2 - ssig1 * csig2),
                                     csig1 * csig2 + ssig1 * ssig2);
      nvals = this.Lengths(this._n, sig12,
                           ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,
                           outmask | g.DISTANCE | g.REDUCEDLENGTH,
                           C1a, C2a);
      s12x = nvals.s12b;
      m12x = nvals.m12b;
      // Ignore m0
      if ((outmask & g.GEODESICSCALE) !== 0) {
        vals.M12 = nvals.M12;
        vals.M21 = nvals.M21;
      }
      // Add the check for sig12 since zero length geodesics might yield
      // m12 < 0.  Test case was
      //
      //    echo 20.001 0 20.001 0 | GeodSolve -i
      //
      // In fact, we will have sig12 > pi/2 for meridional geodesic
      // which is not a shortest path.
      if (sig12 < 1 || m12x >= 0) {
        // Need at least 2, to handle 90 0 90 180
        if (sig12 < 3 * g.tiny_)
          sig12 = m12x = s12x = 0;
        m12x *= this._b;
        s12x *= this._b;
        vals.a12 = sig12 / m.degree;
      } else
        // m12 < 0, i.e., prolate and too close to anti-podal
        meridian = false;
    }

    somg12 = 2;
    if (!meridian &&
        sbet1 === 0 &&           // and sbet2 == 0
        (this.f <= 0 || lon12s >= this.f * 180)) {

      // Geodesic runs along equator
      calp1 = calp2 = 0; salp1 = salp2 = 1;
      s12x = this.a * lam12;
      sig12 = omg12 = lam12 / this._f1;
      m12x = this._b * Math.sin(sig12);
      if (outmask & g.GEODESICSCALE)
        vals.M12 = vals.M21 = Math.cos(sig12);
      vals.a12 = lon12 / this._f1;

    } else if (!meridian) {

      // Now point1 and point2 belong within a hemisphere bounded by a
      // meridian and geodesic is neither meridional or equatorial.

      // Figure a starting point for Newton's method
      nvals = this.InverseStart(sbet1, cbet1, dn1, sbet2, cbet2, dn2,
                                lam12, slam12, clam12, C1a, C2a);
      sig12 = nvals.sig12;
      salp1 = nvals.salp1;
      calp1 = nvals.calp1;

      if (sig12 >= 0) {
        salp2 = nvals.salp2;
        calp2 = nvals.calp2;
        // Short lines (InverseStart sets salp2, calp2, dnm)

        dnm = nvals.dnm;
        s12x = sig12 * this._b * dnm;
        m12x = m.sq(dnm) * this._b * Math.sin(sig12 / dnm);
        if (outmask & g.GEODESICSCALE)
          vals.M12 = vals.M21 = Math.cos(sig12 / dnm);
        vals.a12 = sig12 / m.degree;
        omg12 = lam12 / (this._f1 * dnm);
      } else {

        // Newton's method.  This is a straightforward solution of f(alp1) =
        // lambda12(alp1) - lam12 = 0 with one wrinkle.  f(alp) has exactly one
        // root in the interval (0, pi) and its derivative is positive at the
        // root.  Thus f(alp) is positive for alp > alp1 and negative for alp <
        // alp1.  During the course of the iteration, a range (alp1a, alp1b) is
        // maintained which brackets the root and with each evaluation of
        // f(alp) the range is shrunk if possible.  Newton's method is
        // restarted whenever the derivative of f is negative (because the new
        // value of alp1 is then further from the solution) or if the new
        // estimate of alp1 lies outside (0,pi); in this case, the new starting
        // guess is taken to be (alp1a + alp1b) / 2.
        numit = 0;
        // Bracketing range
        salp1a = g.tiny_; calp1a = 1; salp1b = g.tiny_; calp1b = -1;
        for (tripn = false, tripb = false; numit < maxit2_; ++numit) {
          // the WGS84 test set: mean = 1.47, sd = 1.25, max = 16
          // WGS84 and random input: mean = 2.85, sd = 0.60
          nvals = this.Lambda12(sbet1, cbet1, dn1, sbet2, cbet2, dn2,
                                salp1, calp1, slam12, clam12, numit < maxit1_,
                                C1a, C2a, C3a);
          v = nvals.lam12;
          salp2 = nvals.salp2;
          calp2 = nvals.calp2;
          sig12 = nvals.sig12;
          ssig1 = nvals.ssig1;
          csig1 = nvals.csig1;
          ssig2 = nvals.ssig2;
          csig2 = nvals.csig2;
          eps = nvals.eps;
          domg12 = nvals.domg12;
          dv = nvals.dlam12;

          // 2 * tol0 is approximately 1 ulp for a number in [0, pi].
          // Reversed test to allow escape with NaNs
          if (tripb || !(Math.abs(v) >= (tripn ? 8 : 1) * tol0_))
            break;
          // Update bracketing values
          if (v > 0 && (numit < maxit1_ || calp1/salp1 > calp1b/salp1b)) {
            salp1b = salp1; calp1b = calp1;
          } else if (v < 0 &&
                     (numit < maxit1_ || calp1/salp1 < calp1a/salp1a)) {
            salp1a = salp1; calp1a = calp1;
          }
          if (numit < maxit1_ && dv > 0) {
            dalp1 = -v/dv;
            sdalp1 = Math.sin(dalp1); cdalp1 = Math.cos(dalp1);
            nsalp1 = salp1 * cdalp1 + calp1 * sdalp1;
            if (nsalp1 > 0 && Math.abs(dalp1) < Math.PI) {
              calp1 = calp1 * cdalp1 - salp1 * sdalp1;
              salp1 = nsalp1;
              // norm(salp1, calp1);
              t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;
              // In some regimes we don't get quadratic convergence because
              // slope -> 0.  So use convergence conditions based on epsilon
              // instead of sqrt(epsilon).
              tripn = Math.abs(v) <= 16 * tol0_;
              continue;
            }
          }
          // Either dv was not positive or updated value was outside legal
          // range.  Use the midpoint of the bracket as the next estimate.
          // This mechanism is not needed for the WGS84 ellipsoid, but it does
          // catch problems with more eccentric ellipsoids.  Its efficacy is
          // such for the WGS84 test set with the starting guess set to alp1 =
          // 90deg:
          // the WGS84 test set: mean = 5.21, sd = 3.93, max = 24
          // WGS84 and random input: mean = 4.74, sd = 0.99
          salp1 = (salp1a + salp1b)/2;
          calp1 = (calp1a + calp1b)/2;
          // norm(salp1, calp1);
          t = m.hypot(salp1, calp1); salp1 /= t; calp1 /= t;
          tripn = false;
          tripb = (Math.abs(salp1a - salp1) + (calp1a - calp1) < tolb_ ||
                   Math.abs(salp1 - salp1b) + (calp1 - calp1b) < tolb_);
        }
        lengthmask = outmask |
            (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE) ?
             g.DISTANCE : g.NONE);
        nvals = this.Lengths(eps, sig12,
                             ssig1, csig1, dn1, ssig2, csig2, dn2, cbet1, cbet2,
                             lengthmask, C1a, C2a);
        s12x = nvals.s12b;
        m12x = nvals.m12b;
        // Ignore m0
        if ((outmask & g.GEODESICSCALE) !== 0) {
          vals.M12 = nvals.M12;
          vals.M21 = nvals.M21;
        }
        m12x *= this._b;
        s12x *= this._b;
        vals.a12 = sig12 / m.degree;
        if (outmask & g.AREA) {
          // omg12 = lam12 - domg12
          sdomg12 = Math.sin(domg12); cdomg12 = Math.cos(domg12);
          somg12 = slam12 * cdomg12 - clam12 * sdomg12;
          comg12 = clam12 * cdomg12 + slam12 * sdomg12;
        }
      }
    }

    if (outmask & g.DISTANCE)
      vals.s12 = 0 + s12x;      // Convert -0 to 0

    if (outmask & g.REDUCEDLENGTH)
      vals.m12 = 0 + m12x;      // Convert -0 to 0

    if (outmask & g.AREA) {
      // From Lambda12: sin(alp1) * cos(bet1) = sin(alp0)
      salp0 = salp1 * cbet1;
      calp0 = m.hypot(calp1, salp1 * sbet1); // calp0 > 0
      if (calp0 !== 0 && salp0 !== 0) {
        // From Lambda12: tan(bet) = tan(sig) * cos(alp)
        ssig1 = sbet1; csig1 = calp1 * cbet1;
        ssig2 = sbet2; csig2 = calp2 * cbet2;
        k2 = m.sq(calp0) * this._ep2;
        eps = k2 / (2 * (1 + Math.sqrt(1 + k2)) + k2);
        // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0).
        A4 = m.sq(this.a) * calp0 * salp0 * this._e2;
        // norm(ssig1, csig1);
        t = m.hypot(ssig1, csig1); ssig1 /= t; csig1 /= t;
        // norm(ssig2, csig2);
        t = m.hypot(ssig2, csig2); ssig2 /= t; csig2 /= t;
        C4a = new Array(g.nC4_);
        this.C4f(eps, C4a);
        B41 = g.SinCosSeries(false, ssig1, csig1, C4a);
        B42 = g.SinCosSeries(false, ssig2, csig2, C4a);
        vals.S12 = A4 * (B42 - B41);
      } else
        // Avoid problems with indeterminate sig1, sig2 on equator
        vals.S12 = 0;
      if (!meridian && somg12 > 1) {
        somg12 = Math.sin(omg12); comg12 = Math.cos(omg12);
      }
      if (!meridian &&
          comg12 > -0.7071 &&      // Long difference not too big
          sbet2 - sbet1 < 1.75) { // Lat difference not too big
        // Use tan(Gamma/2) = tan(omg12/2)
        // * (tan(bet1/2)+tan(bet2/2))/(1+tan(bet1/2)*tan(bet2/2))
        // with tan(x/2) = sin(x)/(1+cos(x))
        domg12 = 1 + comg12; dbet1 = 1 + cbet1; dbet2 = 1 + cbet2;
        alp12 = 2 * Math.atan2( somg12 * (sbet1*dbet2 + sbet2*dbet1),
                                domg12 * (sbet1*sbet2 + dbet1*dbet2) );
      } else {
        // alp12 = alp2 - alp1, used in atan2 so no need to normalize
        salp12 = salp2 * calp1 - calp2 * salp1;
        calp12 = calp2 * calp1 + salp2 * salp1;
        // The right thing appears to happen if alp1 = +/-180 and alp2 = 0, viz
        // salp12 = -0 and alp12 = -180.  However this depends on the sign
        // being attached to 0 correctly.  The following ensures the correct
        // behavior.
        if (salp12 === 0 && calp12 < 0) {
          salp12 = g.tiny_ * calp1;
          calp12 = -1;
        }
        alp12 = Math.atan2(salp12, calp12);
      }
      vals.S12 += this._c2 * alp12;
      vals.S12 *= swapp * lonsign * latsign;
      // Convert -0 to 0
      vals.S12 += 0;
    }

    // Convert calp, salp to azimuth accounting for lonsign, swapp, latsign.
    if (swapp < 0) {
      t = salp1;
      salp1 = salp2;
      salp2 = t;
      // swap(salp1, salp2);
      t = calp1;
      calp1 = calp2;
      calp2 = t;
      // swap(calp1, calp2);
      if (outmask & g.GEODESICSCALE) {
        t = vals.M12;
        vals.M12 = vals.M21;
        vals.M21 = t;
        // swap(vals.M12, vals.M21);
      }
    }

    salp1 *= swapp * lonsign; calp1 *= swapp * latsign;
    salp2 *= swapp * lonsign; calp2 *= swapp * latsign;

    return {vals: vals,
            salp1: salp1, calp1: calp1,
            salp2: salp2, calp2: calp2};
  };

  /**
   * @summary Solve the general direct geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {bool} arcmode is the next parameter an arc length?
   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the
   *   first point to the second in (arcmode ? degrees : meters).
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are always
   *   set; s12 is included if arcmode is false.  For details on the outmask
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.GenDirect = function(lat1, lon1, azi1,
                                            arcmode, s12_a12, outmask) {
    var line;
    if (!outmask) outmask = g.STANDARD;
    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    // Automatically supply DISTANCE_IN if necessary
    if (!arcmode) outmask |= g.DISTANCE_IN;
    line = new l.GeodesicLine(this, lat1, lon1, azi1, outmask);
    return line.GenPosition(arcmode, s12_a12, outmask);
  };

  /**
   * @summary Solve the direct geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {number} s12 the distance from the first point to the second in
   *   meters.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Direct = function(lat1, lon1, azi1, s12, outmask) {
    return this.GenDirect(lat1, lon1, azi1, false, s12, outmask);
  };

  /**
   * @summary Solve the direct geodesic problem with arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {number} a12 the arc length from the first point to the second in
   *   degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.ArcDirect = function(lat1, lon1, azi1, a12, outmask) {
    return this.GenDirect(lat1, lon1, azi1, true, a12, outmask);
  };

  /**
   * @summary Create a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description For details on the caps parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  g.Geodesic.prototype.Line = function(lat1, lon1, azi1, caps) {
    return new l.GeodesicLine(this, lat1, lon1, azi1, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of distance.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {number} s12 the distance between point 1 and point 2 (meters); it
   *   can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.DirectLine = function(lat1, lon1, azi1, s12, caps) {
    return this.GenDirectLine(lat1, lon1, azi1, false, s12, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {number} a12 the arc length between point 1 and point 2 (degrees);
   *   it can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.ArcDirectLine = function(lat1, lon1, azi1, a12, caps) {
    return this.GenDirectLine(lat1, lon1, azi1, true, a12, caps);
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the direct geodesic problem specified in terms
   *   of either distance or arc length.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   *   degrees.
   * @param {bool} arcmode boolean flag determining the meaning of the
   *   s12_a12.
   * @param {number} s12_a12 if arcmode is false, this is the distance between
   *   point 1 and point 2 (meters); otherwise it is the arc length between
   *   point 1 and point 2 (degrees); it can be negative.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the direct geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.GenDirectLine = function(lat1, lon1, azi1,
                                                arcmode, s12_a12, caps) {
    var t;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
    // Automatically supply DISTANCE_IN if necessary
    if (!arcmode) caps |= g.DISTANCE_IN;
    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps);
    t.GenSetDistance(arcmode, s12_a12);
    return t;
  };

  /**
   * @summary Define a {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} in terms of the inverse geodesic problem.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} lat2 the latitude of the second point in degrees.
   * @param {number} lon2 the longitude of the second point in degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include.
   * @returns {object} the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine
   *   GeodesicLine} object
   * @description This function sets point 3 of the GeodesicLine to correspond
   *   to point 2 of the inverse geodesic problem.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  g.Geodesic.prototype.InverseLine = function(lat1, lon1, lat2, lon2, caps) {
    var r, t, azi1;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;
    r = this.InverseInt(lat1, lon1, lat2, lon2, g.ARC);
    azi1 = m.atan2d(r.salp1, r.calp1);
    // Ensure that a12 can be converted to a distance
    if (caps & (g.OUT_MASK & g.DISTANCE_IN)) caps |= g.DISTANCE;
    t = new l.GeodesicLine(this, lat1, lon1, azi1, caps, r.salp1, r.calp1);
    t.SetArc(r.vals.a12);
    return t;
  };

  /**
   * @summary Create a {@link module:GeographicLib/PolygonArea.PolygonArea
   *   PolygonArea} object.
   * @param {bool} [polyline = false] if true the new PolygonArea object
   *   describes a polyline instead of a polygon.
   * @returns {object} the
   *   {@link module:GeographicLib/PolygonArea.PolygonArea
   *   PolygonArea} object
   */
  g.Geodesic.prototype.Polygon = function(polyline) {
    return new p.PolygonArea(this, polyline);
  };

  /**
   * @summary a {@link module:GeographicLib/Geodesic.Geodesic Geodesic} object
   *   initialized for the WGS84 ellipsoid.
   * @constant {object}
   */
  g.WGS84 = new g.Geodesic(c.WGS84.a, c.WGS84.f);
})(GeographicLib.Geodesic, GeographicLib.GeodesicLine,
   GeographicLib.PolygonArea, GeographicLib.Math, GeographicLib.Constants);

/**************** GeodesicLine.js ****************/
/*
 * GeodesicLine.js
 * Transcription of GeodesicLine.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2016) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER GeographicLib/Math.js, GeographicLib/Geodesic.js

(function(
  g,
  /**
   * @exports GeographicLib/GeodesicLine
   * @description Solve geodesic problems on a single geodesic line via the
   *   {@link module:GeographicLib/GeodesicLine.GeodesicLine GeodesicLine}
   *   class.
   */
  l, m) {

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @property {number} lat1 the initial latitude (degrees).
   * @property {number} lon1 the initial longitude (degrees).
   * @property {number} azi1 the initial azimuth (degrees).
   * @property {number} salp1 the sine of the azimuth at the first point.
   * @property {number} calp1 the cosine the azimuth at the first point.
   * @property {number} s13 the distance to point 3 (meters).
   * @property {number} a13 the arc length to point 3 (degrees).
   * @property {bitmask} caps the capabilities of the object.
   * @summary Initialize a GeodesicLine object.  For details on the caps
   *   parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   * @classdesc Performs geodesic calculations along a given geodesic line.
   *   This object is usually instantiated by
   *   {@link module:GeographicLib/Geodesic.Geodesic#Line Geodesic.Line}.
   *   The methods
   *   {@link module:GeographicLib/Geodesic.Geodesic#DirectLine
   *   Geodesic.DirectLine} and
   *   {@link module:GeographicLib/Geodesic.Geodesic#InverseLine
   *   Geodesic.InverseLine} set in addition the position of a reference point
   *   3.
   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic
   *   Geodesic} object.
   * @param {number} lat1 the latitude of the first point in degrees.
   * @param {number} lon1 the longitude of the first point in degrees.
   * @param {number} azi1 the azimuth at the first point in degrees.
   * @param {bitmask} [caps = STANDARD | DISTANCE_IN] which capabilities to
   *   include; LATITUDE | AZIMUTH are always included.
   */
  l.GeodesicLine = function(geod, lat1, lon1, azi1, caps, salp1, calp1) {
    var t, cbet1, sbet1, eps, s, c;
    if (!caps) caps = g.STANDARD | g.DISTANCE_IN;

    this.a = geod.a;
    this.f = geod.f;
    this._b = geod._b;
    this._c2 = geod._c2;
    this._f1 = geod._f1;
    this.caps = caps | g.LATITUDE | g.AZIMUTH | g.LONG_UNROLL;

    this.lat1 = m.LatFix(lat1);
    this.lon1 = lon1;
    if (typeof salp1 === 'undefined' || typeof calp1 === 'undefined') {
      this.azi1 = m.AngNormalize(azi1);
      t = m.sincosd(m.AngRound(this.azi1)); this.salp1 = t.s; this.calp1 = t.c;
    } else {
      this.azi1 = azi1; this.salp1 = salp1; this.calp1 = calp1;
    }
    t = m.sincosd(m.AngRound(this.lat1)); sbet1 = this._f1 * t.s; cbet1 = t.c;
    // norm(sbet1, cbet1);
    t = m.hypot(sbet1, cbet1); sbet1 /= t; cbet1 /= t;
    // Ensure cbet1 = +epsilon at poles
    cbet1 = Math.max(g.tiny_, cbet1);
    this._dn1 = Math.sqrt(1 + geod._ep2 * m.sq(sbet1));

    // Evaluate alp0 from sin(alp1) * cos(bet1) = sin(alp0),
    this._salp0 = this.salp1 * cbet1; // alp0 in [0, pi/2 - |bet1|]
    // Alt: calp0 = hypot(sbet1, calp1 * cbet1).  The following
    // is slightly better (consider the case salp1 = 0).
    this._calp0 = m.hypot(this.calp1, this.salp1 * sbet1);
    // Evaluate sig with tan(bet1) = tan(sig1) * cos(alp1).
    // sig = 0 is nearest northward crossing of equator.
    // With bet1 = 0, alp1 = pi/2, we have sig1 = 0 (equatorial line).
    // With bet1 =  pi/2, alp1 = -pi, sig1 =  pi/2
    // With bet1 = -pi/2, alp1 =  0 , sig1 = -pi/2
    // Evaluate omg1 with tan(omg1) = sin(alp0) * tan(sig1).
    // With alp0 in (0, pi/2], quadrants for sig and omg coincide.
    // No atan2(0,0) ambiguity at poles since cbet1 = +epsilon.
    // With alp0 = 0, omg1 = 0 for alp1 = 0, omg1 = pi for alp1 = pi.
    this._ssig1 = sbet1; this._somg1 = this._salp0 * sbet1;
    this._csig1 = this._comg1 =
      sbet1 !== 0 || this.calp1 !== 0 ? cbet1 * this.calp1 : 1;
    // norm(this._ssig1, this._csig1); // sig1 in (-pi, pi]
    t = m.hypot(this._ssig1, this._csig1);
    this._ssig1 /= t; this._csig1 /= t;
    // norm(this._somg1, this._comg1); -- don't need to normalize!

    this._k2 = m.sq(this._calp0) * geod._ep2;
    eps = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2);

    if (this.caps & g.CAP_C1) {
      this._A1m1 = g.A1m1f(eps);
      this._C1a = new Array(g.nC1_ + 1);
      g.C1f(eps, this._C1a);
      this._B11 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C1a);
      s = Math.sin(this._B11); c = Math.cos(this._B11);
      // tau1 = sig1 + B11
      this._stau1 = this._ssig1 * c + this._csig1 * s;
      this._ctau1 = this._csig1 * c - this._ssig1 * s;
      // Not necessary because C1pa reverts C1a
      //    _B11 = -SinCosSeries(true, _stau1, _ctau1, _C1pa);
    }

    if (this.caps & g.CAP_C1p) {
      this._C1pa = new Array(g.nC1p_ + 1);
      g.C1pf(eps, this._C1pa);
    }

    if (this.caps & g.CAP_C2) {
      this._A2m1 = g.A2m1f(eps);
      this._C2a = new Array(g.nC2_ + 1);
      g.C2f(eps, this._C2a);
      this._B21 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C2a);
    }

    if (this.caps & g.CAP_C3) {
      this._C3a = new Array(g.nC3_);
      geod.C3f(eps, this._C3a);
      this._A3c = -this.f * this._salp0 * geod.A3f(eps);
      this._B31 = g.SinCosSeries(true, this._ssig1, this._csig1, this._C3a);
    }

    if (this.caps & g.CAP_C4) {
      this._C4a = new Array(g.nC4_); // all the elements of _C4a are used
      geod.C4f(eps, this._C4a);
      // Multiplier = a^2 * e^2 * cos(alpha0) * sin(alpha0)
      this._A4 = m.sq(this.a) * this._calp0 * this._salp0 * geod._e2;
      this._B41 = g.SinCosSeries(false, this._ssig1, this._csig1, this._C4a);
    }

    this.a13 = this.s13 = Number.NaN;
  };

  /**
   * @summary Find the position on the line (general case).
   * @param {bool} arcmode is the next parameter an arc length?
   * @param {number} s12_a12 the (arcmode ? arc length : distance) from the
   *   first point to the second in (arcmode ? degrees : meters).
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set; s12 is included if arcmode is false.  For details on the
   *   outmask parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  l.GeodesicLine.prototype.GenPosition = function(arcmode, s12_a12,
                                                  outmask) {
    var vals = {},
        sig12, ssig12, csig12, B12, AB1, ssig2, csig2, tau12, s, c, serr,
        omg12, lam12, lon12, E, sbet2, cbet2, somg2, comg2, salp2, calp2, dn2,
        B22, AB2, J12, t, B42, salp12, calp12;
    if (!outmask) outmask = g.STANDARD;
    else if (outmask === g.LONG_UNROLL) outmask |= g.STANDARD;
    outmask &= this.caps & g.OUT_MASK;
    vals.lat1 = this.lat1; vals.azi1 = this.azi1;
    vals.lon1 = outmask & g.LONG_UNROLL ?
      this.lon1 : m.AngNormalize(this.lon1);
    if (arcmode)
      vals.a12 = s12_a12;
    else
      vals.s12 = s12_a12;
    if (!( arcmode || (this.caps & g.DISTANCE_IN & g.OUT_MASK) )) {
      // Uninitialized or impossible distance calculation requested
      vals.a12 = Number.NaN;
      return vals;
    }

    // Avoid warning about uninitialized B12.
    B12 = 0; AB1 = 0;
    if (arcmode) {
      // Interpret s12_a12 as spherical arc length
      sig12 = s12_a12 * m.degree;
      t = m.sincosd(s12_a12); ssig12 = t.s; csig12 = t.c;
    } else {
      // Interpret s12_a12 as distance
      tau12 = s12_a12 / (this._b * (1 + this._A1m1));
      s = Math.sin(tau12);
      c = Math.cos(tau12);
      // tau2 = tau1 + tau12
      B12 = -g.SinCosSeries(true,
                            this._stau1 * c + this._ctau1 * s,
                            this._ctau1 * c - this._stau1 * s,
                            this._C1pa);
      sig12 = tau12 - (B12 - this._B11);
      ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);
      if (Math.abs(this.f) > 0.01) {
        // Reverted distance series is inaccurate for |f| > 1/100, so correct
        // sig12 with 1 Newton iteration.  The following table shows the
        // approximate maximum error for a = WGS_a() and various f relative to
        // GeodesicExact.
        //     erri = the error in the inverse solution (nm)
        //     errd = the error in the direct solution (series only) (nm)
        //     errda = the error in the direct solution (series + 1 Newton) (nm)
        //
        //       f     erri  errd errda
        //     -1/5    12e6 1.2e9  69e6
        //     -1/10  123e3  12e6 765e3
        //     -1/20   1110 108e3  7155
        //     -1/50  18.63 200.9 27.12
        //     -1/100 18.63 23.78 23.37
        //     -1/150 18.63 21.05 20.26
        //      1/150 22.35 24.73 25.83
        //      1/100 22.35 25.03 25.31
        //      1/50  29.80 231.9 30.44
        //      1/20   5376 146e3  10e3
        //      1/10  829e3  22e6 1.5e6
        //      1/5   157e6 3.8e9 280e6
        ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
        csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
        serr = (1 + this._A1m1) * (sig12 + (B12 - this._B11)) -
          s12_a12 / this._b;
        sig12 = sig12 - serr / Math.sqrt(1 + this._k2 * m.sq(ssig2));
        ssig12 = Math.sin(sig12); csig12 = Math.cos(sig12);
        // Update B12 below
      }
    }

    // sig2 = sig1 + sig12
    ssig2 = this._ssig1 * csig12 + this._csig1 * ssig12;
    csig2 = this._csig1 * csig12 - this._ssig1 * ssig12;
    dn2 = Math.sqrt(1 + this._k2 * m.sq(ssig2));
    if (outmask & (g.DISTANCE | g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      if (arcmode || Math.abs(this.f) > 0.01)
        B12 = g.SinCosSeries(true, ssig2, csig2, this._C1a);
      AB1 = (1 + this._A1m1) * (B12 - this._B11);
    }
    // sin(bet2) = cos(alp0) * sin(sig2)
    sbet2 = this._calp0 * ssig2;
    // Alt: cbet2 = hypot(csig2, salp0 * ssig2);
    cbet2 = m.hypot(this._salp0, this._calp0 * csig2);
    if (cbet2 === 0)
      // I.e., salp0 = 0, csig2 = 0.  Break the degeneracy in this case
      cbet2 = csig2 = g.tiny_;
    // tan(alp0) = cos(sig2)*tan(alp2)
    salp2 = this._salp0; calp2 = this._calp0 * csig2; // No need to normalize

    if (arcmode && (outmask & g.DISTANCE))
      vals.s12 = this._b * ((1 + this._A1m1) * sig12 + AB1);

    if (outmask & g.LONGITUDE) {
      // tan(omg2) = sin(alp0) * tan(sig2)
      somg2 = this._salp0 * ssig2; comg2 = csig2; // No need to normalize
      E = m.copysign(1, this._salp0);
      // omg12 = omg2 - omg1
      omg12 = outmask & g.LONG_UNROLL ?
        E * (sig12 -
             (Math.atan2(ssig2, csig2) -
              Math.atan2(this._ssig1, this._csig1)) +
             (Math.atan2(E * somg2, comg2) -
              Math.atan2(E * this._somg1, this._comg1))) :
        Math.atan2(somg2 * this._comg1 - comg2 * this._somg1,
                     comg2 * this._comg1 + somg2 * this._somg1);
      lam12 = omg12 + this._A3c *
        ( sig12 + (g.SinCosSeries(true, ssig2, csig2, this._C3a) -
                   this._B31));
      lon12 = lam12 / m.degree;
      vals.lon2 = outmask & g.LONG_UNROLL ? this.lon1 + lon12 :
        m.AngNormalize(m.AngNormalize(this.lon1) + m.AngNormalize(lon12));
    }

    if (outmask & g.LATITUDE)
      vals.lat2 = m.atan2d(sbet2, this._f1 * cbet2);

    if (outmask & g.AZIMUTH)
      vals.azi2 = m.atan2d(salp2, calp2);

    if (outmask & (g.REDUCEDLENGTH | g.GEODESICSCALE)) {
      B22 = g.SinCosSeries(true, ssig2, csig2, this._C2a);
      AB2 = (1 + this._A2m1) * (B22 - this._B21);
      J12 = (this._A1m1 - this._A2m1) * sig12 + (AB1 - AB2);
      if (outmask & g.REDUCEDLENGTH)
        // Add parens around (_csig1 * ssig2) and (_ssig1 * csig2) to ensure
        // accurate cancellation in the case of coincident points.
        vals.m12 = this._b * ((      dn2 * (this._csig1 * ssig2) -
                               this._dn1 * (this._ssig1 * csig2)) -
                              this._csig1 * csig2 * J12);
      if (outmask & g.GEODESICSCALE) {
        t = this._k2 * (ssig2 - this._ssig1) * (ssig2 + this._ssig1) /
          (this._dn1 + dn2);
        vals.M12 = csig12 + (t * ssig2 - csig2 * J12) * this._ssig1 / this._dn1;
        vals.M21 = csig12 - (t * this._ssig1 - this._csig1 * J12) * ssig2 / dn2;
      }
    }

    if (outmask & g.AREA) {
      B42 = g.SinCosSeries(false, ssig2, csig2, this._C4a);
      if (this._calp0 === 0 || this._salp0 === 0) {
        // alp12 = alp2 - alp1, used in atan2 so no need to normalize
        salp12 = salp2 * this.calp1 - calp2 * this.salp1;
        calp12 = calp2 * this.calp1 + salp2 * this.salp1;
      } else {
        // tan(alp) = tan(alp0) * sec(sig)
        // tan(alp2-alp1) = (tan(alp2) -tan(alp1)) / (tan(alp2)*tan(alp1)+1)
        // = calp0 * salp0 * (csig1-csig2) / (salp0^2 + calp0^2 * csig1*csig2)
        // If csig12 > 0, write
        //   csig1 - csig2 = ssig12 * (csig1 * ssig12 / (1 + csig12) + ssig1)
        // else
        //   csig1 - csig2 = csig1 * (1 - csig12) + ssig12 * ssig1
        // No need to normalize
        salp12 = this._calp0 * this._salp0 *
          (csig12 <= 0 ? this._csig1 * (1 - csig12) + ssig12 * this._ssig1 :
           ssig12 * (this._csig1 * ssig12 / (1 + csig12) + this._ssig1));
        calp12 = m.sq(this._salp0) + m.sq(this._calp0) * this._csig1 * csig2;
      }
      vals.S12 = this._c2 * Math.atan2(salp12, calp12) +
        this._A4 * (B42 - this._B41);
    }

    if (!arcmode)
      vals.a12 = sig12 / m.degree;
    return vals;
  };

  /**
   * @summary Find the position on the line given s12.
   * @param {number} s12 the distance from the first point to the second in
   *   meters.
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, s12, and a12 fields of the result are
   *   always set; s12 is included if arcmode is false.  For details on the
   *   outmask parameter, see {@tutorial 2-interface}, "The outmask and caps
   *   parameters".
   */
  l.GeodesicLine.prototype.Position = function(s12, outmask) {
    return this.GenPosition(false, s12, outmask);
  };

  /**
   * @summary Find the position on the line given a12.
   * @param {number} a12 the arc length from the first point to the second in
   *   degrees.
   * @param {bitmask} [outmask = STANDARD] which results to include; this is
   *   subject to the capabilities of the object.
   * @returns {object} the requested results.
   * @description The lat1, lon1, azi1, and a12 fields of the result are
   *   always set.  For details on the outmask parameter, see {@tutorial
   *   2-interface}, "The outmask and caps parameters".
   */
  l.GeodesicLine.prototype.ArcPosition = function(a12, outmask) {
    return this.GenPosition(true, a12, outmask);
  };

  /**
   * @summary Specify position of point 3 in terms of either distance or arc
   *   length.
   * @param {bool} arcmode boolean flag determining the meaning of the second
   *   parameter; if arcmode is false, then the GeodesicLine object must have
   *   been constructed with caps |= DISTANCE_IN.
   * @param {number} s13_a13 if arcmode is false, this is the distance from
   *   point 1 to point 3 (meters); otherwise it is the arc length from
   *   point 1 to point 3 (degrees); it can be negative.
   **********************************************************************/
  l.GeodesicLine.prototype.GenSetDistance = function(arcmode, s13_a13) {
    if (arcmode)
      this.SetArc(s13_a13);
    else
      this.SetDistance(s13_a13);
  };

  /**
   * @summary Specify position of point 3 in terms distance.
   * @param {number} s13 the distance from point 1 to point 3 (meters); it
   *   can be negative.
   **********************************************************************/
  l.GeodesicLine.prototype.SetDistance = function(s13) {
    var r;
    this.s13 = s13;
    r = this.GenPosition(false, this.s13, g.ARC);
    this.a13 = 0 + r.a12;       // the 0+ converts undefined into NaN
  };

  /**
   * @summary Specify position of point 3 in terms of arc length.
   * @param {number} a13 the arc length from point 1 to point 3 (degrees);
   *   it can be negative.
   **********************************************************************/
  l.GeodesicLine.prototype.SetArc = function(a13) {
    var r;
    this.a13 = a13;
    r = this.GenPosition(true, this.a13, g.DISTANCE);
    this.s13 = 0 + r.s12;       // the 0+ converts undefined into NaN
  };

})(GeographicLib.Geodesic, GeographicLib.GeodesicLine, GeographicLib.Math);

/**************** PolygonArea.js ****************/
/*
 * PolygonArea.js
 * Transcription of PolygonArea.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * The algorithms are derived in
 *
 *    Charles F. F. Karney,
 *    Algorithms for geodesics, J. Geodesy 87, 43-55 (2013);
 *    https://doi.org/10.1007/s00190-012-0578-z
 *    Addenda: https://geographiclib.sourceforge.io/geod-addenda.html
 *
 * Copyright (c) Charles Karney (2011-2017) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

// Load AFTER GeographicLib/Math.js and GeographicLib/Geodesic.js

(function(
  /**
   * @exports GeographicLib/PolygonArea
   * @description Compute the area of geodesic polygons via the
   *   {@link module:GeographicLib/PolygonArea.PolygonArea PolygonArea}
   *   class.
   */
  p, g, m, a) {

  var transit, transitdirect;
  transit = function(lon1, lon2) {
    // Return 1 or -1 if crossing prime meridian in east or west direction.
    // Otherwise return zero.
    var lon12, cross;
    // Compute lon12 the same way as Geodesic::Inverse.
    lon1 = m.AngNormalize(lon1);
    lon2 = m.AngNormalize(lon2);
    lon12 = m.AngDiff(lon1, lon2).s;
    cross = lon1 <= 0 && lon2 > 0 && lon12 > 0 ? 1 :
      (lon2 <= 0 && lon1 > 0 && lon12 < 0 ? -1 : 0);
    return cross;
  };

  // an alternate version of transit to deal with longitudes in the direct
  // problem.
  transitdirect = function(lon1, lon2) {
    // We want to compute exactly
    //   int(floor(lon2 / 360)) - int(floor(lon1 / 360))
    // Since we only need the parity of the result we can use std::remquo but
    // this is buggy with g++ 4.8.3 and requires C++11.  So instead we do
    lon1 = lon1 % 720.0; lon2 = lon2 % 720.0;
    return ( ((lon2 >= 0 && lon2 < 360) || lon2 < -360 ? 0 : 1) -
             ((lon1 >= 0 && lon1 < 360) || lon1 < -360 ? 0 : 1) );
  };

  /**
   * @class
   * @property {number} a the equatorial radius (meters).
   * @property {number} f the flattening.
   * @property {bool} polyline whether the PolygonArea object describes a
   *   polyline or a polygon.
   * @property {number} num the number of vertices so far.
   * @property {number} lat the current latitude (degrees).
   * @property {number} lon the current longitude (degrees).
   * @summary Initialize a PolygonArea object.
   * @classdesc Computes the area and perimeter of a geodesic polygon.
   *   This object is usually instantiated by
   *   {@link module:GeographicLib/Geodesic.Geodesic#Polygon Geodesic.Polygon}.
   * @param {object} geod a {@link module:GeographicLib/Geodesic.Geodesic
   *   Geodesic} object.
   * @param {bool} [polyline = false] if true the new PolygonArea object
   *   describes a polyline instead of a polygon.
   */
  p.PolygonArea = function(geod, polyline) {
    this._geod = geod;
    this.a = this._geod.a;
    this.f = this._geod.f;
    this._area0 = 4 * Math.PI * geod._c2;
    this.polyline = !polyline ? false : polyline;
    this._mask = g.LATITUDE | g.LONGITUDE | g.DISTANCE |
          (this.polyline ? g.NONE : g.AREA | g.LONG_UNROLL);
    if (!this.polyline)
      this._areasum = new a.Accumulator(0);
    this._perimetersum = new a.Accumulator(0);
    this.Clear();
  };

  /**
   * @summary Clear the PolygonArea object, setting the number of vertices to
   *   0.
   */
  p.PolygonArea.prototype.Clear = function() {
    this.num = 0;
    this._crossings = 0;
    if (!this.polyline)
      this._areasum.Set(0);
    this._perimetersum.Set(0);
    this._lat0 = this._lon0 = this.lat = this.lon = Number.NaN;
  };

  /**
   * @summary Add the next vertex to the polygon.
   * @param {number} lat the latitude of the point (degrees).
   * @param {number} lon the longitude of the point (degrees).
   * @description This adds an edge from the current vertex to the new vertex.
   */
  p.PolygonArea.prototype.AddPoint = function(lat, lon) {
    var t;
    if (this.num === 0) {
      this._lat0 = this.lat = lat;
      this._lon0 = this.lon = lon;
    } else {
      t = this._geod.Inverse(this.lat, this.lon, lat, lon, this._mask);
      this._perimetersum.Add(t.s12);
      if (!this.polyline) {
        this._areasum.Add(t.S12);
        this._crossings += transit(this.lon, lon);
      }
      this.lat = lat;
      this.lon = lon;
    }
    ++this.num;
  };

  /**
   * @summary Add the next edge to the polygon.
   * @param {number} azi the azimuth at the current the point (degrees).
   * @param {number} s the length of the edge (meters).
   * @description This specifies the new vertex in terms of the edge from the
   *   current vertex.
   */
  p.PolygonArea.prototype.AddEdge = function(azi, s) {
    var t;
    if (this.num) {
      t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
      this._perimetersum.Add(s);
      if (!this.polyline) {
        this._areasum.Add(t.S12);
        this._crossings += transitdirect(this.lon, t.lon2);
      }
      this.lat = t.lat2;
      this.lon = t.lon2;
    }
    ++this.num;
  };

  /**
   * @summary Compute the perimeter and area of the polygon.
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   *   area for the rest of the earth.
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description If the object is a polygon (and not a polygon), the perimeter
   *   includes the length of a final edge connecting the current point to the
   *   initial point.  If the object is a polyline, then area is nan.  More
   *   points can be added to the polygon after this call.
   */
  p.PolygonArea.prototype.Compute = function(reverse, sign) {
    var vals = {number: this.num}, t, tempsum, crossings;
    if (this.num < 2) {
      vals.perimeter = 0;
      if (!this.polyline)
        vals.area = 0;
      return vals;
    }
    if (this.polyline) {
      vals.perimeter = this._perimetersum.Sum();
      return vals;
    }
    t = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0,
                           this._mask);
    vals.perimeter = this._perimetersum.Sum(t.s12);
    tempsum = new a.Accumulator(this._areasum);
    tempsum.Add(t.S12);
    crossings = this._crossings + transit(this.lon, this._lon0);
    if (crossings & 1)
      tempsum.Add( (tempsum.Sum() < 0 ? 1 : -1) * this._area0/2 );
    // area is with the clockwise sense.  If !reverse convert to
    // counter-clockwise convention.
    if (!reverse)
      tempsum.Negate();
    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)
    if (sign) {
      if (tempsum.Sum() > this._area0/2)
        tempsum.Add( -this._area0 );
      else if (tempsum.Sum() <= -this._area0/2)
        tempsum.Add( +this._area0 );
    } else {
      if (tempsum.Sum() >= this._area0)
        tempsum.Add( -this._area0 );
      else if (tempsum < 0)
        tempsum.Add( -this._area0 );
    }
    vals.area = tempsum.Sum();
    return vals;
  };

  /**
   * @summary Compute the perimeter and area of the polygon with a tentative
   *   new vertex.
   * @param {number} lat the latitude of the point (degrees).
   * @param {number} lon the longitude of the point (degrees).
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description A new vertex is *not* added to the polygon.
   */
  p.PolygonArea.prototype.TestPoint = function(lat, lon, reverse, sign) {
    var vals = {number: this.num + 1}, t, tempsum, crossings, i;
    if (this.num === 0) {
      vals.perimeter = 0;
      if (!this.polyline)
        vals.area = 0;
      return vals;
    }
    vals.perimeter = this._perimetersum.Sum();
    tempsum = this.polyline ? 0 : this._areasum.Sum();
    crossings = this._crossings;
    for (i = 0; i < (this.polyline ? 1 : 2); ++i) {
      t = this._geod.Inverse(
       i === 0 ? this.lat : lat, i === 0 ? this.lon : lon,
       i !== 0 ? this._lat0 : lat, i !== 0 ? this._lon0 : lon,
       this._mask);
      vals.perimeter += t.s12;
      if (!this.polyline) {
        tempsum += t.S12;
        crossings += transit(i === 0 ? this.lon : lon,
                               i !== 0 ? this._lon0 : lon);
      }
    }

    if (this.polyline)
      return vals;

    if (crossings & 1)
      tempsum += (tempsum < 0 ? 1 : -1) * this._area0/2;
    // area is with the clockwise sense.  If !reverse convert to
    // counter-clockwise convention.
    if (!reverse)
      tempsum *= -1;
    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)
    if (sign) {
      if (tempsum > this._area0/2)
        tempsum -= this._area0;
      else if (tempsum <= -this._area0/2)
        tempsum += this._area0;
    } else {
      if (tempsum >= this._area0)
        tempsum -= this._area0;
      else if (tempsum < 0)
        tempsum += this._area0;
    }
    vals.area = tempsum;
    return vals;
  };

  /**
   * @summary Compute the perimeter and area of the polygon with a tentative
   *   new edge.
   * @param {number} azi the azimuth of the edge (degrees).
   * @param {number} s the length of the edge (meters).
   * @param {bool} reverse if true then clockwise (instead of
   *   counter-clockwise) traversal counts as a positive area.
   * @param {bool} sign if true then return a signed result for the area if the
   *   polygon is traversed in the "wrong" direction instead of returning the
   * @returns {object} r where r.number is the number of vertices, r.perimeter
   *   is the perimeter (meters), and r.area (only returned if polyline is
   *   false) is the area (meters<sup>2</sup>).
   * @description A new vertex is *not* added to the polygon.
   */
  p.PolygonArea.prototype.TestEdge = function(azi, s, reverse, sign) {
    var vals = {number: this.num ? this.num + 1 : 0}, t, tempsum, crossings;
    if (this.num === 0)
      return vals;
    vals.perimeter = this._perimetersum.Sum() + s;
    if (this.polyline)
      return vals;

    tempsum = this._areasum.Sum();
    crossings = this._crossings;
    t = this._geod.Direct(this.lat, this.lon, azi, s, this._mask);
    tempsum += t.S12;
    crossings += transitdirect(this.lon, t.lon2);
    t = this._geod.Inverse(t.lat2, t.lon2, this._lat0, this._lon0, this._mask);
    vals.perimeter += t.s12;
    tempsum += t.S12;
    crossings += transit(t.lon2, this._lon0);

    if (crossings & 1)
      tempsum += (tempsum < 0 ? 1 : -1) * this._area0/2;
    // area is with the clockwise sense.  If !reverse convert to
    // counter-clockwise convention.
    if (!reverse)
      tempsum *= -1;
    // If sign put area in (-area0/2, area0/2], else put area in [0, area0)
    if (sign) {
      if (tempsum > this._area0/2)
        tempsum -= this._area0;
      else if (tempsum <= -this._area0/2)
        tempsum += this._area0;
    } else {
      if (tempsum >= this._area0)
        tempsum -= this._area0;
      else if (tempsum < 0)
        tempsum += this._area0;
    }
    vals.area = tempsum;
    return vals;
  };

})(GeographicLib.PolygonArea, GeographicLib.Geodesic,
   GeographicLib.Math, GeographicLib.Accumulator);

/**************** DMS.js ****************/
/*
 * DMS.js
 * Transcription of DMS.[ch]pp into JavaScript.
 *
 * See the documentation for the C++ class.  The conversion is a literal
 * conversion from C++.
 *
 * Copyright (c) Charles Karney (2011-2015) <charles@karney.com> and licensed
 * under the MIT/X11 License.  For more information, see
 * https://geographiclib.sourceforge.io/
 */

GeographicLib.DMS = {};

(function(
  /**
   * @exports GeographicLib/DMS
   * @description Decode/Encode angles expressed as degrees, minutes, and
   *   seconds.  This module defines several constants:
   *   - hemisphere indicator (returned by
   *       {@link module:GeographicLib/DMS.Decode Decode}) and a formatting
   *       indicator (used by
   *       {@link module:GeographicLib/DMS.Encode Encode})
   *     - NONE = 0, no designator and format as plain angle;
   *     - LATITUDE = 1, a N/S designator and format as latitude;
   *     - LONGITUDE = 2, an E/W designator and format as longitude;
   *     - AZIMUTH = 3, format as azimuth;
   *   - the specification of the trailing component in
   *       {@link module:GeographicLib/DMS.Encode Encode}
   *     - DEGREE;
   *     - MINUTE;
   *     - SECOND.
   */
  d) {

  var lookup, zerofill, internalDecode, numMatch,
      hemispheres_ = "SNWE",
      signs_ = "-+",
      digits_ = "0123456789",
      dmsindicators_ = "D'\":",
      // dmsindicatorsu_ = "\u00b0\u2032\u2033"; // Unicode variants
      dmsindicatorsu_ = "\u00b0'\"", // Use degree symbol
      components_ = ["degrees", "minutes", "seconds"];
  lookup = function(s, c) {
    return s.indexOf(c.toUpperCase());
  };
  zerofill = function(s, n) {
    return String("0000").substr(0, Math.max(0, Math.min(4, n-s.length))) +
      s;
  };
  d.NONE = 0;
  d.LATITUDE = 1;
  d.LONGITUDE = 2;
  d.AZIMUTH = 3;
  d.DEGREE = 0;
  d.MINUTE = 1;
  d.SECOND = 2;

  /**
   * @summary Decode a DMS string.
   * @description The interpretation of the string is given in the
   *   documentation of the corresponding function, Decode(string&, flag&)
   *   in the {@link
   *   https://geographiclib.sourceforge.io/html/classGeographicLib_1_1DMS.html
   *   C++ DMS class}
   * @param {string} dms the string.
   * @returns {object} r where r.val is the decoded value (degrees) and r.ind
   *   is a hemisphere designator, one of NONE, LATITUDE, LONGITUDE.
   * @throws an error if the string is illegal.
   */
  d.Decode = function(dms) {
    var dmsa = dms, end,
        v = 0, i = 0, mi, pi, vals,
        ind1 = d.NONE, ind2, p, pa, pb;
    dmsa = dmsa.replace(/\u00b0/g, 'd')
          .replace(/\u00ba/g, 'd')
          .replace(/\u2070/g, 'd')
          .replace(/\u02da/g, 'd')
          .replace(/\u2032/g, '\'')
          .replace(/\u00b4/g, '\'')
          .replace(/\u2019/g, '\'')
          .replace(/\u2033/g, '"')
          .replace(/\u201d/g, '"')
          .replace(/\u2212/g, '-')
          .replace(/''/g, '"')
          .trim();
    end = dmsa.length;
    // p is pointer to the next piece that needs decoding
    for (p = 0; p < end; p = pb, ++i) {
      pa = p;
      // Skip over initial hemisphere letter (for i == 0)
      if (i === 0 && lookup(hemispheres_, dmsa.charAt(pa)) >= 0)
        ++pa;
      // Skip over initial sign (checking for it if i == 0)
      if (i > 0 || (pa < end && lookup(signs_, dmsa.charAt(pa)) >= 0))
        ++pa;
      // Find next sign
      mi = dmsa.substr(pa, end - pa).indexOf('-');
      pi = dmsa.substr(pa, end - pa).indexOf('+');
      if (mi < 0) mi = end; else mi += pa;
      if (pi < 0) pi = end; else pi += pa;
      pb = Math.min(mi, pi);
      vals = internalDecode(dmsa.substr(p, pb - p));
      v += vals.val; ind2 = vals.ind;
      if (ind1 == d.NONE)
        ind1 = ind2;
      else if (!(ind2 == d.NONE || ind1 == ind2))
        throw new Error("Incompatible hemisphere specifies in " +
                        dmsa.substr(0, pb));
    }
    if (i === 0)
      throw new Error("Empty or incomplete DMS string " + dmsa);
    return {val: v, ind: ind1};
  };

  internalDecode = function(dmsa) {
    var vals = {}, errormsg = "",
        sign, beg, end, ind1, k,
        ipieces, fpieces, npiece,
        icurrent, fcurrent, ncurrent, p,
        pointseen,
        digcount, intcount,
        x;
    do {                       // Executed once (provides the ability to break)
      sign = 1;
      beg = 0; end = dmsa.length;
      ind1 = d.NONE;
      k = -1;
      if (end > beg && (k = lookup(hemispheres_, dmsa.charAt(beg))) >= 0) {
        ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;
        sign = (k & 1) ? 1 : -1;
        ++beg;
      }
      if (end > beg &&
          (k = lookup(hemispheres_, dmsa.charAt(end-1))) >= 0) {
        if (k >= 0) {
          if (ind1 !== d.NONE) {
            if (dmsa.charAt(beg - 1).toUpperCase() ===
                dmsa.charAt(end - 1).toUpperCase())
              errormsg = "Repeated hemisphere indicators " +
              dmsa.charAt(beg - 1) + " in " +
              dmsa.substr(beg - 1, end - beg + 1);
            else
              errormsg = "Contradictory hemisphere indicators " +
              dmsa.charAt(beg - 1) + " and " + dmsa.charAt(end - 1) + " in " +
              dmsa.substr(beg - 1, end - beg + 1);
            break;
          }
          ind1 = (k & 2) ? d.LONGITUDE : d.LATITUDE;
          sign = (k & 1) ? 1 : -1;
          --end;
        }
      }
      if (end > beg && (k = lookup(signs_, dmsa.charAt(beg))) >= 0) {
        if (k >= 0) {
          sign *= k ? 1 : -1;
          ++beg;
        }
      }
      if (end === beg) {
        errormsg = "Empty or incomplete DMS string " + dmsa;
        break;
      }
      ipieces = [0, 0, 0];
      fpieces = [0, 0, 0];
      npiece = 0;
      icurrent = 0;
      fcurrent = 0;
      ncurrent = 0;
      p = beg;
      pointseen = false;
      digcount = 0;
      intcount = 0;
      while (p < end) {
        x = dmsa.charAt(p++);
        if ((k = lookup(digits_, x)) >= 0) {
          ++ncurrent;
          if (digcount > 0) {
            ++digcount;         // Count of decimal digits
          } else {
            icurrent = 10 * icurrent + k;
            ++intcount;
          }
        } else if (x === '.') {
          if (pointseen) {
            errormsg = "Multiple decimal points in " +
              dmsa.substr(beg, end - beg);
            break;
          }
          pointseen = true;
          digcount = 1;
        } else if ((k = lookup(dmsindicators_, x)) >= 0) {
          if (k >= 3) {
            if (p === end) {
              errormsg = "Illegal for colon to appear at the end of " +
                dmsa.substr(beg, end - beg);
              break;
            }
            k = npiece;
          }
          if (k === npiece - 1) {
            errormsg = "Repeated " + components_[k] +
              " component in " + dmsa.substr(beg, end - beg);
            break;
          } else if (k < npiece) {
            errormsg = components_[k] + " component follows " +
              components_[npiece - 1] + " component in " +
              dmsa.substr(beg, end - beg);
            break;
          }
          if (ncurrent === 0) {
            errormsg = "Missing numbers in " + components_[k] +
              " component of " + dmsa.substr(beg, end - beg);
            break;
          }
          if (digcount > 0) {
            fcurrent = parseFloat(dmsa.substr(p - intcount - digcount - 1,
                                              intcount + digcount));
            icurrent = 0;
          }
          ipieces[k] = icurrent;
          fpieces[k] = icurrent + fcurrent;
          if (p < end) {
            npiece = k + 1;
            icurrent = fcurrent = 0;
            ncurrent = digcount = intcount = 0;
          }
        } else if (lookup(signs_, x) >= 0) {
          errormsg = "Internal sign in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        } else {
          errormsg = "Illegal character " + x + " in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        }
      }
      if (errormsg.length)
        break;
      if (lookup(dmsindicators_, dmsa.charAt(p - 1)) < 0) {
        if (npiece >= 3) {
          errormsg = "Extra text following seconds in DMS string " +
            dmsa.substr(beg, end - beg);
          break;
        }
        if (ncurrent === 0) {
          errormsg = "Missing numbers in trailing component of " +
            dmsa.substr(beg, end - beg);
          break;
        }
        if (digcount > 0) {
          fcurrent = parseFloat(dmsa.substr(p - intcount - digcount,
                                            intcount + digcount));
          icurrent = 0;
        }
        ipieces[npiece] = icurrent;
        fpieces[npiece] = icurrent + fcurrent;
      }
      if (pointseen && digcount === 0) {
        errormsg = "Decimal point in non-terminal component of " +
          dmsa.substr(beg, end - beg);
        break;
      }
      // Note that we accept 59.999999... even though it rounds to 60.
      if (ipieces[1] >= 60 || fpieces[1] > 60) {
        errormsg = "Minutes " + fpieces[1] + " not in range [0,60)";
        break;
      }
      if (ipieces[2] >= 60 || fpieces[2] > 60) {
        errormsg = "Seconds " + fpieces[2] + " not in range [0,60)";
        break;
      }
      vals.ind = ind1;
      // Assume check on range of result is made by calling routine (which
      // might be able to offer a better diagnostic).
      vals.val = sign *
        ( fpieces[2] ? (60*(60*fpieces[0] + fpieces[1]) + fpieces[2]) / 3600 :
          ( fpieces[1] ? (60*fpieces[0] + fpieces[1]) / 60 : fpieces[0] ) );
      return vals;
    } while (false);
    vals.val = numMatch(dmsa);
    if (vals.val === 0)
      throw new Error(errormsg);
    else
      vals.ind = d.NONE;
    return vals;
  };

  numMatch = function(s) {
    var t, sign, p0, p1;
    if (s.length < 3)
      return 0;
    t = s.toUpperCase().replace(/0+$/, "");
    sign = t.charAt(0) === '-' ? -1 : 1;
    p0 = t.charAt(0) === '-' || t.charAt(0) === '+' ? 1 : 0;
    p1 = t.length - 1;
    if (p1 + 1 < p0 + 3)
      return 0;
    // Strip off sign and trailing 0s
    t = t.substr(p0, p1 + 1 - p0); // Length at least 3
    if (t === "NAN" || t === "1.#QNAN" || t === "1.#SNAN" || t === "1.#IND" ||
        t === "1.#R")
      return Number.NaN;
    else if (t === "INF" || t === "1.#INF")
      return sign * Number.POSITIVE_INFINITY;
    return 0;
  };

  /**
   * @summary Decode two DMS strings interpreting them as a latitude/longitude
   *   pair.
   * @param {string} stra the first string.
   * @param {string} strb the first string.
   * @param {bool} [longfirst = false] if true assume then longitude is given
   *   first (in the absense of any hemisphere indicators).
   * @returns {object} r where r.lat is the decoded latitude and r.lon is the
   *   decoded longitude (both in degrees).
   * @throws an error if the strings are illegal.
   */
  d.DecodeLatLon = function(stra, strb, longfirst) {
    var vals = {},
        valsa = d.Decode(stra),
        valsb = d.Decode(strb),
        a = valsa.val, ia = valsa.ind,
        b = valsb.val, ib = valsb.ind,
        lat, lon;
    if (!longfirst) longfirst = false;
    if (ia === d.NONE && ib === d.NONE) {
      // Default to lat, long unless longfirst
      ia = longfirst ? d.LONGITUDE : d.LATITUDE;
      ib = longfirst ? d.LATITUDE : d.LONGITUDE;
    } else if (ia === d.NONE)
      ia = d.LATITUDE + d.LONGITUDE - ib;
    else if (ib === d.NONE)
      ib = d.LATITUDE + d.LONGITUDE - ia;
    if (ia === ib)
      throw new Error("Both " + stra + " and " + strb + " interpreted as " +
                      (ia === d.LATITUDE ? "latitudes" : "longitudes"));
    lat = ia === d.LATITUDE ? a : b;
    lon = ia === d.LATITUDE ? b : a;
    if (Math.abs(lat) > 90)
      throw new Error("Latitude " + lat + " not in [-90,90]");
    vals.lat = lat;
    vals.lon = lon;
    return vals;
  };

  /**
   * @summary Decode a DMS string interpreting it as an arc length.
   * @param {string} angstr the string (this must not include a hemisphere
   *   indicator).
   * @returns {number} the arc length (degrees).
   * @throws an error if the string is illegal.
   */
  d.DecodeAngle = function(angstr) {
    var vals = d.Decode(angstr),
        ang = vals.val, ind = vals.ind;
    if (ind !== d.NONE)
      throw new Error("Arc angle " + angstr + " includes a hemisphere N/E/W/S");
    return ang;
  };

  /**
   * @summary Decode a DMS string interpreting it as an azimuth.
   * @param {string} azistr the string (this may include an E/W hemisphere
   *   indicator).
   * @returns {number} the azimuth (degrees).
   * @throws an error if the string is illegal.
   */
  d.DecodeAzimuth = function(azistr) {
    var vals = d.Decode(azistr),
        azi = vals.val, ind = vals.ind;
    if (ind === d.LATITUDE)
      throw new Error("Azimuth " + azistr + " has a latitude hemisphere N/S");
    return azi;
  };

  /**
   * @summary Convert angle (in degrees) into a DMS string (using &deg;, ',
   *  and &quot;).
   * @param {number} angle input angle (degrees).
   * @param {number} trailing one of DEGREE, MINUTE, or SECOND to indicate
   *   the trailing component of the string (this component is given as a
   *   decimal number if necessary).
   * @param {number} prec the number of digits after the decimal point for
   *   the trailing component.
   * @param {number} [ind = NONE] a formatting indicator, one of NONE,
   *   LATITUDE, LONGITUDE, AZIMUTH.
   * @returns {string} the resulting string formatted as follows:
   *   * NONE, signed result no leading zeros on degrees except in the units
   *     place, e.g., -8&deg;03'.
   *   * LATITUDE, trailing N or S hemisphere designator, no sign, pad
   *     degrees to 2 digits, e.g., 08&deg;03'S.
   *   * LONGITUDE, trailing E or W hemisphere designator, no sign, pad
   *     degrees to 3 digits, e.g., 008&deg;03'W.
   *   * AZIMUTH, convert to the range [0, 360&deg;), no sign, pad degrees to
   *     3 digits, e.g., 351&deg;57'.
   */
  d.Encode = function(angle, trailing, prec, ind) {
    // Assume check on range of input angle has been made by calling
    // routine (which might be able to offer a better diagnostic).
    var scale = 1, i, sign,
        idegree, fdegree, f, pieces, ip, fp, s;
    if (!ind) ind = d.NONE;
    if (!isFinite(angle))
      return angle < 0 ? String("-inf") :
      (angle > 0 ? String("inf") : String("nan"));

    // 15 - 2 * trailing = ceiling(log10(2^53/90/60^trailing)).
    // This suffices to give full real precision for numbers in [-90,90]
    prec = Math.min(15 - 2 * trailing, prec);
    for (i = 0; i < trailing; ++i)
      scale *= 60;
    for (i = 0; i < prec; ++i)
      scale *= 10;
    if (ind === d.AZIMUTH)
      angle -= Math.floor(angle/360) * 360;
    sign = angle < 0 ? -1 : 1;
    angle *= sign;

    // Break off integer part to preserve precision in manipulation of
    // fractional part.
    idegree = Math.floor(angle);
    fdegree = (angle - idegree) * scale + 0.5;
    f = Math.floor(fdegree);
    // Implement the "round ties to even" rule
    fdegree = (f == fdegree && (f & 1)) ? f - 1 : f;
    fdegree /= scale;

    fdegree = Math.floor((angle - idegree) * scale + 0.5) / scale;
    if (fdegree >= 1) {
      idegree += 1;
      fdegree -= 1;
    }
    pieces = [fdegree, 0, 0];
    for (i = 1; i <= trailing; ++i) {
      ip = Math.floor(pieces[i - 1]);
      fp = pieces[i - 1] - ip;
      pieces[i] = fp * 60;
      pieces[i - 1] = ip;
    }
    pieces[0] += idegree;
    s = "";
    if (ind === d.NONE && sign < 0)
      s += '-';
    switch (trailing) {
    case d.DEGREE:
      s += zerofill(pieces[0].toFixed(prec),
                    ind === d.NONE ? 0 :
                    1 + Math.min(ind, 2) + prec + (prec ? 1 : 0)) +
        dmsindicatorsu_.charAt(0);
      break;
    default:
      s += zerofill(pieces[0].toFixed(0),
                    ind === d.NONE ? 0 : 1 + Math.min(ind, 2)) +
        dmsindicatorsu_.charAt(0);
      switch (trailing) {
      case d.MINUTE:
        s += zerofill(pieces[1].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +
          dmsindicatorsu_.charAt(1);
        break;
      case d.SECOND:
        s += zerofill(pieces[1].toFixed(0), 2) + dmsindicatorsu_.charAt(1);
        s += zerofill(pieces[2].toFixed(prec), 2 + prec + (prec ? 1 : 0)) +
          dmsindicatorsu_.charAt(2);
        break;
      default:
        break;
      }
    }
    if (ind !== d.NONE && ind !== d.AZIMUTH)
      s += hemispheres_.charAt((ind === d.LATITUDE ? 0 : 2) +
                               (sign < 0 ? 0 : 1));
    return s;
  };
})(GeographicLib.DMS);

cb(GeographicLib);

})(function(geo) {
  if (typeof module === 'object' && module.exports) {
    /******** support loading with node's require ********/
    module.exports = geo;
  } else if (true) {
    /******** support loading with AMD ********/
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return geo; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    /******** otherwise just pollute our global namespace ********/
    window.GeographicLib = geo;
  }
});


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parseCode__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extend__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__projections__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__deriveConstants__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_Datum__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__datum__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__match__ = __webpack_require__(29);








function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__parseCode__["a" /* default */])(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__match__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_4__constants_Datum__["a" /* default */], json.datumCode);
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  var sphere_ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__deriveConstants__["a" /* sphere */])(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__deriveConstants__["b" /* eccentricity */])(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var datumObj = json.datum || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__datum__["a" /* default */])(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(this, json); // transfer everything over from the projection because we don't know what we'll need
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__extend__["a" /* default */])(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calulated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Projection.projections = __WEBPACK_IMPORTED_MODULE_2__projections__["a" /* default */];
Projection.projections.start();
/* harmony default export */ __webpack_exports__["a"] = (Projection);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
});

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
});

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
});

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
});

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = match;
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);



//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];

var MapCredit = function(map, json) {
    this.map = map;
    this.id = json['id'] || null;
    this.notice = json['notice'] || null;
    this.copyrighted = json['copyrighted'] || true;
    this.url = json['url'] || null;
    this.html = utils.simpleWikiLinks(this.notice);
    this.plain = utils.simpleWikiLinks(this.notice);
};


MapCredit.prototype.getInfo = function() {
    return {
        'id' : this.id,
        'notice' : this.notice,
        //"copyrighted" : this.copyrighted,
        //"url" : this.url
        'html' : this.html,
        'plain' : this.plain
    };
};


/* harmony default export */ __webpack_exports__["a"] = (MapCredit);



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_math__ = __webpack_require__(4);



//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_0__utils_math__["a" /* math */];

var MapPosition = function(pos) {
    if (pos instanceof MapPosition) {
        this.pos = pos.pos.slice();
    } else {
        if (!(pos != null && (pos instanceof Array))) {
            this.pos = [];
        } else {
            this.pos = pos.slice();
        }

        this.validate();
    }
};


MapPosition.prototype.clone = function() {
    return new MapPosition(this.pos);
};


MapPosition.prototype.getCoords = function() {
    return [this.pos[1], this.pos[2], this.pos[4]];
};


MapPosition.prototype.getCoords2 = function() {
    return [this.pos[1], this.pos[2]];
};


MapPosition.prototype.setCoords = function(coords) {
    this.pos[1] = coords[0];
    this.pos[2] = coords[1];
    this.pos[4] = coords[2];
    return this;
};


MapPosition.prototype.setCoords2 = function(coords) {
    this.pos[1] = coords[0];
    this.pos[2] = coords[1];
    return this;
};


MapPosition.prototype.getHeight = function() {
    return this.pos[4];
};


MapPosition.prototype.setHeight = function(height) {
    this.pos[4] = height;
    return this;
};


MapPosition.prototype.getOrientation = function() {
    return [this.pos[5], this.pos[6], this.pos[7]];
};


MapPosition.prototype.setOrientation = function(orientation) {
    this.pos[5] = orientation[0];
    this.pos[6] = orientation[1];
    this.pos[7] = orientation[2];
    return this;
};


MapPosition.prototype.getFov = function() {
    return this.pos[9];
};


MapPosition.prototype.setFov = function(fov) {
    this.pos[9] = fov;
    return this;
};


MapPosition.prototype.getViewExtent = function() {
    return this.pos[8];
};


MapPosition.prototype.setViewExtent = function(extent) {
    this.pos[8] = extent;
    return this;
};


MapPosition.prototype.getViewDistance = function() {
    return (this.getViewExtent()*0.5) / Math.tan(math.radians(this.getFov()*0.5));
};


MapPosition.prototype.getViewMode = function() {
    return this.pos[0];
};


MapPosition.prototype.getHeightMode = function() {
    return this.pos[3];
};


MapPosition.prototype.check = function() {
    //check pich
    if (this.getViewMode() == 'obj') {
        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);
    } else {
        this.pos[6] = math.clamp(this.pos[6], -90.0, 90.0);
    }

    this.pos[5] = this.pos[5] % 360;
    this.pos[7] = this.pos[7] % 360;
};


MapPosition.prototype.isSame = function(pos) {
    pos = pos.pos;
    return (this.pos[0] == pos[0] &&
             math.isEqual(this.pos[1], pos[1], 0.0000001) &&
             math.isEqual(this.pos[2], pos[2], 0.0000001) &&
             this.pos[3] == pos[3] &&
             math.isEqual(this.pos[4], pos[4], 0.001) &&
             math.isEqual(this.pos[5], pos[5], 0.001) &&
             math.isEqual(this.pos[6], pos[6], 0.001) &&
             math.isEqual(this.pos[7], pos[7], 0.001) &&
             math.isEqual(this.pos[8], pos[8], 0.001) &&
             math.isEqual(this.pos[9], pos[9], 0.001));
};


MapPosition.prototype.validate = function() {
    var pos = this.pos;
    if (pos[0] == 'fixed') { //old format
        pos[0] = 'obj';
        pos[9] = pos[8];
        pos[8] = pos[7];
        pos[7] = pos[6];
        pos[6] = pos[5];
        pos[5] = pos[4];
        pos[4] = pos[3];
        pos[3] = 'fix';
    }

    pos[0] = (pos[0] == 'obj' || pos[0] == 'subj') ? pos[0] : 'obj';
    pos[1] = (pos[1] != null) ? pos[1] : 0;
    pos[2] = (pos[2] != null) ? pos[2] : 0;
    pos[3] = (pos[3] == 'fix' || pos[3] == 'fixed' || pos[3] == 'float') ? pos[3] : 'float';
    pos[4] = (pos[4] != null) ? pos[4] : 0;
    pos[5] = (pos[5] != null) ? pos[5] : 0;
    pos[6] = (pos[6] != null) ? pos[6] : -90;
    pos[7] = (pos[7] != null) ? pos[7] : 0;
    pos[8] = (pos[8] != null) ? pos[8] : 900;
    pos[9] = (pos[9] != null) ? pos[9] : 45;

    pos[3] = (pos[3] == 'fixed') ? 'fix' : pos[3];
};


MapPosition.prototype.toString = function() {
    var p = this.pos;
    return p[0] + ', ' + p[1].toFixed(0) + ', ' + p[2].toFixed(0) + ', ' + p[3] + ', ' + p[4].toFixed(0)
           + ', ' + p[5].toFixed(0) + ', ' + p[6].toFixed(0) + ', ' + p[7].toFixed(0) + ', ' 
           + ', ' + p[8].toFixed(0) + ', ' + p[9].toFixed(0); 
};


MapPosition.prototype.toArray = function() {
    return this.pos.slice();
};


/* harmony default export */ __webpack_exports__["a"] = (MapPosition);


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var GpuMesh = function(gpu, meshData, fileSize, core, direct, use16bit, verticesUnnormalized) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.bbox = meshData.bbox; //< bbox copy from Mesh
    this.fileSize = fileSize; //used for stats
    this.core = core;
    this.vertexBuffer = null;
    this.uvBuffer = null;
    this.uv2Buffer = null;
    this.use16bit = use16bit ? true : false;
    this.verticesUnnormalized = verticesUnnormalized ? true : false;
    this.size = 0;

    var vertices = meshData.vertices;
    var uvs = meshData.uvs;
    var uvs2 = meshData.uvs2;
    var indices = meshData.indices;
    var vertexSize = meshData.vertexSize || 3;
    var uvSize = meshData.uvSize || 2;
    var uv2Size = meshData.uv2Size || 2;

    var gl = this.gl;

    if (!vertices || !gl) {
        return;
    }

    //create vertex buffer
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    //when direct mode is used vertices can be also unit16
    gl.bufferData(gl.ARRAY_BUFFER, direct ? vertices : (new Float32Array(vertices)), gl.STATIC_DRAW);
    this.vertexBuffer.itemSize = vertexSize;
    this.vertexBuffer.numItems = vertices.length / vertexSize;

    if (uvs != null) {
        //create texture coords buffer
        this.uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);

        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs : (new Float32Array(uvs)), gl.STATIC_DRAW);
        this.uvBuffer.itemSize = uvSize;
        this.uvBuffer.numItems = uvs.length / uvSize;
    }

    if (uvs2 != null) {
        //create texture coords buffer
        this.uv2Buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);

        gl.bufferData(gl.ARRAY_BUFFER, direct ? uvs2 : (new Float32Array(uvs2)), gl.STATIC_DRAW);
        this.uv2Buffer.itemSize = uv2Size;
        this.uv2Buffer.numItems = uvs2.length / uv2Size;
    }

    if (indices != null) {
        //create index buffer
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, direct ? indices : (new Uint16Array(indices)), gl.STATIC_DRAW);
        this.indexBuffer.itemSize = 1;
        this.indexBuffer.numItems = indices.length;
    }

    var varSize = this.use16bit ? 2 : 4;
    this.size = this.vertexBuffer.numItems * vertexSize * varSize;
    this.size += (uvs) ? this.uvBuffer.numItems * uvSize * varSize : 0;
    this.size += (uvs2) ? this.uv2Buffer.numItems * uv2Size * varSize : 0;
    this.size += (indices) ? indices.length * 2 : 0;
    this.polygons = (indices) ? indices.length / 3 : this.vertexBuffer.numItems / 3;

    this.valid = true;
};

//destructor
GpuMesh.prototype.kill = function() {
    if (!this.gl || !this.valid) {
        return;
    }

    if (this.vertexBuffer) {
        this.gl.deleteBuffer(this.vertexBuffer);
    }
    
    if (this.uvBuffer) {
        this.gl.deleteBuffer(this.uvBuffer);
    }

    if (this.uv2Buffer) {
        this.gl.deleteBuffer(this.uv2Buffer);
    }

    if (this.indexBuffer) {
        this.gl.deleteBuffer(this.indexBuffer);
    }
    
    this.vertexBuffer = null;
    this.uvBuffer = null;
    this.uv2Buffer = null;
    this.indexBuffer = null;
};

// Draws the mesh, given the two vertex shader attributes locations.
GpuMesh.prototype.draw = function(program, attrVertex, attrUV, attrUV2, attrBarycenteric, skipDraw) {
    var gl = this.gl;
    if (gl == null || !this.valid) {
        return;
    }

    if (this.use16bit) {
        //bind vetex positions
        var vertexAttribute = program.getAttribute(attrVertex);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.UNSIGNED_SHORT, !this.verticesUnnormalized, 0, 0);

        //bind texture coords
        if (this.uvBuffer && attrUV) {
            var uvAttribute = program.getAttribute(attrUV);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);
        }

        if (this.uv2Buffer && attrUV2) {
            var uv2Attribute = program.getAttribute(attrUV2);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);
            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.UNSIGNED_SHORT, true, 0, 0);
        }
    } else {
        //bind vetex positions
        var vertexAttribute = program.getAttribute(attrVertex);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(vertexAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind texture coords
        if (this.uvBuffer && attrUV) {
            var uvAttribute = program.getAttribute(attrUV);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
            gl.vertexAttribPointer(uvAttribute, this.uvBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        if (this.uv2Buffer && attrUV2) {
            var uv2Attribute = program.getAttribute(attrUV2);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uv2Buffer);
            gl.vertexAttribPointer(uv2Attribute, this.uv2Buffer.itemSize, gl.FLOAT, false, 0, 0);
        }
    }

    if (attrBarycenteric && attrBarycenteric) {
        var barycentericAttribute = program.getAttribute(attrBarycenteric);
        
        if (barycentericAttribute != -1) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.gpu.barycentricBuffer);
            gl.vertexAttribPointer(barycentericAttribute, this.gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
    }

    //draw polygons
    if (this.indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

        if (!skipDraw) gl.drawElements(gl.TRIANGLES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }  else {
        if (!skipDraw) gl.drawArrays(gl.TRIANGLES, 0, this.vertexBuffer.numItems);
    }
};


// Returns GPU RAM used, in bytes.
GpuMesh.prototype.getSize = function(){ return this.size; };


GpuMesh.prototype.getBBox = function(){ return this.bbox; };


GpuMesh.prototype.getPolygons = function(){ return this.polygons; };


/* harmony default export */ __webpack_exports__["a"] = (GpuMesh);



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var GpuProgram = function(gpu, vertex, fragment) {
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.vertex = vertex;
    this.fragment = fragment;
    this.program = null;
    this.uniformLocationCache = [];
    this.attributeLocationCache = [];
    this.m = new Float32Array(16);
    this.ready = false;
    this.createProgram(vertex, fragment);
};


GpuProgram.prototype.createShader = function(source, vertexShader) {
    var gl = this.gl;

    if (!source || !gl) {
        return null;
    }

    var shader;

    if (vertexShader !== true) {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else {
        shader = gl.createShader(gl.VERTEX_SHADER);
    }

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(shader);
        console.log('An error occurred compiling the ' + ((vertexShader !== true) ? 'fragment' : 'vertex') + ' shaders: ' + info);
        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'compilation', 'info' : info });
        return null;
    }

    return shader;
};


GpuProgram.prototype.createProgram = function(vertex, fragment) {
    var gl = this.gl;
    if (gl == null) return;

    var vertexShader = this.createShader(vertex, true);
    var fragmentShader = this.createShader(fragment, false);

    if (!vertexShader ||  !fragmentShader) {
        return;
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log('Unable to initialize the shader program.');
        this.gpu.renderer.core.callListener('renderer-shader-error', { 'where':'linking' });
    }

    gl.useProgram(program);

    this.program = program;
    this.ready = true;
};


GpuProgram.prototype.setSampler = function(name, index) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform1i(key, index);
    }
};

GpuProgram.prototype.isReady = function(name, index) {
    return this.ready;
};

GpuProgram.prototype.setMat4 = function(name, m, zoffset) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        if (zoffset) {
            zoffset = ((1+zoffset)*2)-1;
           
            var m3 = this.m;
            
            m3[0] = m[0];  
            m3[1] = m[1];  
            m3[2] = m[2] * zoffset;  
            m3[3] = m[3];  

            m3[4] = m[4];  
            m3[5] = m[5];  
            m3[6] = m[6] * zoffset;  
            m3[7] = m[7];  

            m3[8] = m[8];
            m3[9] = m[9];
            m3[10] = m[10] * zoffset;  
            m3[11] = m[11];

            m3[12] = m[12];  
            m3[13] = m[13];  
            m3[14] = m[14] * zoffset;  
            m3[15] = m[15];  

            gl.uniformMatrix4fv(key, false, m3);
            
        } else {
            gl.uniformMatrix4fv(key, false, m);
        }
    }
};


GpuProgram.prototype.setMat3 = function(name, m) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniformMatrix3fv(key, false, m);
    }
};


GpuProgram.prototype.setVec2 = function(name, m) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform2fv(key, m);
    }
};


GpuProgram.prototype.setVec3 = function(name, m) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform3fv(key, m);
    }
};


GpuProgram.prototype.setVec4 = function(name, m) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform4fv(key, m);
    }
};


GpuProgram.prototype.setFloat = function(name, value) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform1f(key, value);
    }
};


GpuProgram.prototype.setFloatArray = function(name, array) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var key = this.getUniform(name);
    if (key != null) {
        gl.uniform1fv(key, array);
    }
};


GpuProgram.prototype.getAttribute = function(name) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var location = this.attributeLocationCache[name];

    if (location == null) {
        location = gl.getAttribLocation(this.program, name);
        this.attributeLocationCache[name] = location;
    }

    return location;
};


GpuProgram.prototype.getUniform = function(name) {
    var gl = this.gl;
    if (gl == null || this.program == null) return;

    var location = this.uniformLocationCache[name];

    if (location == null) {
        location = gl.getUniformLocation(this.program, name);
        this.uniformLocationCache[name] = location;
    }
    
    return location;
};


/* harmony default export */ __webpack_exports__["a"] = (GpuProgram);


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = forward;
/* unused harmony export inverse */
/* harmony export (immutable) */ __webpack_exports__["b"] = toPoint;



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
/* harmony default export */ __webpack_exports__["a"] = ({
  forward: forward,
  inverse: inverse,
  toPoint: toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
});


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ __webpack_exports__["a"] = (function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
});

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pj_mlfn__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_values__ = __webpack_require__(0);



var MAX_ITER = 20;

/* harmony default export */ __webpack_exports__["a"] = (function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__pj_mlfn__["a" /* default */])(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
});


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
});

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
});

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony export (immutable) */ __webpack_exports__["c"] = compareDatums;
/* harmony export (immutable) */ __webpack_exports__["b"] = geodeticToGeocentric;
/* harmony export (immutable) */ __webpack_exports__["a"] = geocentricToGeodetic;
/* harmony export (immutable) */ __webpack_exports__["d"] = geocentricToWgs84;
/* harmony export (immutable) */ __webpack_exports__["e"] = geocentricFromWgs84;


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] && Latitude > -1.001 * __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]) {
    Latitude = -__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
  } else if (Latitude > __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] && Latitude < 1.001 * __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]) {
    Latitude = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
  } else if ((Latitude < -__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]) || (Latitude > __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */])) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return null;
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */]) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */]) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__global__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__projString__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_wkt_parser__ = __webpack_require__(46);




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__projString__["a" /* default */])(arguments[1]);
      }
      else {
        defs[name] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_wkt_parser__["a" /* default */])(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__global__["a" /* default */])(defs);
/* harmony default export */ __webpack_exports__["a"] = (defs);


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_PrimeMeridian__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_units__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__match__ = __webpack_require__(29);





/* harmony default export */ __webpack_exports__["a"] = (function(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lat_1: function(v) {
      self.lat1 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lat_2: function(v) {
      self.lat2 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lat_ts: function(v) {
      self.lat_ts = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lon_0: function(v) {
      self.long0 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lon_1: function(v) {
      self.long1 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lon_2: function(v) {
      self.long2 = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    lonc: function(v) {
      self.longc = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__match__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_2__constants_units__["a" /* default */], v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    pm: function(v) {
      var pm = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__match__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__constants_PrimeMeridian__["a" /* default */], v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
});


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_sinh__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_hypot__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_asinhy__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_gatg__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_clens__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_clens_cmplx__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js









function init() {
  if (this.es === undefined || this.es <= 0) {
    throw new Error('incorrect elliptical usage');
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_gatg__["a" /* default */])(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_clens__["a" /* default */])(this.gtu, 2 * Z));
}

function forward(p) {
  var Ce = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(p.x - this.long0);
  var Cn = p.y;

  Cn = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_gatg__["a" /* default */])(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_hypot__["a" /* default */])(sin_Cn, cos_Cn * cos_Ce));
  Ce = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_asinhy__["a" /* default */])(Math.tan(Ce));

  var tmp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_clens_cmplx__["a" /* default */])(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_clens_cmplx__["a" /* default */])(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_sinh__["a" /* default */])(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_hypot__["a" /* default */])(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(Ce + this.long0);
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_gatg__["a" /* default */])(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__datum_transform__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__datumUtils__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__adjust_axis__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Proj__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_toPoint__ = __webpack_require__(40);
/* harmony export (immutable) */ __webpack_exports__["a"] = transform;






function checkNotWGS(source, dest) {
  return ((source.datum.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */] || source.datum.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */] || dest.datum.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]) && source.datumCode !== 'WGS84');
}

function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_toPoint__["a" /* default */])(point);
  }

  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new __WEBPACK_IMPORTED_MODULE_4__Proj__["a" /* default */]('WGS84');
    point = transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== 'enu') {
    point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__adjust_axis__["a" /* default */])(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point.x *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
    point.y *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["g" /* D2R */];
  }
  else {
    if (source.isGeocent) {
      if (source.to_meter) {
        point.x *= source.to_meter;
        point.y *= source.to_meter;
        point.z *= source.to_meter;
      }
      // originally dest.datum.geocentric_to_geodetic_noniter(point);
      point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__datumUtils__["a" /* geocentricToGeodetic */])(point, dest.es, dest.a, dest.b);
    } else {
      if (source.to_meter) {
        point.x *= source.to_meter;
        point.y *= source.to_meter;
      }
      point = source.inverse(point); // Convert Cartesian to longlat
    }
  }
// Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

// Convert datums if needed, and if possible.
  point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datum_transform__["a" /* default */])(source.datum, dest.datum, point);

// Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point.x -= dest.from_greenwich;
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point.x *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["j" /* R2D */];
    point.y *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["j" /* R2D */];
  } else { // else project
    if (dest.isGeocent) {
      point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__datumUtils__["b" /* geodeticToGeocentric */])(point, dest.es, dest.a);
      if (dest.to_meter) {
        point.x /= dest.to_meter;
        point.y /= dest.to_meter;
        point.z /= dest.to_meter;
      }
    } else {
      dest.forward(point);
      if (dest.to_meter) {
        point.x /= dest.to_meter;
        point.y /= dest.to_meter;
      }
    }
  }

// DGR, 2010/11/12
  if (dest.axis !== 'enu') {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__adjust_axis__["a" /* default */])(dest, true, point);
  }

  return point;
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parser__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__process__ = __webpack_require__(116);
var D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert, 10;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['false_easting', 'False_Easting'],
    ['false_northing', 'False_Northing'],
    ['central_meridian', 'Central_Meridian'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
/* harmony default export */ __webpack_exports__["a"] = (function(wkt) {
  var lisp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__parser__["a" /* default */])(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__process__["a" /* sExpr */])(lisp, obj);
  cleanWKT(obj);
  return obj;
});


/***/ }),
/* 47 */
/***/ (function(module, exports) {

// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;
module.exports = function(content, url) {
  try {
    try {
      var blob;
      try { // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
        blob = new BlobBuilder();
        blob.append(content);
        blob = blob.getBlob();
      } catch(e) { // The proposed API
        blob = new Blob([content]);
      }
      return new Worker(URL.createObjectURL(blob));
    } catch(e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch(e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }
    return new Worker(url);
  }
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__credit__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_url__ = __webpack_require__(12);





//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];
var utilsUrl = __WEBPACK_IMPORTED_MODULE_2__utils_url__["a" /* utilsUrl */];
var MapCredit = __WEBPACK_IMPORTED_MODULE_0__credit__["a" /* default */];


var MapBoundLayer = function(map, json, id) {
    this.map = map;
    this.id = id;
    this.currentAlpha = 1.0;

    this.tileSize = [256,256];
    this.lodRange = [0,100];
    this.credits = [];
    this.tileRange = [[0,0],[0,0]];
    this.jsonUrl = null;
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.ready = false;
    this.dataType = 0;
    this.shaderFilters = null;

    //hack
    if (id == 'esri-world-imagery') {
        json['availability'] = {
             // "type" : "negative-type",
             // "mime": "image/png"
             // "type" : "negative-code",
             // "codes": [301, 302, 404]
            'type' : 'negative-size',
            'size': 2521
        };  
    }
    
    if (typeof json === 'string') {
        this.jsonUrl = this.map.url.processUrl(json);
        this.baseUrl = utilsUrl.getBase(this.jsonUrl);
        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);
        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);
        
        var onLoaded = (function(data){
            this.parseJson(data);            
            this.ready = true;
            this.map.refreshView();
        }).bind(this);
        
        var onError = (function(){ }).bind(this);

        utils.loadJSON(this.jsonUrl, onLoaded, onError, null, (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);
    } else {
        this.parseJson(json);
        this.ready = true;
    }
    
};


MapBoundLayer.prototype.parseJson = function(json) {
    this.numberId = json['id'] || null;
    this.type = json['type'] || 'raster';
    this.url = this.processUrl(json['url'], '');
    this.tileSize = json['tileSize'] || [256,256];
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.metaUrl = this.processUrl(json['metaUrl']);
    this.maskUrl = this.processUrl(json['maskUrl']);
    this.isTransparent = json['isTransparent'] || false;
    this.options = json['options'] || {};
    this.credits = json['credits'] || [];
    this.creditsUrl = null;

    this.shaderFilter = this.options['shaderFilter'] || null;

    switch(json['dataType']) {
        default:
        case 'color':          this.dataType = 0;  break;
        case 'height':         this.dataType = 1; break;
        case 'classification': this.dataType = 2;  break;
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    

    this.availability = json['availability'] ? {} : null;

    if (this.availability) {
        var p = json['availability'];

        switch(p['type']) {
            case 'negative-type': this.availability.type = 2; break;
            case 'negative-code': this.availability.type = 3; break;
            case 'negative-size': this.availability.type = 4; break;
        }

        this.availability.mime = p['mime'];
        this.availability.codes = p['codes'];
        this.availability.size = p['size'];
        //this.availability.coverageUrl = p["coverageUrl"];
    }

    if (this.metaUrl && this.maskUrl) {
        this.availability = {
            type : 1
        };
    }

    switch(typeof this.credits) {
    case 'string':
        this.creditsUrl = this.credits;
        this.credits = [];
        break;

    case 'object':
        
        if (!Array.isArray(this.credits)) {
            var credits = this.credits;
            this.credits = [];
                
            for (var key in credits){
                this.map.addCredit(key, new MapCredit(this.map, credits[key]));
                this.credits.push(key);
            }
        }

        /*
        for (var i = 0, li = this.credits.length; i < li; i++) {
            var credit = this.map.getCreditById(this.credits[i]);
                //this.creditsNumbers.push(credit ? credit.id : null); 
        }*/
        
        break;
    }
};


MapBoundLayer.prototype.kill = function() {
};


MapBoundLayer.prototype.setOptions = function() {
};


MapBoundLayer.prototype.getOptions = function() {
    return this.getInfo();
};


MapBoundLayer.prototype.getInfo = function() {
    return {
        'type' : this.type,
        'url' : this.url,
        'tileSize' : this.tileSize,
        'credits' : this.credits,
        'lodRange' : this.lodRange,
        'tileRange' : this.tileRange,
        'mataUrl' : this.metaUrl,
        'maskUrl' : this.maskUrl,
        'isTransparent' : this.isTransparent
    };
};


MapBoundLayer.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    url = url.trim();
    
    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url; 
    }
};


MapBoundLayer.prototype.hasTile = function(id) {
    var shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    var x = id[1] >> shift;
    var y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapBoundLayer.prototype.hasTileOrInfluence = function(id) {
    var shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    var x = id[1] >> shift;
    var y = id[2] >> shift;

    if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return 0;
    }

    return (id[0] > this.lodRange[1]) ? 1 : 2;
};


MapBoundLayer.prototype.getUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.url, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapBoundLayer.prototype.getMetatileUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapBoundLayer.prototype.getMaskUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.maskUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["a"] = (MapBoundLayer);




/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_gpu_group__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geodata_processor_processor__ = __webpack_require__(138);







//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */], math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */], utils = __WEBPACK_IMPORTED_MODULE_2__utils_utils__["a" /* utils */];
var GpuGroup = __WEBPACK_IMPORTED_MODULE_3__renderer_gpu_group__["a" /* default */];
var MapGeodataProcessor = __WEBPACK_IMPORTED_MODULE_4__geodata_processor_processor__["a" /* default */];


var MapGeodataView = function(map, geodata, extraInfo) {
    this.map = map;
    this.stats = map.stats;
    this.geodata = geodata;
    this.gpu = this.map.renderer.gpu;
    this.renderer = this.map.renderer;
    this.gpuGroups = [];
    this.currentGpuGroup = null;
    this.tile = extraInfo.tile;
    this.surface = extraInfo.surface;

    if (!this.surface.geodataProcessor) {
        var processor = new MapGeodataProcessor(this, this.onGeodataProcessorMessage.bind(this));
        processor.setStylesheet(this.surface.stylesheet);
        this.surface.geodataProcessor = processor;
        this.map.geodataProcessors.push(processor);
    } else {
        if (this.surface.styleChanged) {
            this.surface.geodataProcessor.setStylesheet(this.surface.stylesheet);
            this.surface.styleChanged = false;
        }
    }

    this.geodataProcessor = this.surface.geodataProcessor;
    this.processing = false;
    this.statsCounter = 0;
    this.size = 0;
    this.killed = false;
    this.killedByCache = false;
    this.ready = false;
    this.isReady();
};


MapGeodataView.prototype.kill = function() {
    this.killed = true;
    this.geodata = null;
    this.killGeodataView(false);
};


MapGeodataView.prototype.killGeodataView = function(killedByCache) {
    this.killedByCache = killedByCache;

    for (var i = 0, li = this.gpuGroups.length; i < li; i++) {
        this.gpuGroups[i].kill();
    }

    this.gpuGroups = [];

    if (killedByCache !== true && this.gpuCacheItem != null) {
        this.map.gpuCache.remove(this.gpuCacheItem);
    }

    this.stats.gpuGeodata -= this.size;
    this.stats.graphsFluxGeodata[1][0]++;
    this.stats.graphsFluxGeodata[1][1] += this.size;
    
    this.ready = false;
    this.size = 0;
    this.gpuCacheItem = null;
};


MapGeodataView.prototype.processPackedCommands = function(buffer, index) {

    var maxIndex = buffer.byteLength;
    var maxTime = this.map.config.mapMaxGeodataProcessingTime;
    var t = performance.now(), length, str, data;
    var view = new DataView(buffer.buffer);

    do {

        var command = buffer[index]; index += 1;

        switch(command) {
            case 9:
                index += 1;
                length = view.getUint32(index); index += 4;
                str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;
                data = JSON.parse(str);

                this.currentGpuGroup = new GpuGroup(data['id'], data['bbox'], data['origin'], this.gpu, this.renderer);
                this.gpuGroups.push(this.currentGpuGroup);

                //console.log('VTS_WORKERCOMMAND_GROUP_BEGIN ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                break;

            case 10:
                this.size += this.currentGpuGroup.size; index += 1 + 4;
                //console.log('VTS_WORKERCOMMAND_GROUP_END ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                break;

            case 5:
                index = this.currentGpuGroup.addRenderJob2(buffer, index, this.tile);
                break;

            case 7:
                this.map.markDirty();
                this.gpuCacheItem = this.map.gpuCache.insert(this.killGeodataView.bind(this, true), this.size);

                this.stats.gpuGeodata += this.size;
                this.stats.graphsFluxGeodata[0][0]++;
                this.stats.graphsFluxGeodata[0][1] += this.size;
                this.ready = true;
                this.processing = false;

                //console.log('VTS_WORKERCOMMAND_ALL_PROCESSED ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

                index += 1 + 4;
                break;
        }

        if ((performance.now() - t) > maxTime) {
            if (index < maxIndex) {
                return index;
            }
        }

    } while(index < maxIndex);


    this.stats.renderBuild += performance.now() - t; 

    return -1;
};


MapGeodataView.prototype.onGeodataProcessorMessage = function(command, message, task) {
    if (this.killed || this.killedByCache){
        return;
    }

    switch (command) {

    case 'addPackedCommands':

        //console.log('pack size:' + message['buffer'].byteLength);

        if (task) {
            var index = this.processPackedCommands(message['buffer'], message.index);

            if (index < 0) {
                this.map.markDirty();
                //console.log('addPackedCommandsB ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
            } else {
                //console.log('addPackedCommandsC ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
                message.index = index;
                return -123;
            }

        } else {
            message.index = 0;
            this.map.markDirty();
            this.map.addProcessingTask2(this.onGeodataProcessorMessage.bind(this, command, message, true));

            //console.log('addPackedCommandsA ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
        }

        break;

    case 'ready':

        if (this.geodataProcessor.processCounter > 0) {
            this.geodataProcessor.processCounter--;

            if (this.geodataProcessor.processCounter > 0) {
                this.map.markDirty();
                //console.log('ready2 ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

                break;
            }
        }

        if (message['geodata']) {
            this.geodata.geodata = message['geodata'];
        }

        this.geodataProcessor.busy = false;
        this.map.markDirty();
        //console.log('ready ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));

            //this.ready = true;
        break;
    }
};


MapGeodataView.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    if (this.killed) {
        return false;
    }

    //if (!(this.tile.id[0] == 21 && this.tile.id[1] == 566459 && this.tile.id[2] == 355240)) {
      //  return false;
    //}

    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;
    
    //if (!this.ready && !doNotUseGpu && this.geodataProcessor.isReady()) {
    if (!this.ready && !this.processing && !doNotLoad && this.surface.stylesheet.isReady()) {
        if (this.geodata.isReady(doNotLoad, priority, doNotCheckGpu) && this.geodataProcessor.isReady()) {
            this.processing = true;
            this.killedByCache = false;
            this.geodataProcessor.setListener(this.onGeodataProcessorMessage.bind(this));

            var geodata = this.geodata.geodata;

            if (this.map.config.mapGeodataBinaryLoad && (typeof geodata !== 'string')) {
                this.geodataProcessor.sendCommand('processGeodataRaw', geodata, this.tile, (window.devicePixelRatio || 1), [geodata]);
            } else {
                this.geodataProcessor.sendCommand('processGeodata', geodata, this.tile, (window.devicePixelRatio || 1));
            }

            this.geodataProcessor.busy = true;
            //console.log('processGeodata ' + (this.tile ? JSON.stringify(this.tile.id) : '[free]'));
        }
    }

    if (!doNotLoad && this.gpuCacheItem) {
        this.map.gpuCache.updateItem(this.gpuCacheItem);
    }

    return this.ready;
};


MapGeodataView.prototype.getWorldMatrix = function(bbox, geoPos, matrix) {
    var m = matrix;

    if (m != null) {
        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = bbox.min[0] - geoPos[0]; m[13] = bbox.min[1] - geoPos[1]; m[14] = bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(1, 1, 1), m);
    }

    return m;
};


MapGeodataView.prototype.draw = function(cameraPos) {
    if (this.ready) {

        var renderer = this.renderer;
        var tiltAngle = this.tile ? Math.abs(this.tile.tiltAngle) : renderer.cameraTiltFator;
        var useSuperElevation = renderer.useSuperElevation;

        for (var i = 0, li = this.gpuGroups.length; i < li; i++) {
            var group = this.gpuGroups[i]; 

            if (!group.jobs.length) {
                continue; //TODO: remove empty groups
            }

            var mvp = group.mvp;
            var mv = group.mv;
            var mtmp = mvp; //use it as tmp matrix

            if (useSuperElevation) {
                //mat4.set(renderer.camera.getModelviewFMatrix(), mv);
                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);
            } else {
                mat4.multiply(renderer.camera.getModelviewFMatrix(), this.getWorldMatrix(group.bbox, cameraPos, mtmp), mv);
            }     
        
            var proj = renderer.camera.getProjectionFMatrix();
            mat4.multiply(proj, mv, mvp);
            
            group.draw(mv, mvp, null, tiltAngle, (this.tile ? this.tile.texelSize : 1));

            this.stats.drawnFaces += group.polygons;
            this.stats.drawCalls += group.jobs.length;
        }
        
        if (this.statsCoutner != this.stats.counter) {
            this.statsCoutner = this.stats.counter;
            this.stats.gpuRenderUsed += this.size;
        }
    }
    return this.ready;
};

//MapGeodataView.prototype.getSize = function() {
    //return this.size;
//};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodataView);


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderer_bbox__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);




//get rid of compiler mess
var BBox = __WEBPACK_IMPORTED_MODULE_0__renderer_bbox__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];


var MapGeodata = function(map, url, extraInfo) {
    this.map = map;
    this.stats = map.stats;
    this.mapLoaderUrl  = url;
    this.extraInfo = extraInfo;

    this.bbox = new BBox();
    this.size = 0;
    this.fileSize = 0;
    this.geodata = null;

    this.cacheItem = null;

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    this.map.markDirty();
};


MapGeodata.prototype.kill = function() {
    this.bbox = null;
    this.killGeodata();
};


MapGeodata.prototype.killGeodata = function(killedByCache) {
    if (this.geodata) {
        this.geodata = null;
    }
    
    if (killedByCache !== true && this.cacheItem != null) {
        this.map.resourcesCache.remove(this.cacheItem);
    }

    //if (this.gpuSubmeshes.length == 0) {
    this.loadState = 0;
    //}

    this.size = 0;
    this.fileSize = 0;
    this.cacheItem = null;
};


MapGeodata.prototype.isReady = function(doNotLoad, priority) {
    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;

    if (this.loadState == 2) { //loaded
        this.map.resourcesCache.updateItem(this.cacheItem);
        return true;
    } else {
        if (this.loadState == 0) { 
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue

                if (typeof this.mapLoaderUrl === 'object') { //use geodata directly
                    this.geodata = JSON.stringify(this.mapLoaderUrl);
                    this.loadState = 2;
                    this.size = this.geodata.length;
                    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), this.size);
                    this.map.resourcesCache.updateItem(this.cacheItem);
                    return true;
                } else {
                    this.scheduleLoad(priority);
                }
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);                    
            }
        }  //else load in progress
    }

    return false;
};


MapGeodata.prototype.scheduleLoad = function(priority) {
    //if (this.mapLoaderUrl == null) {
        //this.mapLoaderUrl = this.map.url.makeUrl(this.tile.surface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });
    //}

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.extraInfo.tile, 'geodata');
};


MapGeodata.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.loadState = 1;
    
    if (this.map.config.mapGeodataBinaryLoad) {
        this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'geodata');
    } else {
        utils.loadJSON(url, this.onLoaded.bind(this), this.onLoadError.bind(this), true, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
    }

    return;
};


MapGeodata.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { 
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }    

    this.mapLoaderCallError();
};


MapGeodata.prototype.onLoaded = function(data) {
    if (this.map.killed){
        return;
    }

    var size = data.length || data.byteLength;
    if (!size) {
        size = 0;
    }

    this.size = size;
    this.fileSize = size;

    this.geodata = data;

    this.cacheItem = this.map.resourcesCache.insert(this.killGeodata.bind(this, true), size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};

// Returns RAM usage in bytes.
//MapGeodata.prototype.getSize = function () {
  //  return this.size;
//};

//MapGeodata.prototype.getFileSize = function () {
  //  return this.fileSize;
//};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodata);




/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__texture__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_geographiclib__);





//get rid of compiler mess
var MapTexture = __WEBPACK_IMPORTED_MODULE_0__texture__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var GeographicLib = __WEBPACK_IMPORTED_MODULE_2_geographiclib___default.a;


var MapSrs = function(map, id, json) {
    this.map = map;
    this.id = id;
    this.proj4 = map.proj4;
    this.comment = json['comment'] || null;
    this.srsDef = json['srsDef'] || null;
    this.srsModifiers = json['srsModifiers'] || [];
    this.type = json['type'] || 'projected';
    this.vdatum = json['vdatum'] || 'orthometric';
    //this.srsDefEllps = json["srsDefEllps"] || "";
    this.srsDef = json['srsDefEllps'] || this.srsDef;
    this.periodicity = this.parsePeriodicity(json['periodicity']);
    this.srsInfo = this.proj4(this.srsDef).info();
    this.geoidGrid = null;
    this.geoidGridMap = null;
    this.srsProj4 = this.proj4(this.srsDef, null, null, true); 
    this.latlonProj4 = null; 
    this.proj4Cache = {};

    if (json['geoidGrid']) {
        var geoidGridData = json['geoidGrid'];

        this.geoidGrid = {
            definition : geoidGridData['definition'] || null,
            srsDefEllps : geoidGridData['srsDefEllps'] || null,
            valueRange : geoidGridData['valueRange'] || [0,1]
        };

        if (geoidGridData['extents']) {
            this.geoidGrid.extents = {
                ll : geoidGridData['extents']['ll'],
                ur : geoidGridData['extents']['ur']
            };
        } else {
            this.geoidGrid.extents = {
                ll : [0,0],
                ur : [1,1]
            };
        }

        if (this.geoidGrid.definition) {
            var url = this.map.url.makeUrl(this.geoidGrid.definition, {}, null);
            this.geoidGridMap = new MapTexture(this.map, url, true);
        }
        
        if (this.geoidGrid.srsDefEllps) {
            this.geoidGrid.srsProj4 = this.proj4(this.geoidGrid.srsDefEllps, null, null, true);        
        }
    }

    if (this.type == 'geographic') {
        this.spheroid = json['spheroid'] || null;

        if (this.spheroid == null) {
            //TODO: return error
        }
    }
};


MapSrs.prototype.parsePeriodicity = function(periodicityData) {
    if (periodicityData == null) {
        return null;
    }

    var periodicity = {
        'type' : periodicityData['type'] || '',
        'period' : periodicityData['period'] || 0
    };

    return periodicity;
};


MapSrs.prototype.getInfo = function() {
    return {
        'comment' : this.comment,
        'srsDef' : this.srsDef,
        'srsModifiers' : this.srsModifiers,
        'type' : this.type,
        'vdatum' : this.vdatum,
        'srsDefEllps' : this.srsDef,
        'a' : this.srsInfo['a'],
        'b' : this.srsInfo['b']
    };
};


MapSrs.prototype.getSrsInfo = function() {
    return this.srsInfo;
};


MapSrs.prototype.isReady = function() {
    return this.isGeoidGridReady();
};


MapSrs.prototype.isGeoidGridReady = function() {
    return (this.geoidGrid == null ||
           (this.geoidGridMap != null && this.geoidGridMap.isReady()));
};


MapSrs.prototype.isProjected = function() {
    return (this.type == 'projected');
};


MapSrs.prototype.getOriginalHeight = function(coords) {
    var height = coords[2] || 0;
    height /= this.getVerticalAdjustmentFactor(coords);
    height += this.getGeoidGridDelta(coords);
    return height;
};


MapSrs.prototype.getFinalHeight = function(coords) {
    var height = coords[2] || 0;
    height -= this.getGeoidGridDelta(coords);
    height *= this.getVerticalAdjustmentFactor(coords);
    return height;
};


MapSrs.prototype.getGeoidGridDelta = function(coords) {
    if (this.geoidGridMap != null && this.isGeoidGridReady()) {
        //get cooords in geoidGrid space
        var mapCoords = this.proj4(this.srsProj4, this.geoidGrid.srsProj4, [coords[0], coords[1]]);

        //get image coords
        var px = mapCoords[0] - this.geoidGrid.extents.ll[0];
        var py = this.geoidGrid.extents.ur[1] - mapCoords[1];

        var imageExtens = this.geoidGridMap.getImageExtents();

        px *= imageExtens[0] / (this.geoidGrid.extents.ur[0] - this.geoidGrid.extents.ll[0]);
        py *= imageExtens[1] / (this.geoidGrid.extents.ur[1] - this.geoidGrid.extents.ll[1]);

        px = math.clamp(px, 0, imageExtens[0] - 2);
        py = math.clamp(py, 0, imageExtens[1] - 2);

        //get bilineary interpolated value from image
        var ix = Math.floor(px);
        var iy = Math.floor(py);
        var fx = px - ix;
        var fy = py - iy;

        var data = this.geoidGridMap.getImageData();
        var index = iy * imageExtens[0];
        var index2 = index + imageExtens[0];
        var h00 = data[(index + ix)*4];
        var h01 = data[(index + ix + 1)*4];
        var h10 = data[(index2 + ix)*4];
        var h11 = data[(index2 + ix + 1)*4];
        var w0 = (h00 + (h01 - h00)*fx);
        var w1 = (h10 + (h11 - h10)*fx);
        var delta = (w0 + (w1 - w0)*fy);

        //strech deta into value range
        delta = this.geoidGrid.valueRange[0] + (delta * ((this.geoidGrid.valueRange[1] - this.geoidGrid.valueRange[0]) / 255));

        return delta;
    }

    return 0;
};


MapSrs.prototype.getVerticalAdjustmentFactor = function(coords) {
    if (this.srsModifiers.indexOf('adjustVertical') != -1) {
        var info = this.getSrsInfo();

        //convert coords to latlon
        var latlonProj = '+proj=longlat ' +
                          ' +alpha=0' +
                          ' +gamma=0 +a=' + info['a'] +
                          ' +b=' + info['b'] +
                          ' +x0=0 +y0=0';

        if (!this.latlonProj4) {
            this.latlonProj4 = this.proj4(latlonProj, null, null, true); 
        }

        var coords2 = this.proj4(this.srsProj4, this.latlonProj4, [coords[0], coords[1]]);

        //move coors 1000m
        var geod = new GeographicLib.Geodesic.Geodesic(info['a'],
                                                       (info['a'] / info['b']) - 1.0);


        var r = geod.Direct(coords2[1], coords2[0], 90, 1000);
        coords2 = [r.lon2, r.lat2];

        //convet coords from latlon back to projected
        coords2 = this.proj4(this.latlonProj4, this.srsProj4, coords2);

        //get distance between coords
        var dx = coords2[0] - coords[0];
        var dy = coords2[1] - coords[1];

        var distance = Math.sqrt(dx * dx + dy* dy);

        //get factor
        var factor = distance / 1000;

        return factor;
    }

    return 1.0;
};


MapSrs.prototype.convertCoordsTo = function(coords, srs, skipVerticalAdjust) {
    this.isReady();
    if (typeof srs !== 'string') {
        if (srs.id == this.id) {
            return coords.slice();
        }

        srs.isReady();
    }

    coords = coords.slice();

    var stringSrs = (typeof srs === 'string');

    //if (!skipVerticalAdjust && stringSrs) {
    coords[2] = this.getOriginalHeight(coords);
    //}

    var srsDef = (stringSrs) ? srs : srs.srsProj4;

    /*
    if (srsDef.isGeocent && this.srsProj4.projName == "merc") {
        var coords3 = coords.slice();
        this.convertMercToWGS(coords3);
        this.convertWGSToGeocent(coords3, srsDef);
        return coords3;
    }*/


    var srsDef2 = (stringSrs) ? srs : srs.srsDef;
    //var coords2 = this.proj4(this.srsProj4, srsDef, coords);

    var proj = this.proj4Cache[srsDef2];
    
    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    var coords2 = proj.forward(coords);

    if (!skipVerticalAdjust && !stringSrs) {
        coords2[2] = srs.getFinalHeight(coords2);
    }

    return coords2;
};


MapSrs.prototype.convertCoordsToFast = function(coords, srs, skipVerticalAdjust, coords2, index, index2) {

    //if (!skipVerticalAdjust && stringSrs) {
        //coords[2] = this.getOriginalHeight(coords);
    //}

    var srsDef = srs.srsProj4;
    
    /*
    if (srsDef.isGeocent && this.srsProj4.projName == "merc") {
        this.convertMercToWGS(coords, coords2, index, index2);
        this.convertWGSToGeocent(coords2, srsDef, coords2, index2, index2);
        return;
    }*/

    var srsDef2 = srs.srsDef;

    var proj = this.proj4Cache[srsDef2];
    
    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    var coords3 = proj.forward(coords);
    
    coords2[index2] = coords3[0];
    coords2[index2+1] = coords3[1];
    coords2[index2+2] = coords3[2];
    

    //if (!skipVerticalAdjust && stringSrs) {
        //coords2[2] = srs.getFinalHeight(coords2);
    //}
    
    if (srs.geoidGrid) {
        coords2[index2+2] -= srs.getGeoidGridDelta(coords);
    }
};


MapSrs.prototype.convertCoordsFrom = function(coords, srs) {
    this.isReady();
    if (typeof srs !== 'string') {
        if (srs.id == this.id) {
            return coords.slice();
        }

        srs.isReady();
    }

    coords = coords.slice();

    if (typeof srs !== 'string') {
        coords[2] = srs.getOriginalHeight(coords);
    }

    var srsDef = (typeof srs === 'string') ? srs : srs.srsProj4;
    var srsDef2 = (typeof srs === 'string') ? srs : srs.srsDef;

    //var coords2 = this.proj4(srsDef, this.srsProj4, coords);

    var proj = this.proj4Cache[srsDef2];
    
    if (!proj) {
        proj = this.proj4(this.srsProj4, srsDef);
        this.proj4Cache[srsDef2] = proj;
    }

    var coords2 = proj.inverse(coords);

    coords2[2] = this.getFinalHeight(coords2);

    return coords2;
};


MapSrs.prototype.phi2z = function(eccent, ts) {
    var HALFPI = Math.PI*0.5;
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALFPI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
        con = eccent * Math.sin(phi);
        dphi = HALFPI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
        phi += dphi;
        if (Math.abs(dphi) <= 0.0000000001) {
            return phi;
        }
    }
  //console.log("phi2z has NoConvergence");
    return -9999;
};


MapSrs.prototype.convertMercToWGS = function(coords, coords2, index, index2) {
    var TWOPI = Math.PI * 2;
    var HALFPI = Math.PI*0.5;
    var proj = this.srsProj4;
    var x = coords[index] - proj.x0;
    var y = coords[index+1] - proj.y0;

    if (proj.sphere) {
        coords2[index2+1] = HALFPI - 2 * Math.atan(Math.exp(-y / (proj.a * proj.k0)));
    } else {
        var ts = Math.exp(-y / (proj.a * proj.k0));
        var yy = this.phi2z(proj.e, ts);
        coords2[index2+1] = yy;
        if (yy === -9999) {
            return;
        }
    }
    
    //coords[0] = adjustlon(proj.long0 + x / (proj.a * proj.k0));
    x = proj.long0 + x / (proj.a * proj.k0);
    var SPI = 3.14159265359;
    coords2[index2] = (Math.abs(x) <= SPI) ? x : (x - ((x < 0) ? -1 : 1) * TWOPI);
    coords2[index2+2] = coords[index+2];
};


MapSrs.prototype.convertWGSToGeocent = function(coords, srs, coords2, index, index2) {
    var datum = srs.datum;

    var HALFPI = Math.PI*0.5;
    var Longitude = coords[index];
    var Latitude = coords[index+1];
    var Height = coords[index+2]; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var SinLat; /*  Math.sin(Latitude)  */
    var Sin2Lat; /*  Square of Math.sin(Latitude)  */
    var CosLat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALFPI && Latitude > -1.001 * HALFPI) {
        Latitude = -HALFPI;
    }
    else if (Latitude > HALFPI && Latitude < 1.001 * HALFPI) {
        Latitude = HALFPI;
    }
    else if ((Latitude < -HALFPI) || (Latitude > HALFPI)) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
        return null;
    }

    if (Longitude > Math.PI) {
        Longitude -= (2 * Math.PI);
    }

    SinLat = Math.sin(Latitude);
    CosLat = Math.cos(Latitude);
    Sin2Lat = SinLat * SinLat;
    Rn = datum.a / (Math.sqrt(1.0e0 - datum.es * Sin2Lat));
    coords2[index2] = (Rn + Height) * CosLat * Math.cos(Longitude);
    coords2[index2+1] = (Rn + Height) * CosLat * Math.sin(Longitude);
    coords2[index2+2] = ((Rn * (1 - datum.es)) + Height) * SinLat;
};


/* harmony default export */ __webpack_exports__["a"] = (MapSrs);



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);



//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];


var MapStylesheet = function(map, id, url, freeLayer) {
    this.generateLines = true;
    this.map = map;
    this.renderer = this.map.renderer;
    this.stats = map.stats;
    this.id  = id;
    this.url  = null;
    this.data = null;
    this.loadState = 0;
    this.size = 0;
    this.fileSize = 0;
    this.freeLayer = freeLayer;
    this.fonts = {};
    this.fontsReady = false;
    
    if (typeof url === 'object') {
        this.data = url;
        this.setFonts(this.data);
        this.loadState = 2;
        this.map.markDirty();
    } else {
        if (this.freeLayer) {
            this.url = this.freeLayer.processUrl(url, '');
        } else {
            this.url = this.map.url.processUrl(url);
        }

        //load style directly
        utils.loadJSON(this.url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, (utils.useCredentials ? (this.url.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        this.loadState = 1;
    }
};


MapStylesheet.prototype.kill = function() {
};


MapStylesheet.prototype.setData = function(data) {
    this.data = data;
    this.setFonts(data);
    this.loadState = 2;
    this.checkFonts();
};

MapStylesheet.prototype.checkFonts = function() {
    var ready = true;
    for (var key in this.fonts) {
        ready = (ready && this.renderer.getFont(this.fonts[key]).isReady());
    }

    this.fontsReady = ready;

    return ready;
};

MapStylesheet.prototype.isReady = function(doNotLoad, priority) {
    if (this.loadState == 2) { //loaded
        if (this.fontsReady) {
            return true;
        } else {
            return this.checkFonts();
        }

    } else {
        if (this.loadState == 0) { 
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } //else load in progress
    }

    return false;
};


MapStylesheet.prototype.scheduleLoad = function(priority) {
    this.map.loader.load(this.url, this.onLoad.bind(this), priority);
};


MapStylesheet.prototype.onLoad = function() {
    //this.mapLoaderCallLoaded = onLoaded;
    //this.mapLoaderCallError = onError;

    this.loadState = 1;
};


MapStylesheet.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    //this.mapLoaderCallError();
    //this.loadState = 2;
};

MapStylesheet.prototype.setFonts = function(data) {
    this.fonts = data['fonts'] || {};
    
    if (!this.fonts['#default']) {
        this.fonts['#default'] = this.map.core.config.mapDefaultFont;
    }
};

MapStylesheet.prototype.onLoaded = function(data) {
    if (this.map.killed){
        return;
    }
    
    this.data = data;
    this.setFonts(data);

    //this.mapLoaderCallLoaded();
    this.loadState = 2;
    this.map.markDirty();
};


// Returns RAM usage in bytes.
//MapStylesheet.prototype.getSize = function () {
  //  return this.size;
//};

//MapStylesheet.prototype.getFileSize = function () {
  //  return this.fileSize;
//};

/* harmony default export */ __webpack_exports__["a"] = (MapStylesheet);



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer_gpu_texture__ = __webpack_require__(6);




//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_1__renderer_gpu_texture__["a" /* default */];


var MapSubtexture = function(map, path, type, tile, internal) {
    this.map = map;
    this.stats = map.stats;
    this.tile = tile; // used only for stats
    this.internal = internal; // used only for stats
    this.image = null;
    this.imageData = null;
    this.imageExtents = null;
    this.gpuTexture = null;
    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.neverReady = false;
    this.mapLoaderUrl = path;
    this.type = type || false;
    this.statsCounter = 0;
    this.checkStatus = 0;
    this.checkType = null;
    this.checkValue = null;
    this.fastHeaderCheck = false;
    this.gpuSize = 0;
    this.fileSize = 0;
    this.cacheItem = null; //store killImage
    this.gpuCacheItem = null; //store killGpuTexture
};


MapSubtexture.prototype.kill = function() {
    this.killImage();
    this.killGpuTexture();
    
    if (this.mask) {
        this.mask.killImage(); 
        this.mask.killGpuTexture(); 
    }
    
    //this.tile.validate();
};


MapSubtexture.prototype.killImage = function(killedByCache) {
    this.image = null;
    this.imageData = null;

    if (killedByCache !== true && this.cacheItem) {
        this.map.resourcesCache.remove(this.cacheItem);
        //this.tile.validate();
    }

    if (this.mask) {
        this.mask.killImage(); 
    }

    if (!this.gpuTexture) {
        this.loadState = 0;
    } //else {
        //this.loadState = this.loadState;
    //}

    this.cacheItem = null;
};


MapSubtexture.prototype.killGpuTexture = function(killedByCache) {
/*
    //debug only    
    if (!this.map.lastRemoved) {
        this.map.lastRemoved = [];
    }

    //debug only    
    if (this.map.lastRemoved.indexOf(this.mapLoaderUrl) != -1) {
        console.log("tex: " + this.mapLoaderUrl);
    }

    //debug only    
    this.map.lastRemoved.unshift(this.mapLoaderUrl);
    this.map.lastRemoved = this.map.lastRemoved.slice(0,20);
*/

    if (this.gpuTexture != null) {
        this.stats.gpuTextures -= this.gpuTexture.size;
        this.gpuTexture.kill();

        this.stats.graphsFluxTexture[1][0]++;
        this.stats.graphsFluxTexture[1][1] += this.gpuTexture.size;

        if (this.mask) {
            this.mask.killGpuTexture(); 
        }
    }

    this.gpuTexture = null;

    if (killedByCache !== true && this.gpuCacheItem) {
        this.map.gpuCache.remove(this.gpuCacheItem);
        //this.tile.validate();
    }

    if (!this.image && !this.imageData) {
        this.loadState = 0;
    }

    this.gpuCacheItem = null;
};


MapSubtexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu, texture) {
    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;
    
    if (this.neverReady) {
        return false;
    }

    switch (texture.checkType) {
    case 2:
    case 3:
    case 4:
        
        if (this.checkStatus != 2) {
            this.checkType = texture.checkType;
            this.checkValue = texture.checkValue;

            if (this.checkStatus == 0) {
                this.scheduleHeadRequest(priority, (this.checkType == 4));
            } else if (this.checkStatus == 3) { //loadError
                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {
                    this.scheduleHeadRequest(priority, (this.checkType == 4));
                }
            } else if (this.checkStatus == -1) {
            
                if (texture.extraInfo) { //find at least texture with lower resolution
                    if (!texture.extraBound) {
                        texture.extraBound = { tile: texture.extraInfo.tile, layer: texture.extraInfo.layer};
                        texture.setBoundTexture(texture.extraBound.tile.parent, texture.extraBound.layer);        
                    }
        
                    while (texture.extraBound.texture.extraBound || texture.extraBound.texture.checkStatus == -1) {
                        //while (texture.extraBound.texture.checkStatus == -1) {
                        texture.setBoundTexture(texture.extraBound.sourceTile.parent, texture.extraBound.layer);        
                    }
                }
            }
    
            return false;
        }
            
        break;
    }

    if (this.loadState == 2) { //loaded
        var t;

        if (!doNotLoad && this.cacheItem) {
            this.map.resourcesCache.updateItem(this.cacheItem);
        }

        /*
        if (((this.type == VTS_TEXTURETYPE_HEIGHT && !this.imageData) || (this.type != VTS_TEXTURETYPE_HEIGHT && !this.gpuTexture)) &&
              this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
            //console.log("testure resource build overflow");
            this.map.markDirty();
            return false;
        }*/

        if (doNotCheckGpu) {
            if (this.type == 1) {
                if (!this.imageData) {
                    t = performance.now();
                    this.buildHeightMap();
                    this.stats.renderBuild += performance.now() - t; 
                }
            }

            return true;
        }

        if (this.type == 1) {
            if (!this.imageData) {
                t = performance.now();
                this.buildHeightMap();
                this.stats.renderBuild += performance.now() - t; 
            }
        } else {
            if (!this.gpuTexture) {
                if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {
                    return false;
                }
                
                if (doNotUseGpu) {
                    return false;
                }

                //if (this.stats.graphsFluxTexture [0][0] > 2) {
                   // return false;
                //}

                t = performance.now();
                this.buildGpuTexture();
                this.stats.renderBuild += performance.now() - t; 
            }

            if (!doNotLoad && this.gpuCacheItem) {
                this.map.gpuCache.updateItem(this.gpuCacheItem);
            }
        }
        
        
        return true;
    } else {
        if (this.loadState == 0) { 
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                    //this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                this.scheduleLoad(priority);                    
            }
        } //else load in progress
    }

    return false;
};


MapSubtexture.prototype.scheduleLoad = function(priority, header) {
    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this, header), priority, this.tile, this.internal ? 'texture-in' : 'texture-ex');
};


MapSubtexture.prototype.onLoad = function(header, url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    var onerror = this.onLoadError.bind(this);
    var onload = this.onLoaded.bind(this);

    if (header) {
        this.checkStatus = 1;
    } else {
        this.loadState = 1;
    }

    if (this.map.config.mapXhrImageLoad) {
        //utils.loadBinary(url, this.onBinaryLoaded.bind(this), onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
        this.map.loader.processLoadBinary(url, this.onBinaryLoaded.bind(this), onerror, null, 'texture');
    } else {
        this.image = utils.loadImage(url, onload, onerror, (this.map.core.tokenCookieHost ? (url.indexOf(this.map.core.tokenCookieHost) != -1) : false));
    }
    //mapXhrImageLoad
};


MapSubtexture.prototype.onLoadError = function(killBlob) {
    if (this.map.killed){
        return;
    }

    if (killBlob) {
        window.URL.revokeObjectURL(this.image.src);
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;
    
    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { 
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }    
    
    this.mapLoaderCallError();
};


MapSubtexture.prototype.onBinaryLoaded = function(data, direct, filesize) {
    if (this.fastHeaderCheck && this.checkType && this.checkType != 1) {
        this.onHeadLoaded(null, data, null /*status*/);
        
        if (this.checkStatus == -1) {
            this.mapLoaderCallLoaded();
            return;
        }
    }

    if (direct) {
        this.onLoaded(false, data)
        this.fileSize = filesize;
        return;
    }

    this.fileSize = data.size;

    if (this.map.config.mapAsyncImageDecode) {
        createImageBitmap(data).then(this.onLoaded.bind(this, false));
    } else {
        var image = new Image();
        image.onerror = this.onLoadError.bind(this, true, null);
        image.onload = this.onLoaded.bind(this, true, null);
        this.image = image;
        image.src = window.URL.createObjectURL(data);
    }
};


MapSubtexture.prototype.onLoaded = function(killBlob, bitmap) {
    if (this.map.killed){
        return;
    }

    if (killBlob) {
        window.URL.revokeObjectURL(this.image.src);
    }

    if (bitmap) {
        this.image = bitmap;
        this.image.naturalWidth = bitmap.width;
        this.image.naturalHeight = bitmap.height;
    }

    var size = this.image.naturalWidth * this.image.naturalHeight * (this.heightMap ? 3 : 3);
    this.gpuSize = this.image.naturalWidth * this.image.naturalHeight * 4;  //aproximate size 

    //if (!this.image.complete) {
       // size = size;
    //}
    
    //console.log(size);

    this.cacheItem = this.map.resourcesCache.insert(this.killImage.bind(this, true), size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


MapSubtexture.prototype.scheduleHeadRequest = function(priority, downloadAll) {
    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {
        this.scheduleLoad(priority, true);
    } else {
        this.map.loader.load(this.mapLoaderUrl, this.onLoadHead.bind(this, downloadAll), priority, this.tile, this.internal, this.internal ? 'texture-in' : 'texture-ex');
    }
};


MapSubtexture.prototype.onLoadHead = function(downloadAll, url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    var onerror = this.onLoadHeadError.bind(this, downloadAll);
    var onload = this.onHeadLoaded.bind(this, downloadAll);

    this.checkStatus = 1;

    if (downloadAll) {
        //utils.loadBinary(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
        this.map.loader.processLoadBinary(url, onLoad, onerror, null, 'texture');
    } else {
        utils.headRequest(url, onload, onerror, (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams, 'blob');
    }
};


MapSubtexture.prototype.onLoadHeadError = function() {
    if (this.map.killed){
        return;
    }

    this.checkStatus = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;
    
    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { 
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }    
    
    this.mapLoaderCallError();
};


MapSubtexture.prototype.onHeadLoaded = function(downloadAll, data, status) {
    if (this.map.killed){
        return;
    }

    this.checkStatus = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    if (this.map.config.mapXhrImageLoad && this.fastHeaderCheck) {

        switch (this.checkType) {
        case 4:
            if (data) {
                if (data.size == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;
                
        case 2:
            if (data) {
                if (data.type == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;
                
        case 3:
            if (status) {
                if (this.checkValue.indexOf(status) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;
        }

    } else {

        switch (this.checkType) {
        case 4:
            if (data) {
                if (data.byteLength == this.checkValue) {
                    this.checkStatus = -1;
                }
            }
            break;
                
        case 2:
            if (data) {
                //if (!data.indexOf) {
                  //  data = data;
                //}
                    
                if (data.indexOf(this.checkValue) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;
                
        case 3:
            if (status) {
                if (this.checkValue.indexOf(status) != -1) {
                    this.checkStatus = -1;
                }
            }
            break;
        }
        
        this.mapLoaderCallLoaded();
    }
};


MapSubtexture.prototype.buildGpuTexture = function () {
    this.gpuTexture = new GpuTexture(this.map.renderer.gpu, null, this.map.core);
    this.gpuTexture.createFromImage(this.image, (this.type == 2) ? 'nearest' : 'linear', false);
    this.gpuSize = this.gpuTexture.getSize();

    this.stats.gpuTextures += this.gpuSize;

    this.stats.graphsFluxTexture[0][0]++;
    this.stats.graphsFluxTexture[0][1] += this.gpuSize;

    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuTexture.bind(this, true), this.gpuSize);
};


MapSubtexture.prototype.buildHeightMap = function () {
    var canvas = document.createElement('canvas');
    canvas.width = this.image.naturalWidth;
    canvas.height = this.image.naturalHeight;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this.image, 0, 0);
    this.imageData = ctx.getImageData(0, 0, this.image.naturalWidth, this.image.naturalHeight).data;
    this.imageExtents = [this.image.naturalWidth, this.image.naturalHeight];
    this.image = null;
};


MapSubtexture.prototype.getGpuTexture = function() {
    return this.gpuTexture;
};


MapSubtexture.prototype.getHeightMapValue = function(x, y) {
    if (this.imageData) {
        return this.imageData[(y * this.imageExtents[0] + x)*4];
    }
    
    return 0;
};

/* harmony default export */ __webpack_exports__["a"] = (MapSubtexture);



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__surface_tile__ = __webpack_require__(153);




//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
var MapSurfaceTile = __WEBPACK_IMPORTED_MODULE_1__surface_tile__["a" /* default */];


var MapSurfaceTree = function(map, freeLayer, freeLayerSurface) {
    this.map = map;
    this.camera = map.camera;
    this.rootId = [0,0,0];
    this.freeLayer = freeLayer;
    this.freeLayerSurface = freeLayerSurface;
    this.metaBinaryOrder = this.map.referenceFrame.params.metaBinaryOrder;
    //this.initialized = false;
    //this.geocent = !this.map.getNavigationSrs().isProjected();

    this.surfaceTree = new MapSurfaceTile(this.map, null, this.rootId);

    //if (freeLayer !== true) {
        //this.heightTracer = new MapMetanodeTracer(this, null, this.traceTileHeight.bind(this), this.traceHeightChild.bind(this));
        //this.heightTracerNodeOnly = new MapMetanodeTracer(this, null, this.traceTileHeightNodeOnly.bind(this), this.traceHeightChild.bind(this));
    //}

    this.surfaceSequence = [];
    this.surfaceOnlySequence = [];

    this.config = this.map.config;
    this.cameraPos = [0,0,0];
    this.worldPos = [0,0,0];
    this.ndcToScreenPixel = 1.0;
    this.counter = 0;
};


MapSurfaceTree.prototype.kill = function() {
    this.surfaceTree = null;
    this.metastorageTree = null;
    this.surfaceTracer = null;
    this.heightTracer = null;
};


/*MapSurfaceTree.prototype.init = function() {
    var url = this.map.url.makeUrl(surface.metaUrl, {lod:result[0], ix:result[1], iy:result[2] });  //result???
    map.loader.load(url, metatile.load.bind(metatile, url));

    this.metatileTree.load();
    this.surfaceTree.metatile = 1;

    this.initialized = true;
};*/


MapSurfaceTree.prototype.findSurfaceTile = function(id) {
    var tile = this.surfaceTree;

//    for (var lod = 1; lod <= id[0]; lod++) {
//        var mask = 1 << (lod-1);
//        var index = 0;

    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;
        
        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }
        
        tile = tile.children[index];

        if (!tile) {
            return null;
        }
    }
    
    return tile;
};


MapSurfaceTree.prototype.findNavTile = function(id) {
    var tile = this.surfaceTree;
    
    if (id[0] == 0) {
        if (tile.metanode && tile.metanode.hasNavtile()) {
            return tile;
        } else {
            return null;
        }
    }
    
    var navtile = null;

//    for (var lod = 1; lod <= id[0]; lod++) {
//        var mask = 1 << (id[0] - lod);
//        var index = 0;
    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }
        
        tile = tile.children[index];

        if (!tile) {
            return navtile;
        } else {
            if (tile.metanode && tile.metanode.hasNavtile()) {
                navtile = tile;
            }
        }
    }
    
    return navtile;
};


MapSurfaceTree.prototype.draw = function(storeTilesOnly) {
    this.cameraPos = [0,0,0];
    this.worldPos = [0,0,0];

    var map = this.map;
    var draw = map.draw;
    this.ndcToScreenPixel = draw.ndcToScreenPixel;
    
    var srs = map.getPhysicalSrs();

    //var divisionNode = this.divisionNode;
    var periodicity = srs.periodicity;

    //if (this.map.config.mapBasicTileSequence) {
        //this.surfaceTracer = this.surfaceTracerBasic;
    //}
    
    if (this.freeLayerSurface && this.freeLayerSurface.geodata && draw.drawChannel != 0) {
        return;
    }

    if (periodicity != null) {
        this.drawSurface([0,0,0]);

        if (periodicity.type == 'X') {
            this.drawSurface([periodicity.period,0,0], storeTilesOnly);
            this.drawSurface([-periodicity.period,0,0], storeTilesOnly);
        }

    } else {
        var mode;

        if (this.freeLayerSurface && this.freeLayerSurface.geodata) {
            mode = map.config.mapGeodataLoadMode; 
        } else {
            mode = map.config.mapLoadMode; 
        }

        switch(mode) {
        case 'topdown': this.drawSurface([0,0,0], storeTilesOnly); break;
        case 'fit':     this.drawSurfaceFit([0,0,0], storeTilesOnly); break;
        case 'fitonly': this.drawSurfaceFitOnly([0,0,0], storeTilesOnly); break;
        }
    }
};


MapSurfaceTree.prototype.updateNodeHeightExtents = function(tile, node) {
    
    if (!node.heightReady && node.metatile.useVersion < 4) {
        var parent = tile.parent;

        //if (node.hasNavtile()) {
          //  node = node;
        //}
        
        while (parent) {
            var parentNode = parent.metanode;  
            if (parentNode.hasNavtile()) {

                //if (node.hasNavtile()) {
                  //  node = node;
                //}

                node.minHeight = parentNode.minHeight;
                node.maxHeight = parentNode.maxHeight;
                node.minZ = parentNode.minZ;
                node.maxZ = parentNode.maxZ;
                node.minZ2 = parentNode.minZ2;
                node.maxZ2 = parentNode.maxZ2;
                node.generateCullingHelpers();
                break;
            }
            
            parent = parent.parent;
        }

        node.heightReady = true;
    }
};


MapSurfaceTree.prototype.logTileInfo = function(tile, node, cameraPos) {
    if (!tile || !node) {
        return;
    }
    
    var visible = tile.bboxVisible(tile.id, node.bbox, cameraPos, node);
    tile.updateTexelSize();
    
    // eslint-disable-next-line
    console.log('tile: ' + JSON.stringify(tile.id) + ' visible: ' + visible + ' texelsize: ' +  tile.texelSize + ' center: '  + JSON.stringify(node.diskPos) + ' vec: ' + node.diskNormal + 'ang: ' + node.diskAngle + ' dist: ' + node.diskDistance);
};


//loadmode = topdown
MapSurfaceTree.prototype.drawSurface = function(shift, storeTilesOnly) {
    this.counter++;

    var tile = this.surfaceTree;
    
    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }
    
    var map = this.map;
    var node = tile.metanode;
    var cameraPos = map.camera.position;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();
    
    var typeFactor = this.freeLayerSurface ? 1 : 1;

    var draw = map.draw;
    var drawTiles = draw.drawTiles;
    var drawBuffer = draw.drawBuffer;
    var processBuffer = draw.processBuffer;
    var newProcessBuffer = draw.processBuffer2;
    var drawBufferIndex = 0;
    var processBufferIndex = 0;
    var newProcessBufferIndex = 0;
    var gpuNeeded = 0;
    var gpuNeededForRender = 0;
    var size = 0;
    
    processBuffer[0] = tile;
    processBufferIndex = 1;
   
    var texelSizeFit = draw.texelSizeFit;

    var best2 = 0;
    var replay = draw.replay;
    var storeNodes = replay.storeNodes || replay.storeFreeNodes;
    var storeNodesBuffer = replay.nodeBuffer; 
   
    draw.drawCounter++;
    
    var pocessedNodes = 1;
    var pocessedMetatiles = 1;  
    var usedNodes = 1;
    var drawCounter = draw.drawCounter, i, j, lj;


    do {
        var best = 0;
        newProcessBufferIndex = 0;
        
        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }
            
            //if (this.map.drawIndices) {
              //  this.logTileInfo(tile, node, cameraPos);
            //}

            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (tile.texelSize != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }
                
                if (storeNodes) { //used only for inspector
                    storeNodesBuffer.push(tile);
                }
              
                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit /*|| gpuNeeded > gpuMax*/) {
                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);

                    gpuNeeded += size;
                    gpuNeededForRender += size;

                    tile.drawCounter = draw.drawCounter;
                    drawBuffer[drawBufferIndex] = tile;
                    drawBufferIndex++;
                    
                } else { //go deeper
                    size = draw.getDrawCommandsGpuSize(tile.drawCommands[draw.drawChannel] || tile.lastRenderState.drawCommands[draw.drawChannel]);
                    gpuNeeded += size;

                    var childrenCount = 0;
                    var readyCount = 0;
                    var childrenBuffer = [];
                    
                    var more3 = 0;
        
                    for (j = 0; j < 4; j++) {
                        var child = tile.children[j];
                        if (child) {
                            childrenCount++;
       
                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                var factor = 1;

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize(factor);
                                
                                var priority = child.id[0] * typeFactor * child.distance;
                                
                                if (!tile.surface || !child.metanode.hasGeometry()) {

                                    readyCount++;
                                    //child.updateTexelSize();
                                    childrenBuffer.push(child);
                                    
                                } else {

                                    //are draw buffers ready? preventRender=true, preventLoad=false, doNotCheckGpu=true
                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, true)) {
                                        
                                        readyCount++;
                                        //child.updateTexelSize();
                                        childrenBuffer.push(child);
                                    }
                                    
                                }
                            }
                        }
                    }
        
                    if (/*!(gpuNeeded > gpuMax) &&*/ childrenCount > 0 && childrenCount == readyCount && childrenCount != more3) {
                        //sort children by distance
    
                        do {
                            var sorted = true;
                            
                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    var t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                } 
                            }
                            
                        } while(!sorted);
    
    
                        //add children to new process buffer 
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {
                            
                            /*var n = childrenBuffer[j].metanode.divisionNode;
                            if ((n.id[0] == 1 && n.id[1] == 1 && n.id[2] == 0)) {*/
                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                            /*}*/
                            
                        }
                    } else {
                        gpuNeededForRender += size;

                        tile.drawCounter = draw.drawCounter;
                        drawBuffer[drawBufferIndex] = tile;
                        drawBufferIndex++;
                    }
                    
                }
            }
        }

        var tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;

    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }
    
    if (best2 > draw.bestMeshTexelSize) {
        draw.bestMeshTexelSize = best2;
    }

    var stats = map.stats;

    stats.usedNodes = usedNodes;    
    stats.processedNodes = pocessedNodes;    
    stats.processedMetatiles = pocessedMetatiles;    
    stats.gpuNeeded = gpuNeeded;    
    
    //console.log("texel: "+ this.map.bestMeshTexelSize);
    //console.log("more: "+ more + "more2: " + more2);

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);
};


//loadmode = fitonly
MapSurfaceTree.prototype.drawSurfaceFitOnly = function(shift, storeTilesOnly) {
    this.counter++;
//    this.surfaceTracer.trace(this.surfaceTree);//this.rootId);

    var tile = this.surfaceTree;
    
    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }
    
    var map = this.map;
    var node = tile.metanode;
    var cameraPos = map.camera.position;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();
    
    //var typeFactor = this.freeLayerSurface ? 1 : 1;
    
    var draw = map.draw;
    var drawTiles = draw.drawTiles;
    var drawBuffer = draw.drawBuffer;
    var processBuffer = draw.processBuffer;
    var newProcessBuffer = draw.processBuffer2;
    var drawBufferIndex = 0;
    var processBufferIndex = 0;
    var newProcessBufferIndex = 0;
    
    processBuffer[0] = tile;
    processBufferIndex = 1;

    var texelSizeFit = draw.texelSizeFit;

    var replay = map.draw.replay;
    var storeNodes = replay.storeNodes || replay.storeFreeNodes;
    var storeNodesBuffer = replay.nodeBuffer; 

    draw.drawCounter++;
    
    var usedNodes = 1;
    var pocessedNodes = 1;
    var pocessedMetatiles = 1;  
    var drawCounter = map.drawCounter, i, j, lj;
    var grids = false; 
    
    do {
        var best = 0;
        newProcessBufferIndex = 0;
       
        for (i = processBufferIndex - 1; i >= 0; i--) {
            tile = processBuffer[i];
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }

            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (storeNodes) { //used only for inspaector
                    storeNodesBuffer.push(tile);
                }

                if (tile.texelSize  != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }
                
                if (/*node.hasGeometry() && */tile.texelSize <= texelSizeFit) {
                   
                    tile.drawCounter = draw.drawCounter;
                    drawBuffer[drawBufferIndex] = tile;
                    drawBufferIndex++;
                    
                } else { //go deeper

                    var childrenCount = 0;
                    var childrenBuffer = [];
        
                    for (j = 0; j < 4; j++) {
                        var child = tile.children[j];
                        if (child) {
                            childrenCount++;
       
                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();

                                childrenBuffer.push(child);
                            }
                        }
                    }
        
                    if (childrenCount > 0/* && childrenCount == readyCount*/) {
                        //sort children by distance
    
                        do {
                            var sorted = true;
                            
                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    var t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                } 
                            }
                            
                        } while(!sorted);
    
                        //add childrn to new process buffer 
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {

                            newProcessBuffer[newProcessBufferIndex] = childrenBuffer[j];
                            newProcessBufferIndex++;
                        }
                    } else {
                        tile.drawCounter = draw.drawCounter;
                        drawBuffer[drawBufferIndex] = tile;
                        drawBufferIndex++;
                    }
                    
                }
            }
        }
        
        var tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;
        
    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }

    var stats = map.stats;

    stats.usedNodes = usedNodes;    
    stats.processedNodes = pocessedNodes;    
    stats.processedMetatiles = pocessedMetatiles;    

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, false, false, replay, drawBuffer, drawBufferIndex, true);
};


//loadmode = fit
MapSurfaceTree.prototype.drawSurfaceFit = function(shift, storeTilesOnly) {
    this.counter++;

    var tile = this.surfaceTree;
    
    if (!tile.isMetanodeReady(this, 0)) {
        return;
    }
    
    var map = this.map;
    var node = tile.metanode;
    var cameraPos = map.camera.position;

    if (!tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {
        return;
    }

    tile.updateTexelSize();

    var geodata = tile.surface ? tile.surface.geodata : null;
    var free = tile.surface ? tile.surface.free : null;
    var drawGrid = (!geodata && !free && map.config.mapHeightfiledWhenUnloaded);
    var checkGpu = true;
    
    var lodShift = 4;//this.freeLayerSurface ? 1 : 1;
    var typeFactor = 2000;//this.freeLayerSurface ? 1 : 1;

    if (this.freeLayerSurface) {
        lodShift = 0;//this.freeLayerSurface ? 1 : 1;
        typeFactor = 0.1;//this.freeLayerSurface ? 1 : 1;
    }
    
    var draw = map.draw;
    var drawTiles = draw.drawTiles;
    var replay = draw.replay;
    var drawBuffer = draw.drawBuffer;
    var processBuffer = draw.processBuffer;
    var newProcessBuffer = draw.processBuffer2;
    var drawBufferIndex = 0;
    var processBufferIndex = 0;
    var newProcessBufferIndex = 0;
    
    processBuffer[0] = [tile, 0];
    processBufferIndex = 1;

    var texelSizeFit = draw.texelSizeFit;

    var storeNodes = replay.storeNodes || replay.storeFreeNodes;
    var storeNodesBuffer = replay.nodeBuffer; 

    draw.drawCounter++;
    
    var usedNodes = 1;
    var pocessedNodes = 1;
    var pocessedMetatiles = 1;  
    var drawCounter = draw.drawCounter;
    var maxHiresLodLevels = map.config.mapMaxHiresLodLevels, i, j, lj, child, priority, parent, parent2, children2;
    var grids = false; 
    
    do {
        var best = 0;
        newProcessBufferIndex = 0;

        /*if (this.map.drawIndices) {
            console.log("processed begin==============================================");
        }*/            
       
        for (i = processBufferIndex - 1; i >= 0; i--) {
            var pack = processBuffer[i];
            tile = pack[0];
            var depth = pack[1];

            tile.childrenReadyCount = 0;
            
            /*if (this.map.drawIndices) {
                console.log(JSON.stringify(tile.id));
            }*/
            
            if (depth >= maxHiresLodLevels) {
                if (drawGrid) {
                    parent = tile;

                    //make sure that we draw grid with lowest possible detail 
                    parent2 = parent.parent;                    

                    if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {
                        children2 = parent2.children;

                        if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || 
                             (children2[1] && children2[1].childrenReadyCount != 0) ||
                             (children2[2] && children2[2].childrenReadyCount != 0) ||
                             (children2[3] && children2[3].childrenReadyCount != 0)))) {
                            parent = parent.parent;
                        }
                    }

                    //make sure that grid tile is rendered only one time
                    if (parent.drawCounter != draw.drawCounter && (!parent.parent || parent.parent.drawCounter != draw.drawCounter )) { 
                        parent.drawCounter = draw.drawCounter;
                        
                        drawBuffer[drawBufferIndex] = [parent, true]; //draw grid
                        drawBufferIndex++;
                        grids = true;
                    }
                }

                continue;
            }
            
            node = tile.metanode;

            if (node) {
                pocessedNodes++;
                if (node.metatile.drawCounter != drawCounter) {
                    node.metatile.drawCounter = drawCounter;
                    pocessedMetatiles++;
                }
            }


            if (tile.bboxVisible(tile.id, node.bbox, cameraPos, node)) {

                usedNodes++;

                if (tile.texelSize  != Number.POSITIVE_INFINITY){
                    if (tile.texelSize > best) {
                        best = tile.texelSize;
                    }
                }

                if (storeNodes) { //used only for inspaector
                    storeNodesBuffer.push(tile);
                }
                
                var lastProcessBufferIndex = newProcessBufferIndex;
                var lastDrawBufferIndex = drawBufferIndex;

                if (!node.hasChildren() || tile.texelSize <= texelSizeFit) {

                    priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; 
            
                    if (node.hasChildren() && !drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, (depth > 0), checkGpu)) {

                        depth++; //we dont have tile ready, so we try to draw more detailed tiles

                        for (j = 0; j < 4; j++) {
                            child = tile.children[j];
                            if (child) {
           
                                if (child.isMetanodeReady(this, child.id[0], true)) { //lod is used as priority

                                    this.updateNodeHeightExtents(child, child.metanode);
                                    child.updateTexelSize();
                                    
                                    //are draw buffers ready? preventRender=true, preventLoad=false
                                    if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, (depth > 0), checkGpu)) {
                                        tile.childrenReadyCount++;
                                        child.drawCounter = draw.drawCounter;
                                        
                                        drawBuffer[drawBufferIndex] = [child, false];
                                        drawBufferIndex++;
                                    } else {
                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                        newProcessBufferIndex++;
                                    }
                                }
                            }
                        }

                        if (lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {
                            depth--; 
                        }

                    } else {
                        tile.drawCounter = draw.drawCounter;

                        drawBuffer[drawBufferIndex] = [tile, false];
                        drawBufferIndex++;
                    }
                    
                } else if (depth == 0 && node.hasGeometry() && tile.texelSize <= (texelSizeFit * 2)) {
                    
                    //are all children ready? if not then draw carser lod
                    var childrenCount = 0;
                    var readyCount = 0;
                    var childrenBuffer = [];
        
                    for (j = 0; j < 4; j++) {
                        child = tile.children[j];
                        if (child) {
                            childrenCount++;
       
                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority

                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();
                                
                                priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; 
                               
                                //are draw buffers ready? preventRender=true, preventLoad=true
                                if (drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, true, checkGpu)) {
                                    readyCount++;
                                    childrenBuffer.push(child);
                                }
                            }
                        }
                    }
        
                    if (childrenCount > 0 && childrenCount == readyCount) {
                        //sort children by distance
    
                        do {
                            var sorted = true;
                            
                            for (j = 0, lj = childrenBuffer.length - 1; j < lj; j++) {
                                if (childrenBuffer[j].distance > childrenBuffer[j+1].distance) {
                                    var t = childrenBuffer[j];
                                    childrenBuffer[j] = childrenBuffer[j+1];
                                    childrenBuffer[j+1] = t;
                                    sorted = false;
                                } 
                            }
                            
                        } while(!sorted);
    
                        //add children to new process buffer 
                        for (j = 0, lj = childrenBuffer.length; j < lj; j++) {
                            newProcessBuffer[newProcessBufferIndex] = [childrenBuffer[j], depth];
                            newProcessBufferIndex++;
                        }
                    } else {
                        
                        //can i use coarser lod
                        priority = ((tile.id[0] + lodShift) * typeFactor) * tile.distance; 

                        if (drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, priority, true, true, checkGpu)) {
                            tile.drawCounter = draw.drawCounter;

                            drawBuffer[drawBufferIndex] = [tile, false];
                            drawBufferIndex++;

                            for (j = 0; j < 4; j++) {
                                child = tile.children[j];
                                if (child) {
                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                        priority = ((child.id[0] + lodShift) * typeFactor) * child.distance; 
                                        drawTiles.drawSurfaceTile(child, child.metanode, cameraPos, child.texelSize, priority, true, false, checkGpu);
                                    }
                                }
                            }

                        } else {

                            //add children to new process buffer 
                            for (j = 0; j < 4; j++) {
                                child = tile.children[j];
                                if (child) {
                                    if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                        this.updateNodeHeightExtents(child, child.metanode);
                                        child.updateTexelSize();

                                        newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                        newProcessBufferIndex++;
                                    }
                                }
                            }

                        } 
                    }

                }  else  {  //go deeper
                    
                    
                    for (j = 0; j < 4; j++) {
                        child = tile.children[j];
                        if (child) {

                            if (child.isMetanodeReady(this, child.id[0])) { //lod is used as priority
                                this.updateNodeHeightExtents(child, child.metanode);
                                child.updateTexelSize();
                                
                                newProcessBuffer[newProcessBufferIndex] = [child, depth];
                                newProcessBufferIndex++;
                            }
                        }
                    }                    
                }
            }


            if (drawGrid && lastProcessBufferIndex == newProcessBufferIndex && lastDrawBufferIndex == drawBufferIndex) {
                parent = tile;

                //make sure that we draw grid with lowest possible detail 
                parent2 = parent.parent;                    

                if (parent.id[0] > 3 && depth !=0 && parent2 && parent2.childrenReadyCount == 0) {
                    children2 = parent2.children;

                    if (!(depth >= 1 && parent.parent && ((children2[0] && children2[0].childrenReadyCount != 0) || 
                         (children2[1] && children2[1].childrenReadyCount != 0) ||
                         (children2[2] && children2[2].childrenReadyCount != 0) ||
                         (children2[3] && children2[3].childrenReadyCount != 0)))) {
                        parent = parent.parent;
                    }
                }

                //make sure that grid tile is rendered only one time
                if (parent && parent.drawCounter != draw.drawCounter) { 
                    parent.drawCounter = draw.drawCounter;

                    drawBuffer[drawBufferIndex] = [parent, true]; //draw grid
                    drawBufferIndex++;
                    grids = true;
                }
            }

        }

        /*if (this.map.drawIndices) {
            console.log("processed end==============================================");
        }*/
        
        var tmp = processBuffer;
        processBuffer = newProcessBuffer;
        newProcessBuffer = tmp;
        processBufferIndex = newProcessBufferIndex;
        
    } while(processBufferIndex > 0);

    if (storeTilesOnly) {
        this.storeDrawBufferGeometry(drawBufferIndex);
        return;
    }

    var stats = map.stats;

    stats.usedNodes = usedNodes;    
    stats.processedNodes = pocessedNodes;    
    stats.processedMetatiles = pocessedMetatiles;    

    this.processDrawBuffer(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex);
};


MapSurfaceTree.prototype.processDrawBuffer = function(draw, drawTiles, cameraPos, map, stats, drawGrid, grids, replay, drawBuffer, drawBufferIndex, noGrid) {

    if (replay.storeTiles || replay.storeFreeTiles) { //used only in inspectors
        if (!draw.tileBuffer[0]) {
            draw.tileBuffer[0] = [];
        }
        
        var tiles = draw.tileBuffer[0];
        for (i = drawBufferIndex - 1; i >= 0; i--) {
            tiles.push(drawBuffer[i]);
        }
    }

    var scanExtents = (!this.freeLayerSurface && map.config.mapFeatureStickMode[0] == 2); // && this.freeLayerSurface.geodata && draw.drawChannel == 0);
    var hmax = -999999, hmin = 999999;
    var renderer = map.renderer;
    var mvp = this.camera.getMvpMatrix(), p1, p2, camVec, length, tilt, factor, i, tile, node; 

    map.gpuCache.skipCostCheck = true;

    var underSurfaceGrid = (drawGrid && map.config.mapGridUnderSurface > 0 && grids);
    
    if (underSurfaceGrid) {
        //draw only grid
        for (i = drawBufferIndex - 1; i >= 0; i--) {
            drawBuffer[i][0].drawGrid(cameraPos); 
        }

        //clear zbuffer
        map.renderer.gpu.clear(true, false);
    }

    //draw surface
    for (i = drawBufferIndex - 1; i >= 0; i--) {
        var item = drawBuffer[i];
        tile = (noGrid) ? item : item[0];
        node = tile.metanode;

        if (scanExtents && node) {
            // TODO noramlize by distance and tilt

            p2 = node.diskPos;
            p1 = renderer.cameraPosition;
            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            length = vec3.normalize4(camVec);
            tilt = -vec3.dot(camVec, node.diskNormal);

            if (tilt < 0) {
                tilt = 0;
            }

            tilt = 1 - tilt;

            factor = (renderer.camera.fovDist / length) * tilt;
            //renderer.camera.scaleFactor2(d) * screenPixelSize
            //pp = this.renderer.project2(tile.diskPos, mvp);                

            if (node.minZ * factor < hmin) {
                hmin = node.minZ * factor;
            }

            if (node.maxZ * factor > hmax) {
                hmax = node.maxZ * factor;
            }
        }


        if (noGrid)  {

            if (stats.gpuRenderUsed >= draw.maxGpuUsed)  {
                break;
            }

            //draw tile,  preventRender=false, preventLoad=false
            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false);

        } else {

            if (underSurfaceGrid) {

                if (!item[1] && !(stats.gpuRenderUsed >= draw.maxGpuUsed))  {
                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);
                } else {
                    if (drawTiles.debug.drawBBoxes) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                    }
                }

            } else {

                if ((drawGrid && item[1]) || stats.gpuRenderUsed >= draw.maxGpuUsed)  {

                    if (drawTiles.debug.drawBBoxes) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                    }

                    tile.drawGrid(cameraPos); 
                } else if (!item[1]) {
                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.texelSize, 0, false, false /*, checkGpu*/);
                }
            }

        }
    }

    if (scanExtents) {
        renderer.gridHmax = hmax;
        renderer.gridHmin = hmin;
    }

    map.gpuCache.skipCostCheck = false;
    map.gpuCache.checkCost();

};


MapSurfaceTree.prototype.storeDrawBufferGeometry = function(drawBufferIndex) {
    var map = this.map;
    var drawBuffer = map.draw.drawBuffer;

    this.storeGeometry(drawBuffer, drawBufferIndex);
};


MapSurfaceTree.prototype.storeGeometry = function(array, length) {
    var map = this.map;
    var drawBuffer = array;
    map.storedTilesRes = new Array(length);        

    for (var i = length - 1; i >= 0; i--) {
        var tile = drawBuffer[i];

        if (tile.metanode && tile.surface && tile.metanode.hasGeometry() &&
            tile.surfaceMesh && tile.surfaceMesh.isReady(true, 0, true)) {

            var mesh = tile.surfaceMesh;
            var submeshes = [];

            for (var j = 0, lj = mesh.submeshes.length; j < lj; j++) {
                var submesh = mesh.submeshes[j],
                    vertices = submesh.vertices.slice(),
                    min = submesh.bbox.min,
                    max = submesh.bbox.max,
                    delta = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];

                for (var k = 0, lk = vertices.length; k < lk; k+=3) {
                    vertices[k] = vertices[k]*delta[0] + min[0];
                    vertices[k+1] = vertices[k+1]*delta[1] + min[1];
                    vertices[k+2] = vertices[k+2]*delta[2] + min[2];
                }

                submeshes.push({ 
                    "bbox": [min.slice(), max.slice()],
                    "vertices" : vertices });
            }

            map.storedTilesRes[i] = {
                "id": tile.id.slice(),
                "type": "mesh",
                "submeshes": submeshes
            };
        }
    }
};


MapSurfaceTree.prototype.traceHeight = function(tile, params, nodeOnly) {
    if (!tile) {
        return;
    }

    this.params = params;

    var heightFunction = nodeOnly ? this.traceHeightTileByNodeOnly : this.traceHeightTileByMap;  

    if (tile.id[0] == 1) { //update root, get height in VTS2015 starts in division node which has lod 1
        this.traceHeightTile(tile.parent, 0, true);
        if (!tile.parent.metanode) {
            return;
        }
    }
    
    this.traceHeightTile(tile, 0, false, heightFunction);
};


MapSurfaceTree.prototype.traceHeightTile = function(tile, priority, nodeReadyOnly, heightFunction) {
    if (tile == null) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {
        this.params.waitingForNode = true;
        return;
    }

    tile.metanode.metatile.used();

    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }
    
    //process tile e.g. draw or get height
    var res = heightFunction(tile, this.params, priority); 
    
    if (res) { //we need to go deeper
        var childIndex = this.traceHeightChild(tile, this.params);
        var child = tile.children[childIndex];
        
        if (!child) {
            this.params.finalNode = true;
        }

        this.traceHeightTile(child, 0, false, heightFunction);
    }
};


MapSurfaceTree.prototype.traceHeightChild = function(tile, params) {
    var coords = params.coords;
    var extents = params.extents;
    var center = [(extents.ll[0] + extents.ur[0]) *0.5,
        (extents.ll[1] + extents.ur[1]) *0.5];

    //ul,ur,ll,lr
    //deside in which quadrant are provided coodinates
    var right = (coords[0] >= center[0]);
    var bottom = (coords[1] >= center[1]);

    if (right) {
        extents.ll[0] = center[0];
        if (bottom) {
            extents.ll[1] = center[1];
        } else {
            extents.ur[1] = center[1];
        }
    } else {
        extents.ur[0] = center[0];
        if (bottom) {
            extents.ll[1] = center[1];
        } else {
            extents.ur[1] = center[1];
        }
    }

    /*
    if (extents.ll[0] > extents.ur[0]) {
        right = !right;
    }

    if (extents.ll[1] < extents.ur[1]) {
        bottom = !bottom;
    }*/

    //trace only resulting quadrant 
    if (right) {
        return bottom ? 1 : 3;
    } else {
        return bottom ? 0 : 2;
    }
};


MapSurfaceTree.prototype.traceHeightTileByMap = function(tile, params) {
    if (!tile || (tile.id[0] > params.desiredLod && params.heightMap)) {
        return false;
    }

    var node = tile.metanode;

    if (!node) {
        return false;
    }

    if (node.hasNavtile()) {
        params.bestHeightMap = tile.id[0];

        if (!tile.heightMap) {
            //if (!preventLoad) {
                //if (!tile.surface || tile.surface.virtual) {
            if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {
                return false; //is it best way how to do it?
            }
                
            if (!tile.resourceSurface.getNavUrl) { //virtual surface is as resource surface. Is it bug??!!
                return false; //is it best way how to do it?
            }
                
            var path = tile.resourceSurface.getNavUrl(tile.id);
            tile.heightMap = tile.resources.getTexture(path, true);
            //}
        } else {
            if (tile.heightMap.isReady(null, null, true)) {
                params.parent = {
                    metanode : params.metanode,
                    heightMap : params.heightMap,
                    heightMapExtents : params.heightMapExtents
                };
                
                params.metanode =  node;
                params.heightMap = tile.heightMap;
                params.heightMapExtents = {
                    ll : params.extents.ll.slice(),
                    ur : params.extents.ur.slice()
                };
                return (tile.id[0] != params.desiredLod);
            }
        }
    } else {
        if (!params.heightMap) {
            params.metanode =  node;
        }
        
        return true;
    }

    return false;
};


MapSurfaceTree.prototype.traceHeightTileByNodeOnly = function(tile, params) {
    if (!tile || tile.id[0] > params.desiredLod) {
        return false;
    }

    var node = tile.metanode;

    if (!node) {
        return false;
    }

    params.parent = {
        metanode : params.metanode
    };

    params.metanode =  node;
    return (tile.id[0] != params.desiredLod);
};


MapSurfaceTree.prototype.getNodeById = function(id, preventLoad) {
    var tile = this.surfaceTree;

    if (tile == null) {
        return;
    }

    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }
        
        if (!tile.children[index]) {

            if (!tile.isMetanodeReady(this, 0, preventLoad)) {
                return null;
            }

            if (!tile.metanode.hasChild(index)) {
                return null;
            }

            tile.addChild(index);
        } 

        tile = tile.children[index];
    }

    if (!tile) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0, preventLoad)) {
        return;
    }
	
    var node = tile.metanode;
    tile.metanode.metatile.used();

    return node;

	/*
    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }*/
};


MapSurfaceTree.prototype.getRenderedNodeById = function(id, drawCounter) {
    var tile = this.surfaceTree;

    if (tile == null) {
        return;
    }

    if (tile.drawCounter == drawCounter) {
        if (!tile.isMetanodeReady(this, 0)) {
            return;
        }

        return tile.metanode;
    }

    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }
        
        if (!tile.children[index]) {

            if (!tile.isMetanodeReady(this, 0)) {
                return;
            }

            if (!tile.metanode.hasChild(index)) {
                return;
            }
        } 

        tile = tile.children[index];

        if (tile.drawCounter == drawCounter) {
            if (!tile.isMetanodeReady(this, 0)) {
                return;
            }

            return tile.metanode;
        } else {
            if (lod == 1) { //rendered lod is probably from more detailed lod so we take one which is from same lod
                return tile.metanode;
            }
        }
    }

    return;
};


MapSurfaceTree.prototype.chekTileMesh = function(tile) {
    if (this.params.loadMeshes || this.params.loadTextures) {

        var tmp = this.config.mapNoTextures;
        this.config.mapNoTextures = !this.params.loadTextures;

        //are resources ready? priority=0, preventRender=true, preventLoad=false, doNotCheckGpu=true
        if (!this.map.draw.drawTiles.drawSurfaceTile(tile, tile.metanode, this.map.renderer.cameraPosition, tile.texelSize, 0, true, false, true)) {
            this.params.loaded = false;
        }

        this.config.mapNoTextures = tmp;
    }
};


MapSurfaceTree.prototype.traceAreaTiles = function(tile, priority, nodeReadyOnly) {
    if (tile == null) {
        return;
    }

    if (!tile.isMetanodeReady(this, 0) || nodeReadyOnly) {
        this.params.loaded = false;
        //console.log('(L)' + JSON.stringify(tile.id));
        tile.isMetanodeReady(this, 0);
        return;
    }

    tile.metanode.metatile.used();

    if (tile.lastSurface && tile.lastSurface == tile.surface) {
        tile.lastSurface = null;
        tile.restoreLastState();
        //return;
    }

    if (!tile.insideCone(this.params.coneVec, this.params.coneAngle, tile.metanode)) {
        return;
    }

    var fit = (this.params.mode == 'lod') ? (tile.id[0] >= this.params.limit) : (tile.metanode.pixelSize <= this.params.limit);

    if (fit) {
        //console.log('(A)' + JSON.stringify(tile.id));
        this.chekTileMesh(tile);
        this.params.areaTiles.push(tile);
        return;
    }

    if (!tile.metanode.hasChildren()) {
        //console.log('(A)' + JSON.stringify(tile.id));
        this.chekTileMesh(tile);
        this.params.areaTiles.push(tile);
    } else {
        for (var i = 0; i < 4; i++) {
            this.traceAreaTiles(tile.children[i], priority, nodeReadyOnly);
        }
    }
};



/* harmony default export */ __webpack_exports__["a"] = (MapSurfaceTree);


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__credit__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stylesheet__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__surface_tree__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_url__ = __webpack_require__(12);







//get rid of compiler mess
var MapCredit = __WEBPACK_IMPORTED_MODULE_0__credit__["a" /* default */];
var MapStylesheet = __WEBPACK_IMPORTED_MODULE_1__stylesheet__["a" /* default */];
var MapSurfaceTree = __WEBPACK_IMPORTED_MODULE_2__surface_tree__["a" /* default */];
var BBox = __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_4__utils_utils__["a" /* utils */];
var utilsUrl = __WEBPACK_IMPORTED_MODULE_5__utils_url__["a" /* utilsUrl */];


var MapSurface = function(map, json, type) {
    this.map = map;
    this.id = null;
    this.type = 'basic';
    this.metaBinaryOrder = 1;
    this.metaUrl = '';
    this.navUrl = '';
    this.navDelta = 1;
    this.meshUrl = '';
    this.textureUrl = '';
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.lodRange = [0,0];
    this.tileRange = [[0,0],[0,0]];
    this.textureLayer = null;
    this.boundLayerSequence = [];
    this.glue = (type == 'glue');
    this.free = (type == 'free');
    this.virtual = false;
    this.zFactor = 0;
    this.ready = false;
    this.geodataProcessor = null;
    this.geodataCounter = 0;
    this.geodataNavtileInfo = false;
    this.monoGeodata = null;
    this.monoGeodataView = null;
    this.monoGeodataCounter = -1;
    this.creditsNumbers = [];
    this.surfaceCounter = map.surfaceCounter;
    map.surfaceCounter++;

    this.style = null;
    this.stylesheet = null;
    this.originalStyle = null;
    this.originalStylesheet = null;
    this.styleChanged = true;
    
    if (this.free) { //each free layer has its own data tree
        this.tree = new MapSurfaceTree(this.map, true, this);
    } else {
        this.tree = null;
    }
    
    if (typeof json === 'string') {
        this.jsonUrl = this.map.url.processUrl(json);
        this.baseUrl = utilsUrl.getBase(this.jsonUrl);
        this.baseUrlSchema = utilsUrl.getSchema(this.jsonUrl);
        this.baseUrlOrigin = utilsUrl.getOrigin(this.jsonUrl);
        
        var onLoaded = (function(data){
            this.parseJson(data);            
            this.ready = true;
            this.map.refreshView();
        }).bind(this);
        
        var onError = (function(){ }).bind(this);

        utils.loadJSON(this.jsonUrl, onLoaded, onError, null,(utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
        //utils.loadJSON(this.url, onLoaded, onError, null, utils.useCredentials);
    } else {
        this.parseJson(json);
        this.ready = true;
    }
};


MapSurface.prototype.parseJson = function(json) {
    this.id = json['id'] || null;
    this.type = json['type'] || 'basic';
    this.metaBinaryOrder = json['metaBinaryOrder'] || 1;
    this.metaUrl = this.processUrl(json['metaUrl'], '');
    this.navUrl = this.processUrl(json['navUrl'], '');
    this.hmapUrl = this.processUrl(json['hmapUrl'], json['navUrl'] + '00');
    //this.cmapUrl = this.processUrl(json['cmapUrl'], '');
    this.pipeline = this.map.config.mapForcePipeline ? this.map.config.mapForcePipeline : (json['pipeline']); // || VTS_PIPELINE_HMAP);//VTS_PIPELINE_BASIC);
    //this.pipeline = json['pipeline'] || VTS_PIPELINE_BASIC;
    this.navDelta = json['navDelta'] || 1;
    this.meshUrl = this.processUrl(json['meshUrl'], '');
    this.textureUrl = this.processUrl(json['textureUrl'], '');
    this.geodataUrl = this.processUrl(json['geodataUrl'] || json['geodata'], '');
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.textureLayer = json['textureLayer'] || null;
    this.geodata = (this.type == 'geodata' || this.type == 'geodata-tiles');
    this.credits = json['credits'] || [];
    this.creditsUrl = null;
    this.displaySize = json['displaySize'] || 1024;

    var i, li;
    
    if (json['extents']) {
        var ll = json['extents']['ll'];
        var ur = json['extents']['ur'];
        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);
    } else {
        this.extents = new BBox(0,0,0,1,1,1);
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    
    
    switch(typeof this.credits) {
    case 'string':
        this.creditsUrl = this.credits;
        this.credits = [];
        break;

    case 'object':
        
        if (!Array.isArray(this.credits)) {
            var credits = this.credits;
            this.credits = [];
                
            for (var key in credits){
                this.map.addCredit(key, new MapCredit(this.map, credits[key]));
                this.credits.push(key);
            }
        }

        for (i = 0, li = this.credits.length; i < li; i++) {
            var credit = this.map.getCreditById(this.credits[i]);
            this.creditsNumbers.push(credit ? credit.id : null); 
        }
        
        break;
    }    


    if (this.geodataUrl && (typeof this.geodataUrl === 'string') && this.geodataUrl.indexOf('{geonavtile}') != -1) {
        //this.geodataNavtileInfo = true;
        this.geodataNavtileInfo = false;
    }

    //load stylesheet
    if (this.geodata) {
        var style = json['style'];

        if (typeof this.credits === 'string') {
            style = this.processUrl(style, '');
        }

        this.originalStyle = style;
        
        if (style) {
            this.setStyle(style);
            this.originalStylesheet = this.stylesheet;
        }
    }

    this.surfaceReference = [];
    if (this.glue) {
        for (i = 0, li = this.id.length; i < li; i++) {
            this.surfaceReference.push(this.map.getSurface(this.id[i]));
        }
    }
};


MapSurface.prototype.kill = function() {
    if (this.geodataProcessor) {
        this.geodataProcessor.kill();
        this.geodataProcessor = null;
    }

    this.geodataUrl = null;
    this.style = null;
    this.stylesheet = null;
    this.originalStyle = null;
    this.originalStylesheet = null;
};


MapSurface.prototype.setOptions = function() {
};


MapSurface.prototype.getOptions = function() {
    return this.getInfo();
};


MapSurface.prototype.getInfo = function() {
    if (this.geodata) {
        return {
            'type' : this.type,
            'metaUrl' : this.metaUrl,
            'geodataUrl' : this.geodataUrl,
            'lodRange' : this.lodRange,
            'tileRange' : this.tileRange,
            'style' : this.originalStyle
        };
    } else {
        return {
            'type' : this.type,
            'metaUrl' : this.metaUrl,
            'navUrl' : this.navUrl,
            'meshUrl' : this.meshUrl,
            'textureUrl' : this.textureUrl,
            'lodRange' : this.lodRange,
            'tileRange' : this.tileRange,
            'textureLayer' : this.textureLayer
        };
    }
};


MapSurface.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    if (typeof url !== 'string') {
        return url;
    }

    url = url.trim();
    
    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url; 
    }
};


MapSurface.prototype.hasTile = function(id) {
    var shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    var x = id[1] >> shift;
    var y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapSurface.prototype.hasTile2 = function(id) {
    var shift = id[0] - this.lodRange[0];
    var above = (shift < 0);

    if (id[0] < this.lodRange[0]) {
        shift = -shift;
        var x1 = this.tileRange[0][0] >> shift;
        var y1 = this.tileRange[0][1] >> shift;
        var x2 = this.tileRange[1][0] >> shift;
        var y2 = this.tileRange[1][1] >> shift;
    
        if (id[0] > this.lodRange[1] ||
            id[1] < x1 || id[1] > x2 ||
            id[2] < y1 || id[2] > y2 ) {
            return [false , false];
        }
    } else {
        var x = id[1] >> shift;
        var y = id[2] >> shift;
    
        if (id[0] > this.lodRange[1] ||
            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return [false , false];
        }
    }

    return [true, above];
};


MapSurface.prototype.hasMetatile = function(id) {
    if (id[0] > this.lodRange[1]) {
        return false;
    }

    var shift = id[0] - this.lodRange[0];

    if (shift >= 0) {
        var x = id[1] >> shift;
        var y = id[2] >> shift;

        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return false;
        }
    } else {
        shift = -shift;

        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||
            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {
            return false;
        }
    }

    return true;
};


MapSurface.prototype.setStyle = function(style) {
    if (this.style == style) {
        return;
    }

    var id = style;

    if (typeof id !== 'object') {
        id = this.processUrl(id, '');
    } else {
        id = JSON.stringify(id);
        id = utils.getHash(id);
        id = "#obj#" + id.toString(16); 
    }
    
    this.stylesheet = this.map.getStylesheet(id);
    
    if (!this.stylesheet) {
        this.stylesheet = new MapStylesheet(this.map, id, style, this);
        this.map.addStylesheet(id, this.stylesheet); 
    } 

    this.style = style;
    this.styleChanged = true;
    this.geodataCounter++;

    //this.map.setStylesheetData(id); //force update
    
    this.map.markDirty();
};


//used only for glues
MapSurface.prototype.getSurfaceReference = function(index) {
    return this.surfaceReference[index - 1];
};


MapSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getNavUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.navUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getHMapUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.hmapUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};

MapSurface.prototype.getMeshUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.meshUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


MapSurface.prototype.getTextureUrl = function(id, subId, skipBaseUrl) {
    return this.map.url.makeUrl(this.textureUrl, {lod:id[0], ix:id[1], iy:id[2] }, subId, skipBaseUrl);
};


MapSurface.prototype.getGeodataUrl = function(id, navtileStr, skipBaseUrl) {
//    return this.map.makeUrl(this.geodataUrl + "&v=1", {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);
    return this.map.url.makeUrl(this.geodataUrl, {lod:id[0], ix:id[1], iy:id[2] }, navtileStr, skipBaseUrl);
};


MapSurface.prototype.getMonoGeodataUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.geodataUrl, {}, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["a"] = (MapSurface);



  

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__subtexture__ = __webpack_require__(53);



//get rid of compiler mess
var MapSubtexture = __WEBPACK_IMPORTED_MODULE_0__subtexture__["a" /* default */];


var MapTexture = function(map, path, type, extraBound, extraInfo, tile, internal) {
    this.map = map;
    this.stats = map.stats;
    this.tile = tile; // used only for stats
    this.internal = internal; // used only for stats
    
    if (tile) {
        this.mainTexture = tile.resources.getSubtexture(this, path, type, tile, internal); 
    } else {
        this.mainTexture = new MapSubtexture(map, path, type, tile, internal); 
    }

    this.maskTexture = null; 

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.neverReady = false;
    this.maskTexture = null;
    this.mapLoaderUrl = path;
    this.type = type || 0;
    this.extraBound = extraBound;
    this.extraInfo = extraInfo;
    this.statsCounter = 0;
    this.checkStatus = 0;
    this.checkType = null;
    this.checkValue = null;
    this.fastHeaderCheck = false;
    this.fileSize = 0;

    if (extraInfo && extraInfo.layer) {
        var layer = extraInfo.layer;
        
        if (layer.availability) {
            this.checkType = layer.availability.type;
            switch (this.checkType) {
            case 2: this.checkValue = layer.availability.mime; break;
            case 3: this.checkValue = layer.availability.codes; break;
            case 4: this.checkValue = layer.availability.size; break;
            }
        }       
    }
};


MapTexture.prototype.kill = function() {
    this.mainTexture.killImage();
    this.mainTexture.killGpuTexture();
    this.mainTexture = null;
    
    if (this.maskTexture) {
        this.maskTexture.killImage(); 
        this.maskTexture.killGpuTexture(); 
    }
};


MapTexture.prototype.killImage = function() {
    this.mainTexture.killImage();

    if (this.maskTexture) {
        this.maskTexture.killImage(); 
    }
};


MapTexture.prototype.killGpuTexture = function() {
    this.mainTexture.killGpuTexture();

    if (this.maskTexture) {
        this.maskTexture.killGpuTexture(); 
    }
};


MapTexture.prototype.setBoundTexture = function(tile, layer, hmap) {
    if (tile) {
        if (hmap) {
            this.extraBound.sourceTile = tile;
            this.extraBound.hmap = hmap;

            if (!tile.hmap) {
                var path = tile.resourceSurface.getHMapUrl(tile.id, true);
                tile.hmap = tile.resources.getTexture(path, null, null, {tile: tile, hmap: hmap}, this.tile, this.internal);
            }

            this.extraBound.texture = tile.hmap; 

        } else if (layer) {
            this.extraBound.sourceTile = tile;
            this.extraBound.layer = layer;
            
            if (!tile.boundTextures[layer.id]) {
                tile.boundLayers[layer.id] = layer;
                var path = layer.getUrl(tile.id);
                tile.boundTextures[layer.id] = tile.resources.getTexture(path, null, null, {tile: tile, layer: layer}, this.tile, this.internal);
            }

            this.extraBound.texture = tile.boundTextures[layer.id]; 
        }
        
        this.extraBound.transform = this.map.draw.drawTiles.getTileTextureTransform(tile, this.extraBound.tile);
        this.map.markDirty();
    }
};


MapTexture.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;
/*   
   if (this.mapLoaderUrl == "https://ecn.t3.tiles.virtualearth.net/tiles/a1202310323212333.jpeg?g=5549") {
       this.mapLoaderUrl = this.mapLoaderUrl;
   }
*/
    if (this.neverReady) {
        return false;
    }

    var parent;
   
    if (this.extraBound) {
        if (this.extraBound.texture) {
            while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {
//            while (this.extraBound.texture.checkStatus == -1) {
                parent = this.extraBound.sourceTile.parent;

                if (this.extraBound.hmap) {
                    if (!parent || parent.id[0] < 1) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }
                } else if (this.extraBound.layer) {
                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }
                }
 
                this.setBoundTexture(parent, this.extraBound.layer);
            }
            
            var ready = this.extraBound.texture.isReady(doNotLoad, priority, doNotCheckGpu);
            
            if (ready && this.checkMask) {
                this.extraBound.tile.resetDrawCommands = (this.extraBound.texture.getMaskTexture() != null);
                this.checkMask = false;
            }

            return ready;
            
        } else {
            this.setBoundTexture(this.extraBound.sourceTile, this.extraBound.layer, this.extraBound.hmap);        
            return this.isReady(doNotLoad, priority, doNotCheckGpu);
        }
        
        return false;
    }

    /*
    if (!this.extraBound && this.extraInfo && !this.maskTexture) {
        var layer = this.extraInfo.layer;
        
        if (layer && layer.maskUrl && this.checkType != "metatile") {
            var path = layer.getMaskUrl(this.tile.id);
            this.maskTexture = this.tile.resources.getTexture(path, null, null, null, this.tile, this.internal);
        }
    }*/

    switch (this.checkType) {
    case 1:

        if (this.checkStatus != 2) {
            if (this.checkStatus == 0) {
                if (this.extraInfo && this.extraInfo.tile) {
                    var metaresources = this.extraInfo.tile.boundmetaresources;
                    if (!metaresources) {
                        metaresources = this.map.resourcesTree.findAgregatedNode(this.extraInfo.tile.id, 8);
                        this.extraInfo.tile.boundmetaresources = metaresources;
                    }
                        
                    var layer = this.extraInfo.layer;
                    var path = this.extraInfo.metaPath;
						
                    if(!this.extraInfo.metaPath) {
                        path = layer.getMetatileUrl(metaresources.id);	
                        this.extraInfo.metaPath = path;
                    }
						
                    var texture = metaresources.getTexture(path, true, null, null, this.tile, this.internal);
                        
                    if (this.maskTexture) {
                        if (this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this)) {
                            this.checkStatus = 2;
                        }
                    } else {
                        if (texture.isReady(doNotLoad, priority, doNotCheckGpu)) {
                            var tile = this.extraInfo.tile;
                            var value = texture.getHeightMapValue(tile.id[1] & 255, tile.id[2] & 255);
                            this.checkStatus = (value & 128) ? 2 : -1;
                                
                            if (this.checkStatus == 2) {
                                if (!(value & 64)) { //load mask
                                    path = layer.getMaskUrl(tile.id);
                                    this.maskTexture = tile.resources.getTexture(path, null, null, null, this.tile, this.internal);
                                    this.checkStatus = 0;
                                }
                            }

                            tile.resetDrawCommands = true;
                            this.map.markDirty();
                        }
                    }
                }
            }
                
            if (this.checkStatus == -1) {
                if (!this.extraBound) {
                    parent = this.extraInfo.tile.parent;
                    if (parent.id[0] < this.extraInfo.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraInfo.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }

                    this.extraBound = { tile: this.extraInfo.tile, layer: this.extraInfo.layer};
                    this.setBoundTexture(this.extraBound.tile.parent, this.extraBound.layer);
                    this.checkMask = true;
                }

                while (this.extraBound.texture.extraBound || this.extraBound.texture.checkStatus == -1) {
                    //while (this.extraBound.texture.checkStatus == -1) {
                    parent = this.extraBound.sourceTile.parent;
                    if (parent.id[0] < this.extraBound.layer.lodRange[0]) {
                        this.neverReady = true;
                        this.extraBound.tile.resetDrawCommands = true;
                        this.map.markDirty();
                        return false;
                    }
                        
                    this.setBoundTexture(parent, this.extraBound.layer);        
                }
            }

            return false;
        }
        
        break;
    }

    var maskState = true;

    if (this.maskTexture) {
        maskState = this.maskTexture.isReady(doNotLoad, priority, doNotCheckGpu, this);
    }
    

    return this.mainTexture.isReady(doNotLoad, priority, doNotCheckGpu, this) && maskState;
};

MapTexture.prototype.isMaskPosible = function() {
    var texture = this;

    if (this.extraBound) {
        if (this.extraBound.texture) {
            texture = this.extraBound.texture;
        }
    }

    if (texture.checkType == 1) {
        return true;
    } else {
        return false;
    }
};

MapTexture.prototype.isMaskInfoReady = function() {
    var texture = this;

    if (this.extraBound) {
        if (this.extraBound.texture) {
            texture = this.extraBound.texture;
        }
    }

    if (texture.checkType == 1) {
        if (this.maskTexture || texture.checkStatus == 2 || texture.checkStatus ==  -1) {
            return true;
        }

        return false;
    }

    return true;
}

MapTexture.prototype.getGpuTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.texture.getGpuTexture();
        }
        return null;
    } 

    return this.mainTexture.getGpuTexture();
};


MapTexture.prototype.getMaskTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.texture.getMaskTexture();
        }
    } 

    return this.maskTexture;
};


MapTexture.prototype.getGpuMaskTexture = function() {
    if (this.extraBound) {
        if (this.extraBound.texture && this.extraBound.texture.maskTexture) {
            return this.extraBound.texture.getGpuMaskTexture();
        }
        return null;
    } 

    if (this.maskTexture) {
        return this.maskTexture.getGpuTexture();
    }
    
    return null;
};

MapTexture.prototype.getGpuSize = function() {
    return (this.mainTexture ? (this.mainTexture.gpuSize ? this.mainTexture.gpuSize : 0) : 0) + (this.maskTexture ? (this.maskTexture.gpuSize ? this.maskTexture.gpuSize : 0) : 0);
};

MapTexture.prototype.getImageData = function() {
    return this.mainTexture.imageData;
};


MapTexture.prototype.getImageExtents = function() {
    return this.mainTexture.imageExtents;
};


MapTexture.prototype.getHeightMapValue = function(x, y) {
    return this.mainTexture.getHeightMapValue(x, y);
};


MapTexture.prototype.getTransform = function() {
    if (this.extraBound) {
        if (this.extraBound.texture) {
            return this.extraBound.transform;
        }
        return null;
    } 

    return [1,1,0,0];
};


/* harmony default export */ __webpack_exports__["a"] = (MapTexture);



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapView = function(map, json, fixPaths) {
    this.map = map;
    //this.id = json["id"] || null;
    this.parse(json, fixPaths);
};


MapView.prototype.parse = function(json, fixPaths) {
    //this.description = json['description'] || '';
    //this.boundLayers = json["boundLayers"] || [];
    this.freeLayers = json['freeLayers'] || {};
    this.surfaces = {};    
    this.options = json['options'] || {};    

    if (json['surfaces']) {
        var surfaces = json['surfaces']; 
        if (Array.isArray(surfaces)) { //convert from old version
            for (var i = 0, li = surfaces.length; i < li; i++) {
                this.surfaces[surfaces[i]] = [];
            }
        } else {
            this.surfaces = surfaces;            
        }
    }

    if (!this.freeLayers || Array.isArray(this.freeLayers)) { //convert from old version
        this.freeLayers = {};
    } else {
        this.freeLayers = JSON.parse(JSON.stringify(this.freeLayers));

        if (fixPaths) {
            for (var key in this.freeLayers) {
                var layer = this.freeLayers[key];

                if (typeof layer['style'] === 'string') {
                    layer['style'] = this.processUrl(layer['style'], '');
                }
            }
        }
    }
    
    this.surfaces = JSON.parse(JSON.stringify(this.surfaces));
    this.options = JSON.parse(JSON.stringify(this.options));
};


MapView.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    if (typeof url !== 'string') {
        return url;
    }

    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.map.url.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.map.url.baseUrlOrigin + url;
    } else {  //relative
        return this.map.url.baseUrl + url; 
    }
};


MapView.prototype.getInfo = function() {
    var view = {
        //'description' : JSON.parse(JSON.stringify(this.description)),
        'surfaces' : JSON.parse(JSON.stringify(this.surfaces)),
        'freeLayers' : JSON.parse(JSON.stringify(this.freeLayers)),
        'options' : JSON.parse(JSON.stringify(this.options)),
    };

    var renderer = this.map.renderer;

    if (this.map.renderer.getSuperElevationState()) {
        var se = this.map.renderer.getSuperElevation();

        view['options'] = {
            'superelevation' : [[se[0],se[2]],[se[1],se[3]]]
        }
    }

    return view;
};


/* harmony default export */ __webpack_exports__["a"] = (MapView);



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__texture__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);




//get rid of compiler mess
var GpuTexture = __WEBPACK_IMPORTED_MODULE_0__texture__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];


var GpuFont = function(gpu, core, font, size, path) {
    this.bbox = null;
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.core = core;

    this.data = null;
    this.path = path;

    this.texture = {width:256, height:256}; //hack

    this.textures = [];
    this.images = [];
    this.ready = false;    
    this.version = 1;    

    this.load(path);
};


//destructor
GpuFont.prototype.kill = function() {
};

// Returns GPU RAM used, in bytes.
GpuFont.prototype.getSize = function(){ return this.size; };


GpuFont.prototype.load = function(path) {
    utils.loadBinary(path, this.onLoaded.bind(this), this.onError.bind(this));
};

GpuFont.prototype.onLoaded = function(data) {
    this.data = data;
    this.ready = true;    
    this.core.markDirty();
};

GpuFont.prototype.isReady = function() {
    return this.ready;
};

GpuFont.prototype.onError = function() {

};

GpuFont.prototype.onFileLoaded = function(index, data) {
    this.core.markDirty();
    this.textures[index].createFromData(256, 256, new Uint8Array(data), 'linear');
};

GpuFont.prototype.onFileLoadError = function() {
};

GpuFont.prototype.areTexturesReady = function(files) {
    var ready = true;
    for (var i = 0, li = files.length; i < li; i++) {
        var index = files[i];//Math.round( (planes[i] - (planes[i] % 3)) );

        if (!this.textures[index]) {
            utils.loadBinary(this.path + (index+2), this.onFileLoaded.bind(this, index), this.onFileLoadError.bind(this));
            this.textures[index] = new GpuTexture(this.gpu, null, this.core);
            ready = false;
        } else {
            ready = (ready && this.textures[index].loaded);
        }
    }

    return ready;
};

GpuFont.prototype.getTexture = function(file) {
    //if (!this.textures[file]) {
        //debugger;
    //}

    return this.textures[file];
};

/* harmony default export */ __webpack_exports__["a"] = (GpuFont);




/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var GpuShaders = {};

GpuShaders.bboxVertexShader =
    'attribute vec3 aPosition;\n'+
    'uniform mat4 uMVP;\n'+
    'void main(){ \n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
    '}';


GpuShaders.bbox2VertexShader =
    'attribute vec3 aPosition;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform float uPoints[8*3];\n'+
    'void main(){ \n'+
        'int index = int(aPosition.z) * 3; \n'+
        'gl_Position = uMVP * vec4(uPoints[index], uPoints[index+1], uPoints[index+2], 1.0);\n'+
    '}';


GpuShaders.bboxFragmentShader = 'precision mediump float;\n'+
    'void main() {\n'+
        'gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n'+
    '}';

GpuShaders.text2VertexShader =
    'attribute vec4 aPosition;\n'+
    'void main(){ \n'+
    '}';


GpuShaders.lineVertexShader = //line
    '#ifndef dataPoints2\n'+
        'uniform mat4 uMVP;\n'+
    '#else\n'+
        'uniform mat4 uMV, uProj;\n'+
    '#endif\n'+

    '#ifdef pixelLine\n'+
        '#ifdef dataPoints2\n'+
            'attribute vec3 aPosition;\n'+
        '#else\n'+
            'attribute vec4 aPosition;\n'+
            'attribute vec4 aNormal;\n'+
        '#endif\n'+

        '#ifdef dataPoints\n'+
            'uniform vec3 uScale;\n'+
            'uniform vec3 uPoints[32];\n'+
        '#else\n'+
            'uniform vec2 uScale;\n'+
        '#endif\n'+

        '#ifdef dataPoints2\n'+

        'vec4 getClippedPixelLinePoint(vec3 p1, vec3 p2, vec3 params) {\n'+
            'vec2 pp1, pp2, n;\n'+
            'vec4 wp0 = (uMV * vec4(p1.xyz, 1.0)), pp0, pp3;\n'+
            'float near = gl_DepthRange.near + 0.1;\n'+
            //'float near = gl_DepthRange.near + 0.1 + 30000.0;\n'+
            'if (params.y < 0.0) {\n'+
                //'return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                'if (wp0.z > -near) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                'pp0 = uProj * wp0;\n'+
                'if (params.y == -1.0) return pp0;\n'+
                'return pp0 + vec4((vec3(-sin(params.z)*uScale.x*uScale.z*pp0.w, cos(params.z)*uScale.y*uScale.z*pp0.w, 0.0)), 0.0);\n'+
            '} else {\n'+
                'vec3 p2 = uPoints[int(params.y)];\n'+
                'vec4 wp3 = (uMV * vec4(p2.xyz, 1.0));\n'+
                'if (wp0.z > -near) {\n'+
                    'vec3 dir = (wp3.xyz - wp0.xyz);\n'+
                    'float l = length(dir);\n'+
                    'dir = normalize(dir);\n'+
                    'float denominator = -dir.z;\n'+
                    'if (abs(denominator) < 0.0000001) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    'float t = (near + wp0.z) / denominator;\n'+
                    'if (t < 0.0 || t > l) return vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    'wp0.xyz = wp0.xyz + (dir * t);\n'+
                '}\n'+
                'pp0 = uProj * wp0;\n'+
                'pp3 = uProj * wp3;\n'+
                'pp1 = pp0.xy / pp0.w;\n'+
                'pp2 = pp3.xy / pp3.w;\n'+
                //'pp1 = pp0.xy;\n'+
                //'pp2 = pp3.xy;\n'+
                'n = normalize(pp2 - pp1);\n'+
                'return pp0 + vec4((vec3(-n.y*uScale.x*params.z*uScale.z*pp0.w, n.x*uScale.y*params.z*uScale.z*pp0.w, 0.0)), 0.0);\n'+
            '}\n'+
        '}\n'+

        '#endif\n'+

    '#else\n'+

        '#ifdef lineLabel2\n'+

            'attribute vec2 aPosition;\n'+
            'uniform vec4 uData[DSIZE];\n'+
            'uniform float uFile;\n'+
            'varying vec2 vTexCoord;\n'+

        '#else\n'+

            '#ifdef lineLabel\n'+
                'attribute vec4 aPosition;\n'+
                'attribute vec4 aTexCoord;\n'+
                'uniform vec4 uVec;\n'+
                'uniform float uFile;\n'+
                'varying vec2 vTexCoord;\n'+
            '#else\n'+
                'attribute vec3 aPosition;\n'+
            '#endif\n'+

            '#ifdef dynamicWidth\n'+
                'attribute vec4 aNormal;\n'+
                'uniform vec4 uParams;\n'+
            '#endif\n'+

        '#endif\n'+

    '#endif\n'+

    '#ifdef applySE\n'+
        'uniform mat4 uParamsSE;\n'+
    '#endif\n'+

    '#ifdef withElements\n'+
        'attribute float aElement;\n'+
        'varying float vElement;\n'+
    '#endif\n'+


    'void main() {\n'+

        '#ifdef withElements\n'+
            'vElement = aElement;\n'+
        '#endif\n'+

        '#ifdef dataPoints\n'+
            'vec3 p1 = uPoints[int(aPosition.x)];\n'+
        '#else \n'+
            '#ifndef lineLabel2\n'+
                'vec3 p1 = aPosition.xyz;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef pixelLine\n'+
            '#ifndef dataPoints\n'+
                'vec3 p2 = aNormal.xyz;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef applySE\n'+
            'vec3 geoPos2 = p1.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
            'geoPos.z *= uParamsSE[3][3];\n'+
            'float ll = length(geoPos);\n'+
            'vec3 v = geoPos * (1.0/(ll+0.0001));\n'+
            'float h = ll - uParamsSE[3][2];\n'+
            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
            'float h3 = h;\n'+
            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
            'geoPos2.xyz += v * (h - h3);\n'+

            '#ifdef pixelLine\n'+

                'vec4 pp0 = uMVP * vec4(geoPos2, 1.0);\n'+

                'if (aNormal.w == 0.0) {\n'+
                    'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n'+
                '} else {\n'+
                    'geoPos2 = p2.xyz*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
                    'geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
                    'geoPos.z *= uParamsSE[3][3];\n'+
                    'll = length(geoPos);\n'+
                    'v = geoPos * (1.0/(ll+0.0001));\n'+
                    'h = ll - uParamsSE[3][2];\n'+
                    'h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
                    'h3 = h;\n'+
                    'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
                    'geoPos2.xyz += v * (h - h3);\n'+

                    'vec4 pp3 = uMVP * vec4(geoPos2, 1.0);\n'+
                    'vec2 pp1 = pp0.xy / pp0.w;\n'+
                    'vec2 pp2 = pp3.xy / pp3.w;\n'+
                    'vec2 n = normalize(pp2 - pp1);\n'+
                    'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
                '}\n'+

            '#else\n'+

                '#ifdef lineLabel\n'+

                    'vTexCoord = aTexCoord.xy;\n'+
                    'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\n'+
                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    '}else{\n'+
                        'float file = floor(aTexCoord.y/4.0);\n'+
                        'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
                        'if (file != floor(uFile)) {\n'+
                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                        '}else{\n'+
                            'gl_Position = uMVP * vec4(geoPos2, 1.0);\n'+
                        '}\n'+
                    '}\n'+

                '#else\n'+

                    'gl_Position = uMVP * vec4(geoPos2, 1.0);\n'+

                '#endif\n'+

            '#endif\n'+

        '#else\n'+

            '#ifdef pixelLine\n'+

                '#ifdef dataPoints2\n'+

                    'vec3 p2 = uPoints[int(aPosition.y)];\n'+
                    'gl_Position = getClippedPixelLinePoint(p1.xyz, p2.xyz, aPosition.xyz);\n'+

                '#else\n'+

                    'vec4 pp0 = (uMVP * vec4(p1.xyz, 1.0));\n'+

                    '#ifdef dataPoints\n'+

                        'if (aPosition.y < 0.0) {\n'+
                            'if (aPosition.y == -1.0) {\n'+
                                'gl_Position = pp0;\n'+
                            '} else {\n'+
                                'gl_Position = pp0 + vec4((vec3(-sin(aPosition.z)*uScale.x*uScale.z, cos(aPosition.z)*uScale.y*uScale.z, 0.0)), 0.0);\n'+
                            '}\n'+
                        '} else {\n'+
                            'vec3 p2 = uPoints[int(aPosition.y)];\n'+
                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\n'+
                            'vec2 pp1 = pp0.xy / pp0.w;\n'+
                            'vec2 pp2 = pp3.xy / pp3.w;\n'+
                            'vec2 n = normalize(pp2 - pp1);\n'+
                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aPosition.z*uScale.z, n.x*uScale.y*aPosition.z*uScale.z, 0.0)), 0.0);\n'+
                        '}\n'+

                    '#else\n'+

                        'if (aNormal.w == 0.0) {\n'+
                            'gl_Position = pp0 + vec4((vec3(aNormal.x*uScale.x*pp0.w, aNormal.y*uScale.y*pp0.w, 0.0)), 0.0);\n'+
                        '} else {\n'+
                            'vec4 pp3 = (uMVP * vec4(p2.xyz, 1.0));\n'+
                            'vec2 pp1 = pp0.xy / pp0.w;\n'+
                            'vec2 pp2 = pp3.xy / pp3.w;\n'+
                            'vec2 n = normalize(pp2 - pp1);\n'+
                            'gl_Position = pp0 + vec4((vec3(-n.y*uScale.x*aNormal.w*pp0.w, n.x*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
                        '}\n'+

                    '#endif\n'+

                '#endif\n'+

            '#else\n'+

                '#ifdef lineLabel2\n'+

                    'int index = int(aPosition.x) * 3;\n'+
                    'vec4 data = uData[index];\n'+
                    'vec4 data2 = uData[index+1];\n'+
                    'vec4 data3 = uData[index+2];\n'+

                    'vec3 pos = vec3(data[0],data[1],data[2]);\n'+
                    'vec4 q = vec4(data[3],data2[0],data2[1],data2[2]);\n'+
                    'vec2 factor = vec2(data2[3],data3[0]);\n'+
                    'vec2 uv = vec2(data3[1],data3[2]);\n'+
                    'float duv = data3[3];\n'+
//                    'vec3 up = vec3(1.0,0.0,0.0);\n'+
  //                  'vec3 right = vec3(0.0,1.0,0.0);\n'+

                    //get up, right vectors from quaternion
                    'float x=q[0], y=q[1], z=q[2], w=q[3];\n'+
                    'float x2=x+x, y2=y+y, z2=z+z, xx=x*x2, yx=y*x2, yy=y*y2;\n'+
                    'float zx=z*x2, zy=z*y2, zz=z*z2, wx=w*x2, wy=w*y2, wz=w*z2;\n'+

                    'vec3 right = vec3(1.0-yy-zz, yx-wz, zx+wy) * factor.x;\n'+
                    'vec3 up = vec3(yx+wz, 1.0-xx-zz, zy-wx) * (-factor.y);\n'+

                    /*
                      out[0] = 1 - yy - zz;
                      out[3] = yx - wz;
                      out[6] = zx + wy;
                      out[1] = yx + wz;
                      out[4] = 1 - xx - zz;
                      out[7] = zy - wx;
                      out[2] = zx - wy;
                      out[5] = zy + wx;
                      out[8] = 1 - xx - yy;
                    */

                    'float file = floor(uv.y/4.0);\n'+
                    'uv.y = (uv.y-file*4.0);\n'+

                    'int corner = int(aPosition.y);\n'+
                    'if (corner==1){ pos+=right; uv.x+=floor(duv)*(1.0/1024.0);  }\n'+
                    'if (corner==2){ pos+=right; pos+=up; uv.x+=floor(duv)*(1.0/1024.0); uv.y+=fract(duv); }\n'+
                    'if (corner==3){ pos+=up; uv.y+=fract(duv); }\n'+

                    'vTexCoord = uv;\n'+

                    'if (file != floor(uFile)) {\n'+
                        'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                    '}else{\n'+
                        'gl_Position = uMVP * vec4(pos.xyz, 1.0);\n'+
                    '}\n'+

                '#else\n'+

                    '#ifdef lineLabel\n'+

                        'vTexCoord = aTexCoord.xy;\n'+
                        'if (dot(uVec.xyz, vec3(aTexCoord.z, aTexCoord.w, aPosition.w)) < 0.0) {\n'+
                            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                        '}else{\n'+
                            'float file = floor(aTexCoord.y/4.0);\n'+
                            'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
                            'if (file != floor(uFile)) {\n'+
                                'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
                            '}else{\n'+
                                'gl_Position = uMVP * vec4(aPosition.xyz, 1.0);\n'+
                            '}\n'+
                        '}\n'+

                    '#else\n'+

                        '#ifdef dynamicWidth\n'+
                            'gl_Position = uMVP * vec4(aPosition.xyz + aNormal.xyz*(abs(aNormal.w)*uParams[3]), 1.0);\n'+
                        '#else\n'+
                            'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
                        '#endif\n'+

                    '#endif\n'+

                '#endif\n'+

            '#endif\n'+

        '#endif\n'+
        
    '}';


GpuShaders.lineFragmentShader = 'precision mediump float;\n'+ //line

    'uniform vec4 uColor;\n'+

    '#ifdef withElements\n'+
        'varying float vElement;\n'+
    '#endif\n'+

    'void main() {\n'+

        '#ifdef withElements\n'+
            'gl_FragColor.xyz = fract(vec3(1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vElement) + (-0.5/255.0);\n'+
            'gl_FragColor.w = 1.0;\n'+
        '#else\n'+
            'gl_FragColor = uColor;\n'+
        '#endif\n'+

    '}';

GpuShaders.tlineVertexShader = // textured line
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vec4 p=vec4(aPosition.xyz, 1.0);\n'+
        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\n'+
        'if (aNormal.w < 0.0){\n'+
            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], (uParams[1]+uParams[2])*0.5);\n'+
        '} else {\n'+
            'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n'+
        '}\n'+

        'gl_Position = uMVP * p;\n'+
    '}';


GpuShaders.etlineVertexShader = // textured line elements
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'attribute float aElement;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying float vElement;\n'+
    'void main(){ \n'+
        'vec4 p=vec4(aPosition.xyz, 1.0);\n'+
        'p.xyz+=aNormal.xyz*(abs(aNormal.w)*uParams[3]);\n'+
        'vElement = aElement;\n'+
        'gl_Position = uMVP * p;\n'+
    '}';

GpuShaders.tplineVertexShader = // textured pixel line
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n'+
        'vTexCoord=vec2(abs(aPosition.w)*uParams[0], aPosition.w < 0.0 ? uParams[1] : uParams[2]);\n'+
        'if (aNormal.w == 0.0) {\n'+
            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\n'+
        '} else {\n'+
            'vec2 pp1 = pp0.xy / pp0.w;\n'+
            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n'+
            'vec2 pp2 = pp3.xy / pp3.w;\n'+
            'vec2 n = normalize(pp2 - pp1);\n'+
            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
        '}\n'+
    '}';

GpuShaders.etplineVertexShader = // textured pixel line elements
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aNormal;\n'+
    'attribute float aElement;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec2 uScale;\n'+
    'uniform vec4 uParams;\n'+
    'varying float vElement;\n'+
    'void main(){ \n'+
        'vec4 pp0 = (uMVP * vec4(aPosition.xyz, 1.0));\n'+
        'vElement = aElement;\n'+
        'if (aNormal.w == 0.0) {\n'+
            'gl_Position = pp0 + vec4((vec3(aNormal.x*uParams[3]*uScale.x*pp0.w, aNormal.y*uParams[3]*uScale.y*pp0.w, 0.0)), 0.0);\n'+
        '} else {\n'+
            'vec2 pp1 = pp0.xy / pp0.w;\n'+
            'vec4 pp3 = (uMVP * vec4(aNormal.xyz, 1.0));\n'+
            'vec2 pp2 = pp3.xy / pp3.w;\n'+
            'vec2 n = normalize(pp2 - pp1);\n'+
            'gl_Position = pp0 + vec4((vec3(-n.y*uParams[3]*uScale.x*aNormal.w*pp0.w, n.x*uParams[3]*uScale.y*aNormal.w*pp0.w, 0.0)), 0.0);\n'+
        '}\n'+
    '}';

GpuShaders.tlineFragmentShader = 'precision mediump float;\n'+ // textured line
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec4 uColor2;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c=texture2D(uSampler, vTexCoord)*uColor;\n'+
        'gl_FragColor = c;\n'+
    '}';


GpuShaders.tblineFragmentShader = 'precision mediump float;\n'+  // textured line with background color
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec4 uColor2;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c1=texture2D(uSampler, vTexCoord)*uColor;\n'+
        'vec4 c2=uColor2,c=c1;\n'+
        'c.xyz*=c.w; c2.xyz*=c2.w;\n'+
        'c=mix(c,c2,1.0-c.w);\n'+
        'c.xyz/=(c.w+0.00001);\n'+
        'c.w=max(c1.w,c2.w);\n'+
        'gl_FragColor = c;\n'+
    '}';


GpuShaders.polygonVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec3 aNormal;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform mat4 uRot;\n'+
    'uniform vec4 uColor;\n'+
    'varying vec4 vColor;\n'+
    'void main(){ \n'+
        'float l = dot((uRot*vec4(aNormal,1.0)).xyz, vec3(0.0,0.0,1.0)) * 0.5;\n'+
        'vec3 c = uColor.xyz;\n'+
        'c = (l > 0.0) ? mix(c,vec3(1.0,1.0,1.0),l) : mix(vec3(0.0,0.0,0.0),c,1.0+l);\n'+
        'vColor = vec4(c, uColor.w);\n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
    '}';


GpuShaders.polygonFragmentShader = 'precision mediump float;\n'+
    'varying vec4 vColor;\n'+
    'void main() {\n'+
        'gl_FragColor = vColor;\n'+
    '}';


GpuShaders.iconVertexShader =
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aTexCoord;\n'+
    'attribute vec3 aOrigin;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec4 uScale;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'vTexCoord = aTexCoord.xy * uScale[2];\n'+
        'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\n'+
        'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\n'+
    '}';

GpuShaders.icon2VertexShader =
    'attribute vec4 aPosition;\n'+
    'attribute vec4 aTexCoord;\n'+
    'attribute vec3 aOrigin;\n'+
    'uniform mat4 uMVP;\n'+
    'uniform vec4 uScale;\n'+
    'uniform float uFile;\n'+
    'varying vec2 vTexCoord;\n'+
    //'float round(float x) { return floor(x + 0.5); }\n'+
    'void main(){ \n'+
        'vTexCoord = aTexCoord.xy * uScale[2];\n'+
        'float file = floor(aTexCoord.y/4.0);\n'+
        'vTexCoord.y = mod(aTexCoord.y,4.0);\n'+
        'if (file != floor(uFile)) {\n'+
            'gl_Position = uMVP * vec4(8.0, 0.0, 0.0, 1.0);\n'+
        '}else{\n'+
            'vec4 pos = (uMVP * vec4(aOrigin, 1.0));\n'+
            //'pos.x = (floor((pos.x/pos.w)*800.0+0.5)/800.0)*pos.w;\n'+
            //'pos.y = (floor((pos.y/pos.w)*410.0+0.5)/410.0)*pos.w;\n'+
            'gl_Position = pos + vec4(aPosition.x*uScale.x*pos.w, (aPosition.y+uScale.w)*uScale.y*pos.w, 0.0, 0.0);\n'+
        '}'+
    '}';


GpuShaders.icon3VertexShader =
    'attribute vec2 aPosition;\n'+
    'uniform mat4 uProjectionMatrix;\n'+
    'uniform vec4 uScale;\n'+
    'uniform vec3 uOrigin;\n'+
    'uniform vec4 uData[DSIZE];\n'+
    'uniform float uFile;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'int index = int(aPosition.x);\n'+
        'vec4 data = uData[index];\n'+
        'vec4 data2 = uData[index+1];\n'+
        'vec4 v;\n'+
        'int corner = int(aPosition.y);\n'+
        'if (corner==0) v = vec4(data.x, data.y, data2.x, data2.y);\n'+
        'if (corner==1) v = vec4(data.z, data.y, data2.z, data2.y);\n'+
        'if (corner==2) v = vec4(data.z, data.w, data2.z, data2.w);\n'+
        'if (corner==3) v = vec4(data.x, data.w, data2.x, data2.w);\n'+
        'vTexCoord = vec2(v.z, v.w);\n'+
        'float file = floor(v.w/4.0);\n'+
        //'vTexCoord.y = mod(v.w,4.0);\n'+
        'vTexCoord.y = (v.w-file*4.0);\n'+

        'if (file != floor(uFile)) {\n'+
            'gl_Position = uProjectionMatrix * vec4(2.0, 0.0, 0.0, 2.0);\n'+
        '}else{\n'+
            'vec4 pos = (uProjectionMatrix * vec4(uOrigin.xyz, 1.0));\n'+
            'gl_Position = pos + vec4(v.x*uScale.x*pos.w, v.y*uScale.y*pos.w, 0.0, 0.0);\n'+
        '}'+
    '}';

GpuShaders.textFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'vec4 c=texture2D(uSampler, vTexCoord);\n'+
        'if(c.w < 0.01){ discard; }\n'+
        'gl_FragColor = c*uColor;\n'+
    '}';

GpuShaders.text2FragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uColor;\n'+
    'uniform vec2 uParams;\n'+
    'varying vec2 vTexCoord;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+

    'void main() {\n'+
        'vec2 uv=(vTexCoord);\n'+
        'uv.y=fract(uv.y);\n'+
        'vec4 c=texture2D(uSampler, uv);\n'+

        'float r = 0.0;\n'+
        'int i=int(floor(vTexCoord.y));\n'+

        'if (i == 0) r=c.x;else\n'+
        'if (i == 1) r=c.y;else\n'+
        'if (i == 2) r=c.z;else\n'+
        'if (i == 3) r=c.w;\n'+
        
        'float u_buffer = uParams[0];\n'+
        'float u_gamma = uParams[1];\n'+
        'float alpha = uColor.a * smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, r);\n'+

        //'gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n'+

        'if(alpha < 0.01){ discard; }\n'+
        'gl_FragColor = vec4(uColor.rgb, alpha);\n'+
    '}';

GpuShaders.skydomeVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMVP;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main(){ \n'+
        'gl_Position = uMVP * vec4(aPosition, 1.0);\n'+
        'vTexCoord = aTexCoord;\n'+
    '}';


GpuShaders.skydomeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'varying vec2 vTexCoord;\n'+
    'const vec4 gray = vec4(0.125, 0.125, 0.125, 1.0);\n'+
    'void main() {\n'+
        'float fade = smoothstep(0.51, 0.55, vTexCoord.t);\n'+
        'gl_FragColor = mix(texture2D(uSampler, vTexCoord), gray, fade);\n'+
    '}';


GpuShaders.stardomeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'varying vec2 vTexCoord;\n'+
    'void main() {\n'+
        'gl_FragColor = texture2D(uSampler, vTexCoord);\n'+
    '}';


GpuShaders.atmoVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform mat3 uNorm;\n'+
    'varying vec3 vNormal;\n'+
    'varying vec4 vPosition;\n'+
    'void main(){ \n'+
        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'vec4 c = uMV * vec4(aPosition, 1.0);\n'+
        'vNormal = (aPosition.xyz - vec3(0.5));\n'+
        'vPosition = camSpacePos;\n'+
    '}';


GpuShaders.atmoFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams;\n'+       //[radius, atmoSize, 0 ,0]
    'uniform vec4 uParams2;\n'+       //[radius, atmoSize, 0 ,0]
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform vec4 uFogColor;\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'uniform vec4 uFogColor2;\n'+ //= vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'float l = dot(normalize(vNormal),-uParams2.xyz);\n'+
        'l = (1.0-pow(abs(l),uParams.x));\n'+
        'vec4 c = mix(uFogColor2, uFogColor, l);\n'+
        'gl_FragColor = vec4(c.xyz, c.w*l);\n'+
    '}';


GpuShaders.atmoFragmentShader2 = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uNFactor;\n'+
    'uniform vec2 uRadius;\n'+
    'uniform vec3 uPos;\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform vec4 uFogColor;\n'+ //= vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vPosition.xyz);\n'+
        'vec3 diff = uPos;\n'+
        'float a = dot(ldir, ldir);\n'+
        'float b = 2 * dot(ldir, diff);\n'+
        'float c = dot(diff, diff) - (uRadius[0] * uRadius[0]);\n'+
        'float i = 0;\n'+
        'float discr = b * b - 4 * a * c;\n'+
        'if (discr > 0.0) {}\n'+

        '}\n'+
        'gl_FragColor = uFogColor;\n'+
    '}';


GpuShaders.atmoVertexShader3 =
    'attribute vec3 aPosition;\n'+
    //'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    //"uniform mat3 uNorm;\n"+
    'uniform vec4 uParams;\n'+       //[surfaceRadius, surfaceRadius, strech ,safetyfactor]
    'uniform vec4 uParams2;\n'+       //[cameraPos, 1]

    'varying vec2 vTexcoords;\n'+

    'void main(){ \n'+
        'gl_Position = uProj * (uMV * vec4(aPosition, 1.0));\n'+

        'vec3 position = (aPosition.xyz - vec3(0.5)) * vec3(uParams.w * 2.0);\n'+
        'vec4 camPos = uParams2;\n'+
        'float SurfaceRadius = uParams.x;\n'+ 
        'float AtmosphereRadius = uParams.y;\n'+ 
        'float StretchAmt = uParams.z;\n'+ 
     
        'float camHeight = length(camPos.xyz);\n'+
        'vec3 camToPos = position - camPos.xyz;\n'+
        'float farDist = length(camToPos);\n'+
    
        // get distance to surface horizon
        'float altitude = max(0.0,camHeight - SurfaceRadius);\n'+
        'float horizonDist = sqrt((altitude*altitude) + (2.0 * SurfaceRadius * altitude));\n'+
        'float maxDot = horizonDist / camHeight;\n'+
     
        // get distance to atmosphere horizon - use max(0,...) because we can go into the atmosphere
        'altitude = max(0.0,camHeight - AtmosphereRadius);\n'+
        'horizonDist = sqrt((altitude*altitude) + (2.0 * AtmosphereRadius * altitude));\n'+
     
        // without this, the shift between inside and outside atmosphere is  jarring
        'float tweakAmount = 0.1;\n'+
        'float minDot = max(tweakAmount,horizonDist / camHeight);\n'+
     
        // scale minDot from 0 to -1 as we enter the atmosphere
        'float minDot2 = ((camHeight - SurfaceRadius) * (1.0 / (AtmosphereRadius  - SurfaceRadius))) - (1.0 - tweakAmount);\n'+
        'minDot = min(minDot, minDot2);\n'+
      
        // get dot product of the vertex we're looking out
        'float posDot = dot(camToPos / farDist,-camPos.xyz / camHeight) - minDot;\n'+
     
        // calculate the height from surface in range 0..1
        'float height = posDot * (1.0 / (maxDot - minDot));\n'+
    
        'vTexcoords.y = height;\n'+ 
     
        'height -= min(0.0,minDot2 + ((1.0 + StretchAmt) * minDot2));\n'+
        'vTexcoords.x = height;\n'+
    '}';


GpuShaders.atmoFragmentShader3 = 'precision mediump float;\n'+
    'varying vec2 vTexcoords;\n'+
    'uniform vec4 uParams3;\n'+       //[treshold, mutiplier, 0,0]
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'uniform vec4 uFogColor2;\n'+ // = vec4(72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0);\n'+
    'const vec4 fogColor3 = vec4(0.0/255.0, 0.0/255.0, 0.0/255.0, 1.0);\n'+

    'void main() {\n'+
        'float l = vTexcoords.y;\n'+
        'if (l > uParams3.z){ discard; } else {\n'+
            'float l2 = clamp((l*l)*0.9+0.1, 0.0, 1.5);\n'+
            'vec4 c = mix(uFogColor2, uFogColor, l2);\n'+
            'gl_FragColor = vec4(c.xyz, c.w*l);\n'+
        
            'if (l > uParams3.x){ gl_FragColor.xyz = mix(gl_FragColor.xyz, fogColor3.xyz, (l-uParams3.x)*uParams3.y); }\n'+
        '}'+

    '}';


//heightmap tile
GpuShaders.heightmapVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform float uFogDensity;\n'+
    'uniform mat4 uGridMat;\n'+
    'uniform float uGridStep1, uGridStep2;\n'+
    'const int HMSize = 5;\n'+
    'const float HMSize1 = float(HMSize-1);\n'+
    'uniform float uHeight[HMSize*HMSize];\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+
    'void main() {\n'+
        'vec3 pos = aPosition;\n'+
        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n'+
        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uFogDensity * camDist);\n'+
        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n'+
        'vTexCoord1 = aTexCoord;\n'+
        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n'+
        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n'+
    '}';


GpuShaders.heightmapFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uGridBlend;\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec4 gridColor = mix(texture2D(uSampler, vTexCoord1), texture2D(uSampler, vTexCoord2), uGridBlend);\n'+
        'gl_FragColor = mix(uFogColor, gridColor, vFogFactor);\n'+
    '}';


//depth encoded heightmap tile
GpuShaders.heightmapDepthVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform float uFogDensity;\n'+
    'uniform mat4 uGridMat;\n'+
    'uniform float uGridStep1, uGridStep2;\n'+
    'const int HMSize = 5;\n'+
    'const float HMSize1 = float(HMSize-1);\n'+
    'uniform float uHeight[HMSize*HMSize];\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vDepth;\n'+
    'float round(float x) { return floor(x + 0.5); }\n'+
    'void main() {\n'+
        'vec3 pos = aPosition;\n'+
        'float z = uHeight[int(round(pos.y*HMSize1)*float(HMSize) + round(pos.x*HMSize1))];\n'+
        'vec4 camSpacePos = uMV * vec4(pos.xy, z, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vDepth = camDist;\n'+
        'vec4 gridCoord = uGridMat * vec4(pos, 1.0);\n'+
        'vTexCoord1 = aTexCoord;\n'+
        'vTexCoord1 = gridCoord.xy * vec2(uGridStep1);\n'+
        'vTexCoord2 = gridCoord.xy * vec2(uGridStep2);\n'+
    '}';


GpuShaders.heightmapDepthFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform float uGridBlend;\n'+
    'varying vec2 vTexCoord1;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vDepth;\n'+
    'void main() {\n'+
        'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
    '}';

GpuShaders.quadPoint = 
    'vec3 quadPoint(int i1, int i2, int i3, float t, float t2) {\n'+
        'float p1x = uPoints[i1], p1y = uPoints[i1+1], p1z = uPoints[i1+2];\n'+
        'float p3x = uPoints[i3], p3y = uPoints[i3+1], p3z = uPoints[i3+2];\n'+
        'float p2x = 2.0*uPoints[i2]-p1x*0.5-p3x*0.5;\n'+
        'float p2y = 2.0*uPoints[i2+1]-p1y*0.5-p3y*0.5;\n'+
        'float p2z = 2.0*uPoints[i2+2]-p1z*0.5-p3z*0.5;\n'+
        'return vec3(t2*t2*p1x+2.0*t2*t*p2x+t*t*p3x, t2*t2*p1y+2.0*t2*t*p2y+t*t*p3y, t2*t2*p1z+2.0*t2*t*p2z+t*t*p3z); }\n';
 
GpuShaders.planeVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform vec4 uParams;\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]
    'uniform vec4 uParams3;\n'+    //[px, py, sx, sy]
    'uniform float uPoints[9*3];\n'+

    '#ifndef poles\n'+
        'uniform vec3 uVector;\n'+  
        'uniform float uHeights[9];\n'+
    '#endif\n'+

    'varying vec2 vTexCoord;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying float vFogFactor;\n'+ GpuShaders.quadPoint + 

    '#ifndef poles\n'+
        'float linearHeight(float x, float y) {\n'+
            'int ix = int(x);\n'+
            'int iy = int(y);\n'+
            'int index = (2-iy)*3+ix;\n'+
            'int index2 = (2-(iy+1))*3+ix;\n'+
            'float fx = fract(x);\n'+
            'float fy = fract(y);\n'+
            'float w0 = (uHeights[index] + (uHeights[index+1] - uHeights[index])*fx);\n'+
            'float w1 = (uHeights[index2] + (uHeights[index2+1] - uHeights[index2])*fx);\n'+
            'return (w0 + (w1 - w0)*fy);\n'+
        '}\n'+
    '#endif\n'+

    'void main() {\n'+
        'vec3 indices = aPosition;\n'+
        'float t = aPosition.y * uParams[2];\n'+  //vertical index
        'float tt = t;\n'+
        'float t2 = (1.0-t);\n'+
        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\n'+
        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\n'+
        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\n'+
        't = aPosition.x * uParams[2];\n'+  //horizontal index
        'float tt2 = t;\n'+
        't2 = (1.0-t);\n'+
        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\n'+
        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\n'+
        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\n'+
        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\n'+

        '#ifndef poles\n'+
            '#ifndef flat\n'+
                'p.xyz += uVector * linearHeight(tt*2.0, tt2*2.0);\n'+
            '#endif\n'+
        '#endif\n'+

        'vec4 camSpacePos = uMV * p;\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+

        '#ifdef depth\n'+
            'vFogFactor = camDist;\n'+
        '#else\n'+
            'vFogFactor = exp(uParams[1] * camDist);\n'+
        '#endif\n'+

        'vec2 uv;\n'+
        'uv.x = aTexCoord.y * uParams3[2] + uParams3[0];\n'+
        'uv.y = (1.0-aTexCoord.x) * uParams3[3] + uParams3[1];\n'+
        'vTexCoord = uv;\n'+
        'vTexCoord2 = p.xy;\n'+
    '}';

GpuShaders.planeFragmentShader = 'precision mediump float;\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams2;\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]

    '#ifdef poles\n'+
        'uniform vec4 uParams4;\n'+    //[pole-x, pole-y, pole-radius, 0]
        'varying vec2 vTexCoord2;\n'+
    '#endif\n'+

    'varying vec2 vTexCoord;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        '#ifdef poles\n'+
            'if (length(uParams4.xy - vTexCoord2.xy) > uParams4.z){ discard; }\n'+ 
        '#endif\n'+

        '#ifdef depth\n'+
            'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vFogFactor) + (-0.5/255.0);\n'+
        '#else\n'+
            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\n'+
            'gl_FragColor = mix(uFogColor, c, vFogFactor);\n'+
        '#endif\n'+
    '}';

GpuShaders.getHFNormal =
    'vec3 getHFNormal(vec2 uv, float texelSize, float heightDelta) {\n'+
        'vec4 h;\n'+
        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\n'+
        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\n'+
        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\n'+
        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\n'+
        'return normalize(vec3(h[1] - h[2], h[3] - h[0], 2.0));}\n';

GpuShaders.getHFNormal2 =
    'vec2 getHFNormal2(vec2 uv, float texelSize, float heightDelta) {\n'+
        'vec4 h;\n'+
        'h[0] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0,-1.0))).r * heightDelta;\n'+
        'h[1] = texture2D(uSampler2, uv + (texelSize * vec2(-1.0, 0.0))).r * heightDelta;\n'+
        'h[2] = texture2D(uSampler2, uv + (texelSize * vec2( 1.0, 0.0))).r * heightDelta;\n'+
        'h[3] = texture2D(uSampler2, uv + (texelSize * vec2( 0.0, 1.0))).r * heightDelta;\n'+
        'return vec2(h[1] - h[2], h[3] - h[0]);}\n';

GpuShaders.planeVertex4Shader =
    '#define newspace\n'+
    'uniform sampler2D uSampler2;\n'+
    'attribute vec3 aPosition;\n'+
    //'attribute vec2 aTexCoord;\n'+
    //'attribute vec3 aBarycentric;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform vec4 uParams;\n'+    //[uGridStep1, fogDensity, indexFactor, uGridStep2]
    'uniform vec4 uParams3;\n'+    //[px, py, sx, sy]
    'uniform float uPoints[9*3];\n'+
    'uniform vec3 uVector;\n'+  
    'uniform vec3 uHeights;\n'+   //[hmin, hmax]
    'uniform vec4 uTransform;\n'+
    //'uniform vec4 uTransform2;\n'+
    'varying vec2 vTexCoord;\n'+
    'varying vec2 vTexCoord2;\n'+
    'varying vec3 vBarycentric;\n'+

    '#ifdef newspace\n'+
        'varying mat3 vTBN;\n'+
    '#else\n'+
        'varying vec3 vNormal;\n'+
    '#endif\n'+

    'varying float vFogFactor;\n'+ GpuShaders.quadPoint +  GpuShaders.getHFNormal + GpuShaders.getHFNormal2 +
    //'float random(vec2 p) { return fract(cos(dot(p,vec2( 23.14069263277926, 2.665144142690225)))*12345.6789);}\n'+

    'void main() {\n'+
        'vec3 indices = aPosition;\n'+
        'float t = aPosition.y * uParams[2];\n'+  //vertical index
        'float tt = t;\n'+
        'float t2 = (1.0-t);\n'+
        'vec3 p1 = quadPoint(0, 3, 6, t, t2);\n'+
        'vec3 p2 = quadPoint(9, 9+3, 9+6, t, t2);\n'+
        'vec3 p3 = quadPoint(18, 18+3, 18+6, t, t2);\n'+
        't = aPosition.x * uParams[2];\n'+  //horizontal index
        'float tt2 = t;\n'+
        't2 = (1.0-t);\n'+
        'float p2x = 2.0*p2.x-p1.x*0.5-p3.x*0.5;\n'+
        'float p2y = 2.0*p2.y-p1.y*0.5-p3.y*0.5;\n'+
        'float p2z = 2.0*p2.z-p1.z*0.5-p3.z*0.5;\n'+
        'vec4 p = vec4(t2*t2*p1.x+2.0*t2*t*p2x+t*t*p3.x, t2*t2*p1.y+2.0*t2*t*p2y+t*t*p3.y, t2*t2*p1.z+2.0*t2*t*p2z+t*t*p3.z, 1);\n'+
        'vec2 uv2 = vec2(tt, 1.0-tt2);\n'+
        'uv2 = vec2(uTransform[0] * uv2[0] + uTransform[2], uTransform[1] * uv2[1] + uTransform[3]);\n'+

        'p.xyz += uVector * (uHeights[0] + (uHeights[1]-uHeights[0])*texture2D(uSampler2, uv2).x);\n'+

        'vec4 camSpacePos = uMV * p;\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uParams[1] * camDist);\n'+

        'vec2 uv = vec2(tt, 1.0-tt2);\n'+
        'uv.x = uv.x * uParams3[0] + uParams3[2];\n'+
        'uv.y = uv.y * uParams3[1] + uParams3[3];\n'+
        'vTexCoord = uv;\n'+

        'vBarycentric = camSpacePos.xyz;\n'+

        '#ifdef newspace\n'+
            'vec2 d = getHFNormal2(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\n'+
            'vec3 T = vec3(2.0,0.0,-d.x); vec3 B = vec3(0.0,2.0,-d.y);\n'+
            'vTBN = mat3(normalize(T), normalize(B), cross(T,B));\n'+
        '#else\n'+
            'vec3 n = getHFNormal(uv2, 1.0/(128.0), (uHeights[1]-uHeights[0]) * uHeights[2]);\n'+
            'vNormal = normalize(n);\n'+
        '#endif\n'+

    '}';    

GpuShaders.planeFragmentShader2 = 'precision mediump float;\n'+
    '#extension GL_OES_standard_derivatives : enable\n'+
    '#define newspace\n'+
    'uniform sampler2D uSampler;\n'+
    'uniform vec4 uParams2;\n'+    //[uGridStep1, uGridStep2, uGridBlend, 0]
    'uniform mat3 uSpace;\n'+  
    'varying vec2 vTexCoord;\n'+
    'varying float vFogFactor;\n'+
    'varying vec3 vBarycentric;\n'+

    '#ifdef newspace\n'+
        'varying mat3 vTBN;\n'+
    '#else\n'+
        'varying vec3 vNormal;\n'+
    '#endif\n'+

    'uniform vec4 uFogColor;\n'+ // = vec4(216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0);\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vBarycentric);\n'+
        
        '#ifdef flat\n'+
            'vec3 nx = dFdx(vBarycentric);\n'+
            'vec3 ny = dFdy(vBarycentric);\n'+
            'vec3 normal2 = normalize(cross(nx,ny));\n'+
            'vec4 c2 = vec4(vec3(max(0.0,normal2.z*(204.0/255.0))+(32.0/255.0)),1.0);\n'+
        '#else\n'+

            '#ifdef newspace\n'+
                //'vec3 normal = cross(normalize(vTangent), normalize(vBitangent));\n'+

                '#ifdef nmix\n'+
                    'vec3 normal = vTBN * normalize((texture2D(uSampler, vTexCoord).xyz-0.5)*2.0);\n'+
                '#else\n'+
                    'vec3 normal = vTBN * vec3(0.0,0.0,1.0);\n'+
                '#endif\n'+

            '#else\n'+
                'vec3 normal = vNormal;\n'+
            '#endif\n'+

            'normal = normalize(uSpace * normal);\n'+

            'vec3 eyeDir = ldir;\n'+
            'vec3 refDir = reflect(-ldir, normal);\n'+
            'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), 90.0));\n'+
            'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\n'+
            'float lcolor = (dot(normal, ldir) + 1.0) * 0.5;\n'+
            //'float lcolor = 0.25+(0.5*diffW)+(0.25*specW);\n'+
            //'float lcolor = 0.25+(0.75*diffW);\n'+

            '#ifdef normals\n'+
                'vec4 c2 = vec4(normal*0.5+0.5,1.0);\n'+        
            '#else\n'+
                'vec4 c2 = vec4(vec3(dot(vec3(0.0,0.0,1.0), normal)),1.0);\n'+        
            '#endif\n'+
            //'vec4 c2 = vec4(normalize(ldir)*0.5+0.5,1.0);\n'+
            //'vec4 c2 = vec4(vec3(lcolor),1.0);\n'+
        '#endif\n'+

        '#ifdef grid\n'+
            'vec4 c = mix(texture2D(uSampler, vTexCoord), texture2D(uSampler, vTexCoord*8.0), uParams2[2]);\n'+
            'c = mix(c, c2, 0.5);\n'+
        '#else\n'+
            '#ifdef exmap\n'+

                'vec4 c = texture2D(uSampler, vTexCoord);\n'+

                '#ifdef classmap\n'+
                    'int i = int(c.x*255.0);\n'+

                    /*
                    'if (i == 0) c = vec4(0.3, 0.44, 0.64, 1.0);\n'+
                    'if (i == 1) c = vec4(0.0, 0.24, 0.0, 1.0);\n'+
                    'if (i == 2) c = vec4(0.58, 0.61, 0.44, 1.0);\n'+
                    'if (i == 3) c = vec4(0.0, 0.39, 0.0, 1.0);\n'+
                    'if (i == 4) c = vec4(0.12, 0.67, 0.02, 1.0);\n'+
                    'if (i == 5) c = vec4(0.08, 0.55, 0.24, 1.0);\n'+
                    'if (i == 6) c = vec4(0.36, 0.46, 0.17, 1.0);\n'+
                    'if (i == 7) c = vec4(0.7, 0.62, 0.18, 1.0);\n'+
                    'if (i == 8) c = vec4(0.7, 0.54, 0.2, 1.0);\n'+
                    'if (i == 9) c = vec4(0.91, 0.86, 0.37, 1.0);\n'+
                    'if (i == 10) c = vec4(0.88, 0.81, 0.54, 1.0);\n'+
                    'if (i == 11) c = vec4(0.61, 0.46, 0.33, 1.0);\n'+
                    'if (i == 12) c = vec4(0.73, 0.83, 0.56, 1.0);\n'+
                    'if (i == 13) c = vec4(0.25, 0.54, 0.45, 1.0);\n'+
                    'if (i == 14) c = vec4(0.42, 0.64, 0.54, 1.0);\n'+
                    'if (i == 15) c = vec4(0.9, 0.68, 0.4, 1.0);\n'+
                    'if (i == 16) c = vec4(0.66, 0.67, 0.68, 1.0);\n'+
                    'if (i == 17) c = vec4(0.86, 0.13, 0.15, 1.0);\n'+
                    'if (i == 18) c = vec4(0.3, 0.44, 0.64, 1.0);\n'+
                    'if (i == 19) c = vec4(1.0, 0.98, 1.0, 1.0);\n'+
                    'c = c * c2;\n'+
                    */

                    'if (i == 1 || i == 2 || i == 5 || i == 6) c = vec4(146.0, 178.0, 144.0, 255.0);\n'+
                    'if (i == 3 || i == 4) c = vec4(94.0, 169.0, 133.0, 255.0);\n'+
                    'if (i == 8 || i == 11) c = vec4(238.0, 221.0, 185.0, 255.0);\n'+
                    'if (i == 7) c = vec4(226.0, 192.0, 154.0, 255.0);\n'+
                    'if (i == 9 || i == 10 || i == 12) c = vec4(250.0, 246.0, 167.0, 255.0);\n'+
                    'if (i == 13 || i == 16) c = vec4(245.0, 236.0, 211.0, 255.0);\n'+
                    'if (i == 14) c = vec4(139.0, 185.0, 166.0, 255.0);\n'+
                    'if (i == 15) c = vec4(199.0, 219.0, 155.0, 255.0);\n'+
                    'if (i == 17) c = vec4(149.0, 132.0, 162.0, 255.0);\n'+
                    'if (i == 18 || i == 0) c = vec4(188.0, 221.0, 255.0, 255.0);\n'+
                    'if (i == 19) c = vec4(255.0, 255.0, 255.0, 255.0);\n'+
                    'c = (c*(1.0/255.0)) * c2;\n'+
                '#endif\n'+

            '#else\n'+
                'vec4 c = c2;\n'+
            '#endif\n'+
        '#endif\n'+

        '#ifdef fog\n'+
            'gl_FragColor = mix(uFogColor, c, vFogFactor);\n'+
        '#else\n'+
            'gl_FragColor = c;\n'+
        '#endif\n'+
    '}';


//textured tile mesh
GpuShaders.tileVertexShader =
    'attribute vec3 aPosition;\n'+

    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#else\n'+

        '#ifdef externalTex\n'+
            'attribute vec2 aTexCoord2;\n'+
        '#else\n'+
            'attribute vec2 aTexCoord;\n'+
        '#endif\n'+
    
        'varying vec3 vTexCoord;\n'+  //u,v,fogFactor

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        ///'attribute vec3 aBarycentric;\n'+
        'varying vec3 vBarycentric;\n'+
    '#endif\n'+

                                             //0-3                            4-7          8-11            12-15 
    'uniform mat4 uMV, uProj, uParams;\n'+  //[zfactor, fogDensity, scale.xy][camVec.xyzw][transform.xyzw][scale.z, trans.xyz]

    '#ifdef applySE\n'+
        'uniform mat4 uParamsSE;\n'+
    '#endif\n'+

    'void main() {\n'+

        '#ifdef applySE\n'+
            'vec3 geoPos2 = aPosition*vec3(uParamsSE[0][3],uParamsSE[1][0],uParamsSE[1][1]);\n'+
            'vec3 geoPos = geoPos2+vec3(uParamsSE[0][0],uParamsSE[0][1],uParamsSE[0][2]);\n'+
            'geoPos.z *= uParamsSE[3][3];\n'+
            'float ll = length(geoPos);\n'+
            'vec3 v = geoPos * (1.0/(ll+0.0001));\n'+
            'float h = ll - uParamsSE[3][2];\n'+
            'float h2 = clamp(h, uParamsSE[2][1], uParamsSE[2][3]);\n'+
            'float h3 = h;\n'+
            'h *= (uParamsSE[2][2] + ((h2 - uParamsSE[2][1]) * uParamsSE[3][0]) * uParamsSE[3][1]);\n'+
            'geoPos2.xyz += v * (h - h3);\n'+
            'vec4 camSpacePos = uMV * vec4(geoPos2, 1.0);\n'+
            'float l = dot(v, vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
        '#else\n'+
            'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
            'vec3 worldPos = vec3(aPosition.x * uParams[0][2] + uParams[3][1], aPosition.y * uParams[0][3] + uParams[3][2], aPosition.z * uParams[3][0] + uParams[3][3]);\n'+
            'float l = dot(normalize(worldPos.xyz), vec3(uParams[1][0],uParams[1][1],uParams[1][2]));\n'+
        '#endif\n'+

        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+

        '#ifdef depth\n'+
            'vDepth = camDist;\n'+
        '#endif\n'+

        '#ifdef flatShadeVar\n'+
            'vBarycentric = camSpacePos.xyz;\n'+
        '#endif\n'+

        'float fogFactor = 1.0-exp(uParams[0][1] * camDist);\n'+
        'fogFactor = clamp((1.0-abs(l))*uParams[1][3] + fogFactor, 0.0, 1.0);\n'+

        '#ifdef onlyFog\n'+
            'vFogFactor = fogFactor;\n'+
        '#else\n'+
            'vTexCoord.z = fogFactor;\n'+

            '#ifdef externalTex\n'+
                'vTexCoord.xy = vec2(uParams[2][0] * aTexCoord2[0] + uParams[2][2], uParams[2][1] * aTexCoord2[1] + uParams[2][3]);\n'+
            '#else\n'+
                'vTexCoord.xy = aTexCoord;\n'+
            '#endif\n'+

        '#endif\n'+
    '}';

GpuShaders.tileFragmentShader = 'precision mediump float;\n'+

    '#ifdef onlyFog\n'+
        'varying float vFogFactor;\n'+
    '#else\n'+

        'varying vec3 vTexCoord;\n'+
        'uniform sampler2D uSampler;\n'+

        '#ifdef mask\n'+
            'uniform sampler2D uSampler2;\n'+
        '#endif\n'+

    '#endif\n'+

    '#ifdef depth\n'+
        'varying float vDepth;\n'+
    '#endif\n'+

    '#ifdef flatShadeVar\n'+
        'varying vec3 vBarycentric;\n'+

        '#ifdef fogAndColor\n'+
            'uniform vec4 uColor;\n'+
        '#endif\n'+

    '#endif\n'+

    'uniform vec4 uParams2;\n'+        
    'void main() {\n'+

        '#ifdef flatShadeVar\n'+

            '#ifdef flatShadeVarFallback\n'+
                'vec4 flatShadeData = vec4(1.0);\n'+
            '#else\n'+
                '#ifdef GL_OES_standard_derivatives\n'+
                    'vec3 nx = dFdx(vBarycentric);\n'+
                    'vec3 ny = dFdy(vBarycentric);\n'+
                    'vec3 normal=normalize(cross(nx,ny));\n'+
                    'vec4 flatShadeData = vec4(vec3(max(0.0,normal.z*(204.0/255.0))+(32.0/255.0)),1.0);\n'+
                '#else\n'+
                    'vec4 flatShadeData = vec4(1.0);\n'+
                '#endif\n'+
            '#endif\n'+

        '#endif\n'+

        '#ifdef flatShade\n'+

            '#ifdef fogAndColor\n'+
               // 'gl_FragColor = vec4(mix(uColor.xyz * flatShadeData.xyz, uParams2.xyz, vTexCoord.z), uColor.w);\n'+
                'gl_FragColor = vec4(uColor.xyz * flatShadeData.xyz, uColor.w);\n'+
            '#else\n'+
                'gl_FragColor = vec4(flatShadeData.xyz, 1.0);\n'+
            '#endif\n'+

        '#else\n'+

            'vec4 fogColor = vec4(uParams2.xyz, 1.0);\n'+

            '#ifdef onlyFog\n'+
                'gl_FragColor = vec4(fogColor.xyz, vFogFactor);\n'+
            '#else\n'+

                '#ifdef depth\n'+
                    'gl_FragColor = fract(vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) * vDepth) + (-0.5/255.0);\n'+
                '#else\n'+

                    '#ifdef externalTex\n'+
                        'vec4 c = texture2D(uSampler, vTexCoord.xy);\n'+'__FILTER__' +
                        'vec4 cc = mix(c, fogColor, vTexCoord.z);\n'+
                        '#ifdef mask\n'+
                            'vec4 c2 = texture2D(uSampler2, vTexCoord.xy);\n'+
                            'cc.w = c.w * uParams2.w * c2.x;\n'+
                        '#else\n'+
                            'cc.w = c.w * uParams2.w;\n'+
                        '#endif\n'+

                        'gl_FragColor = cc;\n'+
                    '#else\n'+
                        'gl_FragColor = mix(texture2D(uSampler, vTexCoord.xy), fogColor, vTexCoord.z);\n'+
                    '#endif\n'+

                '#endif\n'+

            '#endif\n'+

        '#endif\n'+
    '}';


GpuShaders.shadedMeshVertexShader =
    'attribute vec3 aPosition;\n'+
    'attribute vec2 aTexCoord;\n'+
    'attribute vec3 aNormal;\n'+
    'uniform mat4 uMV, uProj;\n'+
    'uniform mat3 uNorm;\n'+
    'uniform float uFogDensity;\n'+
    'varying vec2 vTexCoord;\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'varying float vFogFactor;\n'+
    'void main() {\n'+
        'vec4 camSpacePos = uMV * vec4(aPosition, 1.0);\n'+
        'gl_Position = uProj * camSpacePos;\n'+
        'float camDist = length(camSpacePos.xyz);\n'+
        'vFogFactor = exp(uFogDensity * camDist);\n'+
        'vTexCoord = aTexCoord;\n'+
        'vPosition = camSpacePos;\n'+
        'vNormal = aNormal * uNorm;\n'+
    '}';


GpuShaders.shadedMeshFragmentShader = 'precision mediump float;\n'+
    '#ifdef textured\n'+
        'uniform sampler2D uSampler;\n'+
        'varying vec2 vTexCoord;\n'+
    '#endif\n'+
    'varying vec4 vPosition;\n'+
    'varying vec3 vNormal;\n'+
    'uniform mat4 uMaterial;\n'+
    'varying float vFogFactor;\n'+
    'uniform vec4 uFogColor;\n'+
    'void main() {\n'+
        'vec3 ldir = normalize(-vPosition.xyz);\n'+
        'vec3 normal = normalize(vNormal);\n'+
        'vec3 eyeDir = ldir;\n'+
        'vec3 refDir = reflect(-ldir, normal);\n'+
        'float specW = min(1.0, pow(max(dot(refDir, eyeDir), 0.0), uMaterial[3][0]));\n'+
        'float diffW = min(1.0, max(dot(normal, ldir), 0.0));\n'+
        'vec4 lcolor = uMaterial[0]+(uMaterial[1]*diffW)+(uMaterial[2]*specW);\n'+
        '#ifdef textured\n'+
            'vec4 tcolor = texture2D(uSampler, vTexCoord);\n'+
            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0) * tcolor, vFogFactor); gl_FragColor.w *= uMaterial[3][1];\n'+
        '#else\n'+
            'gl_FragColor = mix(uFogColor, vec4(lcolor.xyz*(1.0/255.0), 1.0), vFogFactor);  gl_FragColor.w = uMaterial[3][1];\n'+
        '#endif\n'+

    '}';

GpuShaders.tileWireFrameBasicShader = 'precision mediump float;\n'+
    'uniform vec4 uColor;\n'+
    'void main() {\n'+
        'gl_FragColor = uColor;\n'+
    '}';


//used for 2d images
GpuShaders.imageVertexShader = '\n'+
    'attribute vec4 aPosition;\n'+
    'uniform mat4 uProjectionMatrix;\n'+
    'uniform mat4 uData;\n'+
    'uniform vec4 uColor;\n'+
    'uniform float uDepth;\n'+
    'varying vec4 vColor;\n'+
    'varying vec2 vTexcoords;\n'+
    'void main(void){\n'+
        'int i=int(aPosition.x);\n'+
        //"gl_Position=uProjectionMatrix*vec4(floor(uData[i][0]+0.1),floor(uData[i][1]+0.1),0.0,1.0);\n"+
        //IE11 :(

        'vec4 p;\n'+

        'if(i==0) p = vec4(floor(uData[0][0]+0.1),floor(uData[0][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[0][2], uData[0][3]);\n'+
        'if(i==1) p = vec4(floor(uData[1][0]+0.1),floor(uData[1][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[1][2], uData[1][3]);\n'+
        'if(i==2) p = vec4(floor(uData[2][0]+0.1),floor(uData[2][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[2][2], uData[2][3]);\n'+
        'if(i==3) p = vec4(floor(uData[3][0]+0.1),floor(uData[3][1]+0.1),uDepth,1.0), vTexcoords=vec2(uData[3][2], uData[3][3]);\n'+

        'gl_Position=uProjectionMatrix*p;\n'+
        'vec4 c=uColor;\n'+
        'c.w*=1.0;\n'+
        'vColor=c;\n'+
    '}';


GpuShaders.imageFragmentShader = 'precision mediump float;\n'+
    'varying vec4 vColor;\n'+
    'varying vec2 vTexcoords;\n'+
    'uniform sampler2D uSampler;\n'+
    'void main(void){\n'+
        'vec4 c=texture2D(uSampler, vec2(vTexcoords.x, vTexcoords.y) );\n'+
        'c*=vColor;\n'+
        'if(c.w < 0.01){ discard; }\n'+
        'gl_FragColor = c;\n'+
    '}';
    

/* harmony default export */ __webpack_exports__["a"] = (GpuShaders);







/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_proj4__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core__ = __webpack_require__(13);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoreInterface; });




//import {CoreInterface as CoreInterface_} from './interface';

//get rid of compiler mess
//var CoreInterface = CoreInterface_;
var Core = __WEBPACK_IMPORTED_MODULE_2__core__["c" /* Core */];
var proj4 = __WEBPACK_IMPORTED_MODULE_0_proj4__["a" /* default */];


var CoreInterface = function(element, config) {
    this.core = new Core(element, config, this);

    Object.defineProperty(this, 'map', {
        get: function() {
            if (!this.core) { return null; }
            return this.core.getMapInterface();
        }
    });

    Object.defineProperty(this, 'renderer', {
        get: function() {
            if (!this.core) { return null; }
            return this.core.getRendererInterface();
        }
    });

    Object.defineProperty(this, 'proj4', {
        get: function() {
            if (!this.core) { return null; }
            return proj4;
        }
    });

    Object.defineProperty(this, 'earcut', {
        get: function() {
            if (!this.core) { return null; }
            return __WEBPACK_IMPORTED_MODULE_1_earcut___default.a;
        }
    });
};


CoreInterface.prototype.destroy = function() {
    this.core.destroy();
    this.core = null;
};


CoreInterface.prototype.loadMap = function(path) {
    if (!this.core) { return null; }
    return this.core.loadMap(path);
};


CoreInterface.prototype.destroyMap = function() {
    if (!this.core) { return null; }
    return this.core.destroyMap();
};


/*CoreInterface.prototype.getMap = function() {
    if (!this.core) { return null; }
    return this.core.getMapInterface();
};


CoreInterface.prototype.getRenderer = function() {
    if (!this.core) { return null; }
    return this.core.getRendererInterface();
};


CoreInterface.prototype.getProj4 = function() {
    if (!this.core) { return null; }
    return this.core.getProj4();
};*/


CoreInterface.prototype.on = function(eventName, call) {
    if (!this.core) { return null; }
    return this.core.on(eventName, call);
};

CoreInterface.prototype.once = function(eventName, call, wait) {
    if (!this.core) { return null; }
    return this.core.once(eventName, call, wait);
};

CoreInterface.prototype.callListener = function(name, event) {
    if (!this.core) { return null; }
    this.core.callListener(name, event);
};





/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mgrs__ = __webpack_require__(35);


function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_mgrs__["b" /* toPoint */])(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_mgrs__["c" /* forward */])([this.x, this.y], accuracy);
};
/* harmony default export */ __webpack_exports__["a"] = (Point);


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      t = 'x';
    }
    else if (i === 1) {
      v = yin;
      t = 'y';
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      out[t] = v;
      break;
    case 'w':
      out[t] = -v;
      break;
    case 'n':
      out[t] = v;
      break;
    case 's':
      out[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
});


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adjust_lon__ = __webpack_require__(3);


/* harmony default export */ __webpack_exports__["a"] = (function(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__adjust_lon__["a" /* default */])(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
});


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hypot__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__log1py__ = __webpack_require__(70);



/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  var y = Math.abs(x);
  y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__log1py__["a" /* default */])(y * (1 + y / (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__hypot__["a" /* default */])(1, y) + 1)));

  return x < 0 ? -y : y;
});


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
});


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__sinh__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cosh__ = __webpack_require__(67);



/* harmony default export */ __webpack_exports__["a"] = (function(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__sinh__["a" /* default */])(arg_i);
  var cosh_arg_i = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__cosh__["a" /* default */])(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
});


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
});

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
});


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);


/* harmony default export */ __webpack_exports__["a"] = (function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]);
    }
    else {
      return __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
});


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
});


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
});

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exports; });
var exports = {};

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return WGS84; });
var exports = {};

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exports; });
var exports = {};


exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Proj__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transform__ = __webpack_require__(45);


var wgs84 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__Proj__["a" /* default */])('WGS84');

function transformer(from, to, coords) {
  var transformedArray;
  if (Array.isArray(coords)) {
    transformedArray = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__transform__["a" /* default */])(from, to, coords);
    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    }
    else {
      return [transformedArray.x, transformedArray.y];
    }
  }
  else {
    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__transform__["a" /* default */])(from, to, coords);
  }
}

function checkProj(item) {
  if (item instanceof __WEBPACK_IMPORTED_MODULE_0__Proj__["a" /* default */]) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__Proj__["a" /* default */])(item);
}
function proj4(fromProj, toProj, coord, retProj) {
  if(retProj) {
    return fromProj;
  }
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  }
  else {
    obj = {
      forward: function (coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function (coords) {
        return transformer(toProj, fromProj, coords);
      },
      info: function () {
        return {
          "a": toProj.a,
          "b": toProj.b,
          "ra": toProj.R_A,
          "proj-name": toProj.projName
        };
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ __webpack_exports__["a"] = (proj4);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);


function datum(datumCode, datum_params, a, b, es, ep2) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = __WEBPACK_IMPORTED_MODULE_0__constants_values__["k" /* PJD_NODATUM */];
  } else {
    out.datum_type = __WEBPACK_IMPORTED_MODULE_0__constants_values__["l" /* PJD_WGS84 */];
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */];
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */];
        out.datum_params[3] *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["f" /* SEC_TO_RAD */];
        out.datum_params[4] *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["f" /* SEC_TO_RAD */];
        out.datum_params[5] *= __WEBPACK_IMPORTED_MODULE_0__constants_values__["f" /* SEC_TO_RAD */];
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ __webpack_exports__["a"] = (datum);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__datumUtils__ = __webpack_require__(41);



function checkParams(type) {
  return (type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["h" /* PJD_3PARAM */] || type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["i" /* PJD_7PARAM */]);
}

/* harmony default export */ __webpack_exports__["a"] = (function(source, dest, point) {
  // Short cut if the datums are identical.
  if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datumUtils__["c" /* compareDatums */])(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["k" /* PJD_NODATUM */] || dest.datum_type === __WEBPACK_IMPORTED_MODULE_0__constants_values__["k" /* PJD_NODATUM */]) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.

  // Do we need to go through geocentric coordinates?
  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datumUtils__["b" /* geodeticToGeocentric */])(point, source.es, source.a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datumUtils__["d" /* geocentricToWgs84 */])(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datumUtils__["e" /* geocentricFromWgs84 */])(point, dest.datum_type, dest.datum_params);
  }
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__datumUtils__["a" /* geocentricToGeodetic */])(point, dest.es, dest.a, dest.b);

});


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_Ellipsoid__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__match__ = __webpack_require__(29);
/* harmony export (immutable) */ __webpack_exports__["b"] = eccentricity;
/* harmony export (immutable) */ __webpack_exports__["a"] = sphere;




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (__WEBPACK_IMPORTED_MODULE_0__constants_values__["m" /* SIXTH */] + es * (__WEBPACK_IMPORTED_MODULE_0__constants_values__["n" /* RA4 */] + es * __WEBPACK_IMPORTED_MODULE_0__constants_values__["o" /* RA6 */]));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__match__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__constants_Ellipsoid__["a" /* default */], ellps);
    if (!ellipse) {
      ellipse = __WEBPACK_IMPORTED_MODULE_1__constants_Ellipsoid__["b" /* WGS84 */];
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
});


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
});


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defs__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_wkt_parser__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__projString__ = __webpack_require__(43);



function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in __WEBPACK_IMPORTED_MODULE_0__defs__["a" /* default */];
}
 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; 
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return __WEBPACK_IMPORTED_MODULE_0__defs__["a" /* default */][code];
    }
    if (testWKT(code)) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_wkt_parser__["a" /* default */])(code);
    }
    if (testProj(code)) {
      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__projString__["a" /* default */])(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (parse);


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__projections_merc__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__projections_longlat__ = __webpack_require__(96);
/* unused harmony export add */
/* unused harmony export get */
/* unused harmony export start */


var projs = [__WEBPACK_IMPORTED_MODULE_0__projections_merc__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__projections_longlat__["a" /* default */]];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ __webpack_exports__["a"] = ({
  start: start,
  add: add,
  get: get
});


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_qsfnz__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_asinz__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export phi1z */
/* unused harmony export names */






function init() {

  if (Math.abs(this.lat1 + this.lat2) < __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_msfnz__["a" /* default */])(this.e3, this.sin_po, this.cos_po);
  this.qs1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_msfnz__["a" /* default */])(this.e3, this.sin_po, this.cos_po);
  this.qs2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__["a" /* default */])(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_asinz__["a" /* default */])(0.5 * qs);
  if (eccent < __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  phi1z: phi1z
});


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_mlfn__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_e0fn__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_e1fn__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_e2fn__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_e3fn__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_gN__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_asinz__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__common_imlfn__ = __webpack_require__(26);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */














function init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //North Pole case
      p.x = this.x0 + this.a * (__WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */] - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (__WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */] - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //South Pole case
      p.x = this.x0 + this.a * (__WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */] + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (__WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */] + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_e0fn__["a" /* default */])(this.es);
    e1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_e1fn__["a" /* default */])(this.es);
    e2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_e2fn__["a" /* default */])(this.es);
    e3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_e3fn__["a" /* default */])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //North Pole case
      Mlp = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */]);
      Ml = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //South Pole case
      Mlp = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */]);
      Ml = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_gN__["a" /* default */])(this.a, this.e, this.sin_p12);
      Nl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_gN__["a" /* default */])(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */] * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      lat = this.lat0;
    }
    else {
      lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__common_asinz__["a" /* default */])(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */];
      if (Math.abs(con) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
        if (this.lat0 >= 0) {
          lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_e0fn__["a" /* default */])(this.es);
    e1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_e1fn__["a" /* default */])(this.es);
    e2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_e2fn__["a" /* default */])(this.es);
    e3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_e3fn__["a" /* default */])(this.es);
    if (Math.abs(this.sin_p12 - 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //North pole case
      Mlp = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_imlfn__["a" /* default */])(M / this.a, e0, e1, e2, e3);
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      //South pole case
      Mlp = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_mlfn__["a" /* default */])(e0, e1, e2, e3, __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */]);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_9__common_imlfn__["a" /* default */])(M / this.a, e0, e1, e2, e3);
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_gN__["a" /* default */])(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_mlfn__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_e0fn__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_e1fn__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_e2fn__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_e3fn__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_gN__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_adjust_lat__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_imlfn__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */











function init() {
  if (!this.sphere) {
    this.e0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_e0fn__["a" /* default */])(this.es);
    this.e1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_e1fn__["a" /* default */])(this.es);
    this.e2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_e2fn__["a" /* default */])(this.es);
    this.e3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_e3fn__["a" /* default */])(this.es);
    this.ml0 = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_gN__["a" /* default */])(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__common_imlfn__["a" /* default */])(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - __WEBPACK_IMPORTED_MODULE_9__constants_values__["a" /* HALF_PI */]) <= __WEBPACK_IMPORTED_MODULE_9__constants_values__["d" /* EPSLN */]) {
      p.x = this.long0;
      p.y = __WEBPACK_IMPORTED_MODULE_9__constants_values__["a" /* HALF_PI */];
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_gN__["a" /* default */])(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(lam + this.long0);
  p.y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_adjust_lat__["a" /* default */])(phi);
  return p;

}

var names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_qsfnz__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_iqsfnz__ = __webpack_require__(69);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function init() {
  //no-op
  if (!this.sphere) {
    this.k0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_msfnz__["a" /* default */])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_iqsfnz__["a" /* default */])(this.e, 2 * p.y * this.k0 / this.a);
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["cea"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_adjust_lat__ = __webpack_require__(10);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */



function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var dlat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lat__["a" /* default */])(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lat__["a" /* default */])(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_e0fn__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_e1fn__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_e2fn__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_e3fn__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_mlfn__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__common_adjust_lat__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_imlfn__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */











function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < __WEBPACK_IMPORTED_MODULE_9__constants_values__["d" /* EPSLN */]) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_e0fn__["a" /* default */])(this.es);
  this.e1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_e1fn__["a" /* default */])(this.es);
  this.e2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_e2fn__["a" /* default */])(this.es);
  this.e3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_e3fn__["a" /* default */])(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_msfnz__["a" /* default */])(this.e, this.sinphi, this.cosphi);
  this.ml1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < __WEBPACK_IMPORTED_MODULE_9__constants_values__["d" /* EPSLN */]) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_msfnz__["a" /* default */])(this.e, this.sinphi, this.cosphi);
    this.ml2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(this.long0 + theta / this.ns);
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_7__common_adjust_lat__["a" /* default */])(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__common_imlfn__["a" /* default */])(ml, this.e0, this.e1, this.e2, this.e3);
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_adjust_lon__["a" /* default */])(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_srat__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */

var MAX_ITER = 20;


function init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + __WEBPACK_IMPORTED_MODULE_1__constants_values__["b" /* FORTPI */]) / (Math.pow(Math.tan(0.5 * this.lat0 + __WEBPACK_IMPORTED_MODULE_1__constants_values__["b" /* FORTPI */]), this.C) * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_srat__["a" /* default */])(this.e * sphi, this.ratexp));
}

function forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + __WEBPACK_IMPORTED_MODULE_1__constants_values__["b" /* FORTPI */]), this.C) * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_srat__["a" /* default */])(this.e * Math.sin(lat), this.ratexp)) - __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */];
  p.x = this.C * lon;
  return p;
}

function inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + __WEBPACK_IMPORTED_MODULE_1__constants_values__["b" /* FORTPI */]) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_srat__["a" /* default */])(this.e * Math.sin(p.y), - 0.5 * this.e)) - __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */];
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gauss"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
function init() {
  this.isGeocent = true;
}

function identity(pt) {
  return pt;
}


var names = ["geocent"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_asinz__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= __WEBPACK_IMPORTED_MODULE_2__constants_values__["d" /* EPSLN */])) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_asinz__["a" /* default */])(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["gnom"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */


function init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var names = ["Krovak", "krovak"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_qsfnz__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export S_POLE */
/* unused harmony export N_POLE */
/* unused harmony export EQUIT */
/* unused harmony export OBLIQ */
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__["a" /* default */])(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.phi0) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
        return null;
      }
      y = __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_qsfnz__["a" /* default */])(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - phi;
      break;
    case this.S_POLE:
      phi -= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_adjust_lon__["a" /* default */])(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_tsfnz__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_sign__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_phi2z__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */






function init() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_msfnz__["a" /* default */])(this.e, sin1, cos1);
  var ts1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_tsfnz__["a" /* default */])(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_msfnz__["a" /* default */])(this.e, sin2, cos2);
  var ts2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_tsfnz__["a" /* default */])(this.e, this.lat2, sin2);

  var ts0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_tsfnz__["a" /* default */])(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) {
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_sign__["a" /* default */])(lat) * (__WEBPACK_IMPORTED_MODULE_5__constants_values__["a" /* HALF_PI */] - 2 * __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]);
  }

  var con = Math.abs(Math.abs(lat) - __WEBPACK_IMPORTED_MODULE_5__constants_values__["a" /* HALF_PI */]);
  var ts, rh1;
  if (con > __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) {
    ts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_tsfnz__["a" /* default */])(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__["a" /* default */])(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_phi2z__["a" /* default */])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -__WEBPACK_IMPORTED_MODULE_5__constants_values__["a" /* HALF_PI */];
  }
  lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__["a" /* default */])(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
function init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var names = ["longlat", "identity"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_tsfnz__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_phi2z__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_msfnz__["a" /* default */])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * __WEBPACK_IMPORTED_MODULE_4__constants_values__["j" /* R2D */] > 90 && lat * __WEBPACK_IMPORTED_MODULE_4__constants_values__["j" /* R2D */] < -90 && lon * __WEBPACK_IMPORTED_MODULE_4__constants_values__["j" /* R2D */] > 180 && lon * __WEBPACK_IMPORTED_MODULE_4__constants_values__["j" /* R2D */] < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - __WEBPACK_IMPORTED_MODULE_4__constants_values__["a" /* HALF_PI */]) <= __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(__WEBPACK_IMPORTED_MODULE_4__constants_values__["b" /* FORTPI */] + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_tsfnz__["a" /* default */])(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = __WEBPACK_IMPORTED_MODULE_4__constants_values__["a" /* HALF_PI */] - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_phi2z__["a" /* default */])(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */

function init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  for (var i = 0; true; i++) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mollweide", "moll"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* unused harmony export iterations */
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / __WEBPACK_IMPORTED_MODULE_0__constants_values__["f" /* SEC_TO_RAD */] * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * __WEBPACK_IMPORTED_MODULE_0__constants_values__["f" /* SEC_TO_RAD */] * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_tsfnz__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_phi2z__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */





/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function init() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_tsfnz__["a" /* default */])(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_tsfnz__["a" /* default */])(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_tsfnz__["a" /* default */])(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(this.long0);
    var dlon10 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

}

/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - __WEBPACK_IMPORTED_MODULE_3__constants_values__["a" /* HALF_PI */]) <= __WEBPACK_IMPORTED_MODULE_3__constants_values__["d" /* EPSLN */]) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(__WEBPACK_IMPORTED_MODULE_3__constants_values__["b" /* FORTPI */] + con * this.gamma0 * 0.5));
    us = -1 * con * __WEBPACK_IMPORTED_MODULE_3__constants_values__["a" /* HALF_PI */] * this.al / this.bl;
  }
  else {
    var t = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_tsfnz__["a" /* default */])(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= __WEBPACK_IMPORTED_MODULE_3__constants_values__["d" /* EPSLN */]) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= __WEBPACK_IMPORTED_MODULE_3__constants_values__["d" /* EPSLN */]) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
}

function inverse(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < __WEBPACK_IMPORTED_MODULE_3__constants_values__["d" /* EPSLN */]) {
    p.x = this.long0;
    p.y = __WEBPACK_IMPORTED_MODULE_3__constants_values__["a" /* HALF_PI */];
  }
  else if (Math.abs(up + 1) < __WEBPACK_IMPORTED_MODULE_3__constants_values__["d" /* EPSLN */]) {
    p.x = this.long0;
    p.y = -1 * __WEBPACK_IMPORTED_MODULE_3__constants_values__["a" /* HALF_PI */];
  }
  else {
    p.y = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_phi2z__["a" /* default */])(this.e, ts);
    p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
}

var names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_asinz__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */




function init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= __WEBPACK_IMPORTED_MODULE_2__constants_values__["d" /* EPSLN */])) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_asinz__["a" /* default */])(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= __WEBPACK_IMPORTED_MODULE_2__constants_values__["d" /* EPSLN */]) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_asinz__["a" /* default */])(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - __WEBPACK_IMPORTED_MODULE_2__constants_values__["a" /* HALF_PI */];
  if (Math.abs(con) <= __WEBPACK_IMPORTED_MODULE_2__constants_values__["d" /* EPSLN */]) {
    if (this.lat0 >= 0) {
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["ortho"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_e0fn__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_e1fn__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_e2fn__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_e3fn__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_adjust_lat__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_mlfn__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__common_gN__ = __webpack_require__(25);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */










var MAX_ITER = 20;

function init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_e0fn__["a" /* default */])(this.es);
  this.e1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_e1fn__["a" /* default */])(this.es);
  this.e2 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_e2fn__["a" /* default */])(this.es);
  this.e3 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_e3fn__["a" /* default */])(this.es);
  this.ml0 = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__["a" /* default */])(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lat__["a" /* default */])(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_8__common_gN__["a" /* default */])(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__["a" /* default */])(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
          lat = phi;
          break;
        }
      }
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__["a" /* default */])(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
      lat = 0;
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__["a" /* default */])(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_mlfn__["a" /* default */])(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= __WEBPACK_IMPORTED_MODULE_7__constants_values__["d" /* EPSLN */]) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_adjust_lon__["a" /* default */])(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Polyconic", "poly"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - lat;
    if (lon >= __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] && lon <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else if (lon > __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] || lon <= -(__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */])) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : lon + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    } else if (lon > -(__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) && lon <= -__WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + lat;
    if (lon >= __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] && lon <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else if (lon < __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] && lon >= -__WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -__WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] && lon >= -(__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */])) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : -lon - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +__WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]) * (theta + Math.acos(Math.sin(theta) * Math.cos(__WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */])) - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */];
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */];
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : mu - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (__WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : theta - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : -theta + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -__WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */]);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] && theta <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */]) {
      area.value = AREA_ENUM.AREA_1;
      theta -= __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    } else if (theta > __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */] || theta <= -(__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + __WEBPACK_IMPORTED_MODULE_0__constants_values__["b" /* FORTPI */])) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */] : theta + __WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -__WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]) {
    slon += __WEBPACK_IMPORTED_MODULE_0__constants_values__["e" /* TWO_PI */];
  } else if (slon > +__WEBPACK_IMPORTED_MODULE_0__constants_values__["c" /* SPI */]) {
    slon -= __WEBPACK_IMPORTED_MODULE_0__constants_values__["e" /* TWO_PI */];
  }
  return slon;
}

var names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});



/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_adjust_lat__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_pj_enfn__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_pj_mlfn__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_pj_inv_mlfn__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__common_asinz__ = __webpack_require__(7);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */



var MAX_ITER = 20;







function init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_pj_enfn__["a" /* default */])(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_pj_mlfn__["a" /* default */])(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_asinz__["a" /* default */])((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__common_asinz__["a" /* default */])(Math.sin(lat) / this.n);
    }
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon + this.long0);
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lat__["a" /* default */])(lat);
  }
  else {
    lat = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_pj_inv_mlfn__["a" /* default */])(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < __WEBPACK_IMPORTED_MODULE_5__constants_values__["a" /* HALF_PI */]) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(temp);
    }
    else if ((s - __WEBPACK_IMPORTED_MODULE_5__constants_values__["d" /* EPSLN */]) < __WEBPACK_IMPORTED_MODULE_5__constants_values__["a" /* HALF_PI */]) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Sinusoidal", "sinu"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme  axe oblique et pour la transformation entre
    des systmes de rfrence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var names = ["somerc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_sign__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_msfnz__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_tsfnz__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__common_phi2z__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export ssfn_ */
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      this.k0 = 0.5 * (1 + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_sign__["a" /* default */])(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      this.k0 = 0.5 * this.cons * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_msfnz__["a" /* default */])(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_tsfnz__["a" /* default */])(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_msfnz__["a" /* default */])(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */] && Math.abs(lat + this.lat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - __WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */];
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      ts = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_tsfnz__["a" /* default */])(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      if (this.lat0 > 0) {
        lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
      if (rh <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_phi2z__["a" /* default */])(this.e, ts);
      lon = this.con * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= __WEBPACK_IMPORTED_MODULE_0__constants_values__["d" /* EPSLN */]) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_adjust_lon__["a" /* default */])(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__common_phi2z__["a" /* default */])(this.e, Math.tan(0.5 * (__WEBPACK_IMPORTED_MODULE_0__constants_values__["a" /* HALF_PI */] + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  ssfn_: ssfn_
});


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gauss__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__ = __webpack_require__(3);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */



function init() {
  __WEBPACK_IMPORTED_MODULE_0__gauss__["a" /* default */].init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function forward(p) {
  var sinc, cosc, cosl, k;
  p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(p.x - this.long0);
  __WEBPACK_IMPORTED_MODULE_0__gauss__["a" /* default */].forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  __WEBPACK_IMPORTED_MODULE_0__gauss__["a" /* default */].inverse.apply(this, [p]);
  p.x = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_adjust_lon__["a" /* default */])(p.x + this.long0);
  return p;
}

var names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_pj_enfn__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_pj_mlfn__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_pj_inv_mlfn__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__common_sign__ = __webpack_require__(11);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_pj_enfn__["a" /* default */])(this.es);
    this.ml0 = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_pj_mlfn__["a" /* default */])(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */]) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */] ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__common_pj_mlfn__["a" /* default */])(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__["a" /* default */])(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_pj_inv_mlfn__["a" /* default */])(con, this.es, this.en);

    if (Math.abs(phi) < __WEBPACK_IMPORTED_MODULE_4__constants_values__["a" /* HALF_PI */]) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > __WEBPACK_IMPORTED_MODULE_4__constants_values__["d" /* EPSLN */] ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__common_adjust_lon__["a" /* default */])(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = __WEBPACK_IMPORTED_MODULE_4__constants_values__["a" /* HALF_PI */] * __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__common_sign__["a" /* default */])(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_zone__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__etmerc__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_values__ = __webpack_require__(0);
/* unused harmony export dependsOn */
/* unused harmony export init */
/* unused harmony export names */


var dependsOn = 'etmerc';



function init() {
  var zone = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_zone__["a" /* default */])(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * __WEBPACK_IMPORTED_MODULE_2__constants_values__["g" /* D2R */];
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  __WEBPACK_IMPORTED_MODULE_1__etmerc__["a" /* default */].init.apply(this);
  this.forward = __WEBPACK_IMPORTED_MODULE_1__etmerc__["a" /* default */].forward;
  this.inverse = __WEBPACK_IMPORTED_MODULE_1__etmerc__["a" /* default */].inverse;
}

var names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  names: names,
  dependsOn: dependsOn
});


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_values__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_asinz__ = __webpack_require__(7);
/* unused harmony export init */
/* unused harmony export forward */
/* unused harmony export inverse */
/* unused harmony export names */






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__common_asinz__["a" /* default */])(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) || (Math.abs(Math.abs(lat) - __WEBPACK_IMPORTED_MODULE_1__constants_values__["a" /* HALF_PI */]) <= __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */])) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < __WEBPACK_IMPORTED_MODULE_1__constants_values__["d" /* EPSLN */]) {
    lon = this.long0;
  }
  else {
    lon = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__common_adjust_lon__["a" /* default */])(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ __webpack_exports__["a"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__package_json__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__package_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__package_json__);
/* harmony reexport (binding) */ if(__webpack_require__.o(__WEBPACK_IMPORTED_MODULE_0__package_json__, "version")) __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_0__package_json__["version"]; });



/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = {
	"_args": [
		[
			{
				"raw": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
				"scope": null,
				"escapedName": null,
				"name": null,
				"rawSpec": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
				"spec": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
				"type": "directory"
			},
			"g:\\code\\melown"
		]
	],
	"_from": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
	"_id": "proj4@2.4.4-alpha",
	"_inCache": true,
	"_location": "/proj4",
	"_phantomChildren": {},
	"_requested": {
		"raw": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
		"scope": null,
		"escapedName": null,
		"name": null,
		"rawSpec": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
		"spec": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
		"type": "directory"
	},
	"_requiredBy": [
		"#USER"
	],
	"_resolved": "file:C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
	"_shasum": "762f64abdcff3ac4aaa425107b49b02cb4386ec6",
	"_shrinkwrap": null,
	"_spec": "C:\\Users\\David\\AppData\\Local\\Temp\\npm-git-117725-13600-x0yd79.599i93haor",
	"_where": "g:\\code\\melown",
	"author": "",
	"bugs": {
		"url": "https://github.com/proj4js/proj4js/issues"
	},
	"contributors": [
		{
			"name": "Mike Adair",
			"email": "madair@dmsolutions.ca"
		},
		{
			"name": "Richard Greenwood",
			"email": "rich@greenwoodmap.com"
		},
		{
			"name": "Calvin Metcalf",
			"email": "calvin.metcalf@gmail.com"
		},
		{
			"name": "Richard Marsden",
			"url": "http://www.winwaed.com"
		},
		{
			"name": "T. Mittan"
		},
		{
			"name": "D. Steinwand"
		},
		{
			"name": "S. Nelson"
		}
	],
	"dependencies": {
		"mgrs": "1.0.0",
		"wkt-parser": "^1.1.3"
	},
	"description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",
	"devDependencies": {
		"chai": "~1.8.1",
		"curl": "git://github.com/cujojs/curl.git",
		"grunt": "~0.4.2",
		"grunt-cli": "~0.1.13",
		"grunt-contrib-connect": "~0.6.0",
		"grunt-contrib-jshint": "~1.1.0",
		"grunt-contrib-uglify": "~0.11.1",
		"grunt-mocha-phantomjs": "~0.4.0",
		"grunt-rollup": "^1.0.1",
		"istanbul": "~0.2.4",
		"mocha": "~1.17.1",
		"rollup": "^0.41.4",
		"rollup-plugin-json": "^2.0.1",
		"rollup-plugin-node-resolve": "^2.0.0",
		"tin": "~0.4.0"
	},
	"directories": {
		"test": "test",
		"doc": "docs"
	},
	"gitHead": "3494d52f2c543b2ee7bea04292924a771dbd3eb8",
	"homepage": "https://github.com/proj4js/proj4js#readme",
	"license": "MIT",
	"main": "dist/proj4-src.js",
	"module": "lib/index.js",
	"name": "proj4",
	"optionalDependencies": {},
	"readme": "# PROJ4JS [![Build Status](https://travis-ci.org/proj4js/proj4js.svg)](https://travis-ci.org/proj4js/proj4js)\n\nProj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.\nOriginally a port of [PROJ.4](http://trac.osgeo.org/proj/) and [GCTCP C](http://edcftp.cr.usgs.gov/pub//software/gctpc) it is\na part of the [MetaCRS](http://wiki.osgeo.org/wiki/MetaCRS) group of projects.\n\n## Installing\n\nDepending on your preferences\n\n```bash\nnpm install proj4\nbower install proj4\ncomponent install proj4js/proj4js\n```\n\nor just manually grab the file `proj4.js` from the [latest release](https://github.com/proj4js/proj4js/releases)'s `dist/` folder.\n\nif you do not want to download anything, Proj4js is also hosted on [cdnjs](http://www.cdnjs.com/libraries/proj4js) for direct use in your browser applications.\n\n## Using\n\nthe basic signature is:\n\n```javascript\nproj4(fromProjection[, toProjection, coordinates])\n```\n\nProjections can be proj or wkt strings.\n\nCoordinates may an object of the form `{x:x,y:y}` or an array of the form `[x,y]`.\n\nWhen all 3 arguments  are given, the result is that the coordinates are transformed from projection1 to projection 2. And returned in the same format that they were given in.\n\n```javascript\nvar firstProjection = 'PROJCS[\"NAD83 / Massachusetts Mainland\",GEOGCS[\"NAD83\",DATUM[\"North_American_Datum_1983\",SPHEROID[\"GRS 1980\",6378137,298.257222101,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6269\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.01745329251994328,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4269\"]],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],PROJECTION[\"Lambert_Conformal_Conic_2SP\"],PARAMETER[\"standard_parallel_1\",42.68333333333333],PARAMETER[\"standard_parallel_2\",41.71666666666667],PARAMETER[\"latitude_of_origin\",41],PARAMETER[\"central_meridian\",-71.5],PARAMETER[\"false_easting\",200000],PARAMETER[\"false_northing\",750000],AUTHORITY[\"EPSG\",\"26986\"],AXIS[\"X\",EAST],AXIS[\"Y\",NORTH]]';\nvar secondProjection = \"+proj=gnom +lat_0=90 +lon_0=0 +x_0=6300000 +y_0=6300000 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\";\n//I'm not going to redefine those two in latter examples.\nproj4(firstProjection,secondProjection,[2,5]);\n// [-2690666.2977344505, 3662659.885459918]\n```\n\nIf only 1 projection is given then it is assumed that it is being projected *from* WGS84 (fromProjection is WGS84).\n\n```javascript\nproj4(firstProjection,[-71,41]);\n// [242075.00535055372, 750123.32090043]\n```\n\nIf no coordinates are given an object with two methods is returned, its methods are `forward` which projects from the first projection to the second and `inverse` which projects from the second to the first.\n\n```javascript\nproj4(firstProjection,secondProjection).forward([2,5]);\n// [-2690666.2977344505, 3662659.885459918]\nproj4(secondProjection,firstProjection).inverse([2,5]);\n// [-2690666.2977344505, 3662659.885459918]\n```\n\nand as above if only one projection is given, it's assumed to be coming from wgs84\n\n```javascript\nproj4(firstProjection).forward([-71,41]);\n// [242075.00535055372, 750123.32090043]\nproj4(firstProjection).inverse([242075.00535055372, 750123.32090043]);\n//[-71, 40.99999999999986]\n//the floating points to answer your question\n```\n\n## Named Projections\n\nIf you prefer to define a projection as a string and reference it that way, you may use the proj4.defs method which can be called 2 ways, with a name and projection:\n\n```js\nproj4.defs('WGS84', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n```\n\nor with an array\n\n```js\nproj4.defs([\n  [\n    'EPSG:4326',\n    '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees'],\n  [\n    'EPSG:4269',\n    '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees'\n  ]\n]);\n```\n\nyou can then do\n\n```js\nproj4('EPSG:4326');\n```\n\ninstead of writing out the whole proj definition, by default proj4 has the following projections predefined:\n\n- 'EPSG:4326', which has the following alias\n    - 'WGS84'\n- 'EPSG:4269'\n- 'EPSG:3857', which has the following aliases\n    - 'EPSG:3785'\n    - 'GOOGLE'\n    - 'EPSG:900913'\n    - 'EPSG:102113'\n\ndefined projections can also be accessed through the proj4.defs function (`proj4.defs('EPSG:4326')`).\n\nproj4.defs can also be used to define a named alias:\n\n```javascript\nproj4.defs('urn:x-ogc:def:crs:EPSG:4326', proj4.defs('EPSG:4326'));\n```\n\n## TypeScript\n\nTypeScript implementation was added to the [DefinitelyTyped repository](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\n```bash\n$ npm install --save @types/proj4\n```\n\n## Developing\nto set up build tools make sure you have node and grunt-cli installed and then run `npm install`\n\nto do the complete build and browser tests run\n\n```bash\nnode_modules/.bin/grunt\n```\n\nto run node tests run\n\n```bash\nnpm test\n```\n\nto run node tests with coverage run\n\n```bash\nnpm test --coverage\n```\n\nto create a build with only default projections (latlon and Mercator) run\n\n```bash\nnode_modules/.bin/grunt build\n```\n\nto create a build with only custom projections include a comma separated list of projections codes (the file name in 'lib/projections' without the '.js') after a colon, e.g.\n\n```bash\nnode_modules/.bin/grunt build:tmerc\n#includes transverse Mercator\nnode_modules/.bin/grunt build:lcc\n#includes lambert conformal conic\nnode_modules/.bin/grunt build:omerc,moll\n#includes oblique Mercator and Mollweide\n```\n",
	"readmeFilename": "README.md",
	"repository": {
		"type": "git",
		"url": "git://github.com/proj4js/proj4js.git"
	},
	"scripts": {
		"build": "grunt",
		"build:tmerc": "grunt build:tmerc",
		"test": "npm run build && istanbul test _mocha test/test.js"
	},
	"version": "2.4.4-alpha"
};

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_projections_tmerc__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_projections_etmerc__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_projections_utm__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_projections_sterea__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_projections_stere__ = __webpack_require__(107);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_projections_somerc__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_projections_omerc__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_projections_lcc__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_projections_krovak__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__lib_projections_cass__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__lib_projections_laea__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__lib_projections_aea__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__lib_projections_gnom__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__lib_projections_cea__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__lib_projections_eqc__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__lib_projections_poly__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__lib_projections_nzmg__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__lib_projections_mill__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__lib_projections_sinu__ = __webpack_require__(105);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__lib_projections_moll__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__lib_projections_eqdc__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__lib_projections_vandg__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__lib_projections_aeqd__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__lib_projections_ortho__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__lib_projections_geocent__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__lib_projections_qsc__ = __webpack_require__(104);


























/* harmony default export */ __webpack_exports__["a"] = (function(proj4){
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_0__lib_projections_tmerc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_1__lib_projections_etmerc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_2__lib_projections_utm__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_3__lib_projections_sterea__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_4__lib_projections_stere__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_5__lib_projections_somerc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_6__lib_projections_omerc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_7__lib_projections_lcc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_8__lib_projections_krovak__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_9__lib_projections_cass__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_10__lib_projections_laea__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_11__lib_projections_aea__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_12__lib_projections_gnom__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_13__lib_projections_cea__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_14__lib_projections_eqc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_15__lib_projections_poly__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_16__lib_projections_nzmg__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_17__lib_projections_mill__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_18__lib_projections_sinu__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_19__lib_projections_moll__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_20__lib_projections_eqdc__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_21__lib_projections_vandg__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_22__lib_projections_aeqd__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_23__lib_projections_ortho__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_24__lib_projections_geocent__["a" /* default */]);
  proj4.Proj.projections.add(__WEBPACK_IMPORTED_MODULE_25__lib_projections_qsc__["a" /* default */]);
});

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = sExpr;


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
	return __webpack_require__(47)("/*!\n * Copyright (c) 2017 Melown Technologies SE\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * *  Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * \n * *  Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return globals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return vec3Normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return vec3Length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return vec3Cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return simpleFmtCall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return getHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return stringToUint8Array; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return unint8ArrayToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return Utf8ArrayToStr; });\n\nvar globals = {\n    stylesheetData : {},\n    stylesheetLayers : {},\n    stylesheetBitmaps : {},\n    stylesheetFonts : {},\n    stylesheetConstants : {},\n    stylesheetVariables : {},\n    insidePack : false,\n    directPoints : [],\n    directPoint : null,\n    fonts : {},\n    fontsMap : {},\n    fontsStorage : {},\n    forceOrigin : false,\n    forceScale : [1,1,1],\n    bboxMin : [0,0,0],\n    bboxMax : [1,1,1],\n    geocent : false,\n    tileX : 0,\n    tileY : 0,\n    tileLod : 0,\n    tileSize : 1,\n    hitState : 0,\n    pixelFactor : 1,\n    alwaysEventInfo : true,\n    metricUnits : true,\n    language : 'en',\n    groupOptimize : true,\n    groupOrigin : [0,0,0],\n    messageBuffer : new Array(65536),\n    messageBufferIndex : 0,\n    messageBufferSize : 65536,\n    messagePackSize : 0,\n    signatureCounter : 0,\n    autoLod : false,\n    featureType : null,\n    groupId : null,\n    disableLog : false,\n    reduceMode : 'scr-count4',\n    reduceParams : null,\n    processLineLabel : false,\n    useLineLabel2 : false\n};\n\n\nfunction clamp(value, min, max) {\n    if (value < min) {\n        value = min;\n    }\n\n    if (value > max) {\n        value = max;\n    }\n\n    return value;\n}\n\n\nfunction vec3Normalize(a, b) {\n    b || (b = a);\n    var c = a[0],\n        d = a[1],\n        e = a[2],\n        g = Math.sqrt(c * c + d * d + e * e);\n    if (g) {\n        if (g == 1) {\n            b[0] = c;\n            b[1] = d;\n            b[2] = e;\n            return b;\n        }\n    } else {\n        b[0] = 0;\n        b[1] = 0;\n        b[2] = 0;\n        return b;\n    }\n    g = 1 / g;\n    b[0] = c * g;\n    b[1] = d * g;\n    b[2] = e * g;\n    return b;\n}\n\n\nfunction vec3Length(a) {\n    var b = a[0],\n        c = a[1];\n    a = a[2];\n    return Math.sqrt(b * b + c * c + a * a);\n}\n\n\nfunction vec3Cross(a, b, c) {\n    c || (c = a);\n    var d = a[0],\n        e = a[1];\n    a = a[2];\n    var g = b[0],\n        f = b[1];\n    b = b[2];\n    c[0] = e * b - a * f;\n    c[1] = a * g - d * b;\n    c[2] = d * f - e * g;\n    return c;\n}\n\n\nfunction getHash(str) {\n    if (!str || str.length === 0) {\n        return 0;    \n    }\n\n    var hash = 0, c;\n    for (var i = 0, li = str.length; i < li; i++) {\n        c   = str.charCodeAt(i);\n        hash  = ((hash << 5) - hash) + c;\n        hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n}\n\n\nvar simpleFmtCall = (function obj(str, call) {\n    if (!str || str == '') {\n        return '';\n    }\n\n    var i = str.indexOf('{'), li, str2;\n\n    if (i == -1) {\n        return str;\n    } else {\n        str2 = i > 0 ? str.substring(0, i) : '';\n    }\n\n    var counter = 0;\n    var begin = -1;\n\n    for (li = str.length; i < li; i++) {\n        var c = str.charAt(i);\n\n        if (c == '{') {\n            if (counter == 0) {\n                begin = i;\n            }\n\n            counter++;\n        } else if (c == '}') {\n            counter--;\n\n            if (counter == 0) {\n                str2 += call(str.substring(begin+1, i));\n            }\n            \n        } else if (counter == 0) {\n            str2 += c;\n        }\n    }\n\n    return str2;\n});\n\n/*\nfunction copyArrayToBuffer(view, index, array) {\n    for (var i = 0, li = array.length; i < li; i++) {\n        view.setFloat32(index, array[i]); index += 4;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayToBuffer(view, index, array) {\n    if (array) {\n        view.setUint8(index, array.length); index += 1;\n\n        for (var i = 0, li = array.length; i < li; i++) {\n            view.setFloat32(index, array[i]); index += 4;\n        }\n    } else {\n        view.setUint8(index, 0); index += 1;\n    }\n\n    return index;\n}\n\nfunction copyDynamicArrayOfArraysToBuffer(view, index, array) {\n    if (array) {\n        view.setUint16(index, array.length); index += 2;\n\n        for (var i = 0, li = array.length; i < li; i++) {\n            var subarray = array[i];\n\n            for (var j = 0, lj = array.length; j < lj; j++) {\n                view.setUint16(index, subarray[j]); index += 2;\n            }\n        }\n    } else {\n        view.setUint16(index, 0); index += 2;\n    }\n\n    return index;\n}\n\nfunction getSizeOfArrayOfArrays(array) {\n    var size = 0;\n\n    for (var i = 0, li = array.length; i < li; i++) {\n        size += array[i].length;\n    }\n\n    return size;\n}\n*/\n\n//var textEncoderUtf8 = null; //(typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\nvar textEncoderUtf8 = (typeof TextEncoder !== 'undefined') ? (new TextEncoder('utf-8')) : null;\n\nfunction stringToUint8Array(str) {\n    if (textEncoderUtf8) {\n        return textEncoderUtf8.encode(str);\n    } else {\n\n        /*\n        console.log('' + (str.length * 2));\n\n        var buffer = new ArrayBuffer(str.length * 2);\n        var view = new Uint16Array(buffer);\n        for (var i = 0, li = str.length; i < li; i++) {\n            view[i] = str.charCodeAt(i);\n        }\n        return new Uint8Array(buffer);\n        */\n\n\n        // 1. Let S be the DOMString value.\n        var s = String(str);\n\n        // 2. Let n be the length of S.\n        var n = s.length;\n\n        // 3. Initialize i to 0.\n        var i = 0;\n\n        // 4. Initialize U to be an empty sequence of Unicode characters.\n        var u = [];\n\n        // 5. While i < n:\n        while (i < n) {\n\n          // 1. Let c be the code unit in S at index i.\n          var c = s.charCodeAt(i);\n\n          // 2. Depending on the value of c:\n\n          // c < 0xD800 or c > 0xDFFF\n          if (c < 0xD800 || c > 0xDFFF) {\n            // Append to U the Unicode character with code point c.\n            u.push(c);\n          }\n\n          // 0xDC00  c  0xDFFF\n          else if (0xDC00 <= c && c <= 0xDFFF) {\n            // Append to U a U+FFFD REPLACEMENT CHARACTER.\n            u.push(0xFFFD);\n          }\n\n          // 0xD800  c  0xDBFF\n          else if (0xD800 <= c && c <= 0xDBFF) {\n            // 1. If i = n1, then append to U a U+FFFD REPLACEMENT\n            // CHARACTER.\n            if (i === n - 1) {\n              u.push(0xFFFD);\n            }\n            // 2. Otherwise, i < n1:\n            else {\n              // 1. Let d be the code unit in S at index i+1.\n              var d = s.charCodeAt(i + 1);\n\n              // 2. If 0xDC00  d  0xDFFF, then:\n              if (0xDC00 <= d && d <= 0xDFFF) {\n                // 1. Let a be c & 0x3FF.\n                var a = c & 0x3FF;\n\n                // 2. Let b be d & 0x3FF.\n                var b = d & 0x3FF;\n\n                // 3. Append to U the Unicode character with code point\n                // 2^16+2^10*a+b.\n                u.push(0x10000 + (a << 10) + b);\n\n                // 4. Set i to i+1.\n                i += 1;\n              }\n\n              // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n              // U+FFFD REPLACEMENT CHARACTER.\n              else  {\n                u.push(0xFFFD);\n              }\n            }\n          }\n\n          // 3. Set i to i+1.\n          i += 1;\n        }\n\n        // 6. Return U.\n        return new Uint8Array((new Uint32Array(u)).buffer);        \n    }\n}\n\n/*\nvar textDecoderUtf8 = TextEncoder ? (new TextDecoder('utf-8')) : null;\n\nfunction unint8ArrayToString(array) {\n    if (textDecoderUtf8) {\n        return textDecoderUtf8.decode(array);\n    } else {\n        return String.fromCharCode.apply(null, new Uint8Array(array.buffer));\n    }\n}\n*/\n\n\nvar textDecoderUtf8 = (typeof TextDecoder !== 'undefined') ? (new TextDecoder('utf-8')) : null;\n\nfunction unint8ArrayToString(array, skip) {\n    if (textDecoderUtf8 && !skip) {\n        return textDecoderUtf8.decode(array);\n    } else {\n        // return String.fromCharCode.apply(null, new Uint8Array(array.buffer)); //works only for small strings\n\n        var s = '';\n        //var code_points2 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        var code_points2 = new Uint8Array(array.byteLength);\n        code_points2.set(array);\n        var code_points = new Uint32Array(code_points2.buffer);\n\n        for (var i = 0, li = code_points.length; i < li; ++i) {\n          var cp = code_points[i];\n          if (cp <= 0xFFFF) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 0x10000;\n            s += String.fromCharCode((cp >> 10) + 0xD800,\n                                     (cp & 0x3FF) + 0xDC00);\n          }\n        }\n        return s;\n\n    }\n}\n\n\nfunction Utf8ArrayToStr(array, skip) {  //more universal\n    if (textDecoderUtf8 && !skip) {\n        return textDecoderUtf8.decode(array);\n    } else {\n\n        var out, i, len, c;\n        var char2, char3;\n\n        array = new Uint8Array(array);\n\n        out = \"\";\n        len = array.length;\n        i = 0;\n\n        while(i < len) {\n            c = array[i++];\n\n            switch(c >> 4) { \n              case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:\n                // 0xxxxxxx\n                out += String.fromCharCode(c);\n                break;\n              case 12: case 13:\n                // 110x xxxx   10xx xxxx\n                char2 = array[i++];\n                out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n                break;\n              case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode(((c & 0x0F) << 12) |\n                               ((char2 & 0x3F) << 6) |\n                               ((char3 & 0x3F) << 0));\n                break;\n            }\n        }\n\n        return out;\n    }\n}\n\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return optimizeGroupMessages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return postGroupMessageFast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return postGroupMessageLite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return postPackedMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return postPackedMessages; });\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */], stringToUint8Array = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"j\" /* stringToUint8Array */];\nvar tmpVertexBuffer = new Uint8Array(65536*4*4*4*4);\nvar tmpVertexBuffer2 = new Uint8Array(65536*4*4*4*4);\nvar packedEvents = [];\nvar packedTransferables = [];\n\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n    }\n}\n\n\nfunction postGroupMessageFast(command, type, message, buffers, signature) {\n\n    var message2 = stringToUint8Array(JSON.stringify(message));\n    var messageSize = 1+1+4+message2.byteLength, i, li;\n\n    for (i = 0, li = buffers.length; i < li; i++) {\n        messageSize += 4+buffers[i].byteLength;\n    }\n\n    var buff = new Uint8Array(messageSize);\n    var view = new DataView(buff.buffer), index = 0, index2 = 0;\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, message2.byteLength); index += 4;\n    buff.set(message2, index); index += message2.byteLength;\n    index2 = index;\n\n    for (i = 0, li = buffers.length; i < li; i++) {\n        view.setUint32(index, buffers[i].length); index += 4;\n        buff.set( new Uint8Array(buffers[i].buffer), index); index += buffers[i].byteLength;\n    }\n\n    postGroupMessageDirect(command, type, buff.buffer, index2, signature, message['hitable'], message['totalPoints'], (type == 11) ? message : null);\n}\n\n\nfunction postGroupMessageLite(command, type, number) {\n    var messageSize = 1+1+4, index = 0;\n\n    var buff = new ArrayBuffer(messageSize);\n    var view = new DataView(buff), index = 0;\n\n    view.setUint8(index, command); index += 1;\n    view.setUint8(index, type); index += 1;\n    view.setUint32(index, (number ? number : 0)); index += 4;\n\n    postGroupMessageDirect(command, type, buff, index, \"\");\n}\n\n\nfunction postGroupMessageDirect(command, type, message, buffersIndex, signature, hitable, totalPoints, job2) {\n\n    if (globals.messageBufferIndex >= globals.messageBufferSize) { \n        var oldBuffer = globals.messageBuffer; \n        globals.messageBufferSize += 65536;\n        globals.messageBuffer = new Array(globals.messageBufferSize);\n        \n        for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n            globals.messageBuffer[i] = oldBuffer[i];\n        }\n    }\n    \n    globals.messageBuffer[globals.messageBufferIndex] = { command: command, type: type, job : message, buffersIndex: buffersIndex, signature: signature, hitable: hitable, totalPoints: totalPoints, job2: job2 };\n    globals.messageBufferIndex++;\n    globals.messagePackSize += message.byteLength;\n}\n\n\nfunction setToTmpBuffer(index, buffer2, offset) {\n    var buffer = (index == 1) ? tmpVertexBuffer2 : tmpVertexBuffer;\n\n    if (buffer.byteLength <= buffer2.byteLength + offset) {\n        var buffer3 = new Uint8Array(buffer.byteLength * 2);\n        buffer3.set(buffer, 0);\n        buffer = buffer3;\n\n        if (index == 1) {\n            tmpVertexBuffer2 = buffer;\n        } else {\n            tmpVertexBuffer = buffer;\n        }\n    }\n\n    buffer.set(buffer2, offset);\n}\n\n\nfunction optimizeGroupMessages() {\n\n    //loop messages\n    var messages = globals.messageBuffer;\n    var j, lk, k, message2, job2, bufferSize, buffer, view, index, length, buff, buff2, index, count, totalVertices;\n\n\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        var message = messages[i];\n        var job = message.job;\n        var type = message.type;\n        var signature = message.signature;\n\n        //console.log('command: ' + message.command + ' type:' + message.type);\n        \n        if (!message.hitable && !message.reduced && \n            (type >= 6 && type <= 13)) {\n            \n            switch(type) {\n            case 13:\n            case 6:\n                count = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex) * 4;\n\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex) * 4;\n\n                        // copy vertices to buffer\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        bufferSize += length;\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n                    buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                    view = new DataView(buffer.buffer);\n                    buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n                }\n\n                break;\n                    \n            case 9:\n            case 11:\n            case 7:\n\n                count = 0;\n                totalVertices = 0;\n\n                //get message vertices length and copy vertices to buffer\n                length = (new DataView(message.job)).getUint32(message.buffersIndex);\n                //console.log('count: ' + count + ' totalPoints:' + message.totalPoints + ' length: ' + length);\n                length *= 4;\n                totalVertices += length;\n\n\n                //tmpVertexBuffer.set(new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                //tmpVertexBuffer2.set(new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\n                setToTmpBuffer(0, new Uint8Array(message.job, message.buffersIndex+4, length), 0);\n                setToTmpBuffer(1, new Uint8Array(message.job, message.buffersIndex+4+length+4, length), 0);\n                bufferSize = length;\n\n                for (j = i + 1; j < li; j++) {\n                    message2 = messages[j];\n\n                    if (message2.signature == signature) {\n                        message2.reduced = true;\n                        globals.messagePackSize -= message2.job.byteLength;\n                        count++;\n\n                        //get message2 vertices length\n                        length = (new DataView(message2.job)).getUint32(message2.buffersIndex);\n                        //console.log('count:' + count + ' totalPoints:' + message2.totalPoints + ' length:' + length + ' jobl:' + message2.job.byteLength + ' remaning:' + (message2.job.byteLength - (message2.buffersIndex+4)) + ' bufferSize:' + bufferSize + ' totalVertices:' + totalVertices);\n                        length *= 4;\n                        totalVertices += length;\n\n\n                        // copy vertices to buffer\n                        //tmpVertexBuffer.set(new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n                        setToTmpBuffer(0, new Uint8Array(message2.job, message2.buffersIndex+4, length), bufferSize);\n\n                        // copy normals to buffer\n                        //tmpVertexBuffer2.set(new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\n                        setToTmpBuffer(1, new Uint8Array(message2.job, message2.buffersIndex+4+length+4, length), bufferSize);\n                        bufferSize += length;\n\n                        if (type == 11) {\n                            var files = message.job2['files'];\n                            var files2 = message2.job2['files'];\n\n                            for (k = 0, lk = files2.length; k < lk; k++) {\n                                if (!files[k]) {\n                                    files[k] = [];\n                                }\n\n                                for (var m = 0, lm = files2[k].length; m < lm; m++) {\n                                    if (files[k].indexOf(files2[k][m]) == -1) {\n                                        files[k].push(files2[k][m]);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (count > 0) {\n\n                    //create new message with merged vertices\n\n                    if (type == 11) { //we have to rebuild header\n                        var buffjob = stringToUint8Array(JSON.stringify(message.job2));\n\n                        buffer = new Uint8Array(1+1+4+buffjob.byteLength+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer), index = 0;\n\n                        view.setUint8(index, message.command); index += 1;\n                        view.setUint8(index, type); index += 1;\n                        view.setUint32(index, buffjob.byteLength); index += 4;\n                        buffer.set(buffjob, index); index += buffjob.byteLength;\n\n                        message.buffersIndex = index;\n                    } else {\n                        buffer = new Uint8Array(message.buffersIndex+2*(4+bufferSize));\n                        view = new DataView(buffer.buffer);\n                        buffer.set(new Uint8Array(message.job, 0, message.buffersIndex), 0);\n                    }\n\n                    view.setUint32(message.buffersIndex, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer.buffer, 0, bufferSize), message.buffersIndex + 4);\n\n                    view.setUint32(message.buffersIndex + 4 + bufferSize, bufferSize / 4);\n                    buffer.set(new Uint8Array(tmpVertexBuffer2.buffer, 0, bufferSize), message.buffersIndex + 4 + bufferSize + 4 );\n\n                    globals.messagePackSize -= message.job.byteLength;\n                    globals.messagePackSize += buffer.byteLength;\n                    message.job = buffer.buffer;\n\n                }\n\n                break;\n            }\n        \n        }\n    }\n\n    var buffer = new Uint8Array(globals.messagePackSize), index = 0;\n\n    for (var i = 0, li = globals.messageBufferIndex; i < li; i++) {\n        var message = globals.messageBuffer[i];\n\n        if (!message.reduced) {\n            buffer.set(new Uint8Array(message.job), index);\n            index += globals.messageBuffer[i].job.byteLength;\n        }\n    }\n\n    //console.log('send:' + buffer.length);\n\n    postPackedMessage({'command' : 'addPackedCommands', 'buffer': buffer}, [buffer.buffer]);\n\n    globals.messageBufferIndex = 0;\n    globals.messagePackSize = 0;\n} \n\n\nfunction postPackedMessages() {\n    if (packedEvents.length > 0) {\n        if (packedTransferables.length > 0) {\n            postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n        } else {\n            postMessage({'command': 'packed-events', 'messages':packedEvents});\n        }\n\n        packedEvents = [];\n        packedTransferables = [];\n    }\n}\n\n\n\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_text_js__ = __webpack_require__(3);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getFilterResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return processStylesheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return getLayerPropertyValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getLayerExpresionValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return getLayerPropertyValueInner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return makeFasterFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return hasLayerProperty; });\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */];\nvar clamp = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"d\" /* clamp */];\nvar simpleFmtCall = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"e\" /* simpleFmtCall */];\nvar getHash = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"f\" /* getHash */];\nvar hasLatin = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\"c\" /* hasLatin */], isCJK = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\"d\" /* isCJK */];\nvar areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\"e\" /* areTextCharactersAvailable */];\n\n\nvar getLayer = function(layerId, featureType, index) {\n    var layer = globals.stylesheetData.layers[layerId];\n    if (layer == null) {\n        logError('wrong-Layer', layerId, null, null, index, featureType);\n        return {};\n    } else {\n        return layer;\n    }\n};\n\n\nvar getLayerExpresionValue = function(layer, value, feature, lod, key, depth) {\n    var finalValue;\n    if (!depth) {\n        depth = 0;\n    }\n    if (depth > 100) {\n        return void(0);\n    }\n\n\n    switch(typeof value) {\n    case 'string':\n\n        if (value.length > 0) {\n\n            switch (value.charAt(0)) {\n                case '#': \n                case '$':\n                case '@':\n                case '&':\n                case '%':\n\n                    finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth + 1);\n\n                    if (typeof finalValue == 'undefined') {\n                        logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                    }\n\n                    return finalValue;\n            }\n\n\n            return simpleFmtCall(value, (function(str){  \n\n                if (str.length > 0) {\n\n                    switch (str.charAt(0)) {\n                        case '#': \n                        case '$':\n                        case '@':\n                        case '&':\n                        case '%':\n\n                            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, str, depth + 1);\n\n                            if (typeof finalValue == 'undefined') {\n                                logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            }\n        \n                            return finalValue;\n                    }\n\n                    if (str.indexOf('{') != -1) {\n\n                        try {\n                            str = str.replace(/'/g, '\"');\n                            finalValue = JSON.parse(str);\n                        } catch(e) {\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            return \"\";\n                        }\n\n                        if (typeof finalValue == 'undefined') {\n                            logError('wrong-expresion', layer['$$layer-id'], value, value, null, 'feature-property');\n                            return \"\";\n                        } else {\n                            return getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth + 1);\n                        }\n\n                    } else {\n                        return str;\n                    }\n\n                }\n\n            }));\n        }\n\n        break;\n    }\n    \n    return value;\n};\n\n\nvar hasLayerProperty = function(layer, key) {\n    return (typeof layer[key] !== 'undefined');\n};\n\n\nvar getLayerPropertyValue = function(layer, key, feature, lod) {\n    var value = getLayerPropertyValueInner(layer, key, feature, lod);\n    return validateLayerPropertyValue(layer['$$layer-id'], key, value);\n};\n\n\nvar getLayerPropertyValueInnerString = function(layer, key, feature, lod, value, depth) {\n    var finalValue = value;\n\n    //is it feature property, variable or constant?\n    switch(value.charAt(0)) {\n        case '$': finalValue = feature.properties[value.substr(1)]; break;\n        case '@': finalValue = globals.stylesheetConstants[value]; break;\n        case '%': finalValue = globals.stylesheetVariables[value.substr(1)]; break;\n        case '&': finalValue = globals.stylesheetLocals[value]; break;\n        case '#': \n            //debugger;\n            switch(value) {\n                case '#id':        return feature.id;\n                case '#type':      return globals.featureType;\n                case '#group':     return globals.groupId;\n                case '#lod':       return globals.tileLod;\n                case '#tileSize':  return globals.tileSize;\n                case '#pixelSize': return globals.pixelSize;\n                case '#metric':    return globals.metricUnits;\n                case '#dpr':       return globals.pixelFactor;\n                case '#language':  return globals.language;\n            }\n            break;\n    }\n\n    if (value.charAt(0) == '&') {\n        if (typeof finalValue === 'undefined') {\n            finalValue = layer[value];\n            if (typeof finalValue !== 'undefined') {\n\n                if (typeof finalValue === 'string') {\n                    finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\n                } else {\n                    if (typeof finalValue !== 'undefined') {\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\n                    }\n                }\n\n                globals.stylesheetLocals[value] = finalValue;\n            }\n        }\n    } else { // @,$,%\n\n        if (typeof finalValue === 'string') {\n            finalValue = getLayerExpresionValue(layer, finalValue, feature, lod, key, depth+1);\n        } else {\n            if (typeof finalValue !== 'undefined' && value.charAt(0) == '@') {\n                finalValue = getLayerPropertyValueInner(layer, key, feature, lod, finalValue, depth+1);\n            }\n        }\n\n    }\n\n    return finalValue;\n};\n\nvar getLayerPropertyValueInner = function(layer, key, feature, lod, value, depth) {\n    var index = 0, i, li, finalValue, root, v1, v2, v3, v4;\n    var tmpValue;\n\n    \n    if ((typeof value) === 'undefined') {\n        /*\n        if (layer[key]) {\n            value = JSON.parse(JSON.stringify(layer[key])); //make copy\n        } else {\n            value = layer[key];\n        }*/\n\n        value = layer[key];\n\n        root = true;\n        depth = 0;\n    } else {\n        if (depth > 100) {\n            return void(0);\n        }\n    }\n\n    switch(typeof value) {\n    case 'string':\n\n        if (value.length > 0) {\n            finalValue = getLayerPropertyValueInnerString(layer, key, feature, lod, value, depth);\n\n            if (typeof finalValue !== 'undefined') {\n                return finalValue;\n            } else {\n                logError('wrong-object', layer['$$layer-id'], key, value, null, 'feature-property');\n                \n                if (root) {\n                    return getDefaultLayerPropertyValue(key);\n                } else {\n                    return void(0);\n                }\n            }\n        }\n\n        return value;\n\n    case 'object':\n\n            //is it null?\n        if (value == null) {\n            if (root) {\n                return getDefaultLayerPropertyValue(key);\n            } else {\n                return void(0);\n            }\n        }\n\n        //is it array (rgb, rgba, vec2)?\n        if (Array.isArray(value)) {\n\n            if (key == 'icon-source') {\n                //index++;\n                if (globals.stylesheetBitmaps[value[0]] == null) {\n                    logError('wrong-object', layer['$$layer-id'], key, value, null, 'bitmap');\n\n                    if (root) {\n                        return getDefaultLayerPropertyValue(key);\n                    } else {\n                        return void(0);\n                    }\n                }\n            }\n\n            if (key != 'filter') {\n                tmpValue = new Array(value.length);\n\n                for (i = index, li = value.length; i < li; i++) {\n                    tmpValue[i] = getLayerPropertyValueInner(layer, key, feature, lod, value[i], depth + 1);\n                }\n\n                return tmpValue;\n            }\n\n            return value;\n        }\n\n        var functionName, functionValue, functionError, finalValue;\n\n        for (functionName in value) {\n            break;\n        }\n\n        if (!functionName) {\n            if (root) {\n                return getDefaultLayerPropertyValue(key);\n            } else {\n                return void(0);\n            }\n        }\n\n        functionValue = value[functionName];\n\n        switch (functionName) {\n            case 'if':\n\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\n                    functionError = true;\n                } else {\n                    if (getFilterResult(functionValue[0], feature, globals.featureType, globals.groupId, layer, key, lod, 0)) {\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                    } else {\n                        finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n                    }\n\n                    if (typeof finalValue === 'undefined') {\n                        functionError = true;\n                    } else {\n                        return finalValue;\n                    }\n                }\n\n                break;\n\n            case 'add':\n            case 'sub':\n            case 'mul':\n            case 'div':\n            case 'mod':\n            case 'pow':\n            case 'tofixed':\n            case 'atan2':\n            case 'random':\n\n                if (!Array.isArray(functionValue) || functionValue.length != 2) {\n                    functionError = true;\n                } else {\n\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number') {\n                        functionError = true;\n                    } else {\n                        switch (functionName) {\n                            case 'add':    return v1 + v2;\n                            case 'sub':    return v1 - v2;\n                            case 'mul':    return v1 * v2;\n                            case 'div':    return v1 / v2;\n                            case 'mod':    return v1 % v2;\n                            case 'pow':    return Math.pow(v1, v2);\n                            case 'atan2':  return Math.atan2(v1, v2);\n                            case 'tofixed': return v1.tofixed(v2);\n                            case 'random': return v1 + Math.random() * (v2-v1);\n                        }\n                    }\n                }\n\n                break;\n\n            case 'clamp':\n\n                if (!Array.isArray(functionValue) || functionValue.length != 3) {\n                    functionError = true;\n                } else {\n\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                    v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                    if (typeof v1 !== 'number' || typeof v2 !== 'number' || typeof v3 !== 'number') {\n                        functionError = true;\n                    } else {\n                        return clamp(v1, v2, v3);\n                    }\n                }\n\n                break;\n\n            case 'logScale':\n            case 'log-scale':\n\n                if (!Array.isArray(functionValue) || functionValue.length < 2) {\n                    functionError = true;\n                } else {\n\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n                    v3 = 0, v4 = 100;\n\n                    if (functionValue.length > 2) {\n                        v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);                        \n\n                        if (typeof v3 !== 'number') {\n                            functionError = true;\n                        }\n                    }\n\n                    if (functionValue.length > 3) {\n                        v4 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[3], depth + 1);                        \n\n                        if (typeof v4 !== 'number') {\n                            functionError = true;\n                        }\n                    }\n\n                    if (functionError || typeof v1 !== 'number' || typeof v2 !== 'number') {\n                        functionError = true;\n                    } else {\n                        var imax = v4, imin = v3, smax = v2, s = v1, p, i;\n\n                        if (s > smax) s = smax; \n\n                        p = (imax - imin) / Math.log(smax + 1);\n                        i = p * Math.log(s + 1) + imin;\n\n                        return i;\n                    }\n                }\n\n                break;\n\n\n            case 'sgn':\n            case 'sin':\n            case 'cos':\n            case 'tan':\n            case 'asin':\n            case 'acos':\n            case 'atan':\n            case 'sqrt':\n            case 'abs':\n            case 'log':\n            case 'round':\n            case 'floor':\n            case 'ceil':\n            case 'deg2rad':\n            case 'rad2deg':\n\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\n\n                if (typeof functionValue !== 'number') {\n                    functionError = true;\n                } else {\n                    switch (functionName) {\n                        case 'sgn':  return functionValue < 0 ? -1 : 1;\n                        case 'sin':  return Math.sin(functionValue);\n                        case 'cos':  return Math.cos(functionValue);\n                        case 'tan':  return Math.tan(functionValue);\n                        case 'asin': return Math.asin(functionValue);\n                        case 'acos': return Math.acos(functionValue);\n                        case 'atan': return Math.atan(functionValue);\n                        case 'sqrt': return Math.sqrt(functionValue);\n                        case 'abs':  return Math.abs(functionValue);\n                        case 'log':  return Math.log(functionValue);\n                        case 'round': return Math.round(functionValue);\n                        case 'floor': return Math.floor(functionValue);\n                        case 'ceil':  return Math.ceil(functionValue);\n                        case 'deg2rad':  return (functionValue / 180) * Math.PI;\n                        case 'rad2deg':  return (functionValue / Math.PI) * 180;\n                    }\n                }\n\n                break;\n\n            case 'strlen':\n            case 'trim':\n            case 'str2num':\n            case 'lowercase':\n            case 'uppercase':\n            case 'capitalize':\n            case 'has-fonts':\n            case 'has-latin':\n            case 'is-cjk':\n                functionValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue, depth + 1);\n\n                if (typeof functionValue !== 'string') {\n                    if (typeof functionValue === 'number') {\n                        return functionValue;\n                    } else {\n                        functionError = true;\n                    }\n                } else {\n                    switch (functionName) {\n                        case 'strlen':     return functionValue.length;\n                        case 'trim':       return functionValue.trim();\n                        case 'str2num':    return parseFloat(functionValue);\n                        case 'lowercase':  return functionValue.toLowerCase();\n                        case 'uppercase':  return functionValue.toUpperCase();\n                        case 'capitalize': return functionValue.replace(/(?:^|\\s)\\S/g, function(a) { return a.toUpperCase(); });\n                        case 'has-fonts':  return areTextCharactersAvailable(functionValue);\n                        case 'has-latin':  return hasLatin(functionValue);\n                        case 'is-cjk':     return isCJK(functionValue); \n                    }\n                }\n\n                break;\n\n            case 'find':\n            case 'replace':\n            case 'substr':\n\n                if (Array.isArray(functionValue) && functionValue.length >= 2) {\n\n                    v1 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n                    v2 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[1], depth + 1);\n\n                    if (functionName == 'find' && typeof v1 === 'string' && typeof v2 === 'string') {\n                        return v1.indexOf(v2);\n                    }\n\n                    if (functionName == 'replace' && functionValue.length == 3) {\n\n                        v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                        if (typeof v1 === 'string' && typeof v2 === 'string' && typeof v3 === 'string') {\n                            return v1.replace(v2,v3);\n                        }\n                    }\n\n                    if (functionName == 'substr') {\n\n                        if (functionValue.length == 2) {\n                            if (typeof v1 === 'string' && typeof v2 === 'number') {\n                                return v1.substr(v2);\n                            }\n                        } else {\n                            v3 = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n\n                            if (typeof v1 === 'string' && typeof v2 === 'number' && typeof v3 === 'number') {\n                                return v1.substr(v2,v3);\n                            }\n                        }\n                    }\n\n                }\n\n                functionError = true;\n                break;\n\n            case 'min':\n            case 'max':\n\n                if (!Array.isArray(functionValue)) {\n                    functionError = true;\n                } else {\n\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n\n                    for (i = index, li = functionValue.length; i < li; i++) {\n                        tmpValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[i], depth + 1);\n\n                        if (typeof tmpValue !== 'number') {\n                            functionError = true;\n                            break;\n                        }\n\n                        if (functionName == 'max') {\n                            finalValue = Math.max(finalValue, tmpValue);\n                        } else {\n                            finalValue = Math.min(finalValue, tmpValue);\n                        }\n                    }\n\n                    return finalValue;\n                }\n\n                break;\n\n            case 'map':\n\n                if (!Array.isArray(functionValue)) {\n                    functionError = true;\n                } else {\n\n                    finalValue = getLayerPropertyValueInner(layer, key, feature, lod, functionValue[0], depth + 1);\n\n                    var mapItems = functionValue[1];\n\n                    if (!Array.isArray(mapItems)) {\n                        functionError = true;\n                    } else {\n\n                        for (i = index, li = mapItems.length; i < li; i++) {\n                            var item = mapItems[i];\n\n                            if (!Array.isArray(item)) {\n                                functionError = true;\n                                break;\n                            } else {\n\n                                var itemValue = getLayerPropertyValueInner(layer, key, feature, lod, item[0], depth + 1);\n\n                                if (finalValue == itemValue) {\n                                    return getLayerPropertyValueInner(layer, key, feature, lod, item[1], depth + 1);\n                                }\n                            }\n                        }\n                    }\n\n                    return getLayerPropertyValueInner(layer, key, feature, lod, functionValue[2], depth + 1);\n                }\n\n                break;\n\n            case 'linear':\n            case 'linear2':\n            case 'discrete':\n            case 'discrete2':\n            case 'lod-scaled':\n\n                //LOD based functions\n                var stops = null;\n                var lodScaledArray = null;\n                var functionValue = lod;\n\n                if (value['lod-scaled'] != null) {\n                    var array = value['lod-scaled'];\n\n                    if ((typeof array[1]) == 'number') {\n                        return array[1] * Math.pow(2*array[2], array[0] - lod);\n                    }\n\n                    stops = array[1];\n                    lodScaledArray = array;\n\n                } if (value['discrete2'] != null || value['linear2'] != null) {\n                    var array = value['discrete2'] || value['linear2'];\n                    stops = array[1];\n                    functionValue = getLayerPropertyValueInner(layer, key, feature, lod, array[0], depth + 1);\n                } else {\n                    stops = value['discrete'] || value['linear'];\n                }\n\n                var lastLod = stops[0][0];\n                var lastValue = stops[0][1];\n                var valueType = (typeof lastValue);\n                var newValue = lastValue;\n\n                var currentLod, currentValue;\n\n                for (var i = 0, li = stops.length; i <= li; i++) {\n\n                    if (i == li) {\n                        newValue = lastValue;\n                        break;\n                    }\n\n                    if (stops[i][0] > functionValue) {\n\n                        if (value['discrete'] != null || value['discrete2'] != null || lodScaledArray != null) { //no interpolation\n                            newValue = lastValue;\n                            break;\n                        } else { //interpolate\n\n                            currentLod = stops[i][0];\n                            currentValue = stops[i][1];\n\n                            if (currentLod == lastLod) { //end of array no interpolation needed\n                                break;\n                            }\n\n                            switch(valueType) {\n\n                            case 'boolean':\n                                lastValue = lastValue ? 1 : 0;\n                                currentValue = lastValue ? 1 : 0;\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\n\n                                newValue = newValue > 0.5 ? true : false;\n                                break;\n\n                            case 'number':\n                                newValue = lastValue + (currentValue - lastValue) * ((functionValue - lastLod) / (currentLod - lastLod));\n                                break;\n\n                            case 'object':\n                                newValue = [];\n\n                                for (var j = 0, lj= lastValue.length; j < lj; j++) {\n                                    newValue[j] = lastValue[j] + (currentValue[j] - lastValue[j]) * ((functionValue - lastLod) / (currentLod - lastLod));\n                                }\n\n                                break;\n                            }\n\n                            break;\n                        }\n                    }\n\n                    lastLod = stops[i][0];\n                    lastValue = stops[i][1];\n                }\n\n                if (lodScaledArray != null) {\n                    newValue *= Math.pow(2*lodScaledArray[2], lodScaledArray[0] - functionValue);\n                }\n\n                return newValue;\n\n            default: \n                functionError = true;\n                break;\n        }\n\n        if (functionError) {\n            if (root) {\n                return getDefaultLayerPropertyValue(key);\n            } else {\n                return void(0);\n            }\n        }\n\n\n    case 'number':\n    case 'boolean':\n        return value;\n    }\n\n    if (root) {\n        return getDefaultLayerPropertyValue(key);\n    } else {\n        return void(0);\n    }\n};\n\n\nvar inheritLayer = function(layerId, layer, layerData, stylesheetLayersData, depth) {\n    if (depth > 100) {\n        logError('custom', 'infinite inherit loop in Layer: ' + layerId);\n        return;\n    }\n\n    //do we need inherite Layer?\n    if (layerData['inherit'] != null) {\n        //get inherited Layer\n        var LayerToInherit = stylesheetLayersData['layers'][layerData['inherit']];\n\n        if (LayerToInherit != null) {\n\n            if (LayerToInherit['inherit'] != null) {\n                inheritLayer(layerData['inherit'], layer, LayerToInherit, stylesheetLayersData, depth++);\n            }\n\n            //copy inherited Layer properties\n            for (var key in LayerToInherit) {\n                layer[key] = LayerToInherit[key];\n            }\n        } else {\n            logError('wrong-object', layerId, 'inherit', LayerToInherit, 'Layer');\n            return getDefaultLayerPropertyValue(key);\n        }\n    }\n};\n\n\nvar copyLayer = function(layerId, layer, layerData, stylesheetLayersData) {\n    //do we need inherite Layer?\n    if (layerData['inherit'] != null) {\n        inheritLayer(layerId, layer, layerData, stylesheetLayersData, 0);\n    }\n\n    //copy Layer properties\n    //if inherited properties are present then they will be overwriten\n    for (var key in layerData) {\n        layer[key] = layerData[key];\n    }\n\n    //store layer id\n    layer['$$layer-id'] = layerId;\n};\n\n\nvar logError = function(errorType, layerId, key, value, index, subkey) {\n    if (globals.disableLog) {\n        return;\n    }\n\n    if ((typeof value) == 'object') {\n        value = JSON.stringify(value);\n    }\n    \n    var str = null;\n\n    switch(errorType) {\n    case 'wrong-property-value':\n        str = 'Error: wrong layer property ' + (subkey ? ('\\'' + subkey + '\\'') : '') + ': ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-property-value[]':\n        str = 'Error: wrong layer property ' + (subkey ? ('\\'' + subkey + '\\'') : '') + '['+index+']: ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-object':\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + ' = ' + value;\n        break;\n\n    case 'wrong-object[]':\n        str = 'Error: reffered '+ subkey + ' does not exist: ' + layerId + '.' + key + '['+index+'] = ' + value;\n        break;\n\n    case 'wrong-Layer':\n        str = 'Error: reffered '+ subkey + ' Layer does not exist: ' + subkey + '['+index+'].Layer = ' + layerId;\n        break;\n\n    case 'wrong-bitmap':\n        str = 'Error: wrong definition of bitmap: ' + layerId;\n        break;\n\n    case 'custom':\n        str = 'Error: ' + layerId;\n        break;\n    }\n    \n    if (str && globals.log) {\n         // eslint-disable-next-line \n        console.log(str);\n        //throw str;\n    }\n};\n\n\nvar getUnitsNormalizedValue = function(value, screen, fallbackUnits) {\n    if (typeof value === 'string') {\n        if (value == '0' || value.length == 0) return 0;\n\n        value = value.trim();\n\n        if (value.length >= 2) {\n\n            var factor = 1, pf = globals.pixelsPerMM, ipf = globals.invPixelsPerMM;\n\n            switch(value.substr(-2, 2)) {\n                case 'km': factor = screen ? pf * 1000 * 1000 : 1000; break;\n                case 'cm': factor = screen ? pf * 10 : 1/100; break;\n                case 'mm': factor = screen ? pf : 1/1000; break;\n                case 'px': factor = screen ? 1 : ipf * 1/1000; break;\n                case 'pc': factor = screen ? pf * 2.54 * 1/6 : ipf * 1/1000 * 2.54 * 1/6; break;\n                case 'pt': factor = screen ? pf * 2.54 * 1/72 : ipf * 1/1000 * 2.54 * 1/72; break;\n                case 'in': factor = screen ? pf * 2.54 : ipf * 1/1000 * 2.54; break;\n\n                default:\n\n                    if (value.charAt(value.length - 1) == 'm') {\n                        return (screen ? pf * 1000 : 1) * parseFloat(value.substr(0, value.length - 1));\n                    } else {\n                        return parseFloat(value);\n                    }\n\n            }\n\n            return factor * parseFloat(value.substr(0, value.length - 2));\n\n        } else {\n\n            //fallbackUnits\n\n            return parseFloat(value);\n        }\n\n    } else if (typeof value === 'number') {\n        return value;\n    }\n}\n\n\nvar validateValue = function(layerId, key, value, type, arrayLength, min, max) {\n    var i, li;\n\n    //check for object\n    if (value != null && (typeof value) == 'object' && !Array.isArray(value)) {\n        logError('wrong-property-value', layerId, key, value);\n        return getDefaultLayerPropertyValue(key);\n    }\n\n    //check value type\n    if ((typeof value) != type) {\n        //check for exceptions\n        if (!(value === null && (key == 'icon-source' || key == 'visibility' || key == 'label-no-overlap-factor'))) {\n            logError('wrong-property-value', layerId, key, value);\n            return getDefaultLayerPropertyValue(key);\n        }\n    }\n\n    //check value\n    switch(typeof value) {\n\n    case 'object':\n\n        //accepted cases for null value\n        if (value === null && (key == 'line-style-texture' || key == 'icon-source' || 'dynamic-reduce' || 'reduce' ||\n            key == 'hysteresis' || key == 'visibility' || key == 'visibility-abs' || key == 'visibility-rel' || key == 'next-pass')) {\n            return value;\n        }\n\n        //check reduce\n        if (key == 'reduce' || key == 'dynamic-reduce' || key == 'label-no-overlap-factor' || key == 'line-points') {\n            if (Array.isArray(value) && value.length > 0 && (typeof value[0] === 'string')) {\n\n                if (key == 'line-points') {\n\n                    if (!(value[0] == 'vertices' || value[0] == 'by-length' || value[0] == 'by-ratio' || value[0] == 'endpoints' ||\n                          value[0] == 'start' || value[0] == 'end' || value[0] == 'middle' || value[0] == 'midpoint')) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    } \n\n                } else if (key == 'dynamic-reduce') {\n                    if (value[0] == 'by-extenal-param') {\n                        value[0] = globals.reduceMode;\n                    }\n\n                    if (!((value[0] == 'tilt' || value[0] == 'tilt-cos' || value[0] == 'tilt-cos2' || value[0] == 'scr-count' || value[0] == 'scr-count2' ||\n                           value[0] == 'scr-count3' || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8') &&\n                        (typeof value[1] === 'number') && ((typeof value[2] === 'number') || value[0] == 'scr-count4' || value[0] == 'scr-count5' || value[0] == 'scr-count6' || value[0] == 'scr-count7' || value[0] == 'scr-count8'))) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                } else if (key == 'reduce') {\n                    if (value[0] != 'odd' && value != 'even') {\n                        if ((typeof value[1] !== 'number') || ((value[0] != 'top' || value != 'bottom') && (typeof value[2] !== 'string'))) {\n                            logError('wrong-property-value', layerId, key, value);\n                            return getDefaultLayerPropertyValue(key);\n                        }\n                    }\n                } else if (key == 'label-no-overlap-factor') {\n                    if (!(value[0] == 'direct' || value[0] == 'div-by-dist')) {\n                        logError('wrong-property-value', layerId, key, value);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //check multipasss\n        if (key == 'next-pass' || key == 'visibility-switch') {\n            var vswitch = (key == 'visibility-switch');\n            if (Array.isArray(value) && value.length > 0) {\n\n                for (i = 0; i < li; i++) {\n                    var valueItem = value[i];\n\n                    if (!(typeof valueItem == 'object' &&\n                            Array.isArray(valueItem) &&\n                            valueItem.length == 2 &&\n                            typeof valueItem[0] == 'number' &&\n                            (typeof valueItem[1] == 'string' || (vswitch && valueItem[1] === null)))) {\n\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                        return getDefaultLayerPropertyValue(key);\n                    } else {\n                        //fast constant \n                        if (typeof valueItem[1] == 'string' && valueItem[1].charAt(0) == '@') {\n                            if (typeof globals.stylesheetConstants[valueItem[1]] == 'undefined') {\n                                logError('wrong-property-value[]', layerId, key, value, i);\n                                return getDefaultLayerPropertyValue(key);\n                            } else {\n                                valueItem[1] = globals.stylesheetConstants[valueItem[1]];\n                            }\n                        }\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'label-font' || key == 'line-label-font') {\n\n            if (!Array.isArray(value) || value.length < 1) {\n                logError('wrong-property-value[]', layerId, key, value, 0);\n                return getDefaultLayerPropertyValue(key);\n            } else {\n                for (i = 0, li = value.length; i < li; i++) {\n                    if (typeof value[i] != 'string' || !globals.fonts[value[i]]) {\n                        logError('wrong-property-value[]', layerId, key, value, 0);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n            }\n\n            return value;\n        }\n\n        //check array\n        if (arrayLength != null) {\n            if (Array.isArray(value) && (value.length == arrayLength || ((key == 'icon-stick' || 'label-stick') && value.length >= 7) )) {\n\n                //validate array values\n                i = 0;\n\n                if (key == 'icon-source' || key == 'line-style-texture') {\n                    if (typeof value[0] != 'string') {\n                        logError('wrong-property-value[]', layerId, key, value, 0);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n\n                    if (globals.stylesheetBitmaps[value[0]] == null) {\n                        logError('wrong-object', layerId, key, value, null, 'bitmap');\n                        return getDefaultLayerPropertyValue(key);\n                    }\n\n                    i = 1;\n                }\n\n                for (li = value.length; i < li; i++) {\n                    if (typeof value[i] != 'number') {\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                        return getDefaultLayerPropertyValue(key);\n                    }\n                }\n\n                if ((key == 'icon-stick' || 'label-stick') && value.length == 7) {\n                    value[7] = 0;\n                }\n\n                return value;\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        return value;\n\n    case 'string':\n\n        if (key == 'line-type' || key == 'point-type') {\n            switch(value) {\n            case 'screen':\n            case 'flat':\n            case 'screen-flat': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate line Layer enum\n        if (key == 'line-style') {\n            switch(value) {\n            case 'solid':\n            case 'texture': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'label-size-units') {\n            switch(value) {\n            case 'pixels':\n            case 'points': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        if (key == 'line-width-units') {\n            switch(value) {\n            case 'pixels':\n            case 'points':\n            case 'meters':\n            case 'ratio': return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate origin enum\n        if (key == 'label-origin' || key == 'icon-origin') {\n            switch(value) {\n            case 'top-left':\n            case 'top-right':\n            case 'top-center':\n            case 'center-left':\n            case 'center-right':\n            case 'center-center':\n            case 'bottom-left':\n            case 'bottom-right':\n            case 'bottom-center':   return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        //validate align enum\n        if (key == 'label-align') {\n            switch(value) {\n            case 'left':\n            case 'right':\n            case 'center':  return value;\n            default:\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n        return value;\n\n    case 'number':\n\n        if (value > max || value < min) {\n            logError('wrong-property-value', layerId, key, value);\n            return getDefaultLayerPropertyValue(key);\n        }\n\n        return value;\n\n    case 'boolean':\n        return value;\n    }\n};\n\n\nvar validateLayerPropertyValue = function(layerId, key, value) {\n\n    switch(key) {\n\n    case 'inherit' :        return validateValue(layerId, key, value, 'string');\n    case 'reduce':          return validateValue(layerId, key, value, 'object');\n    case 'dynamic-reduce':  return validateValue(layerId, key, value, 'object');\n    case 'line-points':     return validateValue(layerId, key, value, 'object');\n\n    case 'line':              return validateValue(layerId, key, value, 'boolean');\n    case 'line-type':         return validateValue(layerId, key, value, 'string');\n    case 'line-flat':         return validateValue(layerId, key, value, 'boolean');\n    case 'line-width':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-width-units':  return validateValue(layerId, key, value, 'string');\n    case 'line-color':        return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-style':        return validateValue(layerId, key, value, 'string');\n    case 'line-style-texture':    return validateValue(layerId, key, value, 'object', 3, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'line-style-background': return validateValue(layerId, key, value, 'object', 4, 0, 255);\n\n    case 'line-label':         return validateValue(layerId, key, value, 'boolean');\n    case 'line-label-source':  return validateValue(layerId, key, value, 'string');\n    case 'line-label-color':   return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-label-color2':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'line-label-size':    return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-label-offset':  return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'line-label-spacing': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'line-label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'line-label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'line-label-no-overlap-margin': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n\n    case 'point':        return validateValue(layerId, key, value, 'boolean');\n    case 'point-type':   return validateValue(layerId, key, value, 'string');\n    case 'point-flat':   return validateValue(layerId, key, value, 'boolean');\n    case 'point-radius': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'point-Layer':  return validateValue(layerId, key, value, 'string');\n\n    case 'point-color':  return validateValue(layerId, key, value, 'object', 4, 0, 255);\n\n    case 'icon':             return validateValue(layerId, key, value, 'boolean');\n    case 'icon-source':      return validateValue(layerId, key, value, 'object', 5, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-scale':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'icon-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-origin':      return validateValue(layerId, key, value, 'string');\n    case 'icon-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'icon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'icon-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'icon-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'icon-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'label':             return validateValue(layerId, key, value, 'boolean');\n    case 'label-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'label-color2':      return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'label-source':      return validateValue(layerId, key, value, 'string');\n    case 'label-size':        return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-size-units':  return validateValue(layerId, key, value, 'string');\n    case 'label-spacing':     return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-line-height': return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-offset':      return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'label-origin':      return validateValue(layerId, key, value, 'string');\n    case 'label-align':       return validateValue(layerId, key, value, 'string');\n    case 'label-stick':       return validateValue(layerId, key, value, 'object', 8, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'label-width':       return validateValue(layerId, key, value, 'number', null, 0.0001, Number.MAX_VALUE);\n    case 'label-no-overlap':  return validateValue(layerId, key, value, 'boolean');\n    case 'label-no-overlap-factor': return validateValue(layerId, key, value, 'object');\n    case 'label-no-overlap-margin': return validateValue(layerId, key, value, 'object', 2, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'polygon':             return validateValue(layerId, key, value, 'boolean');\n    case 'polygon-style':       return validateValue(layerId, key, value, 'string');\n    case 'polygon-use-stencil': return validateValue(layerId, key, value, 'boolean');\n    case 'polygon-culling':     return validateValue(layerId, key, value, 'string');\n    case 'polygon-color':       return validateValue(layerId, key, value, 'object', 4, 0, 255);\n    case 'polygon-extrude':     return validateValue(layerId, key, value, 'number', 0, -Number.MAX_VALUE, Number.MAX_VALUE);\n\n    case 'z-index':        return validateValue(layerId, key, value, 'number', null, -Number.MAX_VALUE, Number.MAX_VALUE);\n    case 'zbuffer-offset': return validateValue(layerId, key, value, 'object', 3, 0, Number.MAX_VALUE);\n\n    case 'selected-hover-layer':  return validateValue(layerId, key, value, 'string');\n    case 'selected-layer':  return validateValue(layerId, key, value, 'string');\n    case 'hover-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'hover-layer':     return validateValue(layerId, key, value, 'string');\n    case 'enter-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'leave-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'click-event':     return validateValue(layerId, key, value, 'boolean');\n    case 'draw-event':      return validateValue(layerId, key, value, 'boolean');\n    case 'advanced-hit':    return validateValue(layerId, key, value, 'boolean');\n    case 'export-geometry': return validateValue(layerId, key, value, 'boolean');\n    case 'pack':            return validateValue(layerId, key, value, 'boolean');\n\n    case 'visible':           return validateValue(layerId, key, value, 'boolean');\n    case 'visibility':        return validateValue(layerId, key, value, 'number', null, 0.00001, Number.MAX_VALUE);\n    case 'visibility-abs':    return validateValue(layerId, key, value, 'object', 2, 0.00001, Number.MAX_VALUE);\n    case 'visibility-rel':    return validateValue(layerId, key, value, 'object', 4, 0.00001, Number.MAX_VALUE);\n    case 'visibility-switch': return validateValue(layerId, key, value, 'object');\n\n    case 'hysteresis':  return validateValue(layerId, key, value, 'object');\n    case 'culling':     return validateValue(layerId, key, value, 'number', 180, 0.0001, 180);\n    case 'next-pass':   return validateValue(layerId, key, value, 'object');\n\n    case 'importance-source':  return validateValue(layerId, key, value, 'string');\n    case 'importance-weight':  return validateValue(layerId, key, value, 'number', null, 0, Number.MAX_VALUE);\n\n    }\n\n    return value; //custom property\n};\n\n\nvar getDefaultLayerPropertyValue = function(key) {\n    switch(key) {\n    case 'inherit':          return '';\n    case 'filter':           return null;\n    case 'reduce':           return null;\n    case 'dynamic-reduce':   return null;\n    case 'line-points':      return ['vertices',0,0];\n\n    case 'line':             return false;\n    case 'line-type':        return 'screen';\n    case 'line-flat':        return false;\n    case 'line-width':       return 1;\n    case 'line-width-units': return 'meters';\n    case 'line-color':       return [255,255,255,255];\n    case 'line-style':       return 'solid';\n    case 'line-style-texture':    return null;\n    case 'line-style-background': return [0,0,0,0];\n\n    case 'line-label':         return false;\n    case 'line-label-font':    return ['#default'];\n    case 'line-label-color':   return [255,255,255,255];\n    case 'line-label-color2':  return [0,0,0,255];\n    case 'line-label-outline': return [0.27,0.75,2.2,2.2];\n    case 'line-label-source':  return '$name';\n    case 'line-label-size':    return 1;\n    case 'line-label-offset':  return 0;\n    case 'line-label-spacing': return 1;\n    case 'line-label-line-height': return 1;\n    case 'line-label-no-overlap':  return true;\n    case 'line-label-no-overlap-factor': return null;\n    case 'line-label-no-overlap-margin': return 1.1;\n\n    case 'point':        return false;\n    case 'point-type':   return 'screen';\n    case 'point-flat':   return false;\n    case 'point-radius': return 1;\n    case 'point-Layer':  return 'solid';\n    case 'point-color':  return [255,255,255,255];\n\n    case 'icon':         return false;\n    case 'icon-source':  return null;\n    case 'icon-scale':   return 1;\n    case 'icon-offset':  return [0,0];\n    case 'icon-origin':  return 'bottom-center';\n    case 'icon-stick':   return [0,0,0,255,255,255,255,0];\n    case 'icon-color':   return [255,255,255,255];\n    case 'icon-no-overlap':  return false;\n    case 'icon-no-overlap-factor': return null;\n    case 'icon-no-overlap-margin': return [5,5];\n\n    case 'label':             return false;\n    case 'label-font':        return ['#default'];\n    case 'label-color':       return [255,255,255,255];\n    case 'label-color2':      return [0,0,0,255];\n    case 'label-outline':     return [0.27,0.75,2.2,2.2];\n    case 'label-source':      return '$name';\n    case 'label-size':        return 10;\n    case 'label-size-units':  return 'pixels';\n    case 'label-spacing':     return 1;\n    case 'label-line-height': return 1;\n    case 'label-offset':      return [0,0];\n    case 'label-origin':      return 'bottom-center';\n    case 'label-align':       return 'center';\n    case 'label-stick':       return [0,0,0,255,255,255,255,0];\n    case 'label-width':       return 200;\n    case 'label-no-overlap':  return true;\n    case 'label-no-overlap-factor': return null;\n    case 'label-no-overlap-margin': return [5,5];\n       \n    case 'polygon':             return false;\n    case 'polygon-style':       return 'solid';\n    case 'polygon-use-stencil': return true;\n    case 'polygon-culling':     return 'none';\n    case 'polygon-color':  return [255,255,255,255];\n\n    case 'z-index':        return 0;\n    case 'zbuffer-offset': return [0,0,0];\n\n    case 'selected-hover-layer':  return '';\n    case 'selected-layer':  return '';\n    case 'hover-event':     return false;\n    case 'hover-layer':     return '';\n    case 'enter-event':     return false;\n    case 'leave-event':     return false;\n    case 'click-event':     return false;\n    case 'draw-event':      return false;\n    case 'advanced-hit':    return false;\n    case 'export-geometry': return false;\n    case 'pack':            return false;\n\n    case 'visible':           return true;\n    case 'visibility':        return null;\n    case 'visibility-abs':    return null;\n    case 'visibility-rel':    return null;\n    case 'visibility-switch': return null;\n\n    case 'hysteresis':      return null;\n    case 'culling':         return 180;\n    case 'next-pass':       return null;\n\n    case 'importance-source':  return null; //''\n    case 'importance-weight':  return 1;\n    }\n};\n\n\nfunction getFilterResult(filter, feature, featureType, group, layer, key, lod, depth, fast) {\n    var result, i, li;\n\n    if (!filter || !Array.isArray(filter)) {\n        return false;\n    }\n\n    if (depth > 100) {\n        return false;\n    }\n\n    switch(filter[0]) {\n        case 'all': \n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, layer, key, lod, depth + 1, fast);\n\n                if (!result) {\n                    return false;\n                }\n            }\n               \n            return true;                         \n\n        case 'any':\n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\n\n                if (result) {\n                    return true;\n                }\n            }\n               \n            return false;                         \n\n        case 'none':\n            for (i = 1, li = filter.length; i < li; i++) {\n                result = getFilterResult(filter[i], feature, featureType, group, key, lod, depth + 1, fast);\n\n                if (result) {\n                    return false;\n                }\n            }\n               \n            return true;\n                              \n        case 'skip': return false; \n    }\n\n    var value, value2;\n\n    if (fast && filter[2]) {\n        value = filter[1];\n    } else {\n        globals.disableLog = (filter[0] == 'has' || filter[0] == '!has');\n        value = getLayerPropertyValueInner(layer, key, feature, lod, filter[1], 0);\n        globals.disableLog = false;\n    }\n\n    switch(filter[0]) {\n    case '==':\n    case '!=':\n    case '>=':\n    case '<=':\n    case '>':\n    case '<':\n        value2 = filter[fast ? 3 : 2];\n\n        if (typeof value2 == 'undefined') {\n            return false;\n        }\n\n        if (!(fast && filter[4])) {\n            value2 = getLayerPropertyValueInner(layer, key, feature, lod, value2, 0);\n        }\n\n        break;\n    }\n\n    switch(filter[0]) {\n    case '==': return (value == value2);\n    case '!=': return (value != value2);\n    case '>=': return (value >= value2);\n    case '<=': return (value <= value2);\n    case '>': return (value > value2);\n    case '<': return (value < value2);\n        \n    case 'has': return (typeof value != 'undefined');\n    case '!has': return (typeof value == 'undefined');\n        \n    case 'in':\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\n            if (filter[i] == value) {\n                return true;\n            }\n        } \n        return false;\n        \n    case '!in':\n        for (i = fast ? 3 : 2, li = filter.length; i < li; i++) {\n            if (filter[i] == value) {\n                return false;\n            }\n        } \n        return true;\n    }            \n\n    return false;    \n}\n\n\nfunction isSimpleValue(value) {\n    switch(typeof value) {\n        case 'number':  return true;\n        case 'string': \n            \n            if (value.length > 0) {\n                switch(value.charAt(0)) {\n                    case '#': \n                    case '$':\n                    case '@':\n                    case '&':\n                        break;\n                    \n                    default: \n\n                        if (value.indexOf('{') == -1) {\n                            return true;\n                        }\n\n                        break;\n                }\n            } else {\n                return true;\n            }\n\n            break;\n    }\n\n    return false;\n}\n\n\nfunction makeFasterFilter(filter) {\n    if (!filter || !Array.isArray(filter)) {\n        return filter;\n    }\n\n    var i, li, value, simple, result = [filter[0]];\n\n    switch(filter[0]) {\n    case 'all': \n    case 'any':\n    case 'none':\n    case 'skip':\n        for (i = 1, li = filter.length; i < li; i++) {\n            result[i] = makeFasterFilter(filter[i]);\n        }\n\n        return result;\n    }\n\n    result[1] = filter[1];\n    result[2] = isSimpleValue(filter[1]);\n\n    switch(filter[0]) {\n    case '==':\n    case '!=':\n    case '>=':\n    case '<=':\n    case '>':\n    case '<':\n        result[3] = filter[2];\n        result[4] = isSimpleValue(filter[2]);\n        break;\n\n    case 'in':\n    case '!in':\n\n        for (i = 2, li = filter.length; i < li; i++) {\n            result[i+1] = filter[i];\n        } \n\n    }\n\n    return result;\n}\n\nvar processLayer = function(layerId, layerData, stylesheetLayersData) {\n    var layer = {}, key, value;\n\n    //copy Layer and inherit Layer if needed\n    copyLayer(layerId, layer, layerData, stylesheetLayersData);\n\n    //replace constants and validate properties\n    for (key in layer) {\n\n        value = layer[key];\n\n        //replace constant with value\n        if ((typeof value) == 'string') {\n            if (value.length > 0) {\n                //is it constant?\n                switch(value.charAt(0)) {\n                    case '@':\n                        if (globals.stylesheetConstants[value] != null) {\n                            //replace constant with value\n                            layer[key] = globals.stylesheetConstants[value];\n                        } else {\n                            logError('wrong-object', layerId, key, value, null, 'constant');\n\n                            //replace constant with deafault value\n                            layer[key] = getDefaultLayerPropertyValue(key);\n                        }\n                        break;\n\n                    case '%':  // reserved for variators\n\n                        if (globals.stylesheetLocals[value] != null) {\n                            if (!layer['$$layer-variables']) {\n                                layer['$$layer-variables'] = {};\n                            }\n\n                            layer['$$layer-variables'][key] = value;\n\n                            //replace variable with value\n                            layer[key] = globals.stylesheetLocals[value];\n\n                        } else {\n                            logError('wrong-object', layerId, key, value, null, 'variable');\n\n                            //replace constant with deafault value\n                            layer[key] = getDefaultLayerPropertyValue(key);\n                        }\n                        break;\n                }\n            }\n        }\n\n        //copy constats to vswitch\n        if (key == 'visibility-switch') {\n            if (Array.isArray(value) && value.length > 0) {\n                for (var i = 0, li = value.length; i < li; i++) {\n                    var valueItem = value[i];\n                    var wrong = false;\n\n                    if (!(typeof valueItem == 'object' && Array.isArray(valueItem) && valueItem.length == 2)) {\n                        wrong = true;\n                    } else {\n                        if (typeof valueItem[0] == 'string' && valueItem[0].charAt(0) == '@') {\n                            if (typeof globals.stylesheetConstants[valueItem[0]] == 'undefined') {\n                                wrong = true;\n                            } else {\n                                valueItem[0] = globals.stylesheetConstants[valueItem[0]];\n                            }\n                        }\n\n                        if (!(typeof valueItem[0] == 'number' && (typeof valueItem[1] == 'string' || valueItem[1] === null))) {\n                            wrong = true;\n                        }\n                    }\n\n                    if (wrong) {\n                        logError('wrong-property-value[]', layerId, key, value, i);\n                    }\n                }\n\n            } else {\n                logError('wrong-property-value', layerId, key, value);\n                return getDefaultLayerPropertyValue(key);\n            }\n        }\n\n    }\n\n    return layer;\n};\n\n\nvar processStylesheet = function(stylesheetLayersData) {\n    var key;\n    globals.stylesheetBitmaps = {};\n    globals.stylesheetFonts = {};\n    globals.stylesheetConstants = stylesheetLayersData['constants'] || {};\n    globals.stylesheetVariables = stylesheetLayersData['variables'] || {};\n    globals.stylesheetLocals = {};\n\n    //get bitmaps\n    var bitmaps = stylesheetLayersData['bitmaps'] || {};\n\n    //build map\n    for (key in bitmaps) {\n        var bitmap = bitmaps[key];\n        //var skip = false;\n\n        if ((typeof bitmap) == 'string') {\n            bitmap = {'url':bitmap, 'hash': getHash(bitmap) };\n        } else if((typeof bitmap) == 'object'){\n            if (bitmap['url'] == null) {\n                bitmap['hash'] = 'null';\n                logError('wrong-bitmap', key);\n            } else {\n                bitmap['hash'] = getHash(bitmap['url']);\n            }\n        } else {\n            logError('wrong-bitmap', key);\n        }\n\n        globals.stylesheetBitmaps[key] = bitmap;\n    }\n\n    //load bitmaps\n    postMessage({'command':'loadBitmaps', 'bitmaps': globals.stylesheetBitmaps});\n\n    //remove urls\n    bitmaps = globals.stylesheetBitmaps;\n\n    for (key in bitmaps) {\n        bitmap = bitmaps[key];\n        bitmap['url'] = null;\n    }\n\n    //get fonts\n    var fonts = stylesheetLayersData['fonts'] || {};\n\n    //build map\n    for (key in fonts) {\n        var font = fonts[key];\n\n        if ((typeof font) == 'string') {\n            font = {'url':font};\n        } else if((typeof font) == 'object'){\n            if (font['url'] == null) {\n                logError('wrong-font', key);\n            }\n        } else {\n            logError('wrong-font', key);\n        }\n\n        globals.stylesheetFonts[key] = font;\n    }\n\n    //load fonts\n    postMessage({'command':'loadFonts', 'fonts': globals.stylesheetFonts});\n\n\n    //get layers\n    globals.stylesheetData = {\n        layers : {}\n    };\n\n    var layers = stylesheetLayersData['layers'] || {};\n\n    globals.stylesheetLayers = globals.stylesheetData.layers;\n\n    //process layers\n    for (key in layers) {\n        globals.stylesheetData.layers[key] = processLayer(key, layers[key], stylesheetLayersData);\n    }\n};\n\n\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_font_js__ = __webpack_require__(8);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"n\", function() { return addStreetTextOnPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return getTextLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return getLineHeight; });\n/* unused harmony export getFontFactor */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return getSplitIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return areTextCharactersAvailable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return addText; });\n/* unused harmony export addTextOnPath */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return setFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return setFontMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return getCharVerticesCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return getFonts; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return getFontsStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return hasLatin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return isCJK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return getTextGlyphs; });\n\n\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */],\n    vec3Normalize = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"g\" /* vec3Normalize */], vec3Length = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"h\" /* vec3Length */],\n    vec3Cross = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"i\" /* vec3Cross */],\n    Typr = __WEBPACK_IMPORTED_MODULE_1__worker_font_js__[\"a\" /* Typr */];\n\n\nvar setFont = function(fontData) {\n    //console.log('setFont ' + fontData['url']);\n    //debugger;\n\n    var font = Typr.parse(fontData['data']);\n\n    globals.fontsStorage[fontData['url']] = font;\n};\n\n\nvar setFontMap = function(fontMap) {\n    var fonts = fontMap['map'];\n    for (var key in fonts) {\n        globals.fonts[key] = globals.fontsStorage[fonts[key]];\n    }\n\n    globals.fontsMap = fonts;\n};\n\n\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n\nvar mat3toQuad2 = function(m) {  //TODO: use m as one dimensional vector\n\n    var tr = m[0][0] + m[1][1] + m[2][2], qx,qy,qz,qw,s;\n\n    if (tr > 0) { \n      s = Math.sqrt(tr+1.0) * 2; // S=4*qw \n      qw = 0.25 * s;\n      qx = (m[2][1] - m[1][2]) / s;\n      qy = (m[0][2] - m[2][0]) / s; \n      qz = (m[1][0] - m[0][1]) / s; \n    } else if ((m[0][0] > m[1][1])&(m[0][0] > m[2][2])) { \n      s = Math.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2; // S=4*qx \n      qw = (m[2][1] - m[1][2]) / s;\n      qx = 0.25 * s;\n      qy = (m[0][1] + m[1][0]) / s; \n      qz = (m[0][2] + m[2][0]) / s; \n    } else if (m[1][1] > m[2][2]) { \n      s = Math.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2; // S=4*qy\n      qw = (m[0][2] - m[2][0]) / s;\n      qx = (m[0][1] + m[1][0]) / s; \n      qy = 0.25 * s;\n      qz = (m[1][2] + m[2][1]) / s; \n    } else { \n      s = Math.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2; // S=4*qz\n      qw = (m[1][0] - m[0][1]) / s;\n      qx = (m[0][2] + m[2][0]) / s;\n      qy = (m[1][2] + m[2][1]) / s;\n      qz = 0.25 * s;\n    }\n\n    return [qx,qy,qz,qw];\n}\n\n\nvar addChar = function(pos, dir, verticalShift, char, factor, spacing, index, index2, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, fontIndex, singleBuffer) {\n    var n, font = fonts[fontIndex];\n    var up = [0,0,0];\n\n    if (globals.geocent && !flat) {\n        n = [0,0,0];\n        vec3Normalize(globals.bboxMin, up);\n        vec3Cross(up, dir, n);\n    } else {\n        n = [-dir[1],dir[0],0];\n    }\n\n    vec3Cross(dir, n, up);\n\n    var p1 = [pos[0], pos[1], pos[2]];\n    var p2 = [p1[0], p1[1], p1[2]];\n\n    //var chars = font.chars;\n    \n    var fc = font.glyphs[char];\n    char = 0; // hack\n\n    if (!fc) {\n        return [pos, index, index2, 0];\n    }\n\n    var l = 0;\n    var nx = textVector[0];\n    var ny = textVector[1];\n    var nz = textVector[2];\n\n    if (char == 9 || char == 32) {  //tab or space\n        fc = chars[32]; //space\n\n        if (fc) {\n            pos[0] += dir[0] * (fc.step) * factor * spacing;\n            pos[1] += dir[1] * (fc.step) * factor * spacing;\n            l = fc.lx * factor;\n        }\n    } else {\n        if (fc.lx == 0) {\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        } else {\n            var planeShift = fontIndex * 4000;\n            var plane = fc.plane + planeShift;\n\n            if (planes) {\n                if (!planes[fontIndex]) {\n                    planes[fontIndex] = {};\n                }\n                \n                planes[fontIndex][plane] = true;\n            }\n\n            var factorX = fc.lx * factor;\n            var factorY = fc.ly * factor;\n\n            if (singleBuffer) {\n\n                if (globals.processLineLabel && globals.useLineLabel2) {\n\n                    p1[0] = p1[0] + dir[0] * fc.sx * factor;\n                    p1[1] = p1[1] + dir[1] * fc.sx * factor;\n                    p1[2] = p1[2] + dir[2] * fc.sx * factor;\n                    p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\n                    p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\n                    p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\n\n                    var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\n                    var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\n\n                    singleBuffer[index] = p1[0] - n2[0];\n                    singleBuffer[index+1] = p1[1] - n2[1];\n                    singleBuffer[index+2] = p1[2] - n2[2];\n\n                    \n                    var m = [ [dir[0], dir[1], dir[2]], \n                              [n[0], n[1], n[2]], \n                              [up[0], up[1], up[2]] ];\n\n                    /*\n                    var m = [ dir[0], dir[1], dir[2], \n                              n[0], n[1], n[2], \n                              up[0], up[1], up[2] ];*/\n\n                    var q = mat3toQuad2(m);\n                    singleBuffer[index+3] = q[0];  //x\n                    singleBuffer[index+4] = q[1];  //y\n                    singleBuffer[index+5] = q[2];  //z\n                    singleBuffer[index+6] = q[3];  //w\n                   \n                    singleBuffer[index+7] = factorX;\n                    singleBuffer[index+8] = factorY;\n                    singleBuffer[index+9] = fc.u1;\n                    singleBuffer[index+10] = fc.v1 + planeShift;\n\n                    var dtx = (fc.u2 - fc.u1) * 1024;\n                    var dty = (fc.v2 - fc.v1);// * 1024;\n\n                    singleBuffer[index+11] = dtx + dty;  // u store in decimal part, v stored in fraction part\n\n                    index += 12;\n\n                    var dx = dir[0]*0.5*factorX - n[0]*0.5*factorY - n2[0];\n                    var dy = dir[1]*0.5*factorX - n[1]*0.5*factorY - n2[1];\n                    var dz = dir[2]*0.5*factorX - n[2]*0.5*factorY - n2[2];\n\n                    globals.lineLabelPoints.push([p1[0] + dx, p1[1] + dy, p1[2] + dz, Math.sqrt(factorX*factorX + factorY*factorY)*0.5]);\n\n                } else {\n                    singleBuffer[index] = p1[0] + fc.sx * factor;\n                    singleBuffer[index+1] = p1[1] + (fc.sy - font.size) * factor;\n                    singleBuffer[index+2] = singleBuffer[index] + factorX;\n                    singleBuffer[index+3] = singleBuffer[index+1] - factorY;\n                    singleBuffer[index+4] = fc.u1;\n                    singleBuffer[index+5] = fc.v1 + planeShift;\n                    singleBuffer[index+6] = fc.u2;\n                    singleBuffer[index+7] = fc.v2 + planeShift;\n\n                    index += 8;\n                }\n\n            } else {\n\n                var n2 = [n[0] * verticalShift, n[1] * verticalShift, n[2] * verticalShift];\n                var n3 = [n2[0] + n[0] * factorY, n2[1] + n[1] * factorY, n2[2] + n[2] * factorY];\n                \n                p1[0] = p1[0] + dir[0] * fc.sx * factor;\n                p1[1] = p1[1] + dir[1] * fc.sx * factor;\n                p1[2] = p1[2] + dir[2] * fc.sx * factor;\n                p1[0] = p1[0] + n[0] * (fc.sy - font.size) * factor;\n                p1[1] = p1[1] + n[1] * (fc.sy - font.size) * factor;\n                p1[2] = p1[2] + n[2] * (fc.sy - font.size) * factor;\n\n                p2[0] = p1[0] + dir[0] * factorX;\n                p2[1] = p1[1] + dir[1] * factorX;\n                p2[2] = p1[2] + dir[2] * factorX;\n\n                //first polygon\n                vertexBuffer[index] = p1[0] - n2[0];\n                vertexBuffer[index+1] = p1[1] - n2[1];\n                vertexBuffer[index+2] = p1[2] - n2[2];\n                vertexBuffer[index+3] = nz;\n\n                texcoordsBuffer[index2] = fc.u1;\n                texcoordsBuffer[index2+1] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+2] = nx;\n                texcoordsBuffer[index2+3] = ny;\n\n                vertexBuffer[index+4] = p1[0] - n3[0];\n                vertexBuffer[index+5] = p1[1] - n3[1];\n                vertexBuffer[index+6] = p1[2] - n3[2];\n                vertexBuffer[index+7] = nz;\n\n                texcoordsBuffer[index2+4] = fc.u1;\n                texcoordsBuffer[index2+5] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+6] = nx;\n                texcoordsBuffer[index2+7] = ny;\n\n                vertexBuffer[index+8] = p2[0] - n2[0];\n                vertexBuffer[index+9] = p2[1] - n2[1];\n                vertexBuffer[index+10] = p2[2] - n2[2];\n                vertexBuffer[index+11] = nz;\n\n                texcoordsBuffer[index2+8] = fc.u2;\n                texcoordsBuffer[index2+9] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+10] = nx;\n                texcoordsBuffer[index2+11] = ny;\n\n\n                //next polygon\n                vertexBuffer[index+12] = p1[0] - n3[0];\n                vertexBuffer[index+13] = p1[1] - n3[1];\n                vertexBuffer[index+14] = p1[2] - n3[2];\n                vertexBuffer[index+15] = nz;\n\n                texcoordsBuffer[index2+12] = fc.u1;\n                texcoordsBuffer[index2+13] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+14] = nx;\n                texcoordsBuffer[index2+15] = ny;\n\n                vertexBuffer[index+16] = p2[0] - n3[0];\n                vertexBuffer[index+17] = p2[1] - n3[1];\n                vertexBuffer[index+18] = p2[2] - n3[2];\n                vertexBuffer[index+19] = nz;\n\n                texcoordsBuffer[index2+16] = fc.u2;\n                texcoordsBuffer[index2+17] = fc.v2 +  planeShift;\n                texcoordsBuffer[index2+18] = nx;\n                texcoordsBuffer[index2+19] = ny;\n\n                vertexBuffer[index+20] = p2[0] - n2[0];\n                vertexBuffer[index+21] = p2[1] - n2[1];\n                vertexBuffer[index+22] = p2[2] - n2[2];\n                vertexBuffer[index+23] = nz;\n\n                texcoordsBuffer[index2+20] = fc.u2;\n                texcoordsBuffer[index2+21] = fc.v1 +  planeShift;\n                texcoordsBuffer[index2+22] = nx;\n                texcoordsBuffer[index2+23] = ny;\n\n                index += 24;\n                index2 += 24;\n            }\n\n            pos[0] = pos[0] + dir[0] * fc.step * factor * spacing;\n            pos[1] = pos[1] + dir[1] * fc.step * factor * spacing;\n            l = fc.lx * factor;\n        }\n    }\n\n    return [pos, index, index2, l * spacing];\n};\n\n\nvar getCharVerticesCount = function(origin) {\n    return (origin ? 3 : 4) * 3 * 2;\n};\n\n\nvar addText = function(pos, dir, text, size, spacing, fonts, vertexBuffer, texcoordsBuffer, flat, index, planes, glyphsRes, singleBuffer) {\n    var textVector = [0,1,0];\n    var p1 = [pos[0], pos[1], pos[2]];\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font);\n\n            var shift = addChar(p1, dir, 0, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, flat, planes, gfonts[i], singleBuffer);\n\n            //var gid2 = (i<gls.length-1 && gls[i+1]!=-1)  ? gls[i+1] : 0;\n            //x += Typr.U.getPairAdjustment(font, gid, gid2);\n\n            p1 = shift[0];\n            index = shift[1];\n        }\n    }\n\n    return index;\n};\n\n\nvar addTextOnPath = function(points, distance, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\n    if (textVector == null) {\n        textVector = [0,1,0];\n    }\n\n    var p1 = points[0];\n    //var newLineSpace = getLineHeight(size, fonts);\n    //var s = [p1[0], p1[1], p1[2]];\n\n    p1 = [p1[0], p1[1], p1[2]];\n    var l = distance;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    globals.processLineLabel = true;\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        /*  \n        var char = text.charCodeAt(i);\n\n        if (char == 10) { //new line\n            s[0] += -dir[1] * newLineSpace;\n            s[1] += dir[0] * newLineSpace;\n            p1 = [s[0], s[1], s[2]];\n            continue;\n        }\n\n        if (char == 9) { //tab\n            char = 32;\n        }\n        */\n\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font);\n\n            var ll = 0.01;\n            var fc = font.glyphs[glyph];\n            if (fc) {\n                ll = fc.step * factor * spacing;\n            }\n\n            var posAndDir = getPathPositionAndDirection(points, l);\n            var posAndDir2 = getPathPositionAndDirection(points, l+ll);\n\n            //average dir\n            var dir = [(posAndDir2[1][0] + posAndDir[1][0])*0.5,\n                (posAndDir2[1][1] + posAndDir[1][1])*0.5,\n                (posAndDir2[1][2] + posAndDir[1][2])*0.5];\n\n            vec3Normalize(dir);\n\n            var shift = addChar(posAndDir[0], dir, -factor*font.size*0.7+verticalOffset, glyph, factor, spacing, index, index, textVector, fonts, vertexBuffer, texcoordsBuffer, null, planes, gfonts[i], singleBuffer);\n\n            p1 = shift[0];\n            index = shift[1];\n            //index2 = shift[2];\n            l += ll;\n        }\n    }\n\n    globals.processLineLabel = false;\n\n    return index;\n};\n\n\nvar addStreetTextOnPath = function(points, text, size, spacing, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer) {\n    var textLength = getTextLength(text, size, spacing, fonts, glyphsRes);\n    var pathLength = getPathLength(points);\n    var shift = (pathLength -  textLength)*0.5;\n    if (shift < 0) {\n        shift = 0;\n    }\n\n    if (textLength > pathLength) {\n        return;\n    }\n\n    var textVector = getPathTextVector(points, shift, text, size, spacing, fonts, glyphsRes);\n    globals.textVector = textVector;\n\n    return addTextOnPath(points, shift, text, size, spacing, textVector, fonts, verticalOffset, vertexBuffer, texcoordsBuffer, index, planes, glyphsRes, singleBuffer);\n};\n\n\nvar getFontFactor = function(size, font) {\n    return font ? ((size / font.size) * 1.52) : 1;\n};\n\n\nvar getLineHeight = function(size, lineHeight, fonts) {\n    var factor = getFontFactor(size, fonts[0]);\n    //return font.space * factor;\n    return fonts[0].cly * factor * lineHeight;\n};\n\n\nvar getTextLength = function(text, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font) * spacing;\n            var fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return l;\n};\n\n\nvar getSplitIndex = function(text, width, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    var gfonts = res[1];\n    var codes = res[2];\n\n    for (var i = 0, li = glyphs.length; i < li; i++) {\n        var glyph = glyphs[i];\n        var char = codes[i];//text.charCodeAt(i);\n\n        if (l > width && (char == 10 || char == 9 || char == 32)) {\n            return i;\n        }\n\n        if (char == 10) { //new line\n            continue;\n        }\n\n        var font = fonts[gfonts[i]];\n\n        if (font) {\n            var factor = getFontFactor(size, font) * spacing;\n            var fc = font.glyphs[glyph];\n\n            if (fc) {\n                if (i == (li-1)) {\n                    l += fc.lx * factor;\n                } else {\n                    l += fc.step * factor;\n                }\n            }\n        }\n    }\n\n    return li;\n};\n\n\nvar getPathLength = function(points) {\n    var l = 0;\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        var p1 = points[i];\n        var p2 = points[i+1];\n        var dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n    }\n\n    return l;\n};\n\n\nvar getPathPositionAndDirection = function(points, distance) {\n    var l = 0;\n    var p1 = [0,0,0];\n    var dir = [1,0,0];\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        var p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        var ll = vec3Length(dir);\n\n        if ((l + ll) > distance) {\n\n            var factor = (distance - l) / (ll);\n            var p = [p1[0] + dir[0] * factor,\n                p1[1] + dir[1] * factor,\n                p1[2] + dir[2] * factor];\n\n            vec3Normalize(dir);\n\n            return [p, dir];\n        }\n\n        l += ll;\n    }\n\n    return [p1, dir];\n};\n\n\nvar getPathTextVector = function(points, shift, text, size, spacing, fonts, glyphsRes) {\n    var l = 0;\n    var p1 = [0,0,0];\n    var dir = [1,0,0];\n    var textDir = [0,0,0];\n    var textStart = shift;\n    var textEnd = shift + getTextLength(text, size, spacing, fonts, glyphsRes);\n    var bboxMin = globals.bboxMin;\n    var geocent = globals.geocent;\n\n    for (var i = 0, li = points.length-1; i < li; i++) {\n        p1 = points[i];\n        var p2 = points[i+1];\n        dir = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n\n        l += vec3Length(dir);\n\n        if (l > textStart) {\n            vec3Normalize(dir);\n            textDir[0] += dir[0];\n            textDir[1] += dir[1];\n            textDir[2] += dir[2];\n        }\n\n        if (l > textEnd) {\n            vec3Normalize(textDir);\n\n            if (geocent) {\n                var nn = [0,0,0];\n                vec3Normalize(bboxMin, nn);\n                vec3Cross(nn, textDir, nn);\n                return nn;\n            } else {\n                return [-textDir[1], textDir[0],0];\n            }\n        }\n    }\n\n    return textDir;\n};\n\n\nvar areTextCharactersAvailable = function(text, fonts, glyphsRes) {\n    if (!text || text == '') {\n        return false;\n    }\n\n    var res = glyphsRes ? glyphsRes : Typr.U.stringToGlyphs(fonts, text);\n    var glyphs = res[0];\n    //var gfonts = res[1];\n\n    if (glyphs.indexOf(0) != -1) {\n        return false;\n    }\n\n    return true;\n};\n\n\nvar hasLatin = function(str) {\n    for (var i = 0, li = str.length; i < li; i++) {\n        var c = str.charCodeAt(i);\n        if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) ||\n            ((c >= 0xc0 && c <= 0xff) && c!= 0xd7 && c!= 0xf7) || (c >= 0x100 && c <= 0x17f)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\nvar isCJK = function(str) {\n    for (var i = 0, li = str.length; i < li; i++) {\n        var c = str.charCodeAt(i);\n\n        if (!((c >= 0x4E00 && c <= 0x62FF) || (c >= 0x6300 && c <= 0x77FF) ||\n              (c >= 0x7800 && c <= 0x8CFF) || (c >= 0x8D00 && c <= 0x9FFF) || \n              (c >= 0x3400 && c <= 0x4DBF) || (c >= 0x20000 && c <= 0x215FF) || \n              (c >= 0x21600 && c <= 0x230FF) || (c >= 0x23100 && c <= 0x245FF) || \n              (c >= 0x24600 && c <= 0x260FF) || (c >= 0x26100 && c <= 0x275FF) || \n              (c >= 0x27600 && c <= 0x290FF) || (c >= 0x29100 && c <= 0x2A6DF) || \n              (c >= 0x2A700 && c <= 0x2B73F) || (c >= 0x2B740 && c <= 0x2B81F) || \n              (c >= 0x2B820 && c <= 0x2CEAF) || (c >= 0x2CEB0 && c <= 0x2EBEF) || \n              (c >= 0xF900 && c <= 0xFAFF) || (c >= 0x3300 && c <= 0x33FF) || \n              (c >= 0xFE30 && c <= 0xFE4F) || (c >= 0xF900 && c <= 0xFAFF) || \n              (c >= 0x2F800 && c <= 0x2FA1F) || \n              (c >= 0x0 && c <= 0x40) || (c >= 0xa0 && c <= 0xbf)  )) { //neutral\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\nvar getFonts = function(fonts) {\n    var fontsMap = [];\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fonts[fonts[i]]);\n    }\n\n    return fontsMap;\n};\n\n\nvar getFontsStorage = function(fonts) {\n    var fontsMap = [];\n    for (var i = 0, li = fonts.length; i < li; i++) {\n        fontsMap.push(globals.fontsMap[fonts[i]]);\n    }\n\n    return fontsMap;\n};\n\n\nvar getTextGlyphs = function(text, fonts) {\n    return Typr.U.stringToGlyphs(fonts, text);\n};\n\n\n\n\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_text_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_message_js__ = __webpack_require__(1);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return processPointArrayPass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return processPointArrayGeometry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return processPointArrayVSwitchPass; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return checkDPoints; });\n\n\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */], clamp = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"d\" /* clamp */];\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"c\" /* getLayerPropertyValue */], getLayerExpresionValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"g\" /* getLayerExpresionValue */];\nvar addText = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"f\" /* addText */], getSplitIndex = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"g\" /* getSplitIndex */], getTextGlyphs = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"h\" /* getTextGlyphs */],\n    getTextLength = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"i\" /* getTextLength */], getFonts = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"j\" /* getFonts */], getFontsStorage = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"k\" /* getFontsStorage */],\n    areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"e\" /* areTextCharactersAvailable */], getCharVerticesCount = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"l\" /* getCharVerticesCount */], getLineHeight = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"m\" /* getLineHeight */];\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_3__worker_message_js__[\"c\" /* postGroupMessageFast */];\n\n\nvar checkDPoints = function(pointArray) {\n    var pointsGroups = []; \n    var i, li, g, gl, points, p, pp;\n\n    if (pointArray['d-points'] || pointArray['d-lines']) {  //converty d-lines/points to lines/points\n        pointsGroups = pointArray['d-points'] || pointArray['d-lines'];\n\n        if (Array.isArray(pointsGroups) && points.length > 0) {\n\n            for (g = 0, gl = pointsGroups; g < gl; g++) {\n                points = pointsGroups[g];\n                \n                if (Array.isArray(points) && points.length > 0) {\n                    p = points[0];\n                    \n                    p[0] = (p[0] >> 1) ^ (-(p[0] & 1));\n                    p[1] = (p[1] >> 1) ^ (-(p[1] & 1));\n                    p[2] = (p[2] >> 1) ^ (-(p[2] & 1));\n\n                    for (i = 1, li = points.length; i < li; i++) {\n                        p = points[i-1];\n                        pp = points[i];\n\n                        pp[0] = ((pp[0] >> 1) ^ (-(pp[0] & 1))) + p[0];\n                        pp[1] = ((pp[1] >> 1) ^ (-(pp[1] & 1))) + p[1];\n                        pp[2] = ((pp[2] >> 1) ^ (-(pp[2] & 1))) + p[2];\n                    }\n                }\n            }\n        }\n\n        if (pointArray['d-points']) {\n            pointArray['points'] = pointArray['d-points'];\n            delete pointArray['d-points'];\n        } else {\n            pointArray['lines'] = pointArray['d-lines'];\n            delete pointArray['d-lines'];\n        }\n    }\n};\n\n\nvar processPointArrayPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    var pointsGroups = []; \n    var i, li, g, gl, points, p, pp;\n\n    checkDPoints(pointArray);\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n    \n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', pointArray, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', pointArray, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', pointArray, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', pointArray, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', pointArray, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-event', pointArray, lod);\n    var linePoints = getLayerPropertyValue(style, 'line-points', pointArray, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', pointArray, lod);\n\n    var point = getLayerPropertyValue(style, 'point', pointArray, lod);\n    var pointFlat = getLayerPropertyValue(style, 'point-flat', pointArray, lod);\n    var pointColor = getLayerPropertyValue(style, 'point-color', pointArray, lod);\n    var pointRadius = 0.5 * getLayerPropertyValue(style, 'point-radius', pointArray, lod);\n\n    var source, bufferSize, bufferSize2, totalPoints = 0, noOverlap;\n    //zIndex = (zIndex !== null) ? zIndex : getLayerPropertyValue(style, \"z-index\", pointArray, lod);\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    var icon = getLayerPropertyValue(style, 'icon', pointArray, lod);\n    if (icon) {\n        source = getLayerPropertyValue(style, 'icon-source', pointArray, lod);\n        \n        if (source) {\n            bufferSize = getCharVerticesCount() * totalPoints;\n            bufferSize2 = getCharVerticesCount(true) * totalPoints;\n    \n            var iconData = {\n                color : getLayerPropertyValue(style, 'icon-color', pointArray, lod),\n                scale : getLayerPropertyValue(style, 'icon-scale', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'icon-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'icon-stick', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'icon-origin', pointArray, lod),\n                source : getLayerPropertyValue(style, 'icon-source', pointArray, lod),\n                noOverlap : getLayerPropertyValue(style, 'icon-no-overlap', pointArray, lod),\n                noOverlapMargin : getLayerPropertyValue(style, 'icon-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'icon-no-overlap-factor', pointArray, lod),\n                index : 0,\n                index2 : 0\n            };\n\n            if (totalPoints > 1) {\n                iconData.vertexBuffer = new Float32Array(bufferSize);\n                iconData.originBuffer = new Float32Array(bufferSize2);\n                iconData.texcoordsBuffer = new Float32Array(bufferSize);\n            } else {\n                iconData.singleBuffer = new Float32Array(16);\n            }\n\n        } else {\n            icon = false;\n        }\n    }\n\n    var label = getLayerPropertyValue(style, 'label', pointArray, lod);\n    if (label) {\n        source = getLayerPropertyValue(style, 'label-source', pointArray, lod);\n\n        var text = getLayerExpresionValue(style, source, pointArray, lod, source);\n        text = text ? text.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n        var size = getLayerPropertyValue(style, 'label-size', pointArray, lod);\n        var fontNames = getLayerPropertyValue(style, 'label-font', pointArray, lod);\n        var fonts = getFonts(fontNames);\n        var glyphsRes = getTextGlyphs(text, fonts);\n        \n        if (source == '$name') {\n            if (!areTextCharactersAvailable(text, fonts, glyphsRes)) {\n                var text2 = getLayerExpresionValue(style, '$name:en', pointArray, lod, source);\n                text2 = text2 ? text2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n                var glyphsRes2 = getTextGlyphs(text2, fonts);\n                \n                if (areTextCharactersAvailable(text2, fonts)) {\n                    text = text2;                     \n                    glyphsRes = glyphsRes2;\n                }\n            }\n        }\n        if (text && text != '' && Math.abs(size) > 0.0001) {\n            noOverlap = getLayerPropertyValue(style, 'label-no-overlap', pointArray, lod);\n            bufferSize = getCharVerticesCount() * text.length * (noOverlap ? 1 : totalPoints);\n            bufferSize2 = getCharVerticesCount(true) * text.length * (noOverlap ? 1 : totalPoints);\n\n            var useSingleBuffer = (totalPoints == 1);\n\n            var factor = 1;\n            if (getLayerPropertyValue(style, 'label-size-units', pointArray, lod) == 'points') {\n                factor = globals.pixelFactor / ((1 / 72) * (96));\n            }\n\n            var labelData = {\n                color : getLayerPropertyValue(style, 'label-color', pointArray, lod),\n                color2 : getLayerPropertyValue(style, 'label-color2', pointArray, lod),\n                outline : getLayerPropertyValue(style, 'label-outline', pointArray, lod),\n                reduce : getLayerPropertyValue(style, 'dynamic-reduce', pointArray, lod),\n                size : size * factor,\n                spacing: getLayerPropertyValue(style, 'label-spacing', pointArray, lod),\n                lineHeight: getLayerPropertyValue(style, 'label-line-height', pointArray, lod),\n                offset : getLayerPropertyValue(style, 'label-offset', pointArray, lod),\n                stick : getLayerPropertyValue(style, 'label-stick', pointArray, lod),\n                origin : getLayerPropertyValue(style, 'label-origin', pointArray, lod),\n                align : getLayerPropertyValue(style, 'label-align', pointArray, lod),\n                fonts : fonts,\n                fontsStorage : getFontsStorage(fontNames),\n                text : text,\n                hysteresis : getLayerPropertyValue(style, 'hysteresis', pointArray, lod),\n                width : factor * getLayerPropertyValue(style, 'label-width', pointArray, lod),\n                noOverlap : noOverlap,\n                noOverlapMargin : getLayerPropertyValue(style, 'label-no-overlap-margin', pointArray, lod),\n                noOverlapFactor : getLayerPropertyValue(style, 'label-no-overlap-factor', pointArray, lod),\n                vertexBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                originBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize2)),\n                texcoordsBuffer : (useSingleBuffer) ? null : (new Float32Array(bufferSize)),\n                singleBuffer : (useSingleBuffer) ? (new Float32Array(text.length * 4 * 2)) : null,\n                index : 0,\n                index2 : 0,\n                glyphsRes : glyphsRes\n            };\n\n            if (labelData.stick) {\n                labelData.stick = labelData.stick.slice();\n                labelData.stick[2] *= factor;\n                //labelData.stick[7] *= factor;\n            }\n\n        } else {\n            label = false;\n        }\n    }\n\n    var index = 0;\n    var index2 = 0;\n\n    \n    var center = [0,0,0];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var labelBBox, iconBBox, p, p1, p2, pp, pp2;\n\n    var generatePoint = (function(pindex) {\n\n        if (icon && (!iconData.noOverlap)) {\n            iconBBox = processIcon(pp, iconData) ;//, pointArray, lod, style, zIndex);\n        }\n\n        if (label && (!labelData.noOverlap)) {\n            labelBBox = processLabel(pp, labelData); //, pointArray, lod, style, zIndex);\n        }\n\n        if (point) {\n\n            for (var j = 0; j < circleSides; j++) {\n\n                if (pointFlat) {\n\n                    //add polygon\n                    vertexBuffer[index] = pp[0];\n                    vertexBuffer[index+1] = pp[1];\n                    vertexBuffer[index+2] = pp[2];\n\n                    vertexBuffer[index+3] = pp[0] + circleBuffer[j][0] * pointRadius;\n                    vertexBuffer[index+4] = pp[1] + circleBuffer[j][1] * pointRadius;\n                    vertexBuffer[index+5] = pp[2];\n\n                    vertexBuffer[index+6] = pp[0] + circleBuffer[j+1][0] * pointRadius;\n                    vertexBuffer[index+7] = pp[1] + circleBuffer[j+1][1] * pointRadius;\n                    vertexBuffer[index+8] = pp[2];\n\n                    index += 9;\n\n                } else {\n\n                    //add polygon\n                    vertexBuffer[index] = pp[0];\n                    vertexBuffer[index+1] = pp[1];\n                    vertexBuffer[index+2] = pp[2];\n                    vertexBuffer[index+3] = 0;\n                    normalBuffer[index2] = 0;\n                    normalBuffer[index2+1] = 0;\n                    normalBuffer[index2+2] = 0;\n                    normalBuffer[index2+3] = 0;\n\n                    vertexBuffer[index+4] = pp[0];\n                    vertexBuffer[index+5] = pp[1];\n                    vertexBuffer[index+6] = pp[2];\n                    vertexBuffer[index+7] = 0;\n                    normalBuffer[index2+4] = circleBuffer[j][0] * pointRadius;\n                    normalBuffer[index2+5] = circleBuffer[j][1] * pointRadius;\n                    normalBuffer[index2+6] = 0;\n                    normalBuffer[index2+7] = 0;\n\n                    vertexBuffer[index+8] = pp[0];\n                    vertexBuffer[index+9] = pp[1];\n                    vertexBuffer[index+10] = pp[2];\n                    vertexBuffer[index+11] = 0;\n                    normalBuffer[index2+8] = circleBuffer[j+1][0] * pointRadius;\n                    normalBuffer[index2+9] = circleBuffer[j+1][1] * pointRadius;\n                    normalBuffer[index2+10] = 0;\n                    normalBuffer[index2+11] = 0;\n\n                    index += 12;\n                    index2 += 12;\n                }\n            }\n        }\n    });\n\n\n    var getLinePoint = (function(length) {\n\n        var l1 = 0;\n        var l2 = 0;\n\n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n\n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n\n        if (length == 0) {\n            return p1;\n        }\n\n        for (var k = 0, lk = points.length - 1; k < lk; k++) {\n            p = points[k+1];\n            p2 = [p[0], p[1], p[2]];\n\n            if (forceOrigin) {\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n            }\n\n            if (forceScale != null) {\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n            }\n\n            var dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2]; \n            var l = Math.sqrt(dx*dx+dy*dy+dz*dz);\n\n            l1 = l2;\n            l2 += l;\n\n            if (length >= l1 && length <= l2) {\n                var d = (length - l1) / l;\n\n                return [p1[0] + dx * d,  p1[1] + dy * d, p1[2] + dz * d];\n            }\n\n            p1 = p2;\n        }\n\n    });\n\n    var pointsBuffer = new Array(2048), pointsBufferLength = 0;\n\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        \n        if (Array.isArray(points) && points.length > 0) {\n\n            var totalLength = 0, lengths = null;\n\n            if (linePoints[0] != 'vertices') {\n                lengths = new Array(points.length);\n                lengths[0] = 0;\n            }\n\n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n                p = points[i];\n                p1 = [p[0], p[1], p[2]];\n\n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n        \n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n                \n                if (i + 1 < li) {\n                    p = points[i+1];\n                    p2 = [p[0], p[1], p[2]];\n\n                    if (forceOrigin) {\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    }\n            \n                    if (forceScale != null) {\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    }\n\n                    var dx = p2[0] - p1[0], dy = p2[1] - p1[1], dz = p2[2] - p1[2]; \n                    var l = Math.sqrt(dx*dx+dy*dy+dz*dz);\n\n                    if (lengths) {\n                        lengths[i] = l;\n                    }\n\n                    totalLength += l;\n                }\n        \n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n\n                if (linePoints[0] == 'vertices') {\n                    pointsBuffer[pointsBufferLength] = p1;\n                    pointsBufferLength++;\n                }\n            }\n\n            if (linePoints[0] == 'by-length' || linePoints[0] == 'by-ratio') {\n                var period = linePoints[1];\n                var offset = linePoints[2] || 0;\n\n                if (linePoints[0] == 'by-ratio') {\n                    period *= totalLength;\n                    offset *= totalLength;\n                }\n\n                if (period <= 0) {\n                    pointsBuffer[pointsBufferLength] = getLinePoint(offset);\n                    if (pointsBuffer[pointsBufferLength]) {\n                        pointsBufferLength++;\n                    }\n                } else {\n                    for (i = offset; i < totalLength; i += period) {\n                        pointsBuffer[pointsBufferLength] = getLinePoint(i);\n                        if (pointsBuffer[pointsBufferLength]) {\n                            pointsBufferLength++;\n                        }\n                    }\n                }\n            }\n\n            if (linePoints[0] == 'start') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'end') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'endpoints') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(0);\n                pointsBufferLength++;\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength);\n                pointsBufferLength++;\n            }\n\n            if (linePoints[0] == 'middle' || linePoints[0] == 'midpoint') {\n                pointsBuffer[pointsBufferLength] = getLinePoint(totalLength * 0.5);\n                pointsBufferLength++;\n            }\n        }\n    }\n\n    var pointsVertices, vertexBuffer, pointsNormals, normalBuffer, bufferPoints = pointsBufferLength;\n\n    if (point) {\n        var circleBuffer = [];\n        var circleSides = clamp(pointRadius * 8 * 0.5, 8, 32);\n\n        var angle = 0, step = (2.0*Math.PI) / circleSides;\n\n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            angle += step;\n        }\n\n        circleBuffer[circleSides] = [0, 1.0];\n\n        //allocate buffers\n        if (!pointFlat) {\n            pointsVertices = circleSides * 3 * 4;\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\n            pointsNormals = circleSides * 3 * 4;\n            normalBuffer = new Float32Array(bufferPoints * pointsNormals);\n        } else {\n            pointsVertices = circleSides * 3 * 3;\n            vertexBuffer = new Float32Array(bufferPoints * pointsVertices);\n        }\n    }\n\n    if (!pointsBufferLength) {\n        return;\n    }\n\n    //if (pointsBufferLength > 1) {\n      //  globals.directPoints = pointsBuffer.slice(1,pointsBufferLength);\n    //}\n \n    globals.directPoints = pointsBuffer.slice(0,pointsBufferLength);\n\n    for (i = 0; i < pointsBufferLength; i++) {\n        pp = pointsBuffer[i];\n        generatePoint(i);\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    var message, messageSize;\n\n    globals.signatureCounter++;\n    var signature = (\"\"+globals.signatureCounter);\n\n    if (visibility && !Array.isArray(visibility)) {\n        visibility = [visibility];\n    }\n\n    if (point) {\n        if (pointFlat) {\n            postGroupMessageFast(5, 6, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\n        } else {\n            postGroupMessageFast(5, 9, {\n                'color':pointColor, 'z-index':zIndex, 'visibility': visibility, 'center': center,\n                'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent,\n                'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n                'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, \n                'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer, normalBuffer], signature);\n        }\n    }\n\n    var sendIconMessage = (function(){\n\n        if (icon) {\n\n            globals.signatureCounter++;\n            signature = (\"\"+globals.signatureCounter);\n\n            if (iconData.noOverlap) {\n                var margin = iconData.noOverlapMargin;\n                var factorType = null, factorValue = null;\n\n                if (iconData.noOverlapFactor !== null) {\n                    switch(iconData.noOverlapFactor[0]) {\n                        case 'direct':      factorType = 0;      break;\n                        case 'div-by-dist': factorType = 1; break;\n                    }\n\n                    factorValue = iconData.noOverlapFactor[1];\n                }\n\n                var noOverlap = [iconBBox[0]-margin[0], iconBBox[1]-margin[1], iconBBox[2]+margin[0], iconBBox[3]+margin[1], factorType, factorValue];\n            }\n\n            if ((iconData.singleBuffer && iconData.singleBuffer.length > 0) || (iconData.vertexBuffer && iconData.vertexBuffer.length > 0)) {\n\n                postGroupMessageFast(5, (iconData.singleBuffer) ? 3 : 4, {\n                    'icon':globals.stylesheetBitmaps[iconData.source[0]], 'color':iconData.color, 'z-index':zIndex,\n                    'visibility': visibility, 'culling': culling, 'center': pp2, 'stick': iconData.stick,\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'advancedHit': advancedHit,\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'noOverlap' : (iconData.noOverlap ? noOverlap: null),\n                    'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n                    'index': featureIndex, 'reduce': iconData.reduce, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                    (iconData.singleBuffer) ? [iconData.singleBuffer] : [iconData.vertexBuffer, iconData.originBuffer, iconData.texcoordsBuffer],\n                    signature);\n            }\n        }\n\n    });\n\n    var sendLabelMessage = (function(){\n\n        if (label) {\n            globals.signatureCounter++;\n            signature = (\"\"+globals.signatureCounter);\n\n            if (labelData.noOverlap) {\n                var margin = labelData.noOverlapMargin;\n                var factorType = null, factorValue = null;\n\n                if (labelData.noOverlapFactor !== null) {\n                    switch(labelData.noOverlapFactor[0]) {\n                        case 'direct':      factorType = 0;      break;\n                        case 'div-by-dist': factorType = 1; break;\n                    }\n\n                    factorValue = labelData.noOverlapFactor[1];\n                }\n\n                var noOverlap = [labelBBox[0]-margin[0], labelBBox[1]-margin[1], labelBBox[2]+margin[0], labelBBox[3]+margin[1], factorType, factorValue];\n            }\n\n            if ((labelData.singleBuffer && labelData.singleBuffer.length > 0) || (labelData.vertexBuffer && labelData.vertexBuffer.length > 0)) {\n\n                postGroupMessageFast(5, (labelData.singleBuffer) ? 1 : 2, {\n                    'size':labelData.size, 'origin':labelData.pos, 'color':labelData.color,\n                    'color2':labelData.color2, 'outline':labelData.outline, 'z-index':zIndex, 'visibility': visibility,\n                    'culling': culling, 'center': pp2, 'stick': labelData.stick, 'noOverlap' : (labelData.noOverlap ? noOverlap: null),\n                    'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'files':labelData.files, 'index': featureIndex,\n                    'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'fonts': labelData.fontsStorage,\n                    'hitable':hitable, 'state':globals.hitState, 'advancedHit': advancedHit, 'reduce': labelData.reduce, 'hysteresis': labelData.hysteresis, \n                    'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}, 'lod':(globals.autoLod ? null : globals.tileLod) },\n                    (labelData.singleBuffer) ? [labelData.singleBuffer] : [labelData.vertexBuffer, labelData.originBuffer, labelData.texcoordsBuffer],\n                    signature);\n            }\n        }\n\n    });\n\n    if (icon && (!iconData.noOverlap)) {\n        pp2 = center;\n        sendIconMessage();\n    }\n\n    if (label && (!labelData.noOverlap)) {\n        pp2 = center;\n        sendLabelMessage();\n    }\n\n    for (i = 0, li = globals.insidePack ? 1 : globals.directPoints.length; i < li; i++) {\n        pp = globals.directPoints[i];\n        pp2 = [pp[0] + bboxMin[0], pp[1] + bboxMin[1], pp[2] + bboxMin[2]];\n\n        if (icon && (iconData.noOverlap)) {\n            iconBBox = processIcon(pp, iconData, iconBBox) ;//, pointArray, lod, style, zIndex);\n            sendIconMessage();\n        }\n\n        if (label && (labelData.noOverlap)) {\n            labelBBox = processLabel(pp, labelData, labelBBox); //, pointArray, lod, style, zIndex);\n            sendLabelMessage();\n        }\n    }\n\n};\n\n\nvar processPointArrayVSwitchPass = function(pointArray, lod, style, featureIndex, zIndex, eventInfo) {\n    var pointsGroups = []; \n    var i, li;\n\n    checkDPoints(pointArray);\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n    \n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n\n    var visibility = getLayerPropertyValue(style, 'visibility-rel', pointArray, lod) || \n                     getLayerPropertyValue(style, 'visibility-abs', pointArray, lod) ||\n                     getLayerPropertyValue(style, 'visibility', pointArray, lod);\n    var culling = getLayerPropertyValue(style, 'culling', pointArray, lod);\n    var hysteresis = getLayerPropertyValue(style, 'hysteresis', pointArray, lod);\n\n    var points, g, gl, totalPoints = 0;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        if (Array.isArray(points) && points.length > 0) {\n            totalPoints += points.length;\n        }\n    }\n\n    var center = [0,0,0];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var p, p1;\n\n    for (g = 0, gl = pointsGroups.length; g < gl; g++) {\n        points = pointsGroups[g];\n        \n        if (Array.isArray(points) && points.length > 0) {\n       \n            //add ponints\n            for (i = 0, li = points.length; i < li; i++) {\n                p = points[i];\n                p1 = [p[0], p[1], p[2]];\n        \n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                }\n        \n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                }\n        \n                center[0] += p1[0];\n                center[1] += p1[1];\n                center[2] += p1[2];\n            }\n        }\n    }\n   \n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += bboxMin[0];//groupOrigin[0];\n    center[1] += bboxMin[1];//groupOrigin[1];\n    center[2] += bboxMin[2];//groupOrigin[2];\n\n    globals.signatureCounter++;\n    var signature = (\"\"+globals.signatureCounter);\n\n    postGroupMessageFast(5, 20, {\n        'z-index':zIndex, 'hysteresis' : hysteresis,\n        'visibility': visibility, 'culling': culling, 'center': center, 'eventInfo': {} /*(globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {}*/,\n         'index': featureIndex, 'lod':(globals.autoLod ? null : globals.tileLod) }, [], signature);\n};\n\n\nvar getOriginOffset = function(origin, width, height) { //TODO: fix pixel units\n    switch(origin) {\n    case 'top-left':        return [0, 0];\n    case 'top-right':       return [-width, 0];\n    case 'top-center':      return [-width*0.5, 0];\n    case 'center-left':     return [0, -height*0.5];\n    case 'center-right':    return [-width, -height*0.5];\n    case 'center-center':   return [-width*0.5, -height*0.5];\n    case 'bottom-left':     return [0, -height];\n    case 'bottom-right':    return [-width, -height];\n    case 'bottom-center':   return [-width*0.5, -height];\n    }\n};\n\n\nvar processIcon = function(point, iconData, cloneBuffers) {\n\n    if (cloneBuffers) {\n        iconData.index = 0;\n        iconData.index2 = 0;\n        iconData.vertexBuffer = iconData.vertexBuffer ?  (new Float32Array(iconData.vertexBuffer.length)) : null;\n        iconData.originBuffer = iconData.originBuffer ?  (new Float32Array(iconData.originBuffer.length)) : null;\n        iconData.singleBuffer = iconData.singleBuffer ?  (new Float32Array(iconData.singleBuffer.length)) : null;\n    }\n\n    var icon = iconData.source;\n    var index = iconData.index;\n    var index2 = iconData.index2;\n    var lastIndex = index;\n\n    var width = Math.abs(icon[3] * iconData.scale * 0.5);\n    var height = Math.abs(icon[4] * iconData.scale * 0.5);\n\n    //get offset\n    var originOffset = getOriginOffset(iconData.origin, width, height);\n    var offsetX = originOffset[0] + iconData.offset[0];\n    var offsetY = originOffset[1] + iconData.offset[1];\n\n    if (iconData.singleBuffer) {\n        var b = iconData.singleBuffer;\n\n        b[0] = offsetX; b[1] = offsetY;\n        b[2] = icon[1];\n        b[3] = icon[2];\n\n        b[4] = width + offsetX; b[5] = offsetY;\n        b[6] = icon[1]+icon[3];\n        b[7] = icon[2];\n\n        b[8] = width + offsetX; b[9] = height + offsetY;\n        b[10] = icon[1]+icon[3];\n        b[11] = icon[2]+icon[4];\n\n        b[12] = offsetX; b[13] = height + offsetY;\n        b[14] = icon[1];\n        b[15] = icon[2]+icon[4];\n\n        return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n    }\n\n    var vertexBuffer = iconData.vertexBuffer;\n    var texcoordsBuffer = iconData.texcoordsBuffer;\n    var originBuffer = iconData.originBuffer;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = width;\n    vertexBuffer[index+5] = 0;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1]+icon[3];\n    texcoordsBuffer[index+5] = icon[2];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n\n    index += 12;\n\n    //add polygon\n    vertexBuffer[index] = 0;\n    vertexBuffer[index+1] = 0;\n    vertexBuffer[index+2] = 0;\n    vertexBuffer[index+3] = 0;\n\n    vertexBuffer[index+4] = 0;\n    vertexBuffer[index+5] = -height;\n    vertexBuffer[index+6] = 0;\n    vertexBuffer[index+7] = 0;\n\n    vertexBuffer[index+8] = width;\n    vertexBuffer[index+9] = -height;\n    vertexBuffer[index+10] = 0;\n    vertexBuffer[index+11] = 0;\n\n    texcoordsBuffer[index] = icon[1];\n    texcoordsBuffer[index+1] = icon[2];\n    texcoordsBuffer[index+2] = 0;\n    texcoordsBuffer[index+3] = 0;\n\n    texcoordsBuffer[index+4] = icon[1];\n    texcoordsBuffer[index+5] = icon[2]+icon[4];\n    texcoordsBuffer[index+6] = 0;\n    texcoordsBuffer[index+7] = 0;\n\n    texcoordsBuffer[index+8] = icon[1]+icon[3];\n    texcoordsBuffer[index+9] = icon[2]+icon[4];\n    texcoordsBuffer[index+10] = 0;\n    texcoordsBuffer[index+11] = 0;\n    \n    index += 12;\n\n    var p1 = point[0];\n    var p2 = point[1];\n    var p3 = point[2];\n\n    //set origin buffer and apply offset\n    for (var i = lastIndex; i < index; i+=4) {\n        vertexBuffer[i] += offsetX;\n        vertexBuffer[i+1] -= offsetY;\n\n        originBuffer[index2] = p1;\n        originBuffer[index2 + 1] = p2;\n        originBuffer[index2 + 2] = p3;\n        index2 += 3;\n    }\n\n    iconData.index = index;\n    iconData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + width) * 0.5 + 1, (offsetY + height) *0.5];\n};\n\n\nvar processLabel = function(point, labelData, cloneBuffers) {\n\n    if (cloneBuffers) {\n        labelData.index = 0;\n        labelData.index2 = 0;\n        labelData.vertexBuffer = labelData.vertexBuffer ?  (new Float32Array(labelData.vertexBuffer.length)) : null;\n        labelData.originBuffer = labelData.originBuffer ?  (new Float32Array(labelData.originBuffer.length)) : null;\n        labelData.singleBuffer = labelData.singleBuffer ?  (new Float32Array(labelData.singleBuffer.length)) : null;\n    }\n\n    var vertexBuffer = labelData.vertexBuffer;\n    var texcoordsBuffer = labelData.texcoordsBuffer;\n    var originBuffer = labelData.originBuffer;\n    var singleBuffer = labelData.singleBuffer;\n    var index = labelData.index;\n    var index2 = labelData.index2;\n    var lastIndex = index;\n    var text = '' + labelData.text;\n    var fonts = labelData.fonts;\n    var planes = {}, i, li;\n    var glyphsRes = labelData.glyphsRes;\n\n    var linesGlyphsRes = [];\n    var linesGlyphsRes2 = [];\n\n    //split text to lines\n    do {\n        var res = glyphsRes[2].indexOf(10); //search /n\n\n        if (res != -1) {\n            linesGlyphsRes.push([glyphsRes[0].slice(0,res), glyphsRes[1].slice(0,res), glyphsRes[2].slice(0,res)]);\n            glyphsRes = [glyphsRes[0].slice(res+1), glyphsRes[1].slice(res+1), glyphsRes[2].slice(res+1)];\n        } else {\n            linesGlyphsRes.push(glyphsRes);\n        }\n\n    } while (res != -1);\n\n    //split lines by width\n    for (var i = 0, li = linesGlyphsRes.length; i < li; i++) {\n\n        var glyphsRes = linesGlyphsRes[i];\n\n        // eslint-disable-next-line\n        do {\n            var splitIndex = getSplitIndex(null, labelData.width, labelData.size, labelData.spacing, fonts, glyphsRes);\n            var codes = glyphsRes[2];\n\n            if (codes.length == splitIndex) {\n                linesGlyphsRes2.push(glyphsRes);\n                break;\n            }\n\n            linesGlyphsRes2.push([glyphsRes[0].slice(0,splitIndex), glyphsRes[1].slice(0,splitIndex), glyphsRes[2].slice(0,splitIndex)]);\n\n            glyphsRes = [glyphsRes[0].slice(splitIndex+1), glyphsRes[1].slice(splitIndex+1), glyphsRes[2].slice(splitIndex+1)];\n\n        } while(true);\n\n    }\n\n    var x = 0, y = 0;\n    var lineHeight = getLineHeight(labelData.size, labelData.lineHeight, fonts);\n    var maxWidth = 0;\n    var lineWidths = [];\n\n    //get max width\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        lineWidths[i] = getTextLength(null, labelData.size, labelData.spacing, fonts, linesGlyphsRes2[i]);\n        maxWidth = Math.max(lineWidths[i], maxWidth);\n    }\n\n    //generate text\n    for (i = 0, li = linesGlyphsRes2.length; i < li; i++) {\n        var textWidth = lineWidths[i];\n\n        switch(labelData.align) {\n        case 'left': x = 0; break;\n        case 'right': x = maxWidth - textWidth; break;\n        case 'center': x = (maxWidth - textWidth)*0.5; break;\n        }\n\n        index = addText([x,y,0], [1,0,0], null, labelData.size, labelData.spacing, fonts, vertexBuffer, texcoordsBuffer, true, index, planes, linesGlyphsRes2[i], singleBuffer);\n        y -= lineHeight;\n    }\n\n    //get offset\n    var originOffset = getOriginOffset(labelData.origin, maxWidth, -y);\n    var offsetX = originOffset[0] + labelData.offset[0];\n    var offsetY = originOffset[1] + labelData.offset[1];\n    \n    var p1 = point[0];\n    var p2 = point[1];\n    var p3 = point[2];\n\n    //set origin buffer and apply offset\n    if (!singleBuffer) {\n        for (i = lastIndex; i < index; i+=4) {\n            vertexBuffer[i] += offsetX;\n            vertexBuffer[i+1] -= offsetY;\n\n            originBuffer[index2] = p1;\n            originBuffer[index2 + 1] = p2;\n            originBuffer[index2 + 2] = p3;\n            index2 += 3;\n        }\n    } else {\n        for (i = lastIndex; i < index; i+=8) {\n            singleBuffer[i] += offsetX;\n            singleBuffer[i+1] -= offsetY;\n            singleBuffer[i+2] += offsetX;\n            singleBuffer[i+3] -= offsetY;\n        }\n\n        labelData.pos = [p1,p2,p3];\n        singleBuffer = new Float32Array(singleBuffer.buffer, 0, index);\n    }\n    \n    var fonts = labelData.fonts;\n    labelData.files = new Array(fonts.length);\n\n    for (i = 0, li= fonts.length; i < li; i++) {\n        labelData.files[i] = [];\n    }\n\n    for (var key in planes) {\n        var fontIndex = parseInt(key);\n        var planes2 = planes[key];\n\n        var files = [];\n\n        for (var key2 in planes2) {\n            var plane = parseInt(key2) - (fontIndex*4000);\n            var file = Math.round((plane - (plane % 4)) / 4);\n            \n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelData.files[fontIndex] = files;\n    }\n\n    labelData.index = index;\n    labelData.index2 = index2;\n\n    return [offsetX * 0.5, offsetY * 0.5, (offsetX + maxWidth) * 0.5 + 1, (offsetY + Math.abs(y)) *0.5];\n};\n\nvar processPointArrayGeometry = function(pointArray) {\n    var i, li;\n\n    checkDPoints(pointArray);\n\n    if (pointArray['lines']) {  //use lines as points\n        pointsGroups = pointArray['lines'];\n    } else {\n        pointsGroups = [pointArray['points']];\n    }\n    \n    if (!pointsGroups || pointsGroups.length == 0) {\n        return;\n    }\n\n    var totalPoints = 0;\n    var indicesBuffer = new Uint32Array(pointsGroups.length);\n\n    for (i = 0; i < pointsGroups.length; i++) {\n        indicesBuffer[i] = totalPoints;\n\n        if (Array.isArray(pointsGroups[i])) {\n            totalPoints += pointsGroups[i].length;\n        }\n    }\n\n    var geometryBuffer = new Float64Array(totalPoints * 3);\n\n    /*var forceOrigin = globals.forceOrigin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;*/\n    var forceScale = globals.forceScale;\n    var index = 0, p1, p2, pp, p;\n\n    for (var i = 0; i < pointsGroups.length; i++) {\n        if (!Array.isArray(pointsGroups[i]) || !pointsGroups[i].length) {\n            continue;\n        }\n        \n        var points = pointsGroups[i];\n   \n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n    \n        //add lines\n        for (var j = 0, lj = points.length; j < lj; j++) {\n\n            /*if (forceOrigin) {\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }*/\n    \n            if (forceScale != null) {\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            geometryBuffer[index] = pp[0];\n            geometryBuffer[index+1] = pp[1];\n            geometryBuffer[index+2] = pp[2];\n            index += 3;\n\n            if (j == (lj - 1)) {\n                break;\n            }\n    \n            p1 = points[j+1];\n        }\n    }\n\n    globals.signatureCounter++;\n    postGroupMessageFast(5, 5, {\n        'id':pointArray['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n};\n\n\n\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_text_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_message_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__ = __webpack_require__(4);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return processLineStringPass; });\n/* unused harmony export processLineLabel */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return processLineStringGeometry; });\n\n\n\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */], vec3Normalize = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"g\" /* vec3Normalize */],\n    vec3Cross = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"i\" /* vec3Cross */];\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"c\" /* getLayerPropertyValue */],\n    getLayerExpresionValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"g\" /* getLayerExpresionValue */], hasLayerProperty = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"h\" /* hasLayerProperty */];\nvar addStreetTextOnPath = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"n\" /* addStreetTextOnPath */], areTextCharactersAvailable = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"e\" /* areTextCharactersAvailable */],\n    getCharVerticesCount = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"l\" /* getCharVerticesCount */], getFonts = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"j\" /* getFonts */], getFontsStorage = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"k\" /* getFontsStorage */];\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_3__worker_message_js__[\"c\" /* postGroupMessageFast */], getTextGlyphs = __WEBPACK_IMPORTED_MODULE_2__worker_text_js__[\"h\" /* getTextGlyphs */];\nvar checkDPoints = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\"d\" /* checkDPoints */];\n\n\nvar getLineInfo = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\n\n};\n\nvar processLineStringPass = function(lineString, lod, style, featureIndex, zIndex, eventInfo) {\n\n    checkDPoints(lineString);\n\n    var lines = lineString['lines'];\n\n    if (!lines || lines.length == 0) {\n        return;\n    }\n\n    var line = getLayerPropertyValue(style, 'line', lineString, lod);\n    var lineLabel = getLayerPropertyValue(style, 'line-label', lineString, lod);\n\n    if (!line && !lineLabel) {\n        return;\n    }\n\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n\n    if (hasLayerProperty(style,'line-type')) {\n\n    } else {\n        var lineFlat = getLayerPropertyValue(style, 'line-flat', lineString, lod);\n    }\n\n    var lineColor = getLayerPropertyValue(style, 'line-color', lineString, lod);\n    var lineWidth = 0.5 * getLayerPropertyValue(style, 'line-width', lineString, lod);\n    var lineWidthUnits = getLayerPropertyValue(style, 'line-width-units', lineString, lod);\n\n    var lineStyle = getLayerPropertyValue(style, 'line-style', lineString, lod);\n    var lineStyleTexture = getLayerPropertyValue(style, 'line-style-texture', lineString, lod);\n    var lineStyleBackground = getLayerPropertyValue(style, 'line-style-background', lineString, lod);\n\n    var lineLabelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n\n    var texturedLine = (lineStyle != 'solid');\n    var widthByRatio = (lineWidthUnits == 'ratio');\n\n    if (lineWidthUnits == 'points') {\n        lineWidth *= globals.pixelFactor / ((1 / 72) * (96));\n    }\n\n    var index = 0, index2 = 0, index3 = 0;\n    var skipJoins = false;\n\n    if (widthByRatio) {\n        skipJoins = (!lineFlat && ((lineWidth/* *globals.invPixelFactor*/)*1080) < 2.1);\n    } else {\n        skipJoins = (!lineFlat && (lineWidth/* *globals.invPixelFactor*/) < 2.1);        \n    }\n\n    var ii, i, li, p2, v, vv, l, n, nn, p1, p, elementIndex, elemetBase = 1;\n\n    if (!skipJoins) {\n        var circleBuffer = [];\n        var circleBuffer2 = [];\n        var circleSides = 8;//Math.max(8, (14 - lod) * 8);\n    \n        var angle = 0, step = (2.0*Math.PI) / circleSides;\n    \n        for (i = 0; i < circleSides; i++) {\n            circleBuffer[i] = [-Math.sin(angle), Math.cos(angle)];\n            circleBuffer2[i] = angle;\n            angle += step;\n        }\n    \n        circleBuffer[circleSides] = [0, 1.0];\n        circleBuffer2[circleSides] = 0;\n    }\n\n    var totalPoints = 0;\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (Array.isArray(lines[ii])) {\n            totalPoints += lines[ii].length;\n        }\n    }\n\n    if (totalPoints <= 1) {\n        return;\n    }\n\n    if (lineFlat) {\n        circleSides = 2;\n    }\n\n    //allocate buffers\n    var lineVertices = ((texturedLine || (widthByRatio)) || !lineFlat ? 4 : 3) * 3 * 2;\n    var joinVertices = skipJoins ? 0 : (circleSides * ((texturedLine || (widthByRatio)) || !lineFlat? 4 : 3) * 3);\n    var vertexBuffer = new Float32Array((totalPoints-1) * lineVertices + totalPoints * joinVertices);\n\n    if (advancedHit) {\n       var elementBuffer = new Float32Array((totalPoints-1) * (3 * 2) + totalPoints * (skipJoins ? 0 : circleSides) * 3);\n    }\n\n    if (!(lineFlat && !texturedLine && !widthByRatio)) {\n        var lineNormals = 3 * 4 * 2;\n        var joinNormals = skipJoins ? 0 : (circleSides * 3 * 4);\n        var normalBuffer = new Float32Array((totalPoints-1) * lineNormals + totalPoints * joinNormals);\n    }\n\n    var center = [0,0,0];\n    var lineLabelStack = [];\n    var forceOrigin = globals.forceOrigin;\n    var bboxMin = globals.bboxMin;\n    var geocent = globals.geocent;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceScale = globals.forceScale;\n    var vstart = [1,0,0], vend = [-1,0,0];\n\n    for (ii = 0; ii < lines.length; ii++) {\n        if (!Array.isArray(lines[ii]) || !lines[ii].length) {\n            continue;\n        }\n        \n        var points = lines[ii];\n\n        if (lineLabel) {\n            var lineLabelPoints = new Array(points.length);\n            var lineLabelPoints2 = new Array(points.length);\n            \n            lineLabelStack.push({points: lineLabelPoints, points2 :lineLabelPoints2});\n        }\n    \n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n    \n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n    \n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n    \n        var distance = 0.001;\n        var distance2 = 0.001;\n        /*var ln = null;*/\n        var vertexBase = index;\n        var normalBase = index2;\n\n        //add lines\n        for (i = 0, li = points.length - 1; i < li; i++) {\n    \n            p1 = points[i];\n            p2 = points[i+1];\n\n            if (forceOrigin) {\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n            }\n\n            if (forceScale != null) {\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n            }\n    \n            if (advancedHit) {\n                elementIndex = elemetBase + i;\n\n                elementBuffer[index3] = elementIndex;\n                elementBuffer[index3+1] = elementIndex;\n                elementBuffer[index3+2] = elementIndex;\n    \n                //add polygon\n                elementBuffer[index3+3] = elementIndex;\n                elementBuffer[index3+4] = elementIndex;\n                elementBuffer[index3+5] = elementIndex;\n\n                index3 += 6;\n            }\n\n            if (lineFlat && !texturedLine && !widthByRatio) {\n\n                //normalize vector to line width and rotate 90 degrees\n                if (geocent) {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                    distance2 += l;\n        \n                    l = (l != 0) ? (1 / l) : 0;\n\n                    vv = [v[0]*l, v[1]*l, v[2]*l];\n                    n = [0,0,0];\n                    nn = [0,0,0];\n                    \n                    vec3Normalize(bboxMin, nn);\n                    vec3Cross(nn, vv, n);\n\n                    if (i == 0) {\n                        vstart = vv;\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = vv;\n                    }\n                    \n                    n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                } else {\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n        \n                    l = (l != 0) ? (lineWidth / l) : 0;\n\n                    n = [-v[1]*l, v[0]*l, 0];\n\n                    if (i == 0) {\n                        vstart = [v[0]*l, v[1]*l, 0];\n                    }\n\n                    if (i == (li - 1)) {\n                        vend = [v[0]*l, v[1]*l, 0];\n                    }\n                }\n                        \n                //add polygon\n                vertexBuffer[index] = p1[0] + n[0];\n                vertexBuffer[index+1] = p1[1] + n[1];\n                vertexBuffer[index+2] = p1[2] + n[2];\n    \n                vertexBuffer[index+3] = p1[0] - n[0];\n                vertexBuffer[index+4] = p1[1] - n[1];\n                vertexBuffer[index+5] = p1[2] - n[2];\n    \n                vertexBuffer[index+6] = p2[0] + n[0];\n                vertexBuffer[index+7] = p2[1] + n[1];\n                vertexBuffer[index+8] = p2[2] + n[2];\n    \n                //add polygon\n                vertexBuffer[index+9] = p1[0] - n[0];\n                vertexBuffer[index+10] = p1[1] - n[1];\n                vertexBuffer[index+11] = p1[2] - n[2];\n    \n                vertexBuffer[index+12] = p2[0] - n[0];\n                vertexBuffer[index+13] = p2[1] - n[1];\n                vertexBuffer[index+14] = p2[2] - n[2];\n    \n                vertexBuffer[index+15] = p2[0] + n[0];\n                vertexBuffer[index+16] = p2[1] + n[1];\n                vertexBuffer[index+17] = p2[2] + n[2];\n    \n                index += 18;\n\n            } else {\n    \n   \n                //console.log(\"distance(\"+i+\"): \" + distance + \" \" + distance2);\n    \n                if (lineFlat) {\n                    \n                    /*\n                    //normalize vector to line width and rotate 90 degrees\n                    l = (l != 0) ? (lineWidth / l) : 0;\n                    n = [-v[1]*l, v[0]*l,0];\n    \n                    if (joinParams != null) {\n                        joinParams[i] = (l != 0) ? Math.atan2(v[0], v[1]) + Math.PI *0.5 : 0;\n                    }*/\n    \n                    //normalize vector to line width and rotate 90 degrees\n                    if (geocent) {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];\n            \n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n                        distance2 += l;\n            \n                        l = (l != 0) ? (1 / l) : 0;\n\n                        vv = [v[0]*l, v[1]*l, v[2]*l];\n                        n = [0,0,0];\n                        nn = [0,0,0];\n\n                        if (i == 0) {\n                            vstart = vv;\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = vv;\n                        }\n                        \n                        vec3Normalize(bboxMin, nn);\n                        vec3Cross(nn, vv, n);\n                        \n                        //n = [n[0] * lineWidth, n[1] * lineWidth, n[2] * lineWidth];\n                        n = [n[0], n[1], n[2]];\n                    } else {\n                        //direction vector\n                        v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n            \n                        //get line length\n                        l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                        distance2 += l;\n            \n                        l = (l != 0) ? (lineWidth / l) : 0;\n\n                        n = [-v[1], v[0], 0];\n\n                        if (i == 0) {\n                            vstart = [v[0]*l, v[1]*l, 0];\n                        }\n\n                        if (i == (li - 1)) {\n                            vend = [v[0]*l, v[1]*l, 0];\n                        }\n                    }\n\n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = n[0];\n                    normalBuffer[index2+1] = n[1];\n                    normalBuffer[index2+2] = n[2];\n                    normalBuffer[index2+3] = lineWidth;\n    \n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = -n[0];\n                    normalBuffer[index2+5] = -n[1];\n                    normalBuffer[index2+6] = -n[2];\n                    normalBuffer[index2+7] = lineWidth;\n    \n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = distance2;\n                    normalBuffer[index2+8] = n[0];\n                    normalBuffer[index2+9] = n[1];\n                    normalBuffer[index2+10] = n[2];\n                    normalBuffer[index2+11] = lineWidth;\n    \n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = -distance;\n                    normalBuffer[index2+12] = -n[0];\n                    normalBuffer[index2+13] = -n[1];\n                    normalBuffer[index2+14] = -n[2];\n                    normalBuffer[index2+15] = lineWidth;\n    \n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = -n[0];\n                    normalBuffer[index2+17] = -n[1];\n                    normalBuffer[index2+18] = -n[2];\n                    normalBuffer[index2+19] = lineWidth;\n    \n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = n[0];\n                    normalBuffer[index2+21] = n[1];\n                    normalBuffer[index2+22] = n[2];\n                    normalBuffer[index2+23] = lineWidth;\n    \n                    index += 24;\n                    index2 += 24;\n                    \n                } else {\n\n                    //direction vector\n                    v = [p2[0] - p1[0], p2[1] - p1[1], 0];\n        \n                    //get line length\n                    l = Math.sqrt(v[0]*v[0] + v[1]*v[1]);\n                    distance2 += l;\n    \n                    //add polygon\n                    vertexBuffer[index] = p1[0];\n                    vertexBuffer[index+1] = p1[1];\n                    vertexBuffer[index+2] = p1[2];\n                    vertexBuffer[index+3] = distance;\n                    normalBuffer[index2] = p2[0];\n                    normalBuffer[index2+1] = p2[1];\n                    normalBuffer[index2+2] = p2[2];\n                    normalBuffer[index2+3] = lineWidth;\n    \n                    vertexBuffer[index+4] = p1[0];\n                    vertexBuffer[index+5] = p1[1];\n                    vertexBuffer[index+6] = p1[2];\n                    vertexBuffer[index+7] = -distance;\n                    normalBuffer[index2+4] = p2[0];\n                    normalBuffer[index2+5] = p2[1];\n                    normalBuffer[index2+6] = p2[2];\n                    normalBuffer[index2+7] = -lineWidth;\n    \n                    vertexBuffer[index+8] = p2[0];\n                    vertexBuffer[index+9] = p2[1];\n                    vertexBuffer[index+10] = p2[2];\n                    vertexBuffer[index+11] = -distance2;\n                    normalBuffer[index2+8] = p1[0];\n                    normalBuffer[index2+9] = p1[1];\n                    normalBuffer[index2+10] = p1[2];\n                    normalBuffer[index2+11] = lineWidth;\n    \n                    //add polygon\n                    vertexBuffer[index+12] = p1[0];\n                    vertexBuffer[index+13] = p1[1];\n                    vertexBuffer[index+14] = p1[2];\n                    vertexBuffer[index+15] = distance;\n                    normalBuffer[index2+12] = p2[0];\n                    normalBuffer[index2+13] = p2[1];\n                    normalBuffer[index2+14] = p2[2];\n                    normalBuffer[index2+15] = lineWidth;\n    \n                    vertexBuffer[index+16] = p2[0];\n                    vertexBuffer[index+17] = p2[1];\n                    vertexBuffer[index+18] = p2[2];\n                    vertexBuffer[index+19] = -distance2;\n                    normalBuffer[index2+16] = p1[0];\n                    normalBuffer[index2+17] = p1[1];\n                    normalBuffer[index2+18] = p1[2];\n                    normalBuffer[index2+19] = lineWidth;\n    \n                    vertexBuffer[index+20] = p2[0];\n                    vertexBuffer[index+21] = p2[1];\n                    vertexBuffer[index+22] = p2[2];\n                    vertexBuffer[index+23] = distance2;\n                    normalBuffer[index2+20] = p1[0];\n                    normalBuffer[index2+21] = p1[1];\n                    normalBuffer[index2+22] = p1[2];\n                    normalBuffer[index2+23] = -lineWidth;\n    \n                    index += 24;\n                    index2 += 24;\n                }\n            }\n    \n            distance = distance2;\n            p1 = p2; //only for dlines\n        }\n    \n        p1 = [p[0], p[1], p[2]];\n    \n        //add joins\n        for (i = 0, li = points.length; i < li; i++) {\n    \n            if (forceOrigin) {\n                p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }\n    \n            if (forceScale != null) {\n                p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n    \n            center[0] += p1[0];\n            center[1] += p1[1];\n            center[2] += p1[2];\n            \n            if (!skipJoins) {\n                var angleShift = 0;//(joinParams != null) ? joinParams[i] : 0;\n                /*var dx, dy;*/\n\n                if (lineFlat) {\n\n                    if (advancedHit) {\n                        elementIndex = elemetBase + ((i != (li-1)) ? i : (i -1));\n\n                        elementBuffer[index3] = elementIndex;\n                        elementBuffer[index3+1] = elementIndex;\n                        elementBuffer[index3+2] = elementIndex;\n            \n                        //add polygon\n                        elementBuffer[index3+3] = elementIndex;\n                        elementBuffer[index3+4] = elementIndex;\n                        elementBuffer[index3+5] = elementIndex;\n\n                        index3 += 6;\n                    }\n\n                    var lineIndex, lineIndex2;\n\n                    if (!(texturedLine || widthByRatio)) {\n\n                        if (i != (li-1)) {\n                            lineIndex = vertexBase + i * lineVertices;\n                        } else {\n                            lineIndex = vertexBase + (i - 1) * lineVertices;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = vertexBase + (i - 1) * lineVertices;\n                        } else {\n                            lineIndex2 = vertexBase + lineIndex;\n                        }\n\n                        if (i == 0) { //start cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] - vstart[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = p1[0] - vstart[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] - vstart[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] - vstart[2] * lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex+15];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+16];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+17];\n\n                            vertexBuffer[index+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+8] = p1[2] + vend[2] * lineWidth;\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+12];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+13];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+14];\n\n                            vertexBuffer[index+9+6] = p1[0] + vend[0] * lineWidth;\n                            vertexBuffer[index+9+7] = p1[1] + vend[1] * lineWidth;\n                            vertexBuffer[index+9+8] = p1[2] + vend[2] * lineWidth;\n                        } else {\n                            //add polygon\n                            vertexBuffer[index] = p1[0];\n                            vertexBuffer[index+1] = p1[1];\n                            vertexBuffer[index+2] = p1[2];\n\n                            vertexBuffer[index+3] = vertexBuffer[lineIndex];\n                            vertexBuffer[index+4] = vertexBuffer[lineIndex+1];\n                            vertexBuffer[index+5] = vertexBuffer[lineIndex+2];\n\n                            vertexBuffer[index+6] = vertexBuffer[lineIndex2 + 15];\n                            vertexBuffer[index+7] = vertexBuffer[lineIndex2 + 16];\n                            vertexBuffer[index+8] = vertexBuffer[lineIndex2 + 17];\n\n                            //add polygon\n                            vertexBuffer[index+9] = p1[0];\n                            vertexBuffer[index+9+1] = p1[1];\n                            vertexBuffer[index+9+2] = p1[2];\n\n                            vertexBuffer[index+9+3] = vertexBuffer[lineIndex+3];\n                            vertexBuffer[index+9+4] = vertexBuffer[lineIndex+4];\n                            vertexBuffer[index+9+5] = vertexBuffer[lineIndex+5];\n\n                            vertexBuffer[index+9+6] = vertexBuffer[lineIndex2 + 12];\n                            vertexBuffer[index+9+7] = vertexBuffer[lineIndex2 + 13];\n                            vertexBuffer[index+9+8] = vertexBuffer[lineIndex2 + 14];\n                        }\n\n                        index += 18;\n\n                    } else {\n\n                        if (i != (li-1)) {\n                            distance = vertexBuffer[i * lineVertices + 3];\n                        } else {\n                            distance = vertexBuffer[(i - 1) * lineVertices + 11];\n                        }\n\n                        if (i != (li-1)) {\n                            lineIndex = normalBase + i * lineVertices;\n                        } else {\n                            lineIndex = normalBase + (i - 1) * lineVertices + 8;\n                        }\n\n                        if (i > 0) {\n                            lineIndex2 = normalBase + (i - 1) * lineVertices + 8;\n                        } else {\n                            lineIndex2 = normalBase + lineIndex;\n                        }\n\n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n\n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n\n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n\n                        //add polygon\n                        vertexBuffer[index+12] = p1[0];\n                        vertexBuffer[index+1+12] = p1[1];\n                        vertexBuffer[index+2+12] = p1[2];\n                        vertexBuffer[index+3+12] = distance;\n\n                        vertexBuffer[index+4+12] = p1[0];\n                        vertexBuffer[index+5+12] = p1[1];\n                        vertexBuffer[index+6+12] = p1[2];\n                        vertexBuffer[index+7+12] = -distance;\n\n                        vertexBuffer[index+8+12] = p1[0];\n                        vertexBuffer[index+9+12] = p1[1];\n                        vertexBuffer[index+10+12] = p1[2];\n                        vertexBuffer[index+11+12] = -distance;\n\n                        if (i == 0) { //start cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = -vstart[0];\n                            normalBuffer[index2+9] = -vstart[1];\n                            normalBuffer[index2+10] = -vstart[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = -vstart[0];\n                            normalBuffer[index2+9+12] = -vstart[1];\n                            normalBuffer[index2+10+12] = -vstart[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else if (i == (li - 1)) {  //end cap\n                            //first polygon\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = vend[0];\n                            normalBuffer[index2+9] = vend[1];\n                            normalBuffer[index2+10] = vend[2];\n                            normalBuffer[index2+11] = -lineWidth;\n\n                            //second polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = vend[0];\n                            normalBuffer[index2+9+12] = vend[1];\n                            normalBuffer[index2+10+12] = vend[2];\n                            normalBuffer[index2+11+12] = -lineWidth;\n                        } else {\n                            normalBuffer[index2] = 0;\n                            normalBuffer[index2+1] = 0;\n                            normalBuffer[index2+2] = 0;\n                            normalBuffer[index2+3] = -lineWidth;\n            \n                            normalBuffer[index2+4] = normalBuffer[lineIndex];\n                            normalBuffer[index2+5] = normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6] = normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7] = lineWidth;\n            \n                            normalBuffer[index2+8] = normalBuffer[lineIndex2];\n                            normalBuffer[index2+9] = normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10] = normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11] = lineWidth;\n\n                            //add polygon\n                            normalBuffer[index2+12] = 0;\n                            normalBuffer[index2+1+12] = 0;\n                            normalBuffer[index2+2+12] = 0;\n                            normalBuffer[index2+3+12] = -lineWidth;\n\n                            normalBuffer[index2+4+12] = -normalBuffer[lineIndex];\n                            normalBuffer[index2+5+12] = -normalBuffer[lineIndex+1];\n                            normalBuffer[index2+6+12] = -normalBuffer[lineIndex+2];\n                            normalBuffer[index2+7+12] = lineWidth;\n            \n                            normalBuffer[index2+8+12] = -normalBuffer[lineIndex2];\n                            normalBuffer[index2+9+12] = -normalBuffer[lineIndex2+1];\n                            normalBuffer[index2+10+12] = -normalBuffer[lineIndex2+2];\n                            normalBuffer[index2+11+12] = lineWidth;\n                        }\n\n                        index += 24;\n                        index2 += 24;\n\n                    }\n\n                } else {\n\n                    var segmentIndex = (i != (li-1)) ? i : (i - 1);\n\n                    for (var j = 0; j < circleSides; j++) {\n           \n                        if (advancedHit) {\n                            elementIndex = elemetBase + segmentIndex;\n                            elementBuffer[index3] = elementIndex;\n                            elementBuffer[index3+1] = elementIndex;\n                            elementBuffer[index3+2] = elementIndex;\n                            index3 += 3;\n                        }\n\n                        distance = vertexBuffer[segmentIndex * lineVertices + 3];\n        \n                        //add polygon\n                        vertexBuffer[index] = p1[0];\n                        vertexBuffer[index+1] = p1[1];\n                        vertexBuffer[index+2] = p1[2];\n                        vertexBuffer[index+3] = distance;\n                        normalBuffer[index2] = 0;\n                        normalBuffer[index2+1] = 0;\n                        normalBuffer[index2+2] = 0;\n                        normalBuffer[index2+3] = 0;\n        \n                        vertexBuffer[index+4] = p1[0];\n                        vertexBuffer[index+5] = p1[1];\n                        vertexBuffer[index+6] = p1[2];\n                        vertexBuffer[index+7] = distance;\n                        normalBuffer[index2+4] = circleBuffer[j][0] * lineWidth;\n                        normalBuffer[index2+5] = circleBuffer[j][1] * lineWidth;\n                        normalBuffer[index2+6] = circleBuffer2[j] + angleShift;\n                        normalBuffer[index2+7] = 0;\n        \n                        vertexBuffer[index+8] = p1[0];\n                        vertexBuffer[index+9] = p1[1];\n                        vertexBuffer[index+10] = p1[2];\n                        vertexBuffer[index+11] = distance;\n                        normalBuffer[index2+8] = circleBuffer[j+1][0] * lineWidth;\n                        normalBuffer[index2+9] = circleBuffer[j+1][1] * lineWidth;\n                        normalBuffer[index2+10] = circleBuffer2[j+1] + angleShift;\n                        normalBuffer[index2+11] = 0;\n        \n                        index += 12;\n                        index2 += 12;\n                    }\n                }\n            }\n    \n            if (lineLabel) {\n                p = [p1[0], p1[1], p1[2] + lineLabelSize*0.1];\n                lineLabelPoints[i] = p;\n                lineLabelPoints2[li - i - 1] = p;\n            }\n    \n            if ((i + 1) < li) {\n                p1 = points[i+1];\n            }\n        }\n\n        elemetBase += points.length;\n    }\n\n    if (totalPoints > 0) {\n        center[0] /= totalPoints;\n        center[1] /= totalPoints;\n        center[2] /= totalPoints;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent, type;\n\n    if (line) {\n        //console.log('totalPoints:' + totalPoints + ' vbuff-l:' + (vertexBuffer ? vertexBuffer.length : '??'));\n\n        var messageData = {\n            'color':lineColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'totalPoints': totalPoints,\n            'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'width-units': lineWidthUnits,\n            'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n            'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, \n            'line-width':lineWidth*2, 'lod':(globals.autoLod ? null : globals.tileLod) };\n    \n        if (lineFlat) {\n            type = texturedLine ? 8 : (widthByRatio ? 7 : 6);\n        } else {\n            type = texturedLine ? 10 : 9;\n        }\n    \n        if (texturedLine) {\n            if (lineStyleTexture != null) {\n                messageData['texture'] = [globals.stylesheetBitmaps[lineStyleTexture[0]], lineStyleTexture[1], lineStyleTexture[2]];\n                messageData['background'] = lineStyleBackground;\n            }\n        }\n\n        var signature = JSON.stringify({\n            type: 'T'+type,\n            color : lineColor,\n            zIndex : zIndex,\n            zOffset : zbufferOffset,\n            state : globals.hitState\n        });\n\n        var buffers = (normalBuffer) ? [vertexBuffer, normalBuffer] : [vertexBuffer];\n\n        if (advancedHit) {\n            buffers.push(elementBuffer);\n        }\n        \n        postGroupMessageFast(5, type, messageData, buffers, signature);\n    }\n\n    if (lineLabel) {\n        for (i = 0, li = lineLabelStack.length; i < li; i++) {\n            processLineLabel(lineLabelStack[i].points, lineLabelStack[i].points2, lineString, center, lod, style, featureIndex, zIndex, eventInfo);\n        }\n    }\n\n};\n\nvar processLineLabel = function(lineLabelPoints, lineLabelPoints2, lineString, center, lod, style, featureIndex, zIndex, eventInfo) {\n    var labelColor = getLayerPropertyValue(style, 'line-label-color', lineString, lod);\n    var labelColor2 = getLayerPropertyValue(style, 'line-label-color2', lineString, lod);\n    var labelOutline = getLayerPropertyValue(style, 'line-label-outline', lineString, lod);\n    var labelSource = getLayerPropertyValue(style, 'line-label-source', lineString, lod);\n    var labelSize = getLayerPropertyValue(style, 'line-label-size', lineString, lod);\n    var labelSpacing = getLayerPropertyValue(style, 'line-label-spacing', lineString, lod);\n    var labelLineHeight = getLayerPropertyValue(style, 'line-label-line-height', lineString, lod);\n    var labelOffset = getLayerPropertyValue(style, 'line-label-offset', lineString, lod);\n    var labelReduce =  getLayerPropertyValue(style, 'dynamic-reduce', lineString, lod);\n    var labelOverlap = getLayerPropertyValue(style, 'line-label-no-overlap', lineString, lod);\n    var labelOverlapFactor = getLayerPropertyValue(style, 'line-label-no-overlap-factor', lineString, lod);\n    var labelOverlapMargin = getLayerPropertyValue(style, 'line-label-no-overlap-margin', lineString, lod);\n\n    if (Math.abs(labelSize) < 0.0001) {\n        return;\n    }\n\n    var labelText = getLayerExpresionValue(style, labelSource, lineString, lod, labelSource);\n    labelText = labelText ? labelText.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n    var fontNames = getLayerPropertyValue(style, 'line-label-font', lineString, lod);\n    var fonts = getFonts(fontNames);\n    var fontsStorage = getFontsStorage(fontNames);\n    var glyphsRes = getTextGlyphs(labelText, fonts);\n\n    if (labelSource == '$name') {\n        if (!areTextCharactersAvailable(labelText, fonts, glyphsRes)) {\n            var labelText2 = getLayerExpresionValue(style, '$name:en', lineString, lod, labelSource);\n            labelText2 = labelText2 ? labelText2.replace('\\r\\n', '\\n').replace('\\r', '\\n') : '';\n            var glyphsRes2 = getTextGlyphs(labelText, fonts);\n            \n            if (areTextCharactersAvailable(labelText2, fonts, glyphsRes2)) {\n                labelText = labelText2;                     \n                glyphsRes = glyphsRes2;\n            }\n        }\n    }\n\n    if (!labelText || labelText == '') {\n        return;\n    }\n\n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', lineString, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', lineString, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', lineString, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', lineString, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', lineString, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', lineString, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', lineString, lod);\n\n    var bufferSize, vertexBuffer, texcoordsBuffer, singleBuffer, singleBuffer2;\n\n    if (globals.useLineLabel2) {\n        bufferSize = 12 * labelText.length;\n        singleBuffer = new Float32Array(bufferSize);\n        singleBuffer2 = new Float32Array(bufferSize);\n    } else {\n        bufferSize = getCharVerticesCount() * labelText.length * 2;\n        vertexBuffer = new Float32Array(bufferSize);\n        texcoordsBuffer = new Float32Array(bufferSize);\n    }\n\n    var planes = {};\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n\n    globals.lineLabelPoints = [];\n    var index = addStreetTextOnPath(lineLabelPoints, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, 0, planes, glyphsRes, singleBuffer);\n    var labelPoints = globals.lineLabelPoints;\n\n    globals.lineLabelPoints = [];\n    index = addStreetTextOnPath(lineLabelPoints2, labelText, labelSize, labelSpacing, fonts, labelOffset, vertexBuffer, texcoordsBuffer, globals.useLineLabel2 ? 0 : index, null, glyphsRes, singleBuffer2);\n    var labelPoints2 = globals.lineLabelPoints;\n\n    if (!index) {\n        return;\n    }\n\n    //var fonts = labelData.fonts;\n    var labelFiles = new Array(fonts.length);\n\n    for (var i = 0, li= fonts.length; i < li; i++) {\n        labelFiles[i] = [];\n    }\n\n    for (var key in planes) {\n        var fontIndex = parseInt(key);\n        var planes2 = planes[key];\n\n        var files = [];\n\n        for (var key2 in planes2) {\n            var plane = parseInt(key2) - (fontIndex*4000);\n            var file = Math.round((plane - (plane % 4)) / 4);\n\n            if (files.indexOf(file) == -1) {\n                files.push(file);\n            }\n        }\n\n        labelFiles[fontIndex] = files;\n    }\n\n    var signature = JSON.stringify({\n        type: 'line-label',\n        color : labelColor,\n        color2 : labelColor2,\n        outline : labelOutline,\n        fonts : fontNames,\n        zIndex : zIndex,\n        zOffset : zbufferOffset\n    });\n\n\n    if (labelOverlap) {\n        var factorType = null, factorValue = null;\n\n        if (labelOverlapFactor !== null) {\n            switch(labelOverlapFactor[0]) {\n                case 'direct':      factorType = 0;      break;\n                case 'div-by-dist': factorType = 1; break;\n            }\n\n            factorValue = labelOverlapFactor[1];\n        }\n\n        var noOverlap = [labelOverlapMargin, factorType, factorValue];\n    }\n\n    postGroupMessageFast(5, globals.useLineLabel2 ? 12 : 11, {\n        'color':labelColor, 'color2':labelColor2, 'outline':labelOutline, 'textVector':globals.textVector, 'labelPoints': globals.useLineLabel2 ? [labelPoints, labelPoints2] : [],\n        'z-index':zIndex, 'center': center, 'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'reduce':labelReduce, 'noOverlap': (labelOverlap ? noOverlap : null),\n        'files': labelFiles, 'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset, 'advancedHit': advancedHit,\n        'fonts': fontsStorage, 'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n        'lod':(globals.autoLod ? null : globals.tileLod) }, globals.useLineLabel2 ? [singleBuffer, singleBuffer2] : [vertexBuffer, texcoordsBuffer], signature);\n};\n\nvar processLineStringGeometry = function(lineString) {\n\n    checkDPoints(lineString);\n\n    var lines = lineString['lines'];\n\n    if (lines || lines.length == 0) {\n        return;\n    }\n\n    //debugger\n    var totalPoints = 0;\n    var indicesBuffer = new Uint32Array(lines.length);\n\n    for (i = 0; i < lines.length; i++) {\n        indicesBuffer[i] = totalPoints;\n\n        if (Array.isArray(lines[i])) {\n            totalPoints += lines[i].length;\n        }\n    }\n\n    var geometryBuffer = new Float64Array(totalPoints * 3);\n\n    /*var forceOrigin = globals.forceOrigin;\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;*/\n    var forceScale = globals.forceScale;\n    var index = 0, p1, p2, pp, p;\n\n    for (var i = 0; i < lines.length; i++) {\n        if (!Array.isArray(lines[i]) || !lines[i].length) {\n            continue;\n        }\n        \n        var points = lines[i];\n   \n        p = points[0];\n        p1 = [p[0], p[1], p[2]];\n    \n        //add lines\n        for (var j = 0, lj = points.length; j < lj; j++) {\n\n            /*if (forceOrigin) {\n                pp = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n            }*/\n    \n            if (forceScale != null) {\n                pp = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n            }\n\n            geometryBuffer[index] = pp[0];\n            geometryBuffer[index+1] = pp[1];\n            geometryBuffer[index+2] = pp[2];\n            index += 3;\n\n            if (j == (lj - 1)) {\n                break;\n            }\n    \n            p1 = points[j+1];\n        }\n    }\n\n    globals.signatureCounter++;\n\n    postGroupMessageFast(5, 14, {\n        'id':lineString['id'] }, [geometryBuffer, indicesBuffer], (\"\"+globals.signatureCounter));\n};\n\n\n\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_style_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_message_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__ = __webpack_require__(4);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return processPolygonPass; });\n\n\n\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */], vec3Normalize = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"g\" /* vec3Normalize */];\nvar getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_1__worker_style_js__[\"c\" /* getLayerPropertyValue */];\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_2__worker_message_js__[\"c\" /* postGroupMessageFast */];\nvar processLineStringPass = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\"a\" /* processLineStringPass */];\nvar processPointArrayPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\"a\" /* processPointArrayPass */];\n\nvar processPolygonPass = function(polygon, lod, style, featureIndex, zIndex, eventInfo) {\n    var vertices = polygon['vertices'] || [];\n    if (vertices.length == 0) {\n        return;\n    }\n    \n    // borders as points\n    if (getLayerPropertyValue(style, 'point', polygon, lod) ||\n        getLayerPropertyValue(style, 'label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, false);\n    }\n    \n    // borders as lines\n    if (getLayerPropertyValue(style, 'line', polygon, lod) ||\n        getLayerPropertyValue(style, 'line-label', polygon, lod)) {\n        processPolygonLines(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, true);\n    }\n    \n    var spolygon = getLayerPropertyValue(style, 'polygon', polygon, lod);\n    \n    if (!spolygon) {\n        return;\n    }\n    \n    var surface = polygon['surface'] || [];\n    if (surface.length == 0) {\n        return;\n    }\n    \n    var hoverEvent = getLayerPropertyValue(style, 'hover-event', polygon, lod);\n    var clickEvent = getLayerPropertyValue(style, 'click-event', polygon, lod);\n    var drawEvent = getLayerPropertyValue(style, 'draw-event', polygon, lod);\n    var enterEvent = getLayerPropertyValue(style, 'enter-event', polygon, lod);\n    var leaveEvent = getLayerPropertyValue(style, 'leave-event', polygon, lod);\n    var advancedHit = getLayerPropertyValue(style, 'advanced-hit', polygon, lod);\n\n    var zbufferOffset = getLayerPropertyValue(style, 'zbuffer-offset', polygon, lod);\n    \n    var polygonColor = getLayerPropertyValue(style, 'polygon-color', polygon, lod);\n    var polygonStyle = getLayerPropertyValue(style, 'polygon-style', polygon, lod);\n    var polygonStencil = getLayerPropertyValue(style, 'polygon-use-stencil', polygon, lod);\n    var polygonCulling = getLayerPropertyValue(style, 'polygon-culling', polygon, lod);\n    var polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\n    \n    polygonStyle = (polygonStyle == 'flatshade') ? 1 : 0;\n    polygonCulling = (polygonCulling == 'back') ? 1 : 0;\n\n    var geocent = globals.geocent;\n    var center = [0,0,0], n = [0,0,0];\n    var bboxMin = globals.bboxMin;\n  \n\n    // allocate vertex buffer\n    var trisCount = surface.length / 3;\n    var vertexCount = trisCount * 3;\n    var vertexBuffer = new Float32Array(vertexCount * 3);\n    \n    var surfaceI = 0;\n    var index = 0;\n    var p1 = [0,0,0], p2 = [0,0,0], p3 = [0,0,0], p4 = [0,0,0];\n    var offs, li, j, lj;\n\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceOrigin = globals.forceOrigin;\n    var forceScale = globals.forceScale;    \n\n    //debugger\n    \n    //console.log(\"vertexCount = \" + vertexCount);\n    //add tris\n    for (var i = 0; i < vertexCount; i++) {\n        offs = 3 * surface[surfaceI++];\n        p1 = [vertices[offs], vertices[offs+1], vertices[offs+2]];\n\n        if (forceOrigin) {\n            p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n        }\n\n        if (forceScale != null) {\n            p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n        }\n \n        if (polygonExtrude) {\n            if (geocent) {\n                vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\n                p1[0] += n[0] * polygonExtrude;\n                p1[1] += n[1] * polygonExtrude;\n                p1[2] += n[2] * polygonExtrude;\n            } else {\n                p1[2] += polygonExtrude;\n            }\n        }\n\n        center[0] += p1[0];\n        center[1] += p1[1];\n        center[2] += p1[2];\n\n        //add vertex\n        vertexBuffer[index++] = p1[0];\n        vertexBuffer[index++] = p1[1];\n        vertexBuffer[index++] = p1[2];\n    }\n    \n    //console.log( \"vertexBuffer: \" + vertexBuffer );\n    \n    if (vertexCount > 0) {\n        var k = 1.0 / vertexCount;\n        center[0] *= k;\n        center[1] *= k;\n        center[2] *= k;\n    }\n\n    center[0] += globals.groupOrigin[0];\n    center[1] += globals.groupOrigin[1];\n    center[2] += globals.groupOrigin[2];\n\n    var borders = polygon['borders'] || [];\n    if (borders.length > 0) {\n\n        var totalFaces = 0;\n\n        for (i = 0, li = borders.length; i < li; i++) {\n            var border = borders[i];\n            totalFaces += (border.length + 1) * 2;\n        }\n\n        var vertexBuffer2 = vertexBuffer;\n        vertexBuffer = new Float32Array(vertexBuffer.length + (totalFaces * 3 * 3));\n        vertexBuffer.set(vertexBuffer2);\n\n        for (i = 0, li = borders.length; i < li; i++) {\n            var border = borders[i], offset;\n\n            for (j = 0, lj = border.length; j < lj; j++) {\n\n                if (border[j] >= 0) {\n                    offset = 3 * border[j];\n                } else {\n                    offset = 3 * (-border[j]);\n                }\n\n                p1[0] = vertices[offset];\n                p1[1] = vertices[offset+1];\n                p1[2] = vertices[offset+2];\n\n                p3[0] = vertices[offset];\n                p3[1] = vertices[offset+1];\n                p3[2] = vertices[offset+2];\n\n                if (j < lj - 1) {\n                    if (border[j+1] >= 0) {\n                        offset = 3 * border[j+1];\n                    } else {\n                        offset = 3 * (-border[j+1]);\n                    }\n                } else {\n                    if (border[0] >= 0) {\n                        offset = 3 * border[0];\n                    } else {\n                        offset = 3 * (-border[0]);\n                    }\n                }\n\n                p2[0] = vertices[offset];\n                p2[1] = vertices[offset+1];\n                p2[2] = vertices[offset+2];\n\n                p4[0] = vertices[offset];\n                p4[1] = vertices[offset+1];\n                p4[2] = vertices[offset+2];\n\n                if (forceOrigin) {\n                    p1 = [p1[0] - tileX, p1[1] - tileY, p1[2]];\n                    p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    p3 = [p3[0] - tileX, p3[1] - tileY, p3[2]];\n                    p4 = [p4[0] - tileX, p4[1] - tileY, p4[2]];\n                }\n\n                if (forceScale != null) {\n                    p1 = [p1[0] * forceScale[0], p1[1] * forceScale[1], p1[2] * forceScale[2]];\n                    p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    p3 = [p3[0] * forceScale[0], p3[1] * forceScale[1], p3[2] * forceScale[2]];\n                    p4 = [p4[0] * forceScale[0], p4[1] * forceScale[1], p4[2] * forceScale[2]];\n                }\n\n                if (polygonExtrude) {\n                    if (geocent) {\n                        vec3Normalize([p1[0] + bboxMin[0], p1[1] + bboxMin[1], p1[2] + bboxMin[2]], n);\n                        p1 = [p1[0] + n[0] * polygonExtrude, p1[1] + n[1] * polygonExtrude, p1[2] + n[2] * polygonExtrude];\n\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\n                        p2 = [p2[0] + n[0] * polygonExtrude, p2[1] + n[1] * polygonExtrude, p2[2] + n[2] * polygonExtrude];\n                    } else {\n                        p1[2] += polygonExtrude;\n                        p2[2] += polygonExtrude;\n                    }\n                }\n\n                vertexBuffer[index] = p4[0];\n                vertexBuffer[index+1] = p4[1];\n                vertexBuffer[index+2] = p4[2];\n\n                vertexBuffer[index+3] = p2[0];\n                vertexBuffer[index+4] = p2[1];\n                vertexBuffer[index+5] = p2[2];\n\n                vertexBuffer[index+6] = p1[0];\n                vertexBuffer[index+7] = p1[1];\n                vertexBuffer[index+8] = p1[2];\n\n                vertexBuffer[index+9] = p1[0];\n                vertexBuffer[index+10] = p1[1];\n                vertexBuffer[index+11] = p1[2];\n\n                vertexBuffer[index+12] = p3[0];\n                vertexBuffer[index+13] = p3[1];\n                vertexBuffer[index+14] = p3[2];\n\n                vertexBuffer[index+15] = p4[0];\n                vertexBuffer[index+16] = p4[1];\n                vertexBuffer[index+17] = p4[2];\n\n                index += 18;\n            }\n        }\n    }    \n\n    var hitable = hoverEvent || clickEvent || enterEvent || leaveEvent;\n    \n    var signature = JSON.stringify({\n        style: polygonStyle,\n        culling: polygonCulling, \n        stencil: polygonStencil, \n        color : polygonColor,\n        zIndex : zIndex,\n        zOffset : zbufferOffset,\n        state : globals.hitState\n    });\n\n    //debugger\n\n    postGroupMessageFast(5, 13, {\n        'color':polygonColor, 'z-index':zIndex, 'center': center, 'advancedHit': advancedHit, 'culling': polygonCulling, \n        'hover-event':hoverEvent, 'click-event':clickEvent, 'draw-event':drawEvent, 'style' : polygonStyle, 'stencil': polygonStencil, \n        'hitable':hitable, 'state':globals.hitState, 'eventInfo': (globals.alwaysEventInfo || hitable || drawEvent) ? eventInfo : {},\n        'enter-event':enterEvent, 'leave-event':leaveEvent, 'zbuffer-offset':zbufferOffset,\n        'lod':(globals.autoLod ? null : globals.tileLod) }, [vertexBuffer], signature);\n};\n\nvar createEmptyFeatureFromPolygon = function(polygon) {\n    var feature = {};\n    for(var key in polygon) {\n        if(key != 'surface' && key != 'vertices' && key != 'borders') {\n            feature[key] = polygon[key];\n        }\n    }\n    return feature;\n};\n\nvar processPolygonLines = function(polygon, vertices, lod, style, featureIndex, zIndex, eventInfo, processLines) {\n    var borders = polygon['borders'] || [];\n    if (borders.length == 0) {\n        return;\n    }\n    var polygonExtrude = getLayerPropertyValue(style, 'polygon-extrude', polygon, lod);\n    var feature = createEmptyFeatureFromPolygon(polygon);\n    var bordersCount = borders.length;\n    var allPoints = [], allPoints2 = [];\n    var p, p2, n = [0,0,0];\n\n    var tileX = globals.tileX;\n    var tileY = globals.tileY;\n    var forceOrigin = globals.forceOrigin;\n    var forceScale = globals.forceScale;    \n    var forceScale2 = [1.0/forceScale[0], 1.0/forceScale[1], 1.0/forceScale[2]];    \n    var geocent = globals.geocent;\n    var bboxMin = globals.bboxMin;\n\n    for (var j = 0; j < bordersCount; j++) {\n        var border = borders[j], offset;\n        var pointsCount = border.length;\n        var pointsCount2 = 0;\n        if (pointsCount > 0) {\n            var points, points3, points4, i;\n            if (processLines) {\n                points = new Array(pointsCount + 1);\n                points3 = new Array(pointsCount + 1);\n            } else {\n                points = new Array(pointsCount);\n                points3 = new Array(pointsCount);\n            }\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    offset = 3 * border[i];\n                    pointsCount2++; // count vertices with positive index\n                } else {\n                    offset = 3 * (-border[i]);\n                }\n\n                if (polygonExtrude) {\n                    p = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                    p2 = p.slice();\n\n                    if (forceOrigin) {\n                        p2 = [p2[0] - tileX, p2[1] - tileY, p2[2]];\n                    }\n\n                    if (forceScale != null) {\n                        p2 = [p2[0] * forceScale[0], p2[1] * forceScale[1], p2[2] * forceScale[2]];\n                    }\n\n                    if (geocent) {\n                        vec3Normalize([p2[0] + bboxMin[0], p2[1] + bboxMin[1], p2[2] + bboxMin[2]], n);\n                        p2 = [p[0] + (n[0] * polygonExtrude) * forceScale2[0], p[1] + (n[1] * polygonExtrude) * forceScale2[1], p[2] + (n[2] * polygonExtrude) * forceScale2[2]];\n                    } else {\n                        p2[2] += polygonExtrude;\n                    }\n\n                    points[i] = p;\n                    points3[i] = p2;\n\n                    if (border[i] >= 0) {\n                        allPoints.push([p,p2]);\n                    }\n\n                } else {\n                    points[i] = [vertices[offset], vertices[offset+1], vertices[offset+2]];\n                }\n\n                if (processLines && i == 0) {\n                    points[pointsCount] = points[0];\n                    points3[pointsCount] = points3[0];\n                }\n            }\n\n            var points2 = new Array(pointsCount2);\n            var points4 = new Array(pointsCount2);\n            var i2 = 0;\n            //debugger\n\n            //create array of points only for vertices with positive value\n            for (i = 0; i < pointsCount; i++) {\n                if (border[i] >= 0) {\n                    points2[i2] = points[i].slice();\n\n                    if (polygonExtrude) {\n                        points4[i2] = points3[i].slice();\n                    }\n\n                    i2++;\n                }\n            }\n\n            allPoints.push(points);\n            allPoints2 = allPoints2.concat(points2);\n\n            if (polygonExtrude) {\n                allPoints.push(points3);\n                allPoints2 = allPoints2.concat(points4);\n            }\n\n        }\n    }\n\n    if(processLines && allPoints.length > 0) {\n        feature['lines'] = allPoints;\n        processLineStringPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n    } else if(allPoints2.length > 0) {\n        feature['points'] = allPoints2;\n        processPointArrayPass(feature, lod, style, featureIndex, zIndex, eventInfo);\n    }\n\n};\n \n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return bidi; });\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Character types for symbols from 0000 to 00FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\nvar baseTypes = [\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'S', 'B', 'S',\n  'WS', 'B', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'B', 'B', 'B', 'S', 'WS', 'ON', 'ON', 'ET',\n  'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'ON', 'ES', 'CS', 'ES', 'CS', 'CS',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'CS', 'ON',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'ON', 'ON', 'ON', 'ON',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'B', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN',\n  'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'BN', 'CS', 'ON', 'ET',\n  'ET', 'ET', 'ET', 'ON', 'ON', 'ON', 'ON', 'L', 'ON', 'ON', 'BN', 'ON',\n  'ON', 'ET', 'ET', 'EN', 'EN', 'ON', 'L', 'ON', 'ON', 'ON', 'EN', 'L',\n  'ON', 'ON', 'ON', 'ON', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L',\n  'L', 'L', 'L', 'L', 'L', 'ON', 'L', 'L', 'L', 'L', 'L', 'L', 'L', 'L'\n];\n\n// Character types for symbols from 0600 to 06FF.\n// Source: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n// Note that 061D does not exist in the Unicode standard (see\n// http://unicode.org/charts/PDF/U0600.pdf), so we replace it with an\n// empty string and issue a warning if we encounter this character. The\n// empty string is required to properly index the items after it.\nvar arabicTypes = [\n  'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'ON', 'ON', 'AL', 'ET', 'ET', 'AL',\n  'CS', 'AL', 'ON', 'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', '', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM',\n  'NSM', 'NSM', 'NSM', 'NSM', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN', 'AN',\n  'AN', 'AN', 'AN', 'ET', 'AN', 'AN', 'AL', 'AL', 'AL', 'NSM', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL',\n  'AL', 'AL', 'AL', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AN',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'NSM', 'NSM',\n  'ON', 'NSM', 'NSM', 'NSM', 'NSM', 'AL', 'AL', 'EN', 'EN', 'EN', 'EN',\n  'EN', 'EN', 'EN', 'EN', 'EN', 'EN', 'AL', 'AL', 'AL', 'AL', 'AL', 'AL'\n];\n\nfunction isOdd(i) {\n  return (i & 1) !== 0;\n}\n\nfunction isEven(i) {\n  return (i & 1) === 0;\n}\n\nfunction findUnequal(arr, start, value) {\n  for (var j = start, jj = arr.length; j < jj; ++j) {\n    if (arr[j] !== value) {\n      return j;\n    }\n  }\n  return j;\n}\n\nfunction setValues(arr, start, end, value) {\n  for (var j = start; j < end; ++j) {\n    arr[j] = value;\n  }\n}\n\nfunction reverseValues(arr, arr2, start, end) {\n  for (var i = start, j = end - 1; i < j; ++i, --j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n    temp = arr2[i];\n    arr2[i] = arr2[j];\n    arr2[j] = temp;\n  }\n}\n\nfunction createBidiText(str, isLTR, vertical) {\n  return {\n    str: str,\n    indices: indices,\n    types : types,\n    dir: (vertical ? 'ttb' : (isLTR ? 'ltr' : 'rtl')),\n  };\n}\n\n// These are used in bidi(), which is called frequently. We re-use them on\n// each call to avoid unnecessary allocations.\nvar chars = [];\nvar types = [];\nvar indices = [];\n\nfunction bidi(str, startLevel, vertical) {\n  var isLTR = true;\n  var strLength = str.length;\n  if (strLength === 0 || vertical) {\n    return createBidiText(str, isLTR, vertical);\n  }\n\n  // Get types and fill arrays\n  chars.length = strLength;\n  types.length = strLength;\n  var numBidi = 0;\n\n  var i, ii;\n  for (i = 0; i < strLength; ++i) {\n    chars[i] = str.charAt(i);\n    indices[i] = i;\n\n    var charCode = str.charCodeAt(i);\n    var charType = 'L';\n    if (charCode <= 0x00ff) {\n      charType = baseTypes[charCode];\n    } else if (0x0590 <= charCode && charCode <= 0x05f4) {\n      charType = 'R';\n    } else if (0x0600 <= charCode && charCode <= 0x06ff) {\n      charType = arabicTypes[charCode & 0xff];\n      if (!charType) {\n        //console.log('Bidi: invalid Unicode character ' + charCode.toString(16));\n      }\n    } else if (0x0700 <= charCode && charCode <= 0x08AC) {\n      charType = 'AL';\n    }\n    if (charType === 'R' || charType === 'AL' || charType === 'AN') {\n      numBidi++;\n    }\n    types[i] = charType;\n  }\n\n  // Detect the bidi method\n  // - If there are no rtl characters then no bidi needed\n  // - If less than 30% chars are rtl then string is primarily ltr\n  // - If more than 30% chars are rtl then string is primarily rtl\n  if (numBidi === 0) {\n    isLTR = true;\n    return createBidiText(str, isLTR);\n  }\n\n  if (startLevel === -1) {\n    if ((numBidi / strLength) < 0.3) {\n      isLTR = true;\n      startLevel = 0;\n    } else {\n      isLTR = false;\n      startLevel = 1;\n    }\n  }\n\n  var levels = [];\n  for (i = 0; i < strLength; ++i) {\n    levels[i] = startLevel;\n  }\n\n  /*\n   X1-X10: skip most of this, since we are NOT doing the embeddings.\n   */\n  var e = (isOdd(startLevel) ? 'R' : 'L');\n  var sor = e;\n  var eor = sor;\n\n  /*\n   W1. Examine each non-spacing mark (NSM) in the level run, and change the\n   type of the NSM to the type of the previous character. If the NSM is at the\n   start of the level run, it will get the type of sor.\n   */\n  var lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'NSM') {\n      types[i] = lastType;\n    } else {\n      lastType = types[i];\n    }\n  }\n\n  /*\n   W2. Search backwards from each instance of a European number until the\n   first strong type (R, L, AL, or sor) is found.  If an AL is found, change\n   the type of the European number to Arabic number.\n   */\n  lastType = sor;\n  var t;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = (lastType === 'AL') ? 'AN' : 'EN';\n    } else if (t === 'R' || t === 'L' || t === 'AL') {\n      lastType = t;\n    }\n  }\n\n  /*\n   W3. Change all ALs to R.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'AL') {\n      types[i] = 'R';\n    }\n  }\n\n  /*\n   W4. A single European separator between two European numbers changes to a\n   European number. A single common separator between two numbers of the same\n   type changes to that type:\n   */\n  for (i = 1; i < strLength - 1; ++i) {\n    if (types[i] === 'ES' && types[i - 1] === 'EN' && types[i + 1] === 'EN') {\n      types[i] = 'EN';\n    }\n    if (types[i] === 'CS' &&\n        (types[i - 1] === 'EN' || types[i - 1] === 'AN') &&\n        types[i + 1] === types[i - 1]) {\n      types[i] = types[i - 1];\n    }\n  }\n\n  /*\n   W5. A sequence of European terminators adjacent to European numbers changes\n   to all European numbers:\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'EN') {\n      // do before\n      var j;\n      for (j = i - 1; j >= 0; --j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n      // do after\n      for (j = i + 1; j < strLength; ++j) {\n        if (types[j] !== 'ET') {\n          break;\n        }\n        types[j] = 'EN';\n      }\n    }\n  }\n\n  /*\n   W6. Otherwise, separators and terminators change to Other Neutral:\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'WS' || t === 'ES' || t === 'ET' || t === 'CS') {\n      types[i] = 'ON';\n    }\n  }\n\n  /*\n   W7. Search backwards from each instance of a European number until the\n   first strong type (R, L, or sor) is found. If an L is found,  then change\n   the type of the European number to L.\n   */\n  lastType = sor;\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (t === 'EN') {\n      types[i] = ((lastType === 'L') ? 'L' : 'EN');\n    } else if (t === 'R' || t === 'L') {\n      lastType = t;\n    }\n  }\n\n  /*\n   N1. A sequence of neutrals takes the direction of the surrounding strong\n   text if the text on both sides has the same direction. European and Arabic\n   numbers are treated as though they were R. Start-of-level-run (sor) and\n   end-of-level-run (eor) are used at level run boundaries.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      var end = findUnequal(types, i + 1, 'ON');\n      var before = sor;\n      if (i > 0) {\n        before = types[i - 1];\n      }\n\n      var after = eor;\n      if (end + 1 < strLength) {\n        after = types[end + 1];\n      }\n      if (before !== 'L') {\n        before = 'R';\n      }\n      if (after !== 'L') {\n        after = 'R';\n      }\n      if (before === after) {\n        setValues(types, i, end, before);\n      }\n      i = end - 1; // reset to end (-1 so next iteration is ok)\n    }\n  }\n\n  /*\n   N2. Any remaining neutrals take the embedding direction.\n   */\n  for (i = 0; i < strLength; ++i) {\n    if (types[i] === 'ON') {\n      types[i] = e;\n    }\n  }\n\n  /*\n   I1. For all characters with an even (left-to-right) embedding direction,\n   those of type R go up one level and those of type AN or EN go up two\n   levels.\n   I2. For all characters with an odd (right-to-left) embedding direction,\n   those of type L, EN or AN go up one level.\n   */\n  for (i = 0; i < strLength; ++i) {\n    t = types[i];\n    if (isEven(levels[i])) {\n      if (t === 'R') {\n        levels[i] += 1;\n      } else if (t === 'AN' || t === 'EN') {\n        levels[i] += 2;\n      }\n    } else { // isOdd\n      if (t === 'L' || t === 'AN' || t === 'EN') {\n        levels[i] += 1;\n      }\n    }\n  }\n\n  /*\n   L1. On each line, reset the embedding level of the following characters to\n   the paragraph embedding level:\n\n   segment separators,\n   paragraph separators,\n   any sequence of whitespace characters preceding a segment separator or\n   paragraph separator, and any sequence of white space characters at the end\n   of the line.\n   */\n\n  // don't bother as text is only single line\n\n  /*\n   L2. From the highest level found in the text to the lowest odd level on\n   each line, reverse any contiguous sequence of characters that are at that\n   level or higher.\n   */\n\n  // find highest level & lowest odd level\n  var highestLevel = -1;\n  var lowestOddLevel = 99;\n  var level;\n  for (i = 0, ii = levels.length; i < ii; ++i) {\n    level = levels[i];\n    if (highestLevel < level) {\n      highestLevel = level;\n    }\n    if (lowestOddLevel > level && isOdd(level)) {\n      lowestOddLevel = level;\n    }\n  }\n\n  // now reverse between those limits\n  for (level = highestLevel; level >= lowestOddLevel; --level) {\n    // find segments to reverse\n    var start = -1;\n    for (i = 0, ii = levels.length; i < ii; ++i) {\n      if (levels[i] < level) {\n        if (start >= 0) {\n          reverseValues(chars, indices, start, i);\n          start = -1;\n        }\n      } else if (start < 0) {\n        start = i;\n      }\n    }\n    if (start >= 0) {\n      reverseValues(chars, indices, start, levels.length);\n    }\n  }\n\n  /*\n   L3. Combining marks applied to a right-to-left base character will at this\n   point precede their base character. If the rendering engine expects them to\n   follow the base characters in the final display process, then the ordering\n   of the marks and the base character must be reversed.\n   */\n\n  // don't bother for now\n\n  /*\n   L4. A character that possesses the mirrored property as specified by\n   Section 4.7, Mirrored, must be depicted by a mirrored glyph if the resolved\n   directionality of that character is R.\n   */\n\n  // don't mirror as characters are already mirrored in the pdf\n\n  // Finally, return string\n  for (i = 0, ii = chars.length; i < ii; ++i) {\n    var ch = chars[i];\n    if (ch === '<' || ch === '>') {\n      chars[i] = '';\n    }\n  }\n  return createBidiText(chars.join(''), isLTR);\n}\n\n\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_bidi_js__ = __webpack_require__(7);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Typr; });\n\n\n\n\n//get rid of compiler mess\nvar bidi = __WEBPACK_IMPORTED_MODULE_0__worker_bidi_js__[\"a\" /* bidi */];\n\n\nvar Typr = {};\n\nTypr.parse = function(buff) {\n    var bin = Typr._bin;\n    var data = new Uint8Array(buff);\n    var offset = 0;\n    \n    var sfnt_version = bin.readFixed(data, offset);\n    offset += 4;\n    var numTables = bin.readUshort(data, offset);\n    offset += 2;\n    var searchRange = bin.readUshort(data, offset);\n    offset += 2;\n    var entrySelector = bin.readUshort(data, offset);\n    offset += 2;\n    var rangeShift = bin.readUshort(data, offset);\n    offset += 2;\n    \n    var tags = [\n        \"cmap\",\n        \"head\",\n        \"hhea\",\n        \"maxp\",\n        \"hmtx\",\n        //\"name\",\n        //\"OS/2\",\n        //\"post\",\n        \n        //\"cvt\",\n        //\"fpgm\",\n        //\"loca\",\n        //\"glyf\",\n        \"kern\",\n        \n        //\"prep\"\n        //\"gasp\"\n        \n        \"GPOS\",\n        \"GSUB\"\n        //\"VORG\",\n        ];\n    \n    var obj = {_data:data};\n    //console.log(sfnt_version, numTables, searchRange, entrySelector, rangeShift);\n    \n    var tabs = {};\n    var tablesOffset = 0;\n    \n    for(var i=0; i<numTables; i++) {\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\n        var checkSum = bin.readUint(data, offset);  offset += 4;\n        var toffset = bin.readUint(data, offset);   offset += 4;\n        var length = bin.readUint(data, offset);    offset += 4;\n        tabs[tag] = {offset:toffset, length:length};\n        tablesOffset = toffset + length;\n        //if(tags.indexOf(tag)==-1) console.log(\"unknown tag\", tag);\n    }\n    \n    for(var i=0; i< tags.length; i++) {\n        var t = tags[i];\n        //console.log(t);\n        //if(tabs[t]) console.log(t, tabs[t].offset, tabs[t].length);\n        if(tabs[t]) obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\n    }\n\n    obj._tabs = tabs;\n\n    Typr._processGlyphs(data, tablesOffset, tabs, obj);\n\n    //get tables\n    var gsub = obj['GSUB'];\n    if (gsub) {\n        var llist = gsub.lookupList, flist = gsub.featureList;\n\n        obj.gsubIsolTable = [];\n        obj.gsubInitTable = [];\n        obj.gsubFinaTable = [];\n        obj.gsubMediTable = [];\n\n        obj.gsubRligLigaTable = [];\n\n        for(var fi = 0; fi < flist.length; fi++) {\n            var tag = flist[fi].tag;\n\n            switch (tag) {\n                case 'isol':\n                case 'init':\n                case 'fina':\n                case 'medi':\n\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\n                        var tab = llist[flist[fi].tab[ti]];\n                        \n                        if(tab.ltype == 1) {\n                            switch (tag) {\n                                case 'isol': obj.gsubIsolTable.push(tab.tabs); break;\n                                case 'init': obj.gsubInitTable.push(tab.tabs); break;\n                                case 'fina': obj.gsubFinaTable.push(tab.tabs); break;\n                                case 'medi': obj.gsubMediTable.push(tab.tabs); break;\n                            }\n                        }\n                    }\n\n                    break;\n\n                case 'rlig':\n                case 'liga':\n\n                    for(var ti = 0; ti < flist[fi].tab.length; ti++) {\n                        var tab = llist[flist[fi].tab[ti]];\n                        \n                        if(tab.ltype == 4) {\n                            obj.gsubRligLigaTable.push(tab.tabs);\n                        }\n                    }\n\n                    break;\n            }\n\n        }\n    }\n   \n    return obj;\n}\n\nTypr._processGlyphs = function(data, index, tabs, obj) {\n    var version = data[index]; index += 1;\n    var textureLX = (data[index] << 8) | (data[index+1]); index += 2;\n    var textureLY = (data[index] << 8) | (data[index+1]); index += 2;\n    var size = data[index]; index += 1;\n    var flags = data[index]; index += 1;\n\n    obj.version = version;\n    obj.textureLX = textureLX;\n    obj.textureLY = textureLY;\n    obj.size = size;\n    obj.cly = size * 1.5;\n    obj.flags = flags;\n\n    var glyphs = new Array(obj.maxp.numGlyphs);\n    var fx = 1.0 / textureLX, fy = 1.0 / textureLY;\n    var step = (textureLX > 256) ? 7 : 6;\n\n    var filesIndicesIndex = index + obj.maxp.numGlyphs * step;\n    var filesIndicesCount = (data[filesIndicesIndex] << 8) | data[filesIndicesIndex+1];\n    var files = new Array(filesIndicesCount);\n\n    filesIndicesIndex += 2;\n\n    for (var i = 0, li = filesIndicesCount; i < li; i++) {\n        files[i] = (data[filesIndicesIndex+i*2] << 8) | data[filesIndicesIndex+i*2+1];\n    }\n\n    var fileIndex = 0;\n\n    for (i = 0, li = obj.maxp.numGlyphs; i < li; i++) {\n        if (i == files[fileIndex]) {\n            fileIndex++;\n        }\n\n        glyphs[i] = Typr._processGlyph(data, index, fx, fy, textureLX, obj, i, fileIndex);\n        index += step;\n    }\n\n    obj.glyphs = glyphs;\n}\n\nTypr._processGlyph = function(data, index, fx, fy, textureLX, font, glyphIndex, fileIndex) {\n    var value = (data[index] << 24) | (data[index+1] << 16) | (data[index+2] << 8) | (data[index+3]);\n\n    // w 6bit | h 6bit | sx sign 1bit | abs sx 6bit | sy sign 1bit | abs sy 6bit | plane 2bit \n    var w = (value >> 22) & 63;\n    var h = (value >> 16) & 63;\n    var sx = ((value >> 9) & 63) * (((value >> 15) & 1) ? -1 : 1);\n    var sy = -((value >> 2) & 63) * (((value >> 8) & 1) ? -1 : 1);\n    var plane = (value & 3) + (fileIndex * 4);\n\n    if (textureLX > 256) {\n        value = (data[index+4] << 16) | (data[index+5] << 8) | (data[index+6]);\n    } else {\n        value = (data[index+4] << 8) | (data[index+5]);\n    }    \n\n    var scale = ((font.size/0.75) / font.head.unitsPerEm) * 0.75;\n    var x, y, step = font.hmtx.aWidth[glyphIndex] * scale;\n\n    //store glyph position\n    switch (textureLX) {\n        case 2048: // x 11bit | y 11bit\n            x = ((value >> 11) & 2047), y = (value & 2047); break;\n                   \n        case 1024: // x 10bit | y 10bit\n            x = ((value >> 10) & 1023), y = (value & 1023); break;\n\n        case 512:  // x 9bit | y 9bit\n            x = ((value >> 9) & 511), y = (value & 511); break;\n\n        default:   // x 8bit | y 8bit\n            x = ((value >> 8) & 255), y = (value & 255); break;\n    }\n\n    return {\n        u1 : (x) * fx,\n        v1 : (y * fy) + plane,\n        u2 : (x + w) * fx,\n        v2 : ((y + h) * fy) + plane,\n        lx : w,\n        ly : h,\n        sx : sx, \n        sy : sy, \n        step : (step), \n        plane: plane\n    };\n}\n\nTypr._tabOffset = function(data, tab) {\n    var bin = Typr._bin;\n    var numTables = bin.readUshort(data, 4);\n    var offset = 12;\n    for(var i=0; i<numTables; i++) {\n        var tag = bin.readASCII(data, offset, 4);   offset += 4;\n        var checkSum = bin.readUint(data, offset);  offset += 4;\n        var toffset = bin.readUint(data, offset);   offset += 4;\n        var length = bin.readUint(data, offset);    offset += 4;\n        if(tag==tab) return toffset;\n    }\n    return 0;\n}\n\n\n\n\nTypr._bin = {\n    readFixed : function(data, o) {\n        return ((data[o]<<8) | data[o+1]) +  (((data[o+2]<<8)|data[o+3])/(256*256+4));\n    },\n\n    readF2dot14 : function(data, o) {\n        var num = Typr._bin.readShort(data, o);\n        return num / 16384;\n        \n        var intg = (num >> 14), frac = ((num & 0x3fff)/(0x3fff+1));\n        return (intg>0) ? (intg+frac) : (intg-frac);\n    },\n\n    readInt : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[0] = buff[p+3];\n        a[1] = buff[p+2];\n        a[2] = buff[p+1];\n        a[3] = buff[p];\n        return Typr._bin.t.int32[0];\n    },\n    \n    readInt8 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[0] = buff[p];\n        return Typr._bin.t.int8[0];\n    },\n\n    readShort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[1] = buff[p]; a[0] = buff[p+1];\n        return Typr._bin.t.int16[0];\n    },\n\n    readUshort : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (buff[p]<<8) | buff[p+1];\n    },\n\n    readUshorts : function(buff, p, len) {\n        var arr = [];\n        for(var i=0; i<len; i++) arr.push(Typr._bin.readUshort(buff, p+i*2));\n        return arr;\n    },\n\n    readUint : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        var a = Typr._bin.t.uint8;\n        a[3] = buff[p];  a[2] = buff[p+1];  a[1] = buff[p+2];  a[0] = buff[p+3];\n        return Typr._bin.t.uint32[0];\n    },\n\n    readUint64 : function(buff, p) {\n        //if(p>=buff.length) throw \"error\";\n        return (Typr._bin.readUint(buff, p)*(0xffffffff+1)) + Typr._bin.readUint(buff, p+4);\n    },\n\n    readASCII : function(buff, p, l) {   // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        var s = \"\";\n        for(var i = 0; i < l; i++) s += String.fromCharCode(buff[p+i]);\n        return s;\n    },\n\n    readUnicode : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        var s = \"\";\n        for(var i = 0; i < l; i++)  \n        {\n            var c = (buff[p++]<<8) | buff[p++];\n            s += String.fromCharCode(c);\n        }\n        return s;\n    },\n\n    readBytes : function(buff, p, l) {\n        //if(p>=buff.length) throw \"error\";\n        var arr = [];\n        for(var i=0; i<l; i++) arr.push(buff[p+i]);\n        return arr;\n    },\n\n    readASCIIArray : function(buff, p, l) {  // l : length in Characters (not Bytes)\n        //if(p>=buff.length) throw \"error\";\n        var s = [];\n        for(var i = 0; i < l; i++)  \n            s.push(String.fromCharCode(buff[p+i]));\n        return s;\n    }\n};\n\nTypr._bin.t = {\n    buff: new ArrayBuffer(8),\n};\nTypr._bin.t.int8   = new Int8Array  (Typr._bin.t.buff);\nTypr._bin.t.uint8  = new Uint8Array (Typr._bin.t.buff);\nTypr._bin.t.int16  = new Int16Array (Typr._bin.t.buff);\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\nTypr._bin.t.int32  = new Int32Array (Typr._bin.t.buff);\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\n\n\n\n\n\n// OpenType Layout Common Table Formats\n\nTypr._lctf = {};\n\nTypr._lctf.parse = function(data, offset, length, font, subt) {\n    var bin = Typr._bin;\n    var obj = {};\n    var offset0 = offset;\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    \n    var offScriptList  = bin.readUshort(data, offset);  offset += 2;\n    var offFeatureList = bin.readUshort(data, offset);  offset += 2;\n    var offLookupList  = bin.readUshort(data, offset);  offset += 2;\n    \n    \n    obj.scriptList  = Typr._lctf.readScriptList (data, offset0 + offScriptList);\n    obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n    obj.lookupList  = Typr._lctf.readLookupList (data, offset0 + offLookupList, subt);\n    \n    return obj;\n}\n\nTypr._lctf.readLookupList = function(data, offset, subt) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = [];\n    var count = bin.readUshort(data, offset);  offset+=2;\n\n    for(var i=0; i<count; i++) \n    {\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n        obj.push(lut);\n    }\n    return obj;\n}\n\nTypr._lctf.readLookupTable = function(data, offset, subt) {\n    //console.log(\"Parsing lookup table\", offset);\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {tabs:[]};\n    \n    obj.ltype = bin.readUshort(data, offset);  offset+=2;\n    obj.flag  = bin.readUshort(data, offset);  offset+=2;\n    var cnt   = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<cnt; i++) {\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        var tab = subt(data, obj.ltype, offset0 + noff);\n        //console.log(obj.type, tab);\n        obj.tabs.push(tab);\n    }\n    return obj;\n}\n\nTypr._lctf.numOfOnes = function(n) {\n    var num = 0;\n    for(var i=0; i<32; i++) if(((n>>>i)&1) != 0) num++;\n    return num;\n}\n\nTypr._lctf.readClassDef = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = { start:[], end:[], class:[] };\n    var format = bin.readUshort(data, offset);  offset+=2;\n\n    if(format==1) {\n        var startGlyph  = bin.readUshort(data, offset);  offset+=2;\n        var glyphCount  = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<glyphCount; i++) {\n            obj.start.push(startGlyph+i);\n            obj.end  .push(startGlyph+i);\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n\n    if(format==2) {\n        var count = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<count; i++) {\n            obj.start.push(bin.readUshort(data, offset));  offset+=2;\n            obj.end  .push(bin.readUshort(data, offset));  offset+=2;\n            obj.class.push(bin.readUshort(data, offset));  offset+=2;\n        }\n    }\n    return obj;\n}\n\nTypr._lctf.readValueRecord = function(data, offset, valFmt) {\n    var bin = Typr._bin;\n    var arr = [];\n    arr.push( (valFmt&1) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&1) ? 2 : 0;\n    arr.push( (valFmt&2) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&2) ? 2 : 0;\n    arr.push( (valFmt&4) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&4) ? 2 : 0;\n    arr.push( (valFmt&8) ? bin.readShort(data, offset) : 0 );  offset += (valFmt&8) ? 2 : 0;\n    return arr;\n}\n\nTypr._lctf.readCoverage = function(data, offset) {\n    var bin = Typr._bin;\n    var cvg = {};\n    cvg.fmt   = bin.readUshort(data, offset);  offset+=2;\n    var count = bin.readUshort(data, offset);  offset+=2;\n    //console.log(\"parsing coverage\", offset-4, format, count);\n    if(cvg.fmt==1) cvg.tab = bin.readUshorts(data, offset, count); \n    if(cvg.fmt==2) cvg.tab = bin.readUshorts(data, offset, count*3);\n\n    //get min,max\n\n    var min = Number.POSITIVE_INFINITY, max = 0;\n    var tab = cvg.tab;\n\n    if(cvg.fmt==1) {\n\n        for(var i=0; i<tab.length; i++) {\n            var v = tab[i];\n            if (v > max) max = v;\n            if (v < min) min = v;\n        }\n    }\n\n    if(cvg.fmt==2) {\n        for(var i=0; i<tab.length; i+=3) {\n            var start = tab[i], end = tab[i+1];\n            if (start > max) max = start;\n            if (start < min) min = start;\n            if (end > max) max = end;\n            if (end < min) min = end;\n        }\n    }\n\n    cvg.min = min;\n    cvg.max = max;\n\n    return cvg;\n}\n\nTypr._lctf.coverageIndex = function(cvg, val) {\n    if (val < cvg.min || val > cvg.max) {\n        return -1;\n    }\n\n    var tab = cvg.tab;\n    if(cvg.fmt==1) return tab.indexOf(val);\n    \n    for(var i=0; i<tab.length; i+=3) {\n        var start = tab[i], end = tab[i+1], index = tab[i+2];\n        if(start<=val && val<=end) return index + (val-start);\n    }\n    return -1;\n}\n\nTypr._lctf.readFeatureList = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = [];\n    \n    var count = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<count; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        obj.push({tag: tag.trim(), tab:Typr._lctf.readFeatureTable(data, offset0 + noff)});\n    }\n    return obj;\n}\n\nTypr._lctf.readFeatureTable = function(data, offset) {\n    var bin = Typr._bin;\n    \n    var featureParams = bin.readUshort(data, offset);  offset+=2;   // = 0\n    var lookupCount = bin.readUshort(data, offset);  offset+=2;\n    \n    var indices = [];\n    for(var i=0; i<lookupCount; i++) indices.push(bin.readUshort(data, offset+2*i));\n    return indices;\n}\n\n\nTypr._lctf.readScriptList = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    var count = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<count; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var noff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n    }\n    return obj;\n}\n\nTypr._lctf.readScriptTable = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    var defLangSysOff = bin.readUshort(data, offset);  offset+=2;\n    obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n    \n    var langSysCount = bin.readUshort(data, offset);  offset+=2;\n    \n    for(var i=0; i<langSysCount; i++) {\n        var tag = bin.readASCII(data, offset, 4);  offset+=4;\n        var langSysOff = bin.readUshort(data, offset);  offset+=2;\n        obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n    }\n    return obj;\n}\n\nTypr._lctf.readLangSysTable = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = {};\n    \n    var lookupOrder = bin.readUshort(data, offset);  offset+=2;\n    //if(lookupOrder!=0)  throw \"lookupOrder not 0\";\n    obj.reqFeature = bin.readUshort(data, offset);  offset+=2;\n    //if(obj.reqFeature != 0xffff) throw \"reqFeatureIndex != 0xffff\";\n    \n    //console.log(lookupOrder, obj.reqFeature);\n    \n    var featureCount = bin.readUshort(data, offset);  offset+=2;\n    obj.features = bin.readUshorts(data, offset, featureCount);\n    return obj;\n}\n\n\nTypr.cmap = {};\nTypr.cmap.parse = function(data, offset, length) {\n    data = new Uint8Array(data.buffer, offset, length);\n    offset = 0;\n\n    var offset0 = offset;\n    var bin = Typr._bin;\n    var obj = {};\n    var version   = bin.readUshort(data, offset);  offset += 2;\n    var numTables = bin.readUshort(data, offset);  offset += 2;\n    \n    //console.log(version, numTables);\n    \n    var offs = [];\n    obj.tables = [];\n    \n    \n    for(var i=0; i<numTables; i++) {\n        var platformID = bin.readUshort(data, offset);  offset += 2;\n        var encodingID = bin.readUshort(data, offset);  offset += 2;\n        var noffset = bin.readUint(data, offset);       offset += 4;\n        \n        var id = \"p\"+platformID+\"e\"+encodingID;\n        \n        //console.log(\"cmap subtable\", platformID, encodingID, noffset);\n                \n        var tind = offs.indexOf(noffset);\n        \n        if(tind==-1) {\n            tind = obj.tables.length;\n            var subt;\n            offs.push(noffset);\n            var format = bin.readUshort(data, noffset);\n            if     (format== 0) subt = Typr.cmap.parse0(data, noffset);\n            else if(format== 4) subt = Typr.cmap.parse4(data, noffset);\n            else if(format== 6) subt = Typr.cmap.parse6(data, noffset);\n            else if(format==12) subt = Typr.cmap.parse12(data,noffset);\n            else console.log(\"unknown format: \"+format, platformID, encodingID, noffset);\n            obj.tables.push(subt);\n        }\n        \n        if(obj[id]!=null) throw \"multiple tables for one platform+encoding\";\n        obj[id] = tind;\n    }\n    return obj;\n}\n\nTypr.cmap.parse0 = function(data, offset) {\n    var bin = Typr._bin;\n    var obj = {};\n    obj.format = bin.readUshort(data, offset);  offset += 2;\n    var len    = bin.readUshort(data, offset);  offset += 2;\n    var lang   = bin.readUshort(data, offset);  offset += 2;\n    obj.map = [];\n    for(var i=0; i<len-6; i++) obj.map.push(data[offset+i]);\n    return obj;\n}\n\nTypr.cmap.parse4 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    var length = bin.readUshort(data, offset);  offset+=2;\n    var language = bin.readUshort(data, offset);  offset+=2;\n    var segCountX2 = bin.readUshort(data, offset);  offset+=2;\n    var segCount = segCountX2/2;\n    obj.searchRange = bin.readUshort(data, offset);  offset+=2;\n    obj.entrySelector = bin.readUshort(data, offset);  offset+=2;\n    obj.rangeShift = bin.readUshort(data, offset);  offset+=2;\n    obj.endCount   = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    offset+=2;\n    obj.startCount = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.idDelta = [];\n    for(var i=0; i<segCount; i++) {obj.idDelta.push(bin.readShort(data, offset));  offset+=2;}\n    obj.idRangeOffset = bin.readUshorts(data, offset, segCount);  offset += segCount*2;\n    obj.glyphIdArray = [];\n    while(offset< offset0+length) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n    return obj;\n}\n\nTypr.cmap.parse6 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    var length = bin.readUshort(data, offset);  offset+=2;\n    var language = bin.readUshort(data, offset);  offset+=2;\n    obj.firstCode = bin.readUshort(data, offset);  offset+=2;\n    var entryCount = bin.readUshort(data, offset);  offset+=2;\n    obj.glyphIdArray = [];\n    for(var i=0; i<entryCount; i++) {obj.glyphIdArray.push(bin.readUshort(data, offset));  offset+=2;}\n    \n    return obj;\n}\n\nTypr.cmap.parse12 = function(data, offset) {\n    var bin = Typr._bin;\n    var offset0 = offset;\n    var obj = {};\n    \n    obj.format = bin.readUshort(data, offset);  offset+=2;\n    offset += 2;\n    var length = bin.readUint(data, offset);  offset+=4;\n    var lang   = bin.readUint(data, offset);  offset+=4;\n    var nGroups= bin.readUint(data, offset);  offset+=4;\n    obj.groups = [];\n    \n    for(var i=0; i<nGroups; i++) {\n        var off = offset + i * 12;\n        var startCharCode = bin.readUint(data, off+0);\n        var endCharCode   = bin.readUint(data, off+4);\n        var startGlyphID  = bin.readUint(data, off+8);\n        obj.groups.push([  startCharCode, endCharCode, startGlyphID  ]);\n    }\n    return obj;\n}\n\n\n\nTypr.GPOS = {};\nTypr.GPOS.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);  }\n\n\n\nTypr.GPOS.subt = function(data, ltype, offset) { // lookup type\n    if(ltype!=2) return null;\n    \n    var bin = Typr._bin, offset0 = offset, tab = {};\n    \n    tab.format  = bin.readUshort(data, offset);  offset+=2;\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);\n    tab.valFmt1 = bin.readUshort(data, offset);  offset+=2;\n    tab.valFmt2 = bin.readUshort(data, offset);  offset+=2;\n    var ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\n    var ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\n\n    if(tab.format==1) {\n        tab.pairsets = [];\n        var count = bin.readUshort(data, offset);  offset+=2;\n        \n        for(var i=0; i<count; i++) {\n            var psoff = bin.readUshort(data, offset);  offset+=2;\n            psoff += offset0;\n            var pvcount = bin.readUshort(data, psoff);  psoff+=2;\n            var arr = [];\n\n            for(var j=0; j<pvcount; j++) {\n                var gid2 = bin.readUshort(data, psoff);  psoff+=2;\n                var value1, value2;\n                if(tab.valFmt1!=0) {  value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);  psoff+=ones1*2;  }\n                if(tab.valFmt2!=0) {  value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);  psoff+=ones2*2;  }\n                arr.push({gid2:gid2, val1:value1, val2:value2});\n            }\n            tab.pairsets.push(arr);\n        }\n    }\n\n    if(tab.format==2) {\n        var classDef1 = bin.readUshort(data, offset);  offset+=2;\n        var classDef2 = bin.readUshort(data, offset);  offset+=2;\n        var class1Count = bin.readUshort(data, offset);  offset+=2;\n        var class2Count = bin.readUshort(data, offset);  offset+=2;\n        \n        tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n        tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n        \n        tab.matrix = [];\n        for(var i=0; i<class1Count; i++) {\n            var row = [];\n            for(var j=0; j<class2Count; j++) {\n                var value1 = null, value2 = null;\n                if(tab.valFmt1!=0) { value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);  offset+=ones1*2; }\n                if(tab.valFmt2!=0) { value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);  offset+=ones2*2; }\n                row.push({val1:value1, val2:value2});\n            }\n            tab.matrix.push(row);\n        }\n    }\n    return tab;\n}\n\nTypr.GSUB = {};\nTypr.GSUB.parse = function(data, offset, length, font) {  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);  }\n\n\nTypr.GSUB.subt = function(data, ltype, offset) { // lookup type\n    var bin = Typr._bin, offset0 = offset, tab = {};\n    \n    if(ltype!=1 && ltype!=4) return null;\n    \n    tab.fmt  = bin.readUshort(data, offset);  offset+=2;\n    var covOff  = bin.readUshort(data, offset);  offset+=2;\n    tab.coverage = Typr._lctf.readCoverage(data, covOff+offset0);   // not always is coverage here\n    \n    if(false) {}\n    else if(ltype==1) {\n        if(tab.fmt==1) {\n            tab.delta = bin.readShort(data, offset);  offset+=2;\n        }\n        else if(tab.fmt==2) {\n            var cnt = bin.readUshort(data, offset);  offset+=2;\n            tab.newg = bin.readUshorts(data, offset, cnt);  offset+=tab.newg.length*2;\n        }\n    }\n    else if(ltype==4) {\n        tab.vals = [];\n        var cnt = bin.readUshort(data, offset);  offset+=2;\n        for(var i=0; i<cnt; i++) {\n            var loff = bin.readUshort(data, offset);  offset+=2;\n            tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0+loff));\n        }\n        //console.log(tab.coverage);\n        //console.log(tab.vals);\n    } \n    \n    return tab;\n}\n\nTypr.GSUB.readChainSubClassSet = function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, lset = [];\n    var cnt = bin.readUshort(data, offset);  offset+=2;\n    for(var i=0; i<cnt; i++) {\n        var loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readChainSubClassRule(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readChainSubClassRule= function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, rule = {};\n    var pps = [\"backtrack\", \"input\", \"lookahead\"];\n    for(var pi=0; pi<pps.length; pi++) {\n        var cnt = bin.readUshort(data, offset);  offset+=2;  if(pi==1) cnt--;\n        rule[pps[pi]]=bin.readUshorts(data, offset, cnt);  offset+= rule[pps[pi]].length*2;\n    }\n    var cnt = bin.readUshort(data, offset);  offset+=2;\n    rule.subst = bin.readUshorts(data, offset, cnt*2);  offset += rule.subst.length*2;\n    return rule;\n}\n\nTypr.GSUB.readLigatureSet = function(data, offset) {\n    var bin = Typr._bin, offset0 = offset, lset = [];\n    var lcnt = bin.readUshort(data, offset);  offset+=2;\n    for(var j=0; j<lcnt; j++) {\n        var loff = bin.readUshort(data, offset);  offset+=2;\n        lset.push(Typr.GSUB.readLigature(data, offset0+loff));\n    }\n    return lset;\n}\n\nTypr.GSUB.readLigature = function(data, offset) {\n    var bin = Typr._bin, lig = {chain:[]};\n    lig.nglyph = bin.readUshort(data, offset);  offset+=2;\n    var ccnt = bin.readUshort(data, offset);  offset+=2;\n    for(var k=0; k<ccnt-1; k++) {  lig.chain.push(bin.readUshort(data, offset));  offset+=2;  }\n    return lig;\n}\n\n\n\nTypr.head = {};\nTypr.head.parse = function(data, offset, length) {\n    var bin = Typr._bin;\n    var obj = {};\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.fontRevision = bin.readFixed(data, offset);  offset += 4;\n    var checkSumAdjustment = bin.readUint(data, offset);  offset += 4;\n    var magicNumber = bin.readUint(data, offset);  offset += 4;\n    obj.flags = bin.readUshort(data, offset);  offset += 2;\n    obj.unitsPerEm = bin.readUshort(data, offset);  offset += 2;\n    obj.created  = bin.readUint64(data, offset);  offset += 8;\n    obj.modified = bin.readUint64(data, offset);  offset += 8;\n    obj.xMin = bin.readShort(data, offset);  offset += 2;\n    obj.yMin = bin.readShort(data, offset);  offset += 2;\n    obj.xMax = bin.readShort(data, offset);  offset += 2;\n    obj.yMax = bin.readShort(data, offset);  offset += 2;\n    obj.macStyle = bin.readUshort(data, offset);  offset += 2;\n    obj.lowestRecPPEM = bin.readUshort(data, offset);  offset += 2;\n    obj.fontDirectionHint = bin.readShort(data, offset);  offset += 2;\n    obj.indexToLocFormat  = bin.readShort(data, offset);  offset += 2;\n    obj.glyphDataFormat   = bin.readShort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hhea = {};\nTypr.hhea.parse = function(data, offset, length) {\n    var bin = Typr._bin;\n    var obj = {};\n    var tableVersion = bin.readFixed(data, offset);  offset += 4;\n    obj.ascender  = bin.readShort(data, offset);  offset += 2;\n    obj.descender = bin.readShort(data, offset);  offset += 2;\n    obj.lineGap = bin.readShort(data, offset);  offset += 2;\n    \n    obj.advanceWidthMax = bin.readUshort(data, offset);  offset += 2;\n    obj.minLeftSideBearing  = bin.readShort(data, offset);  offset += 2;\n    obj.minRightSideBearing = bin.readShort(data, offset);  offset += 2;\n    obj.xMaxExtent = bin.readShort(data, offset);  offset += 2;\n    \n    obj.caretSlopeRise = bin.readShort(data, offset);  offset += 2;\n    obj.caretSlopeRun  = bin.readShort(data, offset);  offset += 2;\n    obj.caretOffset    = bin.readShort(data, offset);  offset += 2;\n    \n    offset += 4*2;\n    \n    obj.metricDataFormat = bin.readShort (data, offset);  offset += 2;\n    obj.numberOfHMetrics = bin.readUshort(data, offset);  offset += 2;\n    return obj;\n}\n\n\nTypr.hmtx = {};\nTypr.hmtx.parse = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    var obj = {};\n    \n    obj.aWidth = [];\n    obj.lsBearing = [];\n        \n    var aw = 0, lsb = 0;\n    \n    for(var i=0; i<font.maxp.numGlyphs; i++) {\n        if(i<font.hhea.numberOfHMetrics) {  aw=bin.readUshort(data, offset);  offset += 2;  lsb=bin.readShort(data, offset);  offset+=2;  }\n        obj.aWidth.push(aw);\n        obj.lsBearing.push(lsb);\n    }\n    \n    return obj;\n}\n\n\nTypr.kern = {};\nTypr.kern.parse = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    \n    var version = bin.readUshort(data, offset);  offset+=2;\n    if(version==1) return Typr.kern.parseV1(data, offset-2, length, font);\n    var nTables = bin.readUshort(data, offset);  offset+=2;\n    \n    var map = {glyph1: [], rval:[]};\n    for(var i=0; i<nTables; i++) {\n        offset+=2;  // skip version\n        var length  = bin.readUshort(data, offset);  offset+=2;\n        var coverage = bin.readUshort(data, offset);  offset+=2;\n        var format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\nTypr.kern.parseV1 = function(data, offset, length, font) {\n    var bin = Typr._bin;\n    \n    var version = bin.readFixed(data, offset);  offset+=4;\n    var nTables = bin.readUint(data, offset);  offset+=4;\n    \n    var map = {glyph1: [], rval:[]};\n    for(var i=0; i<nTables; i++) {\n        var length = bin.readUint(data, offset);   offset+=4;\n        var coverage = bin.readUshort(data, offset);  offset+=2;\n        var tupleIndex = bin.readUshort(data, offset);  offset+=2;\n        var format = coverage>>>8;\n        /* I have seen format 128 once, that's why I do */ format &= 0xf;\n        if(format==0) offset = Typr.kern.readFormat0(data, offset, map);\n        else throw \"unknown kern table format: \"+format;\n    }\n    return map;\n}\n\nTypr.kern.readFormat0 = function(data, offset, map) {\n    var bin = Typr._bin;\n    var pleft = -1;\n    var nPairs        = bin.readUshort(data, offset);  offset+=2;\n    var searchRange   = bin.readUshort(data, offset);  offset+=2;\n    var entrySelector = bin.readUshort(data, offset);  offset+=2;\n    var rangeShift    = bin.readUshort(data, offset);  offset+=2;\n    for(var j=0; j<nPairs; j++) {\n        var left  = bin.readUshort(data, offset);  offset+=2;\n        var right = bin.readUshort(data, offset);  offset+=2;\n        var value = bin.readShort (data, offset);  offset+=2;\n        if(left!=pleft) { map.glyph1.push(left);  map.rval.push({ glyph2:[], vals:[] }) }\n        var rval = map.rval[map.rval.length-1];\n        rval.glyph2.push(right);   rval.vals.push(value);\n        pleft = left;\n    }\n    return offset;\n}\n\n\n\nTypr.maxp = {};\nTypr.maxp.parse = function(data, offset, length) {\n    //console.log(data.length, offset, length);\n    \n    var bin = Typr._bin;\n    var obj = {};\n    \n    // both versions 0.5 and 1.0\n    var ver = bin.readUint(data, offset); offset += 4;\n    obj.numGlyphs = bin.readUshort(data, offset);  offset += 2;\n    \n    // only 1.0\n    if(ver == 0x00010000) {\n        obj.maxPoints             = bin.readUshort(data, offset);  offset += 2;\n        obj.maxContours           = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositePoints    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxCompositeContours  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxZones              = bin.readUshort(data, offset);  offset += 2;\n        obj.maxTwilightPoints     = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStorage            = bin.readUshort(data, offset);  offset += 2;\n        obj.maxFunctionDefs       = bin.readUshort(data, offset);  offset += 2;\n        obj.maxInstructionDefs    = bin.readUshort(data, offset);  offset += 2;\n        obj.maxStackElements      = bin.readUshort(data, offset);  offset += 2;\n        obj.maxSizeOfInstructions = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentElements  = bin.readUshort(data, offset);  offset += 2;\n        obj.maxComponentDepth     = bin.readUshort(data, offset);  offset += 2;\n    }\n    \n    return obj;\n}\n\n\nTypr.U = {};\n\nTypr.U.codeToGlyph = function(font, code) {\n    var cmap = font.cmap;\n    \n    \n    var tind = -1;\n    if(cmap.p0e4!=null) tind = cmap.p0e4;\n    else if(cmap.p3e1!=null) tind = cmap.p3e1;\n    else if(cmap.p1e0!=null) tind = cmap.p1e0;\n    \n    if(tind==-1) throw \"no familiar platform and encoding!\";\n    \n    var tab = cmap.tables[tind];\n    \n    if (tab.format==0) {\n        if(code>=tab.map.length) return 0;\n        return tab.map[code];\n    } else if(tab.format==4) {\n        var sind = -1;\n        for(var i=0; i<tab.endCount.length; i++)   if(code<=tab.endCount[i]){  sind=i;  break;  } \n        if(sind==-1) return 0;\n        if(tab.startCount[sind]>code) return 0;\n        \n        var gli = 0;\n        if(tab.idRangeOffset[sind]!=0) gli = tab.glyphIdArray[(code-tab.startCount[sind]) + (tab.idRangeOffset[sind]>>1) - (tab.idRangeOffset.length-sind)];\n        else                           gli = code + tab.idDelta[sind];\n        return gli & 0xFFFF;\n    } else if(tab.format==12) {\n        if(code>tab.groups[tab.groups.length-1][1]) return 0;\n        for(var i=0; i<tab.groups.length; i++) {\n            var grp = tab.groups[i];\n            if(grp[0]<=code && code<=grp[1]) return grp[2] + (code-grp[0]);\n        }\n        return 0;\n    }\n    else throw \"unknown cmap table format \"+tab.format;\n}\n\n\nTypr.U._getGlyphClass = function(g, cd) {\n    for(var i=0; i<cd.start.length; i++) \n        if(cd.start[i]<=g && cd.end[i]>=g) return cd.class[i];\n    return 0;\n}\n\nTypr.U.getPairAdjustment = function(font, g1, g2) {\n    if(font.GPOS) {\n        var ltab = null;\n        for(var i = 0; i < font.GPOS.featureList.length; i++) {\n            var fl = font.GPOS.featureList[i];\n            if (fl.tag==\"kern\")\n                for(var j=0; j<fl.tab.length; j++) \n                    if(font.GPOS.lookupList[fl.tab[j]].ltype==2) ltab=font.GPOS.lookupList[fl.tab[j]];\n        }\n        if(ltab) {\n            for(var i = 0; i < ltab.tabs.length; i++) {\n                var tab = ltab.tabs[i];\n                var ind = Typr._lctf.coverageIndex(tab.coverage, g1);\n                if (ind==-1) continue;\n                var adj = 0;\n                if (tab.format==1) {\n                    var right = tab.pairsets[ind];\n                    for (var j=0; j<right.length; j++) if (right[j].gid2==g2) adj = right[j];\n                    if (adj==null) continue;\n                } else if (tab.format==2) {\n                    var c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\n                    var c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                }\n                return adj.val1[2];\n            }\n        }\n    }\n    if(font.kern) {\n        var ind1 = font.kern.glyph1.indexOf(g1);\n        if(ind1!=-1) {\n            var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n            if(ind2!=-1) return font.kern.rval[ind1].vals[ind2];\n        }\n    }\n    \n    return 0;\n}\n\n/*\nTypr.U.isRTL = function(str) {           \n    var weakChars       = '\\u0000-\\u0040\\u005B-\\u0060\\u007B-\\u00BF\\u00D7\\u00F7\\u02B9-\\u02FF\\u2000-\\u2BFF\\u2010-\\u2029\\u202C\\u202F-\\u2BFF',\n        rtlChars        = '\\u0591-\\u07FF\\u200F\\u202B\\u202E\\uFB1D-\\uFDFD\\uFE70-\\uFEFC',\n        rtlDirCheck     = new RegExp('^['+weakChars+']*['+rtlChars+']');\n\n    return rtlDirCheck.test(str);\n};*/\n\n// var wsep = \"\\n\\t\\\" ,.:;!?()  \";\n//Typr.U.WSepTable = [9, 10, 32, 33, 34, 40, 41, 44, 46, 58, 59, 63, 1548]\n\n//var L = \"\";\n//Typr.U.LTable = [ 2765, 2775, 43122 ]\n\n//var R = \"\";\nTypr.U.RTable = [\n    1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586,\n    1608, 1649, 1650, 1651, 1653, 1654, 1655, 1672, 1673, 1674,\n    1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684,\n    1685, 1686, 1687, 1688, 1689, 1728, 1731, 1732, 1733, 1734,\n    1735, 1736, 1737, 1738, 1739, 1741, 1743, 1746, 1747, 1749,\n    1774, 1775, 1808, 1813, 1814, 1815, 1816, 1817, 1822, 1832,\n    1834, 1836, 1839, 1869, 1881, 1882, 1883, 1899, 1900, 1905,\n    1907, 1908, 1912, 1913, 2112, 2118, 2119, 2121, 2132, 2151,\n    2153, 2154, 2218, 2219, 2220, 2222, 2225, 2226, 2233, 2757,\n    2759, 2761, 2762, 2766, 2767, 2768, 2769, 2770, 2781, 2785,\n    2788, 2799, 2945, 2947, 2948, 2949, 2953, 2956, 2958, 2959,\n    2961, 2985, 2986, 2987, 2988 ];\n\n\nTypr.U.stringToGlyphs = function(fonts, str) {\n    var gls = [], g, i, li, j, lj, k, ti, c, c2, gsub, font, llist, flist, t, gsubTable;\n    var gl, gfonts = [], codes = [], scodes = [], scodesType = [], str2 = '';\n\n    var bidiResult = bidi(str, -1, false);\n\n    var rtable = Typr.U.RTable;\n\n   for (i = 0, li = str.length; i < li; i++) {\n        c = str.charCodeAt(i);\n        scodes.push(c);\n        scodesType.push(0);\n\n        //types wsep = 1, L = 2, R = 3\n\n        if (c == 2765 || c == 2775 || c == 43122) { // L\n            scodesType[i] = 2;\n        } else if (c == 1548) { // wsep\n            scodesType[i] = 1;\n        } else if (c <= 63) { // wsep\n            if (c == 9 || c == 10 || c == 32 || c == 33 || c == 34 || c == 40 || c == 41 || c == 44 || c == 46 || c == 58 || c == 59 || c == 63) {\n                scodesType[i] = 1;\n            }\n        } else if (c >= 1570 && c <= 2988) { // R\n            if (rtable.indexOf(c) != -1) {\n                scodesType[i] = 3;\n            }\n        }\n    }\n\n    //basic shaping\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        if (scodesType[i] != 1) { //not wsep\n            if (i < li - 2) {\n                c2 = scodes[i+1];\n\n                //myanmar \n                if (c2 == 0x103c) { //medial ra - prebase substitution\n                    scodes[i] = c2;\n                    scodes[i+1] = c;\n                    i++;\n                    continue;\n                }\n            }\n        }\n    }\n\n    //get glyphs and fonts for codes\n    for (i = 0, li = str.length; i < li; i++) {\n        c = scodes[i];\n\n        for (j = 0, lj = fonts.length; j < lj; j++) {\n            font = fonts[j];\n            g = Typr.U.codeToGlyph(font, c);\n            if (g) {\n                break;\n            }\n        }\n\n        gls.push(g);\n        gfonts.push(g ? j : 0);\n    }\n\n    codes = scodes;\n    font = null;\n    \n    \n    for(var ci = 0; ci < gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        var t1 = scodesType[ci-1], t2 = scodesType[ci], t3 = scodesType[ci+1];\n\n        var slft = (ci==0) || (t1 == 1);\n        var srgt = (ci==gls.length-1) || (t3 == 1);\n        \n        if(!slft && (t1 == 3)) slft=true;\n        if(!srgt && (t2 == 3)) srgt=true;\n        \n        if(!srgt && (t3 == 2)) srgt=true;\n        if(!slft && (t2 == 2)) slft=true;\n        \n        gsubTable = null;\n        if (slft) {\n            gsubTable = srgt ? font.gsubIsolTable : font.gsubInitTable;        \n        } else {\n            gsubTable = srgt ? font.gsubFinaTable : font.gsubMediTable;            \n        }\n        \n        if (gsubTable) {\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                var tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    var ttab = tab[j];\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage,gl);\n                    if(ind == -1) continue;  \n\n                    if(ttab.fmt == 0) {\n                        gls[ci] = ind+ttab.delta;\n                    } else {\n                        if (!ttab.newg) {\n                            gls[ci] = gl;\n                            console.log(ci, gl, 'subst-error', ' original:', str);\n                        } else {\n                            gls[ci] = ttab.newg[ind];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    font = null;\n    \n    for(var ci=0; ci<gls.length; ci++) {\n        gl = gls[ci];\n\n        if (font != gfonts[ci]) {\n            font = fonts[gfonts[ci]];\n            gsub = font['GSUB'];\n        }\n\n        if(!gsub) {\n            continue;\n        }\n\n        gsubTable = font.gsubRligLigaTable;\n\n        if (gsubTable) {\n            var rlim = Math.min(3, gls.length-ci-1);\n\n            for(ti = 0; ti < gsubTable.length; ti++) {\n                var tab = gsubTable[ti];\n\n                for(j = 0; j < tab.length; j++) {\n                    var ttab = tab[j];\n                    var ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\n                    if(ind==-1) continue;  \n\n                    var vals = ttab.vals[ind];\n                    \n                    for(k=0; k<vals.length; k++) {\n                        var lig = vals[k], rl = lig.chain.length;  if(rl>rlim) continue;\n                        var good = true;\n                        for(var l=0; l<rl; l++) if(lig.chain[l]!=gls[ci+(1+l)]) good=false;\n                        if(!good) continue;\n                        gls[ci]=lig.nglyph;\n                        for(var l=0; l<rl; l++) gls[ci+l+1]=-1;\n                        //console.log(\"lig\", fl.tag,  gl, lig.chain, lig.nglyph);\n                    }\n                }\n            }\n        }\n    }\n\n    var indices = bidiResult.indices;\n    var gls2 = gls.slice();\n    var codes2 = codes.slice();\n    var gfonts2 = gfonts.slice();\n\n    for (i = 0, li = gls.length; i < li; i++) {\n        c = indices[i];\n        gls2[i] = gls[c];\n        codes2[i] = codes[c];\n        gfonts2[i] = gfonts[c];\n    }\n\n    return [gls2, gfonts2, codes2];\n}\n\n\n\n\n\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_text_js__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__worker_style_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__worker_polygon_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__worker_message_js__ = __webpack_require__(1);\n\n\n\n\n\n\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */];\nvar setFont = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\"a\" /* setFont */];\nvar unint8ArrayToString = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"b\" /* unint8ArrayToString */], Utf8ArrayToStr = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"c\" /* Utf8ArrayToStr */];\nvar setFontMap = __WEBPACK_IMPORTED_MODULE_1__worker_text_js__[\"b\" /* setFontMap */], makeFasterFilter = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"a\" /* makeFasterFilter */];\nvar getLayer = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"b\" /* getLayer */], getLayerPropertyValue = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"c\" /* getLayerPropertyValue */],\n    processStylesheet = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"d\" /* processStylesheet */], getFilterResult = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"e\" /* getFilterResult */];\nvar processLineStringPass = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\"a\" /* processLineStringPass */];\nvar processPointArrayPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\"a\" /* processPointArrayPass */];\nvar processPointArrayVSwitchPass = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\"b\" /* processPointArrayVSwitchPass */];\nvar processPolygonPass = __WEBPACK_IMPORTED_MODULE_5__worker_polygon_js__[\"a\" /* processPolygonPass */];\nvar processLineStringGeometry = __WEBPACK_IMPORTED_MODULE_3__worker_linestring_js__[\"b\" /* processLineStringGeometry */];\nvar processPointArrayGeometry = __WEBPACK_IMPORTED_MODULE_4__worker_pointarray_js__[\"c\" /* processPointArrayGeometry */],\n    postGroupMessageLite = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\"a\" /* postGroupMessageLite */], optimizeGroupMessages = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\"b\" /* optimizeGroupMessages */];\nvar postGroupMessageFast = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\"c\" /* postGroupMessageFast */], postPackedMessage = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\"d\" /* postPackedMessage */], postPackedMessages = __WEBPACK_IMPORTED_MODULE_6__worker_message_js__[\"e\" /* postPackedMessages */];\nvar getLayerPropertyValueInner = __WEBPACK_IMPORTED_MODULE_2__worker_style_js__[\"f\" /* getLayerPropertyValueInner */];\n\nvar exportedGeometries = [];\nvar featureCache = new Array(1024), featureCacheIndex = 0, finalFeatureCache = new Array(1024), finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\nfunction processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo) {\n\n    globals.stylesheetLocals = {};\n\n    switch(type) {\n    case 'line-string':\n        if (getLayerPropertyValue(layer, 'point', feature, lod) ||\n            getLayerPropertyValue(layer, 'label', feature, lod)) {\n            processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        }\n\n        processLineStringPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n\n    case 'point-array':\n        processPointArrayPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;\n            \n    case 'polygon':\n        processPolygonPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n        break;     \n    }\n\n}\n\nfunction processFeatures(type, features, lod, featureType, group) {\n    var reduceParams = globals.reduceParams;\n\n    //loop layers\n    for (var key in globals.stylesheetLayers) {\n        var layer = globals.stylesheetLayers[key];\n\n        if (type == 'point-array') {\n            var importance = layer['importance-source'];\n            //\n\n            if ((typeof importance === 'undefined' || importance === null) && features[0] && features[0]['importance']) {\n                importance = '$importance';\n            }\n\n            if (!(typeof importance === 'undefined' || importance === null)) {\n                //importance = '$importance';\n                switch (globals.reduceMode) {\n                    case 'scr-count1': \n                    case 'scr-count2': \n                        layer['reduce'] = ['top',100,importance];\n                        layer['dynamic-reduce'] = ['scr-count2', reduceParams[0], reduceParams[1]];\n                        break;\n                    case 'scr-count4': \n                        layer['dynamic-reduce'] = ['scr-count4',importance];\n                        break;\n                    case 'scr-count5': \n                        layer['dynamic-reduce'] = ['scr-count5',importance];\n                        break;\n                    case 'scr-count6': \n                    case 'scr-count7': \n                    case 'scr-count8': \n                        var ppi = globals.reduceMode == 'scr-count8' ? reduceParams[6] : reduceParams[5];\n                        layer['dynamic-reduce'] = [globals.reduceMode,importance, (typeof layer['importance-weight'] !== 'undefined') ? layer['importance-weight'] : 1 ];\n                        layer['label-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\n                        layer['icon-no-overlap-margin'] = [reduceParams[0]*ppi, reduceParams[0]*ppi];\n                        layer['label-no-overlap-factor'] = [\"div-by-dist\",importance];\n                        break;\n                }\n            }\n        }\n\n        var filter =  layer['filter'];\n        var reduce =  layer['reduce'], i, li, j, lj;\n\n        if (filter) {\n            filter = layer['#filter'];\n            if (!filter) {\n                layer['#filter'] = makeFasterFilter(layer['filter']);\n                filter = layer['#filter'];\n            }\n        }\n\n        featureCacheIndex = 0, finalFeatureCacheIndex = 0, finalFeatureCacheIndex2 = 0;\n\n        for (i = 0, li = features.length; i < li; i++) {\n            var feature = features[i];\n            feature.properties = feature['properties'] || {};\n\n            if (feature['id']) {\n                feature.properties['#id'] = feature['id']; \n            }\n            \n            if (!filter || getFilterResult(filter, feature, featureType, group, layer, 'filter', lod, 0, true)) {\n                if (reduce) {\n                    featureCache[featureCacheIndex] = feature;\n                    featureCacheIndex++;\n                } else {\n                    processLayerFeature(type, feature, lod, layer, i);\n                }\n            }\n        }\n\n        if (reduce) {\n\n            var count = reduce[1];\n            var property = reduce[2];\n\n            switch (reduce[0]) {\n                case 'top':\n                case 'bottom':\n\n                    if (typeof property === 'string' && property.charAt(0) == '@') {\n                        property = globals.stylesheetConstants[property];\n\n                        if (typeof property === 'undefined') {\n                            break;\n                        }\n                    }\n\n                    if ((typeof property === 'string' && property.charAt(0) == '$') || (typeof property === 'object')) {\n                        var complexProperty = (typeof property === 'object');\n\n                        if (!complexProperty) {\n                            property = property.substr(1);\n                        }\n\n                        if (count > featureCacheIndex) {\n                            count = featureCacheIndex;\n                        }\n\n                        var top = (reduce[0] == 'top'), value;\n                        var currentIndex = 0;\n                        var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n                        do {\n                            var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;\n                            finalFeatureCacheIndex2 = finalFeatureCacheIndex;\n\n                            for (i = 0, li = featureCacheIndex; i < li; i++) {\n                                feature = featureCache[i];\n\n                                if (!currentIndex) {\n                                    if (!complexProperty) {\n                                        value = parseFloat(feature.properties[property]);\n                                    } else {\n                                        value = getLayerPropertyValueInner(layer, null, feature, lod, property, 0);\n                                    }\n                                    feature.tmp = value;\n                                } else {\n                                    value = feature.tmp;\n                                }\n\n                                if (!isNaN(value) && ((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {\n                                    if (currentValue != value) {\n                                        finalFeatureCacheIndex = finalFeatureCacheIndex2;\n                                    }\n\n                                    finalFeatureCache[finalFeatureCacheIndex] = feature;\n                                    finalFeatureCacheIndex++;\n                                    currentValue = value;\n                                }\n                            }\n\n                            currentValue2 = currentValue;\n                            currentIndex++;\n\n                        } while(currentIndex < count);\n                    }\n\n                    break;\n\n                case 'odd':\n                case 'even':\n\n                    for (i = (reduce[0] == 'odd') ? 1 : 0, li = featureCacheIndex; i < li; i+=2) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                case 'every':\n\n                    if (count > featureCacheIndex) {\n                        count = featureCacheIndex;\n                    }\n\n                    for (i = 0, li = featureCacheIndex; i < li; i += count) {\n                        feature = featureCache[i];\n                        finalFeatureCache[finalFeatureCacheIndex] = feature;\n                        finalFeatureCacheIndex++;\n                    }\n\n                    break;\n            }\n\n            //process reduced features\n            for (i = 0, li = finalFeatureCacheIndex; i < li; i++) {\n                feature = finalFeatureCache[i];\n                processLayerFeature(type, finalFeatureCache[i], lod, layer, i);\n            }\n\n        }\n\n    }\n}\n\n\nfunction processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo) {\n    var multiPass = getLayerPropertyValue(layer, 'next-pass', feature, lod);\n\n    var mylayer;\n\n    if (multiPass != null) {\n        for (var i = 0, li = multiPass.length; i < li; i++) {\n            var zIndex = multiPass[i][0];\n            mylayer = getLayer(multiPass[i][1], type, featureIndex);\n            \n            if (!getLayerPropertyValue(mylayer, 'visible', feature, lod)) {\n                continue;\n            }\n\n            var selectedLayerId = getLayerPropertyValue(mylayer, 'selected-layer', feature, lod);\n            var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n            var selectedHoverLayerId = getLayerPropertyValue(mylayer, 'selected-hover-layer', feature, lod);\n            var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n            var hoverLayerId = getLayerPropertyValue(mylayer, 'hover-layer', feature, lod);\n            var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n            var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n            var lastHitState = globals.hitState;\n\n            if (selectedLayer != null) {\n                globals.hitState = flags | 2;\n                processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (selectedHoverLayer != null) {\n                globals.hitState = flags | 3;\n                processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n            }\n\n            if (hoverLayer != null) {\n                globals.hitState = flags | 1;\n                processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n            }\n                \n            //globals.hitState = flags | 0;\n            processLayerFeaturePass(type, feature, lod, mylayer, featureIndex, zIndex, eventInfo);\n\n            globals.hitState = lastHitState;\n        }\n    }\n}\n\n\nfunction processLayerFeature(type, feature, lod, layer, featureIndex, skipPack) {\n    if (!getLayerPropertyValue(layer, 'visible', feature, lod)) {\n        return;\n    }\n\n    if (type == 'point-array') {\n        if (layer['visibility-switch']) {\n            postGroupMessageLite(5, 17);\n            //postGroupMessage({'command':'addRenderJob', 'type':'vswitch-begin'});\n            var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n            var eventInfo = feature.properties;\n            processPointArrayVSwitchPass(feature, lod, layer, featureIndex, zIndex, eventInfo);\n\n            var vswitch = layer['visibility-switch'];\n            for (var i = 0, li = vswitch.length; i <li; i++) {\n                if (vswitch[i][1]) {\n                    var slayer = getLayer(vswitch[i][1], type, featureIndex);\n                    processLayerFeature(type, feature, lod, slayer, featureIndex);\n                }\n                postGroupMessageLite(5, 18, vswitch[i][0]);\n            }\n\n            postGroupMessageLite(5, 19);\n            return;\n        }\n    }\n\n    if (!skipPack && layer['pack'] == true) {\n        globals.directPoints = [];\n\n        postGroupMessageLite(5, 15);\n        processLayerFeature(type, feature, lod, layer, featureIndex, true);\n        postGroupMessageLite(5, 16);\n\n        if (globals.directPoints)  //????????????????? FIXME\n\n        return;\n    }\n\n    var zIndex = getLayerPropertyValue(layer, 'z-index', feature, lod);\n\n    if (getLayerPropertyValue(layer, 'export-geometry', feature, lod) && (typeof feature['id'] !== 'undefined')) {\n        if (!exportedGeometries[feature]) {\n\n            switch(type) {\n            case 'line-string':\n                processLineStringGeometry(feature);\n                break;\n\n            case 'point-array':\n                processPointArrayGeometry(feature);\n                break;\n                    \n            case 'polygon':\n                break;     \n            }\n\n            exportedGeometries[feature] = true;\n        }\n    }\n\n    var eventInfo = feature.properties;\n\n    var selectedLayerId = getLayerPropertyValue(layer, 'selected-layer', feature, lod);\n    var selectedLayer = (selectedLayerId != '') ? getLayer(selectedLayerId, type, featureIndex) : null;\n\n    var selectedHoverLayerId = getLayerPropertyValue(layer, 'selected-hover-layer', feature, lod);\n    var selectedHoverLayer = (selectedHoverLayerId != '') ? getLayer(selectedHoverLayerId, type, featureIndex) : null;\n\n    var hoverLayerId = getLayerPropertyValue(layer, 'hover-layer', feature, lod);\n    var hoverLayer = (hoverLayerId != '') ? getLayer(hoverLayerId, type, featureIndex) : null;\n\n    var flags =  ((hoverLayer != null) ? (1<<8) : 0) | ((selectedLayer != null) ? (1<<9) : 0) | ((selectedHoverLayer != null) ? (1<<10) : 0);\n\n    if (selectedLayer != null) {\n        globals.hitState = flags | 2;\n        processLayerFeaturePass(type, feature, lod, selectedLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedLayer, featureIndex, eventInfo);\n    }\n\n    if (selectedHoverLayer != null) {\n        globals.hitState = flags | 3;\n        processLayerFeaturePass(type, feature, lod, selectedHoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, selectedHoverLayer, featureIndex, eventInfo);\n    }\n\n    if (hoverLayer != null) {\n        globals.hitState = flags | 1;\n        processLayerFeaturePass(type, feature, lod, hoverLayer, featureIndex, zIndex, eventInfo);\n        processLayerFeatureMultipass(type, feature, lod, hoverLayer, featureIndex, eventInfo);\n    }\n\n    globals.hitState = flags | 0;\n    processLayerFeaturePass(type, feature, lod, layer, featureIndex, zIndex, eventInfo);\n    processLayerFeatureMultipass(type, feature, lod, layer, featureIndex, eventInfo);\n}\n\nfunction processGroup(group, lod) {\n    var i, li;\n    var groupId = group['id'] || '';\n    globals.groupId = groupId;\n\n    var bbox = group['bbox'];    \n    if (!bbox) {\n        return;\n    }\n          \n    var bboxMin = bbox[0];\n    var bboxMax = bbox[1];\n    globals.bboxMin = bboxMin;\n    globals.bboxMax = bboxMax;\n\n    var bboxDelta = [bbox[1][0] - bbox[0][0],\n        bbox[1][1] - bbox[0][1],\n        bbox[1][2] - bbox[0][2]];\n    var bboxResolution = group['resolution'] || 4096;\n    \n    globals.groupOrigin = [0,0,0];\n    globals.forceScale = [bboxDelta[0] / bboxResolution,\n        bboxDelta[1] / bboxResolution,\n        bboxDelta[2] / bboxResolution];\n\n    postGroupMessageFast(9, 0, {'id': group['id'], 'bbox': [bboxMin, bboxMax], 'origin': bboxMin}, [], \"\");\n\n    //process points\n    var points = group['points'] || [];\n    globals.featureType = 'point';\n    processFeatures('point-array', points, lod, 'point', groupId);\n\n    //process lines\n    var lines = group['lines'] || [];\n    globals.featureType = 'line';\n    processFeatures('line-string', lines, lod, 'line', groupId);\n\n    //process polygons\n    var polygons = group['polygons'] || [];\n    globals.featureType = 'polygon';\n    processFeatures('polygon', polygons, lod, 'polygon', groupId);\n\n    postGroupMessageLite(10, 0);\n\n    if (globals.groupOptimize) {\n        optimizeGroupMessages();\n    }\n}\n\n\nfunction processGeodata(data, lod) {\n    //console.log(\"processGeodata\");\n\n    //create object from JSON\n    if ((typeof data) == 'string') {\n        try {\n            var geodata = JSON.parse(data);\n        } catch (e) {\n            geodata = null;\n        }\n    } else {\n        geodata = data;\n    }\n\n    if (geodata) {\n\n        var groups = geodata['groups'] || [];\n\n        //process layers\n        for (var i = 0, li = groups.length; i < li; i++) {\n            processGroup(groups[i], lod);\n        }\n    }\n\n    //console.log(\"processGeodata-ready\");\n}\n\n\nself.onmessage = function (e) {\n    var message = e.data;\n    var command = message['command'];\n    var data = message['data'];\n    var dataRaw = null;\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n    case 'config':\n        globals.config = data;\n        break;\n\n    case 'setStylesheet':\n        if (data) {\n            globals.geocent = data['geocent'];\n            globals.metricUnits = data['metric'];\n            globals.reduceMode = data['reduceMode'];\n            globals.reduceParams = data['reduceParams'];\n            globals.log = data['log'];\n            globals.language = data['language'];\n            processStylesheet(data['data']);\n        }\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFont':\n        setFont(data);\n        //postMessage({'command' : 'ready'});\n        break;\n\n    case 'setFontMap':\n        setFontMap(data);\n        postMessage({'command' : 'styleDone'});\n        postMessage({'command' : 'ready'});\n        break;\n\n    case 'processGeodataRaw':\n        dataRaw = data;\n        data = Utf8ArrayToStr(data);\n\n    case 'processGeodata':\n        globals.tileLod = message['lod'] || 0;\n        globals.tileSize = message['tileSize'] || 1;\n        globals.pixelSize = message['pixelSize'] || 1;\n        globals.pixelFactor = message['dpr'] || 1;\n        globals.invPixelFactor = 1.0 / globals.pixelFactor;\n        globals.pixelsPerMM = (globals.pixelFactor / 96) / 2.54;\n        globals.invPixelsPerMM = 1.0 / globals.pixelsPerMM;\n\n        data = JSON.parse(data);            \n        exportedGeometries = [];\n        processGeodata(data, globals.tileLod);\n\n        postGroupMessageLite(7, 0);\n            \n        if (globals.groupOptimize) {  //we need send all processed message\n            optimizeGroupMessages();\n        }\n            \n        //postMessage({'command' : 'allProcessed'});\n\n        if (dataRaw) {\n            postPackedMessage({'command' : 'ready', 'geodata': dataRaw}, [dataRaw]);\n        } else {\n            postPackedMessage({'command' : 'ready'});\n        }\n\n        if (globals.config.mapPackLoaderEvents) {\n            postPackedMessages();\n        }\n\n        break;\n\n    //case 'tick':\n      //  postPackedMessages();\n        //break;\n\n    }\n};\n\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=6849ae50a93d8cd1da78.worker.js.map", null);
};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
	return __webpack_require__(47)("/*!\n * Copyright (c) 2017 Melown Technologies SE\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * *  Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * \n * *  Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return globals; });\n\nvar globals = {};\n\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return parseMesh; });\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */];\n\nvar flagsInternalTexcoords =  1;\nvar flagsExternalTexcoords =  2;\nvar flagsPerVertexUndulation =  4;\nvar flagsTextureMode =  8;\n\n\nfunction parseMesh(stream) {\n    /*\n    struct MapMesh {\n        struct MapMeshHeader {\n            char magic[2];                // letters \"ME\"\n            ushort version;               // currently 1\n            double meanUndulation;        // read more about undulation below\n            ushort numSubmeshes;          // number of submeshes\n        } header;\n        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property\n    };\n    */\n\n    var mesh = {}, i, li, submesh;\n\n    //parase header\n    var streamData = stream.data;\n    var magic = '';\n\n    if (streamData.length < 2) {\n        return false;\n    }\n\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;\n\n    if (magic != 'ME') {\n        return false;\n    }\n\n    mesh.version = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    if (mesh.version > 3) {\n        return false;\n    }\n    \n    stream.uint8Data = new Uint8Array(stream.data.buffer);\n\n    mesh.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;\n    mesh.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;\n\n    mesh.submeshes = [];\n    mesh.gpuSize = 0; \n    mesh.faces = 0;\n    mesh.size = 0;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        var submesh = parseSubmesh(mesh, stream);\n        if (submesh.valid) {\n            mesh.submeshes.push(submesh); \n            mesh.size += submesh.size;\n            mesh.faces += submesh.faces;\n\n            //aproximate size\n            mesh.gpuSize += submesh.size;\n        }\n    }\n    \n    mesh.numSubmeshes = mesh.submeshes.length;\n\n    //prevent minification\n\n    var submeshes = [];\n    var transferables = [];\n\n    for (i = 0, li = mesh.numSubmeshes; i < li; i++) {\n        submesh = mesh.submeshes[i];\n        submeshes.push({\n\n            'bboxMax': submesh.bboxMax,\n            'bboxMin': submesh.bboxMin,\n            'externalUVs': (submesh.externalUVs) ? submesh.externalUVs.buffer : null,\n            'faces': submesh.faces,\n            'flags': submesh.flags,\n            'gpuSize': submesh.gpuSize,\n            'indices': (submesh.indices) ? submesh.indices.buffer : null,\n            'internalUVs': (submesh.internalUVs) ? submesh.internalUVs.buffer : null,\n            'size': submesh.size,\n            'surfaceReference': submesh.surfaceReference,\n            'textureLayer': submesh.textureLayer,\n            'textureLayer2': submesh.textureLayer2,\n            //'valid': submesh.valid\n            'vertices': submesh.vertices.buffer\n\n        });\n\n        if (submesh.externalUVs) transferables.push(submesh.externalUVs.buffer);\n        if (submesh.internalUVs) transferables.push(submesh.internalUVs.buffer);\n        if (submesh.vertices) transferables.push(submesh.vertices.buffer);\n        if (submesh.indices) transferables.push(submesh.indices.buffer);\n    }\n\n    return { mesh:{\n               'faces': mesh.faces,\n               'gpuSize': mesh.gpuSize,\n               'meanUndulation': mesh.meanUndulation,\n               'numSubmeshes': mesh.numSubmeshes,\n               'size': mesh.size,\n               'submeshes': mesh.submeshes,\n               'version': mesh.version\n             },\n             transferables:transferables\n           };\n};\n\n\nfunction parseSubmesh(mesh, stream) {\n    /*\n    struct MapSubmesh {\n        struct MapSubmeshHeader header;\n        struct VerticesBlock vertices;\n        struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )\n        struct FacesBlock faces;\n    };\n    */\n\n    var submesh = { valid:true };\n\n    parseHeader(mesh, submesh, stream);\n    if (mesh.version >= 3) {\n        parseVerticesAndFaces2(mesh, submesh, stream);\n    } else {\n        parseVerticesAndFaces(mesh, submesh, stream);\n    }\n\n    return submesh;\n};\n\n\nfunction parseHeader(mesh, submesh, stream) {\n    /*\n    struct MapSubmeshHeader {\n        char flags;                    // bit 0 - contains internal texture coords\n                                       // bit 1 - contains external texture coords\n                                       // bit 2 - contains per vertex undulation\n                                       // bit 3 - texture mode (0 - internal, 1 - external)\n        \n        uchar surfaceReference;        // reference to the surface of origin, see bellow\n        ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id\n        double boundingBox[2][3];      // read more about bounding box bellow\n    };\n    */\n\n    //debugger\n    var streamData = stream.data;\n\n    submesh.flags = streamData.getUint8(stream.index, true); stream.index += 1;\n\n    if (mesh.version > 1) {\n        submesh.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;\n    } else {\n        submesh.surfaceReference = 0;\n    }\n\n    submesh.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;\n    submesh.textureLayer2 = submesh.textureLayer; //hack for presentation\n\n    var bboxMin = [];\n    var bboxMax = [];\n\n    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n\n    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;\n    \n    submesh.bboxMin = bboxMin;\n    submesh.bboxMax = bboxMax;\n};\n\n\nfunction parseVerticesAndFaces(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            ushort x;\n            ushort y;\n            ushort z;\n\n            // if header.flags & ( 1 << 1 ): external texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort eu;\n            ushort ev;\n\n            // if header.flags & ( 1 << 2 ): undulation delta\n            float16 undulationDelta;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var internalUVs = null;\n    var externalUVs = null;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        if (onlyOneUVs) {\n            externalUVs = true;\n        } else {\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n        }\n    }\n\n    var uvfactor = use16bit ? 1.0 : (1.0 / 65535);\n    var vindex = 0;\n    var uvindex = 0;\n    var i, li;\n\n    for (i = 0; i < numVertices; i++) {\n        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;\n        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;\n        vindex += 3;\n\n        if (externalUVs) {\n            if (!onlyOneUVs) {\n                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;\n                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;\n                uvindex += 2;\n            }\n            index += 10;\n        } else {\n            index += 6;\n        }\n    }\n\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n   \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n    \n        internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        //var uvfactor = 1.0 / 65535;\n    \n        for (i = 0, li = numUVs * 2; i < li; i+=2) {\n            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;\n            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;\n            index += 4;\n        }\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var v1, v2, v3, vv1, vv2, vv3, sindex;\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    for (i = 0; i < numFaces; i++) {\n        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));\n        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));\n        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));\n\n        if (onlyIndices) {\n            vindex = i * 3;\n\n            if (internalUVs != null) {\n                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n\n                vertices[vv1*3] = vtmp[v1*3];\n                vertices[vv1*3+1] = vtmp[v1*3+1];\n                vertices[vv1*3+2] = vtmp[v1*3+2];\n\n                vertices[vv2*3] = vtmp[v2*3];\n                vertices[vv2*3+1] = vtmp[v2*3+1];\n                vertices[vv2*3+2] = vtmp[v2*3+2];\n\n                vertices[vv3*3] = vtmp[v3*3];\n                vertices[vv3*3+1] = vtmp[v3*3+1];\n                vertices[vv3*3+2] = vtmp[v3*3+2];\n\n                indices[vindex] = vv1;\n                indices[vindex+1] = vv2;\n                indices[vindex+2] = vv3;\n\n                index += 12;\n            } else {\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n\n                index += 6;\n            }\n\n        } else {\n            vindex = i * (3 * 3);\n\n            sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n\n            if (internalUVs != null) {\n                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));\n                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));\n                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));\n                index += 12;\n\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            } else {\n                index += 6;\n            }\n        }\n    }\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    tmpVertices = null;\n    tmpInternalUVs = null;\n    tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\n\nfunction parseWord(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);\n        res[1] += 2;\n    } else {\n        res[0] = value;\n        res[1] ++;\n    }\n};\n\n\nfunction parseDelta(data, res) {\n    var value = data[res[1]];\n    \n    if (value & 0x80) {\n        value = (value & 0x7f) | (data[res[1]+1] << 7);\n\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] += 2;\n        } else {\n            res[0] = (value >> 1); \n            res[1] += 2;\n        }\n    } else {\n        if (value & 1) {\n            res[0] = -((value >> 1)+1); \n            res[1] ++;\n        } else {\n            res[0] = (value >> 1); \n            res[1] ++;\n        }\n    }\n};\n\n\nfunction parseVerticesAndFaces2(mesh, submesh, stream) {\n    /*\n    struct VerticesBlock {\n        ushort numVertices;              // number of vertices\n        ushort geomQuantCoef;            // geometry quantization coefficient\n\n        struct Vertex {                  // array of vertices, size of array is defined by numVertices property\n            // vertex coordinates\n            delta x;\n            delta y;\n            delta z;\n        } vertices[];\n    };\n    */\n\n    var data = stream.data;\n    var index = stream.index;\n    var uint8Data = stream.uint8Data;\n\n    var use16bit = globals.config.map16bitMeshes;\n    var onlyOneUVs = globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords);\n    var tmpVertices, tmpExternalUVs, tmpInternalUVs;\n\n    var numVertices = data.getUint16(index, true); index += 2;\n    var quant = data.getUint16(index, true); index += 2;\n\n    if (!numVertices) {\n        submesh.valid = false;\n    }\n\n    var bmin = submesh.bboxMin;\n    var bmax = submesh.bboxMax;\n\n    var center = [(bmin[0] + bmax[0])*0.5, (bmin[1] + bmax[1])*0.5, (bmin[2] + bmax[2])*0.5];\n    var scale = Math.abs(Math.max(bmax[0] - bmin[0], bmax[1] - bmin[1], bmax[2] - bmin[2]));\n\n    var multiplier = 1.0 / quant;\n    var externalUVs = null;\n\n    var vertices = use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));\n    var vindex;\n    \n    var x = 0, y = 0,z = 0;\n    var cx = center[0], cy = center[1], cz = center[2];\n    var mx = bmin[0];\n    var my = bmin[1];\n    var mz = bmin[2];\n    var sx = 1.0 / (bmax[0] - bmin[0]);\n    var sy = 1.0 / (bmax[1] - bmin[1]);\n    var sz = 1.0 / (bmax[2] - bmin[2]);\n    \n    var res = [0, index];\n    var i, li, t;\n\n    if (use16bit) {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            t = ((x * multiplier * scale + cx) - mx) * sx;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex] = t * 65535;\n            t = ((y * multiplier * scale + cy) - my) * sy;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+1] = t * 65535;\n            t = ((z * multiplier * scale + cz) - mz) * sz;\n            if (t < 0) t = 0; if (t > 1.0) t = 1.0;\n            vertices[vindex+2] = t * 65535;\n        }\n    } else {\n        for (i = 0; i < numVertices; i++) {\n            parseDelta(uint8Data, res);\n            x += res[0];\n            parseDelta(uint8Data, res);\n            y += res[0];\n            parseDelta(uint8Data, res);\n            z += res[0];\n            \n            vindex = i * 3;\n            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;\n            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;\n            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;\n        }\n    }\n    \n    index = res[1];\n\n    if (submesh.flags & flagsExternalTexcoords) {\n        quant = data.getUint16(index, true); index += 2;\n        res[1] = index;\n\n        if (onlyOneUVs) {\n\n            for (i = 0; i < numVertices; i++) {\n                parseDelta(uint8Data, res);\n                parseDelta(uint8Data, res);\n            }\n\n        } else {\n            multiplier = (use16bit) ? (65535 / quant) : (1.0 / quant);\n            externalUVs = use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));\n            x = 0, y = 0;\n\n            if (use16bit) {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    t = x * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex] = t;\n                    t = y * multiplier;\n                    if (t < 0) t = 0; if (t > 65535) t = 65535;\n                    externalUVs[uvindex+1] = 65535 - t;\n                }\n            } else {\n                for (i = 0; i < numVertices; i++) {\n                    parseDelta(uint8Data, res);\n                    x += res[0];\n                    parseDelta(uint8Data, res);\n                    y += res[0];\n\n                    var uvindex = i * 2;\n                    externalUVs[uvindex] = x * multiplier;\n                    externalUVs[uvindex+1] = 1 - (y * multiplier);\n                }\n            }\n        }\n    }\n\n    index = res[1];\n\n    tmpVertices = vertices;\n    tmpExternalUVs = externalUVs;\n    \n    /*\n    struct TexcoorsBlock {\n        ushort numTexcoords;              // number of texture coordinates\n\n        struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property\n\n            // internal texture coordinates\n            // values in 2^16^ range represents the 0..1 normalized texture space\n            ushort u;\n            ushort v;\n        } texcoords[];\n    };\n    */\n\n    if (submesh.flags & flagsInternalTexcoords) {\n        var numUVs = data.getUint16(index, true); index += 2;\n        var quantU = data.getUint16(index, true); index += 2;\n        var quantV = data.getUint16(index, true); index += 2;\n        var multiplierU = (use16bit) ? (65536.0 / quantU) : (1.0 / quantU);\n        var multiplierV = (use16bit) ? (65536.0 / quantV) : (1.0 / quantV);\n        x = 0, y = 0;\n    \n        var internalUVs = use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));\n        res[1] = index;7\n\n        if (use16bit) {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                t = x * multiplierU;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i] = t;\n                t = y * multiplierV;\n                if (t < 0) t = 0; if (t > 65535) t = 65535;\n                internalUVs[i+1] = 65535 - t;\n            }\n        } else {\n            for (i = 0, li = numUVs * 2; i < li; i+=2) {\n                parseDelta(uint8Data, res);\n                x += res[0];\n                parseDelta(uint8Data, res);\n                y += res[0];\n\n                internalUVs[i] = x * multiplierU;\n                internalUVs[i+1] = 1 - (y * multiplierV);\n            }\n        }\n\n        index = res[1];\n    \n        tmpInternalUVs = internalUVs;\n    }\n\n    /*\n    struct FacesBlock {\n        ushort numFaces;              // number of faces\n\n        struct Face {                 // array of faces, size of array is defined by numFaces property\n\n            ushort v[3]; // array of indices to stored vertices\n            ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords\n\n        } faces[];\n    };\n    */\n\n    var numFaces = data.getUint16(index, true); index += 2;\n    var indices = null;\n\n    internalUVs = null;\n    externalUVs = null;\n\n    var onlyExternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && !(submesh.flags & flagsInternalTexcoords));\n    var onlyInternalIndices = (globals.config.mapIndexBuffers && globals.config.mapOnlyOneUVs && (submesh.flags & flagsInternalTexcoords));\n    var onlyIndices = onlyExternalIndices || onlyInternalIndices;\n\n    if (onlyIndices) {\n        indices = new Uint16Array(numFaces * 3);\n    } else {\n        vertices = use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));\n\n        if (submesh.flags & flagsInternalTexcoords) {\n            internalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n\n        if (!onlyOneUVs && (submesh.flags & flagsExternalTexcoords)) {\n            externalUVs = use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));\n        }\n    }\n\n    var vtmp = tmpVertices;\n    var eUVs = tmpExternalUVs;\n    var iUVs = tmpInternalUVs;\n    var high = 0;\n    var v1, v2, v3, vv1, vv2, vv3;\n    res[1] = index;\n\n    for (i = 0; i < numFaces; i++) {\n        parseWord(uint8Data, res);\n        v1 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v2 = high - res[0];\n        if (!res[0]) { high++; }\n\n        parseWord(uint8Data, res);\n        v3 = high - res[0];\n        if (!res[0]) { high++; }\n\n        if (onlyIndices) {\n            vindex = i * 3;\n            indices[vindex] = v1;\n            indices[vindex+1] = v2;\n            indices[vindex+2] = v3;\n        } else {\n            vindex = i * (3 * 3);\n            var sindex = v1 * 3;\n            vertices[vindex] = vtmp[sindex];\n            vertices[vindex+1] = vtmp[sindex+1];\n            vertices[vindex+2] = vtmp[sindex+2];\n\n            sindex = v2 * 3;\n            vertices[vindex+3] = vtmp[sindex];\n            vertices[vindex+4] = vtmp[sindex+1];\n            vertices[vindex+5] = vtmp[sindex+2];\n\n            sindex = v3 * 3;\n            vertices[vindex+6] = vtmp[sindex];\n            vertices[vindex+7] = vtmp[sindex+1];\n            vertices[vindex+8] = vtmp[sindex+2];\n\n            if (externalUVs != null) {\n                vindex = i * (3 * 2);\n                externalUVs[vindex] = eUVs[v1*2];\n                externalUVs[vindex+1] = eUVs[v1*2+1];\n                externalUVs[vindex+2] = eUVs[v2*2];\n                externalUVs[vindex+3] = eUVs[v2*2+1];\n                externalUVs[vindex+4] = eUVs[v3*2];\n                externalUVs[vindex+5] = eUVs[v3*2+1];\n            }\n        }\n    }\n\n    if (onlyExternalIndices) {\n        vertices = tmpVertices;\n        externalUVs = tmpExternalUVs;\n    }\n\n    if (onlyInternalIndices) {\n        vertices = use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));\n        internalUVs = tmpInternalUVs;\n    }\n\n    high = 0;\n\n    if (internalUVs != null) {\n        for (i = 0; i < numFaces; i++) {\n            parseWord(uint8Data, res);\n            v1 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v2 = high - res[0];\n            if (!res[0]) { high++; }\n    \n            parseWord(uint8Data, res);\n            v3 = high - res[0];\n            if (!res[0]) { high++; }\n\n            if (onlyInternalIndices) {\n                vindex = i * 3;\n\n                vv1 = indices[vindex] * 3;\n                vv2 = indices[vindex+1] * 3;\n                vv3 = indices[vindex+2] * 3;\n\n                vertices[v1*3] = vtmp[vv1];\n                vertices[v1*3+1] = vtmp[vv1+1];\n                vertices[v1*3+2] = vtmp[vv1+2];\n\n                vertices[v2*3] = vtmp[vv2];\n                vertices[v2*3+1] = vtmp[vv2+1];\n                vertices[v2*3+2] = vtmp[vv2+2];\n\n                vertices[v3*3] = vtmp[vv3];\n                vertices[v3*3+1] = vtmp[vv3+1];\n                vertices[v3*3+2] = vtmp[vv3+2];\n\n                indices[vindex] = v1;\n                indices[vindex+1] = v2;\n                indices[vindex+2] = v3;\n            } else {\n                vindex = i * (3 * 2);\n                internalUVs[vindex] = iUVs[v1*2];\n                internalUVs[vindex+1] = iUVs[v1*2+1];\n                internalUVs[vindex+2] = iUVs[v2*2];\n                internalUVs[vindex+3] = iUVs[v2*2+1];\n                internalUVs[vindex+4] = iUVs[v3*2];\n                internalUVs[vindex+5] = iUVs[v3*2+1];\n            }\n        }\n    }\n\n    index = res[1];\n\n    submesh.vertices = vertices;\n    submesh.internalUVs = internalUVs;\n    submesh.externalUVs = externalUVs;\n    submesh.indices = indices;\n\n    //tmpVertices = null;\n    //tmpInternalUVs = null;\n    //tmpExternalUVs = null;\n\n    stream.index = index;\n\n    submesh.size = submesh.vertices.byteLength;\n    if (submesh.internalUVs) submesh.size += submesh.internalUVs.byteLength;\n    if (submesh.externalUVs) submesh.size += submesh.externalUVs.byteLength;\n    if (submesh.indices) submesh.size += submesh.indices.byteLength;\n    submesh.faces = numFaces;\n};\n\n\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__worker_mesh_js__ = __webpack_require__(1);\n\n\n\n\n//get rid of compiler mess\nvar globals = __WEBPACK_IMPORTED_MODULE_0__worker_globals_js__[\"a\" /* globals */];\nvar parseMesh = __WEBPACK_IMPORTED_MODULE_1__worker_mesh_js__[\"a\" /* parseMesh */];\n\nvar packedEvents = [];\nvar packedTransferables = [];\n\nfunction postPackedMessage(message, transferables) {\n\n    if (globals.config.mapPackLoaderEvents) {\n\n        packedEvents.push(message);\n\n        if (transferables) {\n            packedTransferables = packedTransferables.concat(transferables);\n        }\n\n    } else {\n\n        if (transferables) {\n            postMessage(message, transferables);\n        } else {\n            postMessage(message);\n        }\n\n    }\n}\n\nfunction loadBinary(path, onLoaded, onError, withCredentials, xhrParams, responseType, kind) {\n    var xhr = new XMLHttpRequest();\n\n    xhr.onreadystatechange = (function (){\n\n        switch (xhr.readyState) {\n        case 0 : // UNINITIALIZED\n        case 1 : // LOADING\n        case 2 : // LOADED\n        case 3 : // INTERACTIVE\n            break;\n        case 4 : // COMPLETED\n    \n            if (xhr.status >= 400 || xhr.status == 0) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path, 'status':xhr.status});\n                }\n                break;\n            }\n    \n            var abuffer = xhr.response;\n                    \n            if (!abuffer) {\n                if (onError) {\n                    postPackedMessage({'command' : 'on-error', 'path': path});\n                }\n                break;\n            }\n    \n            if (onLoaded) {\n                if (kind == 'direct-texture') {\n                    createImageBitmap(abuffer).then((function(bitmap){\n                        postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': bitmap, 'filesize': abuffer.size}, [bitmap]);                        \n                    }).bind(this));\n                } else if (kind == 'direct-mesh') {\n                    //debugger\n                    var data = parseMesh({data:new DataView(abuffer), index:0});\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': data.mesh}, data.transferables);\n                } else {\n\n                    postPackedMessage({'command' : 'on-loaded', 'path': path, 'data': abuffer}, [abuffer]);\n                }\n            }\n    \n            break;\n    \n        default:\n    \n            if (onError) {\n                postPackedMessage({'command' : 'on-error', 'path': path});\n            }\n    \n            break;\n        }\n\n    }).bind(this);\n    \n    /*\n    xhr.onerror  = (function() {\n        if (onError) {\n            onError();\n        }\n    }).bind(this);*/\n\n    xhr.open('GET', path, true);\n    xhr.responseType = responseType ? responseType : 'arraybuffer';\n    xhr.withCredentials = withCredentials;\n\n    if (xhrParams && xhrParams['token'] /*&& xhrParams[\"tokenHeader\"]*/) {\n        //xhr.setRequestHeader(xhrParams[\"tokenHeader\"], xhrParams[\"token\"]); //old way\n        xhr.setRequestHeader('Accept', 'token/' + xhrParams['token'] + ', */*');\n    }\n\n    xhr.send('');\n};\n\n\nself.onmessage = function (e) {\n    var message = e.data;\n    var command = message['command'];\n    //var data = message['data'];\n\n    //console.log(\"workeronmessage: \" + command);\n\n    switch(command) {\n\n        case 'config':\n            globals.config = message['data'];\n            break;\n\n        case 'tick':\n\n            if (packedEvents.length > 0) {\n                if (packedTransferables.length > 0) {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents}, packedTransferables);\n                } else {\n                    postMessage({'command': 'packed-events', 'messages':packedEvents});\n                }\n            }\n\n            packedEvents = [];\n            packedTransferables = [];\n\n            break;\n\n        case 'load-binary':\n            loadBinary(message['path'], true, true, message['withCredentials'], message['xhrParams'], message['responseType'], message['kind']);\n            break;\n\n    }\n};\n\n\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=67d9ba12f3d972ffe101.worker.js.map", null);
};

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var InspectorGraphs = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorGraphs.prototype.init = function() {
    var inspector = this.inspector;

    inspector.addStyle( ''
        + '#vts-graphs-panel {'
            + 'position:absolute;'
            + 'left:10px;'
            + 'top:10px;'
            + 'z-index: 7;'
            + 'background-color: #FFFFFF;'
            + 'padding: 5px;'
            + 'border-radius: 4px;'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'color:#000000;'
            + 'text-align: left;'
            + 'font-size: 12px;'
            + 'display:none;'
        + '}'

        + '.vts-graphs-canvas {'
            + 'border: solid 1px #bbb;'
            + 'image-rendering : pixelated;'
        + '}'

        + '.vts-graphs-info {'
            + 'padding: 5px 2px;'
            + 'font-size: 10px;'
        + '}'

        + '.vts-graphs-button {'
            + 'padding: 2px 5px;'
            + 'display:inline-block;'
            + 'margin-right: 4px;'
            + 'border-radius: 4px;'
            + 'cursor:pointer;'
        + '}'

        + '.vts-graphs-button:hover {'
            + 'box-shadow: 0 0 1px #0066ff;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-graphs-panel';
    this.element.innerHTML = ''
        + '<canvas id="vts-graphs-render" class="vts-graphs-canvas" width="900" height="100" ></canvas>'
        + '<div id="vts-graphs-info" class="vts-graphs-info" >&FilledSmallSquare; Frame: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: 1234 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Mesh: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMesh: 1234</div>'
        + '<canvas id="vts-graphs-cache" class="vts-graphs-canvas" width="900" height="100" ></canvas>'
        + '<div id="vts-graphs-info2" class="vts-graphs-info" >&FilledSmallSquare; Cache: 1234 &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Used: 123 &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: 1234 &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> Mesh: &nbsp 1234</div>'
        + '<div id="vts-graphs-rec" class="vts-graphs-button" >Recording On</div>'
        + '<div id="vts-graphs-ref" class="vts-graphs-button" >Refresh On</div>'
        + '<div id="vts-graphs-res" class="vts-graphs-button" >Reset</div>'
        + '<div id="vts-graphs-zoom" class="vts-graphs-button" >Scale: Max value</div>'
        + '<div id="vts-graphs-magnify" class="vts-graphs-button" >Magnify Off</div>'
        + '<div id="vts-graphs-graph" class="vts-graphs-button" >Graph: Cache</div>';

    this.core.element.appendChild(this.element);
    this.canvasRender = document.getElementById('vts-graphs-render');
    this.canvasCache = document.getElementById('vts-graphs-cache');
    this.canvasRenderCtx = this.canvasRender.getContext('2d');
    this.canvasCacheCtx = this.canvasCache.getContext('2d');

    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);

    document.getElementById('vts-graphs-rec').onclick = this.recordingPressed.bind(this);
    document.getElementById('vts-graphs-ref').onclick = this.refreshPressed.bind(this);
    document.getElementById('vts-graphs-res').onclick = this.resetPressed.bind(this);
    document.getElementById('vts-graphs-zoom').onclick = this.zoomPressed.bind(this);
    document.getElementById('vts-graphs-magnify').onclick = this.magnifyPressed.bind(this);
    document.getElementById('vts-graphs-graph').onclick = this.graphPressed.bind(this);

    document.getElementById('vts-graphs-render').onmousemove = this.onMouseMove.bind(this);
    document.getElementById('vts-graphs-render').onmouseout = this.onMouseOut.bind(this);
    document.getElementById('vts-graphs-cache').onmousemove = this.onMouseMove.bind(this);
    document.getElementById('vts-graphs-cache').onmouseout = this.onMouseOut.bind(this);

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.zoom = 'max';
    this.graph = 'Cache';
    this.refresh = true;

    this.panelVisible = false;
};


InspectorGraphs.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
    this.recordingPressed(true);
};


InspectorGraphs.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
    this.recordingPressed(true);
};


InspectorGraphs.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorGraphs.prototype.recordingPressed = function(state) {
    var map = this.core.getMap();

    if (!map) {
        return;
    }

    map.stats.recordGraphs = (state == null) ? state : !map.stats.recordGraphs;
    this.updateGraphsPanel();
    this.updateGraphs(null, true);
};


InspectorGraphs.prototype.refreshPressed = function() {
    this.refresh = !this.refresh;
    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.resetPressed = function() {
    var map = this.core.getMap();

    if (!map) {
        return;
    }

    map.stats.resetGraphs();
    this.updateGraphs(null, true);
};


InspectorGraphs.prototype.zoomPressed = function() {
    switch (this.zoom) {
    case 'max':     this.zoom = '120avrg'; break;
    case '120avrg': this.zoom = '180avrg'; break;
    case '180avrg': this.zoom = 'max'; break;
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.graphPressed = function() {
    switch (this.graph) {
    case 'Cache':      this.graph = 'Polygons'; break;
    case 'Polygons':   this.graph = 'Processing'; break;
    case 'Processing': this.graph = 'LODs'; break;
    case 'LODs':       this.graph = 'Flux'; break;
    case 'Flux':       this.graph = 'Cache'; break;
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.magnifyPressed = function() {
    this.magnify = !this.magnify;

    if (this.magnify) {
        this.canvasRender.style.width = '1400px';
        this.canvasRender.style.height = '200px';
        this.canvasCache.style.width = '1400px';
        this.canvasCache.style.height = '200px';
        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify On';
    } else {
        this.canvasRender.style.width = '900px';
        this.canvasRender.style.height = '100px';
        this.canvasCache.style.width = '900px';
        this.canvasCache.style.height = '100px';
        document.getElementById('vts-graphs-magnify').innerHTML = 'Magnify Off';
    }

    this.updateGraphsPanel();
    this.updateGraphs();
};


InspectorGraphs.prototype.updateGraphsPanel = function() {
    var map = this.core.getMap();

    if (!map) {
        return;
    }

    if (map.stats.recordGraphs) {
        document.getElementById('vts-graphs-rec').innerHTML = 'Recording On';
    } else {
        document.getElementById('vts-graphs-rec').innerHTML = 'Recording Off';
    }

    if (this.refresh) {
        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh On';
    } else {
        document.getElementById('vts-graphs-ref').innerHTML = 'Refresh Off';
    }

    switch (this.zoom) {
    case 'max':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: Max value';
        break;

    case '120avrg':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 100% Avrg';
        break;

    case '180avrg':
        document.getElementById('vts-graphs-zoom').innerHTML = 'Scale: 50% Avrg';
        break;
    }

    document.getElementById('vts-graphs-graph').innerHTML = 'Graph: ' + this.graph;
};


InspectorGraphs.prototype.onMouseMove = function(event) {
    var x = event.clientX - this.canvasRender.getBoundingClientRect().left;
    this.showCursor = true;

    if (this.magnify) {
        x = Math.floor(x * 900/1400);
    }

    this.cursorIndex = x;

    var map = this.core.getMap();
    if (!map) {
        return;
    }

    if (!map.stats.recordGraphs) {
        this.updateGraphs(null);
    }
};


InspectorGraphs.prototype.onMouseOut = function() {
    this.showCursor = false;
    this.updateGraphs(null);
};


InspectorGraphs.prototype.updateGraphs = function(stats, ignoreRefresh) {
    var map = this.core.getMap();

    if (!map || (!this.refresh && !ignoreRefresh) || !this.panelVisible) {
        return;
    }

    stats = stats || map.stats;

    var width = this.canvasRender.width;
    var height = this.canvasRender.height;
    var ctx = this.canvasRenderCtx;

    var samples = stats.graphsTimeSamples;
    var samplesIndex = stats.graphsTimeIndex;

    var factorX = width / samples;

    ctx.clearRect(0, 0, width, height);

    var maxValue = 0;
    var totalFrame = 0;
    var totalRender = 0;
    var totalTexture = 0;
    var totalMeshes = 0;
    var totalGpuMeshes = 0;
    var realCount = 0, i, j, lj;
    var index, value, values, str, y, factorY, max, min;

    var valuesFrame = stats.graphsFrameTimes;
    var valuesRender = stats.graphsRenderTimes;
    var valuesTextures = stats.graphsCreateTextureTimes;
    var valuesMeshes = stats.graphsCreateMeshTimes;
    var valuesGpuMeshes = stats.graphsCreateGpuMeshTimes;
    var valuesGeodata;

    for (i = 0; i < samples; i++) {
        totalFrame += valuesFrame[i];
        totalRender += valuesRender[i];
        totalTexture += valuesTextures[i];
        totalMeshes += valuesMeshes[i];
        totalGpuMeshes += valuesGpuMeshes[i];

        var v = valuesFrame[i];

        if (v > maxValue) {
            maxValue = v;
        }

        if (v > 0) {
            realCount++;
        }
    }

    if (this.zoom == '120avrg') {
        maxValue = (totalFrame / realCount) * 1.0;
    }

    if (this.zoom == '180avrg') {
        maxValue = (totalFrame / realCount) * 0.5;
    }

    factorY = height / maxValue;

    for (i = 0; i < samples; i++) {
        index = samplesIndex + i;
        index %= samples;

        ctx.fillStyle='#000000';
        ctx.fillRect(i*factorX, height, 1, -(valuesFrame[index])*factorY);
        ctx.fillStyle='#ff0000';
        ctx.fillRect(i*factorX, height, 1, -(valuesRender[index])*factorY);

        ctx.fillStyle='#0000ff';
        ctx.fillRect(i*factorX, height, 1, -(valuesTextures[index])*factorY);

        y = height -(valuesTextures[index])*factorY;

        ctx.fillStyle='#007700';
        ctx.fillRect(i*factorX, y, 1, -(valuesMeshes[index])*factorY);

        y -= (valuesMeshes[index])*factorY;

        ctx.fillStyle='#00ff00';
        ctx.fillRect(i*factorX, y, 1, -(valuesGpuMeshes[index])*factorY);

    }

    if (this.showCursor) {
        ctx.fillStyle='#aa00aa';
        index = (this.cursorIndex) % samples;
        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);
        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);
        index = (this.cursorIndex + samplesIndex) % samples;

        str = '&FilledSmallSquare; Frame: ' + valuesFrame[index].toFixed(2) +
              ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + valuesRender[index].toFixed(2) +
              ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + valuesTextures[index].toFixed(2) +
              ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + valuesMeshes[index].toFixed(2) +
              ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + valuesGpuMeshes[index].toFixed(2) + '</div>';
    } else {
        str = '&FilledSmallSquare; Frame: ' + Math.round(totalFrame) +
              ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Render: ' + Math.round(totalRender) +
              ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Textures: ' + Math.round(totalTexture) +
              ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Meshes: ' + Math.round(totalMeshes) +
              ' &nbsp <span style="color:#00bb00">&FilledSmallSquare;</span> GpuMeshes: ' + Math.round(totalGpuMeshes) +'</div>';
    }

    document.getElementById('vts-graphs-info').innerHTML = str;

    width = this.canvasCache.width;
    height = this.canvasCache.height;
    ctx = this.canvasCacheCtx;

    factorX = width / samples;

    ctx.clearRect(0, 0, width, height);

    switch (this.graph) {
    case 'Cache':
        {
            factorY = height / ((map.gpuCache.maxCost+map.resourcesCache.maxCost+map.metatileCache.maxCost));

            var maxMetatiles = 0;
            var maxResources = 0;
            var maxTextures = 0;
            var maxMeshes = 0;
            var maxGeodata = 0;
            var maxGpu = 0;

            var valuesMetatiles = stats.graphsCpuMemoryMetatiles;
            var valuesResources = stats.graphsCpuMemoryUsed;
            var valuesGpu = stats.graphsGpuMemoryRender;
            valuesGeodata = stats.graphsGpuMemoryGeodata;
            valuesTextures = stats.graphsGpuMemoryTextures;
            valuesMeshes = stats.graphsGpuMemoryMeshes;

            for (i = 0; i < samples; i++) {
                maxMetatiles = valuesMetatiles[i] > maxMetatiles ? valuesMetatiles[i] : maxMetatiles;
                maxResources = valuesResources[i] > maxResources ? valuesResources[i] : maxResources;
                maxTextures = valuesTextures[i] > maxTextures ? valuesTextures[i] : maxTextures;
                maxMeshes = valuesMeshes[i] > maxMeshes ? valuesMeshes[i] : maxMeshes;
                maxGeodata = valuesGeodata[i] > maxGeodata ? valuesGeodata[i] : maxGeodata;
                maxGpu = valuesGpu[i] > maxGpu ? valuesGpu[i] : maxGpu;
            }

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                value = valuesMetatiles[index] + valuesMeshes[index] + valuesTextures[index] + valuesGeodata[index] + valuesResources[index];
                ctx.fillStyle='#000000';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesResources[index];

                ctx.fillStyle='#0000ff';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesTextures[index];

                ctx.fillStyle='#009999';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesGeodata[index];

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);
                value -= valuesMeshes[index];

                ctx.fillStyle='#ff0000';
                ctx.fillRect(i*factorX, height, 1, -(value)*factorY);

                value = valuesGpu[index];
                ctx.fillStyle='#ffff00';
                ctx.fillRect(i*factorX, height -(value)*factorY, 1, 1);
            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#555">&FilledSmallSquare;</span> Total: ' + Math.ceil((valuesMetatiles[index] + valuesResources[index] + valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> CPU: ' + Math.ceil(valuesResources[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> GPU: ' + Math.ceil((valuesTextures[index] + valuesMeshes[index])/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Te: ' + Math.ceil(valuesTextures[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Me: ' + Math.ceil(valuesMeshes[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Ge: ' + Math.ceil(valuesGeodata[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Met: ' + Math.ceil(valuesMetatiles[index]/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ffff00">&FilledSmallSquare;</span> Render: ' + Math.ceil(valuesGpu[index]/(1024*1024)) + 'MB' +'</div>';
            } else {
                str = '<span style="color:#555">&FilledSmallSquare;</span> Total: ' + Math.round((maxMetatiles + maxResources + maxTextures + maxMeshes)/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> CPU: ' + Math.ceil(maxResources/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#000000">&FilledSmallSquare;</span> GPU: ' + Math.ceil((maxTextures + maxMeshes)/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#0000ff">&FilledSmallSquare;</span> Te ' + Math.ceil(maxTextures/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#005500">&FilledSmallSquare;</span> Me: ' + Math.ceil(maxMeshes/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Ge: ' + Math.ceil(maxGeodata/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ff0000">&FilledSmallSquare;</span> Met: ' + Math.ceil(maxMetatiles/(1024*1024)) + 'MB' +
                      ' &nbsp <span style="color:#ffff00">&FilledSmallSquare;</span> Render: ' + Math.ceil(maxGpu/(1024*1024)) + 'MB' +'</div>';
            }

        }
        break;


    case 'Polygons':
    case 'Processing':
        {
            max = 0;
            min = 99999999999;
            realCount = 0;
            values = (this.graph == 'Polygons') ? stats.graphsPolygons : stats.graphsBuild;
            var total = 0;

            for (i = 0; i < samples; i++) {
                max = values[i] > max ? values[i] : max;

                if (values[i] > 0) {
                    min = values[i] < min ? values[i] : min;
                    total += values[i];
                    realCount++;
                }
            }

            factorY = height / max;

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, height, 1, -(values[index])*factorY);
            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#007700">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + Math.round(values[index]) +'</div>';
            } else {
                str = '<span style="color:#007700">&FilledSmallSquare;</span> ' + this.graph + ' Max: ' + max +'</div>';
                str += ' &nbsp Min: ' + min;
                str += ' &nbsp Avrg: ' + Math.round(total / realCount) +'</div>';
            }
        }
        break;


    case 'LODs':
        {
            max = 0;
            values = stats.graphsLODs;

            for (i = 0; i < samples; i++) {
                max = values[i][0] > max ? values[i][0] : max;
            }

            factorY = height / max;

            ctx.fillStyle='#000000';
            ctx.fillRect(0, 0, width, height);

            var lods;

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;

                //ctx.fillStyle="#000000";
                //ctx.fillRect(i*factorX, height, 1, -(values[index][0])*factorY);

                y = height;
                
                lods = values[index][1]; 

                for (j = 0, lj = lods.length; j < lj; j++) {
                    if (lods[j]) {
                        ctx.fillStyle='hsl('+((j*23)%360)+',100%,50%)';
                        value = Math.round((lods[j])*factorY);
                        ctx.fillRect(i*factorX, y, 1, -value);
                        y -= value;
                    }
                }

            }

            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;

                str = 'LODs:' + values[index][0];
                lods = values[index][1]; 

                for (j = 0, lj = lods.length; j < lj; j++) {
                    if (lods[j]) {
                        str += '<span style="color:hsl('+((j*23)%360)+',100%,50%)">&FilledSmallSquare;</span>'+j+':'+lods[j];
                    }
                }

            } else {
                str = 'LODs:' + values[index][0];
            }

            str += '</div>';
        }
        break;

    case 'Flux':
        {
            var maxCount = 0;
            var maxSize = 0;

            var maxTexPlusCount = 0;
            var maxTexPlusSize = 0;
            var maxTexMinusCount = 0;
            var maxTexMinusSize = 0;

            var maxMeshPlusCount = 0;
            var maxMeshPlusSize = 0;
            var maxMeshMinusCount = 0;
            var maxMeshMinusSize = 0;

            var maxGeodataPlusCount = 0;
            var maxGeodataPlusSize = 0;
            var maxGeodataMinusCount = 0;
            var maxGeodataMinusSize = 0;

            valuesTextures = stats.graphsFluxTextures;
            valuesMeshes = stats.graphsFluxMeshes;
            valuesGeodata = stats.graphsFluxGeodatas;

            for (i = 0; i < samples; i++) {
                var tmp = valuesTextures[i][0][0] + valuesMeshes[i][0][0];
                maxCount = tmp > maxCount ? tmp : maxCount;
                tmp = valuesTextures[i][1][0] + valuesMeshes[i][1][0];
                maxCount = tmp > maxCount ? tmp : maxCount;

                tmp = valuesTextures[i][0][1] + valuesMeshes[i][0][1];
                maxSize = tmp > maxSize ? tmp : maxSize;
                tmp = valuesTextures[i][1][1] + valuesMeshes[i][1][1];
                maxSize = tmp > maxSize ? tmp : maxSize;

                maxTexPlusCount = valuesTextures[i][0][0] > maxTexPlusCount ? valuesTextures[i][0][0] : maxTexPlusCount;
                maxTexPlusSize = valuesTextures[i][0][1] > maxTexPlusSize ? valuesTextures[i][0][1] : maxTexPlusSize;
                maxTexMinusCount = valuesTextures[i][1][0] > maxTexMinusCount ? valuesTextures[i][1][0] : maxTexMinusCount;
                maxTexMinusSize = valuesTextures[i][1][1] ? valuesTextures[i][1][1] : maxTexMinusSize;

                maxMeshPlusCount = valuesMeshes[i][0][0] > maxMeshPlusCount ? valuesMeshes[i][0][0] : maxMeshPlusCount;
                maxMeshPlusSize = valuesMeshes[i][0][1] > maxMeshPlusSize ? valuesMeshes[i][0][1] : maxMeshPlusSize;
                maxMeshMinusCount = valuesMeshes[i][1][0] > maxMeshMinusCount ? valuesMeshes[i][1][0] : maxMeshMinusCount;
                maxMeshMinusSize = valuesMeshes[i][1][1] > maxMeshMinusSize ? valuesMeshes[i][1][1] : maxMeshMinusSize;

                maxGeodataPlusCount = valuesGeodata[i][0][0] > maxGeodataPlusCount ? valuesGeodata[i][0][0] : maxGeodataPlusCount;
                maxGeodataPlusSize = valuesGeodata[i][0][1] > maxGeodataPlusSize ? valuesGeodata[i][0][1] : maxGeodataPlusSize;
                maxGeodataMinusCount = valuesGeodata[i][1][0] > maxGeodataMinusCount ? valuesGeodata[i][1][0] : maxGeodataMinusCount;
                maxGeodataMinusSize = valuesGeodata[i][1][1] > maxGeodataMinusSize ? valuesGeodata[i][1][1] : maxGeodataMinusSize;
            }

            factorY = (height*0.25-2) / maxCount;
            var factorY2 = (height*0.25-2) / maxSize;

            var base = Math.floor(height*0.25);
            var base2 = Math.floor(height*0.75);

            for (i = 0; i < samples; i++) {
                index = samplesIndex + i;
                index %= samples;
                
                var y1Up = base;
                var y1Down = base+1;
                var y2Up = base2;
                var y2Down = base2+1;

                ctx.fillStyle='#0000aa';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesTextures[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesTextures[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesTextures[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesTextures[index][1][1])*factorY2);

                y1Up -= (valuesTextures[index][0][0])*factorY;
                y1Down += (valuesTextures[index][1][0])*factorY;
                y2Up -= (valuesTextures[index][0][1])*factorY2;
                y2Down += (valuesTextures[index][1][1])*factorY2;

                ctx.fillStyle='#007700';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesMeshes[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesMeshes[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesMeshes[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesMeshes[index][1][1])*factorY2);

                y1Up -= (valuesMeshes[index][0][0])*factorY;
                y1Down += (valuesMeshes[index][1][0])*factorY;
                y2Up -= (valuesMeshes[index][0][1])*factorY2;
                y2Down += (valuesMeshes[index][1][1])*factorY2;

                ctx.fillStyle='#009999';
                ctx.fillRect(i*factorX, y1Up, 1, -(valuesGeodata[index][0][0])*factorY);
                ctx.fillRect(i*factorX, y1Down, 1, (valuesGeodata[index][1][0])*factorY);

                ctx.fillRect(i*factorX, y2Up, 1, -(valuesGeodata[index][0][1])*factorY2);
                ctx.fillRect(i*factorX, y2Down, 1, (valuesGeodata[index][1][1])*factorY2);

                ctx.fillStyle='#aaaaaa';
                ctx.fillRect(0, Math.floor(height*0.5), width, 1);
                ctx.fillStyle='#dddddd';
                ctx.fillRect(0, base, width, 1);
                ctx.fillRect(0, base2, width, 1);
            }


            if (this.showCursor) {
                index = (this.cursorIndex + samplesIndex) % samples;
                str = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + valuesTextures[index][0][0] + '/' + valuesTextures[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesTextures[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesTextures[index][1][1]/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + valuesMeshes[index][0][0] + '/' + valuesMeshes[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesMeshes[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesMeshes[index][1][1]/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Geodata Count +/-: ' + valuesGeodata[index][0][0] + '/' + valuesGeodata[index][1][0];
                str += ' &nbsp Size +/-: ' + (valuesGeodata[index][0][1]/1024/1024).toFixed(2) + '/' + (valuesGeodata[index][1][1]/1024/1024).toFixed(2);
                str += '</div>';
            } else {
                str = '<span style="color:#007700">&FilledSmallSquare;</span> Textures Count +/-: ' + maxTexPlusCount + '/' + maxTexMinusCount;
                str += ' &nbsp Size +/-: ' + (maxTexPlusSize/1024/1024).toFixed(2) + '/' + (maxTexMinusSize/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#0000aa">&FilledSmallSquare;</span> Meshes Count +/-: ' + maxMeshPlusCount + '/' + maxMeshMinusCount;
                str += ' &nbsp Size +/-: ' + (maxMeshPlusSize/1024/1024).toFixed(2) + '/' + (maxMeshMinusSize/1024/1024).toFixed(2);
                str += ' &nbsp <span style="color:#009999">&FilledSmallSquare;</span> Geodata Count +/-: ' + maxGeodataPlusCount + '/' + maxGeodataMinusCount;
                str += ' &nbsp Size +/-: ' + (maxGeodataPlusSize/1024/1024).toFixed(2) + '/' + (maxGeodataMinusSize/1024/1024).toFixed(2);
                str += '</div>';
            }

        }
        break;

    }

    if (this.showCursor) {
        ctx.fillStyle='#aa00aa';
        index = (this.cursorIndex) % samples;
        ctx.fillRect(Math.floor(index*factorX)-1, 0, 1, height);
        ctx.fillRect(Math.floor(index*factorX)+1, 0, 1, height);
    }

    document.getElementById('vts-graphs-info2').innerHTML = str;
};


/* harmony default export */ __webpack_exports__["a"] = (InspectorGraphs);



/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var InspectorInput = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorInput.prototype.init = function() {
    //mouse events
    //document.addEventListener("click", this.onKeyClick.bind(this), false);

    //keyboard events
    document.addEventListener('keyup', this.onKeyUp.bind(this), false);
    document.addEventListener('keypress', this.onKeyPress.bind(this), false);
    document.addEventListener('keydown', this.onKeyDown.bind(this), false);
};


//keyboard events
InspectorInput.prototype.onKeyDown = function(event) {
    if (typeof event == 'undefined') {
        event = window.event;
    }

    this.altDown = event.altKey;
    this.ctrlDown = event.ctrlKey;
    this.shiftDown = event.shiftKey;

    this.onKeyUp(event, true);
};


InspectorInput.prototype.onKeyPress = function(event) {
    this.onKeyUp(event, true);
};


InspectorInput.prototype.onKeyUp = function(event, press) {
    if (typeof event == 'undefined') {
        event = window.event;
    }

    var map = this.core.getMap();
    var inspector = this.inspector;

    if (!map) {
        return;
    }

    var debug = map.draw.debug;

    this.altDown = event.altKey;
    this.ctrlDown = event.ctrlKey;
    this.shiftDown = event.shiftKey;

    var hit = false;
    var blockHit = true;

    if (event) {
        var keyCode;

        if (window.event) {         // eg. IE
            keyCode = window.event.keyCode;
        } else if (event.which) {   // eg. Firefox
            keyCode = event.which;
        } else {
            keyCode = event.charCode;
        }

        if (this.shiftDown) {
            if (this.ctrlDown) {
                switch(keyCode) {
                case 68:
                case 100:
                    inspector.preventDefault(event); break;  //key D pressed
                }
            }
        }

        if (this.shiftDown && press !== true) {

            switch(keyCode) {
            case 76:
            case 108:
                /*this.showMenu(); this.toolbarItemSelected('link'); done();*/  break;  //key L pressed

            case 71:
            case 103:
                /*this.showMenu(); this.toolbarItemSelected('position'); done();*/ break; //key G pressed
            }

            if (this.ctrlDown) {

                switch(keyCode) {
                case 68:
                case 100:
                    
                    inspector.enableInspector();
                    this.diagnosticMode = true; hit = true; break;  //key D pressed
                }
            }

            if (this.diagnosticMode) {
                blockHit = true;

                switch(keyCode) {

                case 67:
                case 99:
                    map.config.mapDegradeHorizon = !map.config.mapDegradeHorizon;

                        //this.measureMode = !this.measureMode;
                        //this.measurePoints = [];
                        //var pos = this.core.hitTest(this.mouseX, this.mouseY, "all");
                        //console.log("hit pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + pos[3] + " d " + pos[4]); //key T pressed

                    break; //key C pressed

                case 49: /*this.core.setControlMode("manual"); done();*/  break;  //key 1 pressed
                case 50: /*this.core.setControlMode("drone"); done();*/   break;  //key 2 pressed
                case 51: /*this.core.setControlMode("observer"); done();*/ break; //key 3 pressed

                case 48:  //key 0 pressed
                        /*this.core.setOption("noForwardMovement" , !this.core.getOption("noForwardMovement"));*/
                    break;

                    //case 84: //key T pressed
                    //case 116:
                        /*var pos = this.core.hitTest(this.mouseX, this.mouseY, "all");
                        console.log("hit pos: " + pos[0] + " " + pos[1] + " " + pos[2] + " " + pos[3] + " d " + pos[4]); //key T pressed
                        this.core.logTile(pos);*/
                        //break;

                case 72:
                case 104:
                    debug.heightmapOnly = !debug.heightmapOnly;

                        /*
                        var pos = map.getPosition();
                        pos.setHeight(pos.setHeight() * 0.9);
                        map.setPosition(pos);*/

                    break;  //key H pressed

                case 81:
                case 113:
                    var pos = map.getPosition();
                    // eslint-disable-next-line
                    console.log('pos-before: ' + JSON.stringify(pos.pos));
                    map.convert.convertPositionViewMode(pos, (pos.getViewMode() == 'obj') ? 'subj' : 'obj');
                    // eslint-disable-next-line
                    console.log('new mode: ' + pos.getViewMode());
                    // eslint-disable-next-line
                    console.log('pos-after: ' + JSON.stringify(pos.pos));
                    map.setPosition(pos);
                    /*this.core.saveScreenshot(pos);*/

                    if (this.altDown && pos.getViewMode() != 'obj') {
                        map.camera.near = 0.1;
                    } else {
                        map.camera.near = 2;
                    }

                    inspector.preventDefault(event);

                    break;  //key Q pressed

                case 80:
                case 112:
                    map.renderer.saveScreenshot('file', 'vts-screenshot.png', 'png'); break;  //key P pressed

                case 83:
                case 115:
                    inspector.stats.switchPanel(); break; //key S pressed

                case 86:
                case 118:
                    inspector.layers.switchPanel(); break; //key V pressed

                case 69:
                case 101:
                    inspector.stylesheets.switchPanel(); break; //key E pressed

                case 84:
                case 116:
                    inspector.replay.switchPanel(); break; //key T pressed

                case 66:
                case 98:
                    debug.drawBBoxes = !debug.drawBBoxes; break; //key B pressed

                case 65:
                case 97:
                    debug.drawLabelBoxes = !debug.drawLabelBoxes; break; //key A pressed

                case 75:
                case 107:
                   debug.drawAllLabels = !debug.drawAllLabels; break; //key K pressed

                case 73:
                case 105:
                    debug.drawHiddenLabels = !debug.drawHiddenLabels; break; //key I pressed
                    //debug.drawGridCells = !debug.drawGridCells; break; //key I pressed

                case 87:
                case 119:
                    
                    if (debug.drawWireframe == 3) {
                        debug.drawWireframe = 1;
                    } else {
                        var value = debug.drawWireframe + 1;
                        debug.drawWireframe = value > 2 ? 0 : value;
                    }
                    break; //key W pressed

                case 70:
                case 102:
                    debug.drawWireframe = debug.drawWireframe != 3 ? 3 : 0;
                    break; //key F pressed

                case 85:
                case 117:
                    map.renderer.setSuperElevationState(!map.renderer.useSuperElevation);
                    break; //key U pressed

                case 71:
                case 103:
                    //map.config.mapHysteresisWait = map.config.mapHysteresisWait ? 0 : 500;
                    console.log('hyst wait' + map.config.mapHysteresisWait);
                    break; //key G pressed

                case 77:
                case 109:
                    map.loaderSuspended = !map.loaderSuspended;            
                    // eslint-disable-next-line
                    console.log('loader state ' + map.loaderSuspended);

                    break; //key M pressed

                case 74:
                case 106:
                    debug.drawEarth = !debug.drawEarth; hit = true; break; //key J pressed

                case 88:
                case 120:
                    debug.drawFog = !debug.drawFog; hit = true; break; //key X pressed

                case 82:
                case 114:
                    inspector.graphs.switchPanel(); break; //key R pressed

                case 79:
                case 111:
                    map.camera.camera.setOrtho(!map.camera.camera.getOrtho()); break; //key O pressed

                case 76:
                case 108:
                    inspector.drawRadar = !inspector.drawRadar; break; //key L pressed

                case 90:
                case 122:
                    debug.maxZoom = !debug.maxZoom; break; //key Z pressed

                case 78:
                case 110:
                    inspector.shakeCamera = !inspector.shakeCamera; break; //key N pressed

                default:
                    blockHit = false;
                    break;

                }

                if (blockHit) {
                    hit = true;
                }
            }
        }

        if (this.diagnosticMode && debug.drawWireframe && !press) {
            if (keyCode >= 96 && keyCode <= 105) {
                if (this.altDown) {
                    debug.drawTestData = keyCode - 96;
                    if (this.ctrlDown) {
                        debug.drawTestData += 10;
                    }
                } else {
                    debug.drawTestMode = keyCode - 96;
                }

                hit = true;
            } 
        }

        if (this.diagnosticMode && inspector.drawRadar && !this.shiftDown && !press) {
            blockHit = true;

            switch(keyCode) {
            case 43:
            case 107:
                if (inspector.radarLod == null) { inspector.radarLod = 8;}
                inspector.radarLod++; /*console.log("radarLOD: " + this.radarLod);*/ break; //key mun + pressed

            case 45:
            case 109:
                if (inspector.radarLod == null) { inspector.radarLod = 8;}
                inspector.radarLod = Math.max(0,inspector.radarLod-1); /*console.log("radarLOD: " + this.radarLod);*/ break; //key mun - pressed

            case 42:
            case 106:
                inspector.radarLod = null; /*console.log("radarLOD: auto");*/ break; //key mun * pressed

            default:
                blockHit = false;
                break;
            }

            if (blockHit) {
                hit = true;
            }
        }

        if (this.diagnosticMode && debug.drawBBoxes && !this.shiftDown && !press) {
            blockHit = true;

            switch(keyCode) {
            case 76:
            case 108:
                debug.drawLods = !debug.drawLods; break; //key L pressed

            case 80:
            case 112:
                debug.drawPositions = !debug.drawPositions; break; //key P pressed

            case 84:
            case 116:
                debug.drawTextureSize = !debug.drawTextureSize; break; //key T pressed

            case 70:
            case 102:
                debug.drawFaceCount = !debug.drawFaceCount; break; //key F pressed

            case 71:
            case 103:
                debug.drawGeodataOnly = !debug.drawGeodataOnly; break; //key G pressed

            case 68:
            case 100:
                debug.drawDistance = !debug.drawDistance; break; //key D pressed

            case 78:
            case 110:
                debug.drawNodeInfo = !debug.drawNodeInfo; break; //key N pressed

            case 77:
            case 109:
                debug.drawMeshBBox = !debug.drawMeshBBox; break; //key M pressed

            case 73:
            case 105:
                debug.drawIndices = !debug.drawIndices; break; //key I pressed

            case 66:
            case 98:
                debug.drawBoundLayers = !debug.drawBoundLayers; break; //key B pressed

            case 83:
            case 115:
                debug.drawSurfaces = !debug.drawSurfaces; break; //key S pressed

            case 90:
            case 122:
                debug.drawSurfaces2 = !debug.drawSurfaces2; break; //key Z pressed

            case 67:
            case 99:
                debug.drawCredits = !debug.drawCredits; break; //key C pressed

            case 79:
            case 111:
                debug.drawOrder = !debug.drawOrder; break; //key O pressed

            case 69:
            case 101:
                debug.debugTextSize = (debug.debugTextSize == 2.0) ? 3.0 : 2.0; break; //key E pressed

            case 88:
            case 120:
                map.config.mapPreciseBBoxTest = !map.config.mapPreciseBBoxTest; break; //key X pressed

            case 87:
            case 119:
                debug.drawPolyWires = !debug.drawPolyWires; break; //key W pressed

            case 90:
            case 122:
                map.config.mapPreciseDistanceTest = !map.config.mapPreciseDistanceTest; break; //key Z pressed

            case 75:
            case 107:
                debug.drawGPixelSize = !debug.drawGPixelSize; break; //key K pressed

            default:
                blockHit = false;
                break;
            }

            if (blockHit) {
                hit = true;
            }
        }

    }

    if (hit) {
        map.markDirty();
        inspector.preventDefault(event);
    }

    //console.log("key" + keyCode);
};


InspectorInput.prototype.setParameter = function(key, value) {
    var map = this.core.getMap();
    var inspector = this.inspector;

    if (!map) {
        return;
    }

    var debug = map.draw.debug;
    var getBool = (function(a){ return (value === true || value == 'true' || value == '1') });

    switch(key) {
        case 'debugBBox':
            debug.drawBBoxes = true;
            var has = (function(a){ return (value.indexOf(a)!=-1); });
            if (has('L')) debug.drawLods = true;
            if (has('P')) debug.drawPositions = true;
            if (has('T')) debug.drawTextureSize = true;
            if (has('F')) debug.drawFaceCount = true;
            if (has('G')) debug.drawGeodataOnly = true;
            if (has('D')) debug.drawDistance = true;
            if (has('N')) debug.drawNodeInfo = true;
            if (has('M')) debug.drawMeshBBox = true;
            if (has('I')) debug.drawIndices = true;
            if (has('B')) debug.drawBoundLayers = true;
            if (has('S')) debug.drawSurfaces = true;
            if (has('Z')) debug.drawSurfaces2 = true;
            if (has('C')) debug.drawCredits = true;
            if (has('O')) debug.drawOrder = true;
            if (has('E')) debug.debugTextSize = 3.0;
            if (has('K')) debug.drawGPixelSize = true;
            break;
        case 'debugLBox': debug.drawLabelBoxes = getBool(value); break;
        case 'debugNoEarth': debug.drawEarth = !getBool(value); break;
        case 'debugShader': debug.drawWireframe = parseInt(value); break;
        case 'debugHeightmap': debug.heightmapOnly = getBool(value); break;
        case 'debugGridCells': debug.drawGridCells = getBool(value); break;
        case 'debugRadar':
            inspector.enableInspector();
            inspector.drawRadar = true;
            inspector.radarLod = parseInt(value);
            if (isNaN(inspector.radarLod)) {
                inspector.radarLod = null;
            } 
            break;

    }

    map.markDirty();
};

/* harmony default export */ __webpack_exports__["a"] = (InspectorInput);



/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__input__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__stats__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__graphs__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__layers__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__replay__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__stylesheets__ = __webpack_require__(125);











//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var utils = __WEBPACK_IMPORTED_MODULE_2__utils_utils__["a" /* utils */];
var InspectorInput = __WEBPACK_IMPORTED_MODULE_3__input__["a" /* default */];
var InspectorStats = __WEBPACK_IMPORTED_MODULE_4__stats__["a" /* default */];
var InspectorGraphs = __WEBPACK_IMPORTED_MODULE_5__graphs__["a" /* default */];
var InspectorLayers = __WEBPACK_IMPORTED_MODULE_6__layers__["a" /* default */];
var InspectorReplay = __WEBPACK_IMPORTED_MODULE_7__replay__["a" /* default */];
var InspectorStylesheets = __WEBPACK_IMPORTED_MODULE_8__stylesheets__["a" /* default */];


var Inspector = function(core) {
    this.core = core;
    this.enabled = false;
    this.input = new InspectorInput(this);
    this.stats = new InspectorStats(this);
    this.graphs = new InspectorGraphs(this);
    this.layers = new InspectorLayers(this);
    this.replay = new InspectorReplay(this);
    this.stylesheets = new InspectorStylesheets(this);

    if (this.core.config.inspector) {
        this.input.init();
    }

    this.shakeCamera = false; 
    this.drawReplayCamera = false; 
    this.drawRadar = false;
    this.radarLod = null;
    this.debugValue = 0;
    this.measureMode = false;
    this.measurePoints = [];
};


Inspector.prototype.enableInspector = function() {
    if (!this.enabled) {
        this.stats.init();
        this.graphs.init();
        this.layers.init();
        this.replay.init();
        this.stylesheets.init();

        //load image    
        if (!this.circleImage) {
            this.circleImage = utils.loadImage(
                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',
                    //"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png",
                    (function(){
                        this.circleTexture = this.core.getRendererInterface().createTexture({ 'source': this.circleImage });
                    }).bind(this)
                );
        }

        this.core.on('map-update', this.onMapUpdate.bind(this));
        this.enabled = true;
    }
};


Inspector.prototype.setParameter = function(key, value) {
    this.input.setParameter(key, value);
};

Inspector.prototype.addStyle = function(string) {
    var style = document.createElement('style');
    style.type = 'text/css';
    style.innerHTML = string;
    document.getElementsByTagName('head')[0].appendChild(style);
};


//used to block mouse events
Inspector.prototype.doNothing = function(e) {
    e.stopPropagation();
    return false;
};


Inspector.prototype.preventDefault = function(e) {
    if (e.preventDefault) {
        e.preventDefault();
    } else {
        e.returnValue = false;
    }
};


Inspector.prototype.onMapUpdate = function() {
    var map = this.core.getMapInterface();
    if (!map) {
        return;
    }

    if (this.shakeCamera) {
        map.redraw();
    } 

    /*if (this.measureMode) {
        var renderer = this.core.getRenderer();
        var p = map.convertCoordsFromPhysToNav(this.measurePoints[0]);
        map.convertCoordsFromPhysToCanvas(this.measurePoints[0]);
    }*/

    var renderer = this.core.getRendererInterface(), i, li, j, lj, lines, slines, p;

    if (this.replay.drawGlobe) {
        p = map.convertCoordsFromPhysToCameraSpace([0,0,0]);
        var renderer2 = this.core.getRenderer();
        renderer2.draw.drawTBall(p, 12742000 * 0.5, renderer2.progStardome, this.replay.globeTexture, 12742000 * 0.5, true);
    }

    if (this.replay.drawCamera) {
        lines = this.replay.cameraLines;
        slines = []; 
        //for (i = 0, li = lines.length; i < li; i++) {
          //  slines.push(map.convertCoordsFromPhysToCanvas(lines[i]));
        //}
        
        renderer.drawLineString({
            points : lines,
            size : 2.0,
            color : [0,128,255,255],
            depthTest : false,
            screenSpace : false,
            blend : false
        });            

        lines = this.replay.cameraLines3;
        for (i = 0, li = lines.length; i < li; i++) {
            slines = []; 
            for (j = 0, lj = lines[i].length; j < lj; j++) {
                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));
                slines.push(lines[i][j]);
            }

            renderer.drawLineString({
                points : slines,
                size : 2.0,
                color : [0,255,128,255],
                depthTest : false,
                screenSpace : false,
                blend : false
            });   
        }

        lines = this.replay.cameraLines2;
        for (i = 0, li = lines.length; i < li; i++) {
            slines = []; 
            for (j = 0, lj = lines[i].length; j < lj; j++) {
                //slines.push(map.convertCoordsFromPhysToCanvas(lines[i][j]));
                slines.push(lines[i][j]);
            }

            renderer.drawLineString({
                points : slines,
                size : 2.0,
                color : [0,255,255,255],
                depthTest : false,
                screenSpace : false,
                blend : false
            });   
        }


        var cameInfo = map.getCameraInfo();
        var p1 = map.convertCoordsFromPhysToCameraSpace(this.replay.cameraLines[0]);

        //var map2 = this.core.getMap();
    
        //var m2 = map2.camera.getRotationviewMatrix();
        var mv = mat4.create(this.replay.cameraMatrix);
        //mat4.inverse(m2, mv);
    
        //matrix which tranforms mesh position and scale
        /*
        var mv = [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            p1[0], p1[1], p1[2], 1
        ];*/
        mv[12] = p1[0];
        mv[13] = p1[1];
        mv[14] = p1[2];
    
        //setup material 
        var material = [ 
            255,128,128, 0, //ambient,
            0,0,0,0, //diffuse
            0,0,0,0, //specular 
            0,0.5,0,0 //shininess, alpha,0,0
        ];
    
        //multiply cube matrix with camera view matrix
        mat4.multiply(cameInfo.viewMatrix, mv, mv);
    
        var norm = [
            0,0,0,
            0,0,0,
            0,0,0
        ];
    
        //normal transformation matrix
        mat4.toInverseMat3(mv, norm);
    
        renderer.setState(this.replay.frustumState);
    
        //draw cube
        renderer.drawMesh({
            mesh : this.replay.frustumMesh,
            texture : null,
            shader : 'shaded',
            shaderVariables : {
                'uMV' : ['mat4', mv],
                'uNorm' : ['mat3', norm],
                'uMaterial' : ['mat4', material]
            }
        });
    }
    
    if (this.drawRadar && this.circleTexture) {
        //var renderer = this.core.getRendererInterface();
        var pos = map.getPosition();
        var count = 16;
        var step = pos.getViewExtent() / (count * 4);

        var cbuffer = new Array(count * count);

/*        
        var coords = pos.getCoords();

        for (var j = 0; j < count; j++) {
            for (var i = 0; i < count; i++) {
                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0] + i*step - count*0.5*step,
                                                                       coords[1] + j*step - count*0.5*step, 0], "float", this.radarLod);
        
                cbuffer[j * count + i] = screenCoords;
            }            
        }
*/


        for (j = 0; j < count; j++) {
            for (i = 0; i < count; i++) {
                var dx =  i*step - count*0.5*step;
                var dy =  j*step - count*0.5*step;
                var a = Math.atan2(dy, dx);
                var l = Math.sqrt(dx*dx + dy*dy);

                var pos2 = map.movePositionCoordsTo(pos, math.degrees(a), l);
                var coords = pos2.getCoords();
                
                var screenCoords = map.convertCoordsFromNavToCanvas([coords[0], coords[1], 0], 'float', this.radarLod);

                cbuffer[j * count + i] = screenCoords;
            }            
        }


        var lbuffer = new Array(count);

        for (j = 0; j < count; j++) {
            for (i = 0; i < count; i++) {
                lbuffer[i] =  cbuffer[j * count + i];
            }
            
            renderer.drawLineString({
                points : lbuffer,
                size : 2.0,
                screenSpace : true,
                color : [0,255,255,255],
                depthTest : false,
                blend : false
            });            
        }


        for (i = 0; i < count; i++) {
            for (j = 0; j < count; j++) {
                lbuffer[j] =  cbuffer[j * count + i];
            }
            
            renderer.drawLineString({
                points : lbuffer,
                size : 2.0,
                screenSpace : true,
                color : [0,255,255,255],
                depthTest : false,
                blend : false
            });            
        }

        for (i = 0, li = cbuffer.length; i < li; i++) {
            p = cbuffer[i];
            renderer.drawImage({
                rect : [p[0]-10, p[1]-10, 20, 20],
                texture : this.circleTexture,
                color : [255,0,255,255],
                depth : p[2],
                depthTest : false,
                blend : true
            });
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (Inspector);


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var InspectorLayers = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorLayers.prototype.init = function() {
    var inspector = this.inspector;
    inspector.addStyle(
        '#vts-layers-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'bottom: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-layers-panel button {'
            + 'max-width: 23px;'
            + 'max-height: 21px;'
        + '}'

        + '#vts-layers-panel-title {'
            + 'margin-bottom: 3px;'
        + '}'

        + '#vts-layers-views-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-views-items {'
            + 'width: 191px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
        + '}'
        
        + '#vts-layers-surfaces-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'        
        
        + '#vts-layers-surfaces-items {'
            + 'width: 150px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border-top: 1px solid #ddd;'
            + 'border-bottom: 1px solid #ddd;'
        + '}'
         
        + '#vts-layers-boundlayers-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-boundlayers-items {'
            + 'width: 275px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
            + 'border-right: none;'
        + '}'

        + '#vts-layers-freelayers-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-freelayers-items {'
            + 'width: 150px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
        + '}'

        + '#vts-layers-fl-properties-panel {'
            + 'margin-top: 5px;'
            + 'float: left;'
        + '}'

        + '#vts-layers-fl-properties-items {'
            + 'width: 250px;'
            + 'overflow-y: scroll;'
            + 'overflow-x: hidden;'
            + 'height: 200px;'
            + 'border: 1px solid #ddd;'
            + 'border-right: none;'
        + '}'

        + '#vts-layers-json-panel {'
            + 'margin-top: 5px;'
            + 'float: right;'
        + '}'

        + '#vts-layers-json-text {'
            + 'width: 200px;'
            + 'resize: none;'
            + 'height: 180px;'
            + 'border: 1px solid #ddd;'
            + 'white-space: pre;'
            + 'padding: 0px;'
        + '}'

        + '#vts-layers-json-text2 {'
            + 'width: 200px;'
            + 'height: 21px;'
            + 'border: 1px solid #ddd;'
        + '}'
        
        + '.vts-layers-panel-title {'
            + 'margin: 0px;'
            + 'margin-bottom: 5px;'
        + '}'

        + '.vts-layers-item {'
            + 'width: 100%;'
        + '}'        
        
        + '.vts-layers-item input[type=number]{'
            + 'width: 43px;'
        + '}'
        
        + '.vts-layers-name {'
            + 'width: 120px;'
            + 'display: inline-block;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'       
        + '}'          

        + '.vts-layers-name2 {'
            + 'width: 126px;'
            + 'display: inline-block;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'       
        + '}'
         
        + '#vts-layers-fl-properties-style {'
            + 'width: 175px;'
            + 'height: 21px;'
        + '}'

        + '.vts-surface-item {'
            + 'width: 100%;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'    
        + '}' 
        
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-layers-panel';
    this.element.innerHTML = ''
        + '<div id="vts-layers-views-panel"><p class="vts-layers-panel-title">Named Views:</p>'
           + '<div id="vts-layers-views-items"></div></div>'
        + '<div id="vts-layers-surfaces-panel"><p class="vts-layers-panel-title">Surfaces:</p>'
           + '<div id="vts-layers-surfaces-items"></div></div>'
        + '<div id="vts-layers-boundlayers-panel"><p class="vts-layers-panel-title">Surface Bound Layers:</p>'
           + '<div id="vts-layers-boundlayers-items"></div></div>'
        + '<div id="vts-layers-freelayers-panel"><p class="vts-layers-panel-title">Free Layers:</p>'
           + '<div id="vts-layers-freelayers-items"></div></div>'
        + '<div id="vts-layers-fl-properties-panel"><p class="vts-layers-panel-title">Free Layer Properties:</p>'
           + '<div id="vts-layers-fl-properties-items"></div></div>'
        + '<div id="vts-layers-json-panel"><p class="vts-layers-panel-title">Definition:</p>'
           + '<textarea id="vts-layers-json-text" cols="48"></textarea><br/>'
           + '<input id="vts-layers-json-text2" type="text"></div>';

    this.core.element.appendChild(this.element);
    this.viewItems = document.getElementById('vts-layers-views-items');
    this.surfacesItems = document.getElementById('vts-layers-surfaces-items');
    this.boundLayersItems = document.getElementById('vts-layers-boundlayers-items');
    this.freeLayersItems = document.getElementById('vts-layers-freelayers-items');
    this.freeLayersPropertiesItems = document.getElementById('vts-layers-fl-properties-items');
    this.jsonText = document.getElementById('vts-layers-json-text');
    this.jsonText2 = document.getElementById('vts-layers-json-text2');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.views = [];
    
    this.panelVisible = false;
    this.panelInitialized = false;
    this.currentView = '';
    this.currentSurface = '';
    this.currentFreeLayer = '';
};


InspectorLayers.prototype.initViews = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var views = map.getNamedViews(), freeLayer;
    var id = '--initial--';
    var i, li, j, lj, layers, states, index, view, surfaces, skey;


    this.views[id] = {
        surfaces : {},
        freeLayers : {},
        options : {},
        original : JSON.parse(JSON.stringify(map.getView()))
    };

    for (i = 0, li = views.length; i < li; i++) {
        view = views[i];
        this.views[view] = {
            surfaces : {},
            freeLayers : {},
            options : {},
            original : JSON.parse(JSON.stringify(map.getNamedView(view).getInfo()))
        };
    }
    
    this.currentView = id;
    views = this.views;
    
    for (var key in views) {
        view = views[key];
        surfaces = map.getSurfaces();   
        
        for (i = 0, li = surfaces.length; i < li; i++) {
            id = surfaces[i];
            surface = map.getSurface(id);
            layers = map.getBoundLayers();
            states = []; 
    
            for (j = 0, lj = layers.length; j < lj; j++) {
                //layer = map.getBoundLayerById(layers[j]);
                
                states.push({
                    id : layers[j],
                    alpha : 100,
                    options : "{}",
                    enabled : false
                });
            }
            
            view.surfaces[id] = {
                enabled : false,
                layers : states 
            };
        }         

        var freeLayers = map.getFreeLayers();   
        
        for (i = 0, li = freeLayers.length; i < li; i++) {
            id = freeLayers[i];
            layers = map.getBoundLayers();
            states = []; 
    
            for (j = 0, lj = layers.length; j < lj; j++) {
                //layer = map.getBoundLayerById(layers[j]);
                
                states.push({
                    id : layers[j],
                    alpha : 100,
                    options : "{}",
                    enabled : false
                });
            }
            
            freeLayer = map.getFreeLayer(id);
            var freeLayerInfo = freeLayer.getInfo(); 
            
            view.freeLayers[id] = {
                enabled : false,
                style : null,
                originalStyle : freeLayerInfo['style'],
                depthShift : 0,
                depthShift2 : 0,
                depthShift3 : 0,
                layers : states 
            };
        }
        
        var viewSurfaces = view.original['surfaces'];
        
        for (skey in viewSurfaces) {
            layers = viewSurfaces[skey];
            
            if (view.surfaces[skey]) {
                var surface = view.surfaces[skey]; 
                surface.enabled = true;

                for (i = 0, li = layers.length; i < li; i++) {
                    if (typeof layers[i] === 'string') {
                        index = this.findIdInArray(surface.layers, layers[i]);
                        if (index != -1 && surface.layers[index]) {
                            surface.layers[index].enabled = true;
                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }    
                    } else {
                        id = layers[i]['id'];
                        index = this.findIdInArray(surface.layers, id);
                        if (index != -1 && surface.layers[index]) {
                            surface.layers[index].enabled = true;
                            surface.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;
                            surface.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : "{}";
                            surface.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }    
                    }
                }
            }
        }

        var viewfreeLayers = view.original['freeLayers'];
        
        for (skey in viewfreeLayers) {
            var freeLayerProperties = viewfreeLayers[skey];
            
            if (view.freeLayers[skey]) {
                freeLayer = view.freeLayers[skey]; 
                freeLayer.enabled = true;
                var depthShift = freeLayerProperties['depthOffset'] || [0,0,0];
                freeLayer.depthShift = depthShift[0];
                freeLayer.depthShift2 = depthShift[1];
                freeLayer.depthShift3 = depthShift[2];
                freeLayer.style = freeLayerProperties['style'];
                //freeLayer.originalStyle = freeLayer.style;
                
                layers = freeLayerProperties['boundLayers'] || [];
                //freeLayer.layers = layers;
                
                for (i = 0, li = layers.length; i < li; i++) {
                    if (typeof layers[i] === 'string') {
                        index = this.findIdInArray(freeLayer.layers, layers[i]);
                        if (index != -1 && freeLayer.layers[index]) {
                            freeLayer.layers[index].enabled = true;
                            freeLayer.layers.splice(i, 0, freeLayer.layers.splice(index, 1)[0]);
                        }    
                    } else {
                        id = layers[i]['id'];
                        index = this.findIdInArray(freeLayer.layers, id);
                        if (index != -1 && surface.layers[index]) {
                            freeLayer.layers[index].enabled = true;
                            freeLayer.layers[index].alpha = layers[i]['alpha'] ? (parseFloat(layers[i]['alpha'])*100) : 100;
                            freeLayer.layers[index].options = layers[i]['options'] ? JSON.stringify(layers[i]['options']) : "{}";
                            freeLayer.layers.splice(i, 0, surface.layers.splice(index, 1)[0]);
                        }    
                    }
                }
            }
        }        
    }
};


InspectorLayers.prototype.findIdInArray = function(array, id) {
    for (var i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return i;
        } 
    }
    
    return -1;
};


InspectorLayers.prototype.buildViews = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var views = this.views;
    var html = '';

    for (var key in views) {
        html += '<div class="vts-views-item" id="vts-views-item-' + key + '">'
                 + '<div class="vts-layers-name2">' + key + '</div>'
                 + '<button id="vts-views-cbutton-' + key + '" type="button" title="Clone">C</button>' 
                 + '<button id="vts-views-xbutton-' + key + '" type="button" title="Remove">X</button>' 
                 + '</div>';
    }

    this.viewItems.innerHTML = html;

    for (key in views) {
        htmlId = 'vts-views-cbutton-' + key;
        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'clone');
        htmlId = 'vts-views-xbutton-' + key;
        document.getElementById(htmlId).onclick = this.switchView.bind(this, key, htmlId, 'remove');
        var htmlId = 'vts-views-item-' + key;
        document.getElementById(htmlId).onclick = this.selectView.bind(this, key);
    }
};


InspectorLayers.prototype.buildSurfaces = function() {
    var view = this.views[this.currentView];
    var surfaces = view.surfaces;
    var html = '', htmlId;
    var firstKey = null, key;
    
    for (key in surfaces) {
        html += '<div id="vts-surface-item-' + key + '" class="vts-surface-item"><input id="vts-surface-checkbox-'
                 + key + '" type="checkbox"/><span title=' + key + '>' + key + '</span></div>';
                 
        if (firstKey === null) {
            firstKey = key;
        }
    }

    this.surfacesItems.innerHTML = html;
    this.currentSurface = firstKey;

    for (key in surfaces) {
        if (surfaces[key].enabled) {
            htmlId = 'vts-surface-checkbox-' + key;
            document.getElementById(htmlId).checked = true;
        }
    }

    for (key in surfaces) {
        htmlId = 'vts-surface-checkbox-' + key;
        document.getElementById(htmlId).onchange = this.switchSurface.bind(this, key, htmlId);
        htmlId = 'vts-surface-item-' + key;
        document.getElementById(htmlId).onclick = this.selectSurface.bind(this, key);
    }
};


InspectorLayers.prototype.buildBoundLayers = function(id) {
    var view = this.views[this.currentView];
    var html = '';

    if (view.surfaces[id]) {
        var layers = view.surfaces[id].layers;

        for (var i = 0, li = layers.length; i < li; i++) {
            var layer = layers[i];

            html += '<div class="vts-layers-item"><input id="vts-boundlayer-checkbox-' + layer.id + '" type="checkbox" ' + (layer.enabled ? 'checked' : '')   + '/>'
                     + '<div class="vts-layers-name">' + layer.id + '</div>'
                     + '<input id="vts-boundlayer-spinner-' + layer.id + '" type="number" title="Alpha" min="0" max="100" step="10" value="' + layer.alpha + '">'
                     + '<button id="vts-boundlayer-obutton-' + layer.id + '" type="button" title="Options">O</button>' 
                     + '<button id="vts-boundlayer-ubutton-' + layer.id + '" type="button" title="Move Above">&uarr;</button>' 
                     + '<button id="vts-boundlayer-dbutton-' + layer.id + '" type="button" title="Move Bellow">&darr;</button>' 
                     + '</div>';
        }
    }

    this.boundLayersItems.innerHTML = html;

    if (view.surfaces[id]) {
        for (i = 0, li = layers.length; i < li; i++) {
            var htmlId = 'vts-boundlayer-checkbox-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'enable');
            htmlId = 'vts-boundlayer-spinner-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');
            htmlId = 'vts-boundlayer-obutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'options');
            htmlId = 'vts-boundlayer-ubutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'up');
            htmlId = 'vts-boundlayer-dbutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchBoundLayer.bind(this, layers[i].id, htmlId, 'down');
        }
    }
};


InspectorLayers.prototype.buildFreeLayers = function() {
    var view = this.views[this.currentView];
    var layers = view.freeLayers;
    var html = '';

    for (var key in layers) {
        //var layer = layers[key];
        html += '<div class="vts-surface-item" id="vts-freelayer-item-' + key
                  + '"><input id="vts-freelayer-checkbox-' + key + '" type="checkbox" '
                  + (layers[key].enabled ? 'checked' : '') + '/><span title=' + key + '>' + key + '</span></div>';
    }

    this.freeLayersItems.innerHTML = html;

    for (key in layers) {
        var htmlId = 'vts-freelayer-checkbox-' + key;
        document.getElementById(htmlId).onchange = this.switchFreeLayer.bind(this, key, htmlId);
        htmlId = 'vts-freelayer-item-' + key;
        document.getElementById(htmlId).onclick = this.selectFreeLayer.bind(this, key);
    }
};


InspectorLayers.prototype.buildFreeLayerProperties = function(id) {
    var map = this.core.getMap();
    var view = this.views[this.currentView];
    var layers = view.freeLayers[id].layers;
    var html = '', i, li, htmlId;
    
    if (!map || !map.getFreeLayer(id)) {
        return;
    }

    var layerInfo = map.getFreeLayer(id).getInfo();
    var layerType = layerInfo['type']; 

    switch(layerType) {
    case 'mesh':
    case 'mesh-tiles':

        html += '<div class="vts-layers-item"><div class="vts-layers-name" style="width:90px">' + 'DepthOffset:' + '</div>'
                     + '<input id="vts-fl-properties-depth-shift" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift + '">'
                     + '<input id="vts-fl-properties-depth-shift2" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift2 + '">'
                     + '<input id="vts-fl-properties-depth-shift3" type="number" min="-100" max="100" step="1" value="' + view.freeLayers[id].depthShift3 + '">'
                     + '</div>';
    
        html += '<div class="vts-layers-item"><div class="vts-layers-name">' + 'BoundLayers:' + '</div></div>';
        
        for (i = 0, li = layers.length; i < li; i++) {
            var layer = layers[i];
        
            html += '<div class="vts-layers-item"><input id="vts-fl-properties-checkbox-' + layer.id + '" type="checkbox" ' + (layer.enabled ? 'checked' : '')   + '/>'
                         + '<div class="vts-layers-name">' + layer.id + '</div>'
                         + '<input id="vts-fl-properties-spinner-' + layer.id + '" type="number" title="Alpha" min="0" max="100" step="10" value="' + layer.alpha + '">'
                         + '<button id="vts-fl-properties-ubutton-' + layer.id + '" type="button" title="Move Above">&uarr;</button>' 
                         + '<button id="vts-fl-properties-dbutton-' + layer.id + '" type="button" title="Move Bellow">&darr;</button>' 
                         + '</div>';
        }
        
        this.freeLayersPropertiesItems.innerHTML = html;
    
        htmlId = 'vts-fl-properties-depth-shift';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift');
        htmlId = 'vts-fl-properties-depth-shift2';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift2');
        htmlId = 'vts-fl-properties-depth-shift3';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'depthShift3');
        
        for (i = 0, li = layers.length; i < li; i++) {
            htmlId = 'vts-fl-properties-checkbox-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'enable');
            htmlId = 'vts-fl-properties-spinner-' + layers[i].id;
            document.getElementById(htmlId).onchange = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'alpha');
            htmlId = 'vts-fl-properties-ubutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'up');
            htmlId = 'vts-fl-properties-dbutton-' + layers[i].id;
            document.getElementById(htmlId).onclick = this.switchFreeLayerBoundLayer.bind(this, layers[i].id, htmlId, 'down');
        }
            
        break;

    case 'geodata':
    case 'geodata-tiles':

        html += '<div class="vts-layers-item"><div class="vts-layers-name" style="width:50px">' + 'Style:' + '</div>'
                    + '<select id="vts-layers-fl-properties-style">';
                    
        var styles = map.getStylesheets();
        var index = styles.indexOf(view.freeLayers[id].style || view.freeLayers[id].originalStyle); // || layerInfo["style"]); 
            
        for (i = 0, li = styles.length; i < li; i++) {
            html += '<option value="' + styles[i] + '" ' + ((i == index) ? 'selected' : '') + '>' + styles[i] + '</option>';
        }
                    
        html += '</select>' + '</div>';

        this.freeLayersPropertiesItems.innerHTML = html;

        htmlId = 'vts-layers-fl-properties-style';
        document.getElementById(htmlId).onchange = this.switchFreeLayerProperty.bind(this, htmlId, 'style');
       
        break;
    }
};


InspectorLayers.prototype.selectView = function(id) {
    if (!this.views[id]) {
        return;
    }

    var element;

    //deselect previous
    if (this.currentView) {
        element = document.getElementById('vts-views-item-' + this.currentView);
        if (element) {
            element.style.backgroundColor = 'initial';
        }
    }

    //select new one
    element = document.getElementById('vts-views-item-' + id);
    element.style.backgroundColor = '#ddd';
    this.currentView = id;
    //this.buildBoundLayers(this.currentSurface);

    this.buildSurfaces();
    this.selectSurface(this.currentSurface);
    this.buildFreeLayers();
    this.applyMapView();
};


InspectorLayers.prototype.switchView = function(id, htmlId, action) {
    //var element = document.getElementById(htmlId);
    var views = this.views;
    
    for (var key in this.views) {
        if (key == id) {
            switch(action) {
            case 'clone':
                    //layers[i].enabled = element.checked;
                var i = 2;
                    
                // eslint-disable-next-line
                while(true) {
                    if (!views[id + ' #' + i]) {
                        views[id + ' #' + i] = JSON.parse(JSON.stringify(views[id]));
                        break;
                    } 
                    i++;
                }
                
                this.buildViews();
                    
                break;
            case 'remove':
                
                var count = 0;
                
                for (key in views) {
                    count++;
                }
                
                if (count > 1) {
                    delete views[id];
                    this.buildViews();

                    if (this.currentView == id) {
                        for (key in views) {
                            this.selectView(key);
                            break;
                        }
                    } else {
                        this.selectView(this.currentView);
                    }
                }
                    
                break;
            }
            
            break;
        }
    }
};


InspectorLayers.prototype.switchSurface = function(id, htmlId) {
    var element = document.getElementById(htmlId);
    var view = this.views[this.currentView];
    view.surfaces[id].enabled = element.checked;
    this.applyMapView();
};


InspectorLayers.prototype.selectSurface = function(id) {
    var element;
    //deselect previous
    if (this.currentSurface) {
        element = document.getElementById('vts-surface-item-' + this.currentSurface);
        element.style.backgroundColor = 'initial';
    }

    //select new one
    element = document.getElementById('vts-surface-item-' + id);
    if (element) {
        element.style.backgroundColor = '#ddd';
    }
    this.currentSurface = id;
    this.buildBoundLayers(this.currentSurface);
};


InspectorLayers.prototype.switchBoundLayer = function(id, htmlId, action) {
    var element = document.getElementById(htmlId);
    var view = this.views[this.currentView];
    var layers = view.surfaces[this.currentSurface].layers;
    
    for (var i = 0, li = layers.length; i < li; i++) {
        if (layers[i].id == id) {
            switch(action) {
            case 'enable':
                layers[i].enabled = element.checked;
                break;
            case 'alpha':
                layers[i].alpha = parseInt(element.value, 10);
                break;
            case 'options':
                //display popup               
                break;
            case 'up':
                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);
                this.selectSurface(this.currentSurface);
                break;
            case 'down':
                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);
                this.selectSurface(this.currentSurface);
                break;
            }
            
            break;
        }
    }
    
    this.applyMapView();
};


InspectorLayers.prototype.switchFreeLayer = function(id, htmlId) {
    var element = document.getElementById(htmlId);
    var view = this.views[this.currentView];
    view.freeLayers[id].enabled = element.checked;
    this.applyMapView();
};


InspectorLayers.prototype.selectFreeLayer = function(id) {
    var element;
    //deselect previous
    if (this.currentFreeLayer) {
        element = document.getElementById('vts-freelayer-item-' + this.currentFreeLayer);
        element.style.backgroundColor = 'initial';
    }

    //select new one
    element = document.getElementById('vts-freelayer-item-' + id);
    element.style.backgroundColor = '#ddd';
    this.currentFreeLayer = id;
    this.buildFreeLayerProperties(this.currentFreeLayer);
};


InspectorLayers.prototype.switchFreeLayerBoundLayer = function(id, htmlId, action) {
    var element = document.getElementById(htmlId);
    var view = this.views[this.currentView];
    var layers = view.freeLayers[this.currentFreeLayer].layers;
    
    for (var i = 0, li = layers.length; i < li; i++) {
        if (layers[i].id == id) {
            switch(action) {
            case 'enable':
                layers[i].enabled = element.checked;
                break;
            case 'alpha':
                layers[i].alpha = parseInt(element.value, 10);
                break;
            case 'up':
                layers.splice(Math.max(0,i-1), 0, layers.splice(i, 1)[0]);
                this.selectFreeLayer(this.currentFreeLayer);
                break;
            case 'down':
                layers.splice(Math.max(0,i+1), 0, layers.splice(i, 1)[0]);
                this.selectFreeLayer(this.currentFreeLayer);
                break;
            }
            
            break;
        }
    }
    
    this.applyMapView();
};


InspectorLayers.prototype.switchFreeLayerProperty = function(htmlId, action) {
    var element = document.getElementById(htmlId);
    var view = this.views[this.currentView];
    var layer = view.freeLayers[this.currentFreeLayer];

    switch(action) {
    case 'depthShift':  layer.depthShift = parseInt(element.value, 10); break;
    case 'depthShift2': layer.depthShift2 = parseInt(element.value, 10); break;
    case 'depthShift3': layer.depthShift3 = parseInt(element.value, 10); break;
    case 'style':       layer.style = element.value; break;
    }
    
    this.applyMapView();
};


InspectorLayers.prototype.applyMapView = function(jsonOnly) {
    var view = {
        'surfaces' : {},
        'freeLayers' : {},
        'options' : {}
    };

    var sourceView = this.views[this.currentView];
    var surfaces = sourceView.surfaces, i, li, layers;

    view['options'] = JSON.parse(JSON.stringify(sourceView.options));
    
    for (var key in surfaces) {
        if (surfaces[key].enabled) {
            var surfaceBoundLayers = [];
            layers = surfaces[key].layers; //bound layers
            
            for (i = 0, li = layers.length; i < li; i++) {
                if (layers[i].enabled) {

                    var options = JSON.parse(JSON.stringify(layers[i].options));
                    var options2 = JSON.stringify(options);

                    if (layers[i].alpha < 100) {
                        var item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};
                        if (options2 != '{}') {
                            item.options = options;
                        }
                        surfaceBoundLayers.push(item);
                    } else {
                        surfaceBoundLayers.push(layers[i].id);
                    }
                }
            }
            
            view['surfaces'][key] = surfaceBoundLayers;
        }
    }

    var freeLayers = sourceView.freeLayers;
    
    for (key in freeLayers) {
        if (freeLayers[key].enabled) {
            var freeLayerBoundLayers = [];
            layers = freeLayers[key].layers; //bound layers
            
            for (i = 0, li = layers.length; i < li; i++) {
                if (layers[i].enabled) {
                    
                    if (layers[i].alpha < 100) {
                        var item = {'id':layers[i].id, 'alpha':(layers[i].alpha*0.01).toFixed(2)};
                        if (options2 != '{}') {
                            item.options = options;
                        }
                        freeLayerBoundLayers.push(item);
                    } else {
                        freeLayerBoundLayers.push(layers[i].id);
                    }
                }
            }
            
            view['freeLayers'][key] = {};
            
            if (freeLayerBoundLayers.length > 0) {
                view['freeLayers'][key]['boundLayers'] = freeLayerBoundLayers;
            }

            if (freeLayers[key].style && freeLayers[key].style != freeLayers[key].originalStyle) {
                view['freeLayers'][key]['style'] = freeLayers[key].style;
            }
            
            if (!(freeLayers[key].depthShift == 0 && freeLayers[key].depthShift2 == 0 && freeLayers[key].depthShift3 == 0)) {
                view['freeLayers'][key]['depthOffset'] = [
                    parseFloat((freeLayers[key].depthShift).toFixed(2)),
                    parseFloat((freeLayers[key].depthShift2).toFixed(2)),
                    parseFloat((freeLayers[key].depthShift3).toFixed(2)) ];
            } 
            
        }
    }

    this.jsonText.value = JSON.stringify(view, null, '  ');
    this.jsonText2.value = encodeURIComponent(JSON.stringify(view));

    if (!jsonOnly) {
        var map = this.core.getMap();
        if (!map) {
            return;
        }
        
        map.setView(view, null, true);
    }
};


InspectorLayers.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
    this.updatePanel();
};


InspectorLayers.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorLayers.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorLayers.prototype.updatePanel = function() {
    if (!this.panelInitialized) {
        this.panelInitialized = false;
        this.initViews();
        this.buildViews();
        this.selectView(this.currentView);
        /*
        this.buildSurfaces();
        this.selectSurface(this.currentSurface);
        this.buildFreeLayers();
        this.applyMapView(true);
        */
    }
};


/* harmony default export */ __webpack_exports__["a"] = (InspectorLayers);


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderer_gpu_texture__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_matrix__ = __webpack_require__(1);





//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_0__renderer_gpu_texture__["a" /* default */];
var vec3 = __WEBPACK_IMPORTED_MODULE_2__utils_matrix__["b" /* vec3 */], mat4 = __WEBPACK_IMPORTED_MODULE_2__utils_matrix__["e" /* mat4 */];


var InspectorReplay = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorReplay.prototype.init = function() {
    var inspector = this.inspector;
    inspector.addStyle(
        '#vts-replay-panel {'
            + 'font-family: Arial, \'Helvetica Neue\', Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 618px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'top: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-replay-panel-left {'
            + 'width: 253px;'
            + 'height: 100%;'
            + 'float: left;'
        + '}'

        + '#vts-replay-panel-right {'
            + 'width: 340px;'
            + 'height: 100%;'
            + 'float: right;'
        + '}'

        + '#vts-replay-items {'
            + 'width: 240px;'
            + 'overflow-x: hidden;'
            + 'border: 1px solid #ddd;'
            + 'padding-right: 5px;'
        + '}'

        + '.vts-replay-item {'
            + 'width: 100%;'
            + 'overflow: hidden;'
            + 'text-overflow: ellipsis;'
            + 'white-space: nowrap;'    
        + '}' 

        + '#vts-replay-lod-slider {'
            + 'width: 240px;'
        + '}'

        + '#vts-replay-lod-text {'
            + 'width: 60px;'
            + 'margin-left: 10px;'
            + 'margin-right: 10px;'
        + '}'

        + '#vts-replay-lod-single {'
            + 'margin-left: 10px;'
        + '}'
    
        + '#vts-replay-time-slider {'
            + 'width: 330px;'
        + '}'

        + '#vts-replay-time-text {'
            + 'width: 60px;'
            + 'margin-left: 10px;'
            + 'margin-right: 10px;'
        + '}'

        + '#vts-replay-time-single {'
            + 'margin-left: 10px;'
        + '}'

        + '#vts-replay-panel-gtime canvas{'
            + 'border: 1px solid #555;'
        + '}'

        + '#vts-replay-panel-gtime span{'
            + 'font-size: 10px;'
        + '}'

        + '#vts-replay-info {'
            + 'width: 240px;'
            + 'height: 140px;'
            + 'overflow-x: hidden;'
            + 'border: 1px solid #ddd;'
            + 'padding-right: 5px;'
            + 'margin-top: 10px;'            
            + 'font-size: 12px;'
            + 'word-wrap: break-word;'   
        + '}'
       
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-replay-panel';
    this.element.innerHTML =
            '<div id="vts-replay-panel-left">'
            + '<div id="vts-replay-items"></div>'
            + '<div id="vts-replay-panel-lod">'  
                + '<input id="vts-replay-lod-slider" type="range" min="0" max="30" step="1" value="30" /><br/>'
                + '<span>LOD:</span>'
                + '<input id="vts-replay-lod-text" type="text" value="30"/>'
                + '<input id="vts-replay-lod-up" type="button" value="<"/>'
                + '<input id="vts-replay-lod-down" type="button" value=">"/>'
                + '<input id="vts-replay-lod-single" type="checkbox"/>'
                + '<span>Single</span>'
            + '</div>'
            + '<div id="vts-replay-info"></div>'
          + '</div>'
          + '<div id="vts-replay-panel-right">'
            + '<div id="vts-replay-panel-gtime">'  
                + '<span id="vts-replay-info-meshes">Meshes Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-meshes" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-textures">Internal Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-textures" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-textures2">External Textures Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-textures2" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-geodata">Geodata Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-geodata" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-metatiles">Metatiles Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-metatiles" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-intervals">Interval Count: 0 Min/Max: 0/0 Avg. 0</span><br/>'
                + '<canvas id="vts-replay-canvas-intervals" width=340 height=30></canvas><br/>'  
                + '<span id="vts-replay-info-threads">Threads Min/Max: 0/0 Avg. 0 </span><br/>'
                + '<canvas id="vts-replay-canvas-threads" width=340 height=30></canvas><br/>'  
            + '</div>'

            + '<div id="vts-replay-panel-time">'  
                + '<input id="vts-replay-time-slider" type="range" min="0" max="2000" value="0" /><br/>'
                + '<span>File:</span>'
                + '<input id="vts-replay-time-text" type="text" value="0"/>'
                + '<input id="vts-replay-time-up" type="button" value="<"/>'
                + '<input id="vts-replay-time-down" type="button" value=">"/>'
                + '<input id="vts-replay-time-single" type="checkbox"/>'
                + '<span>Single</span>'
            + '</div>'
          + '</div>';

    this.core.element.appendChild(this.element);

    this.items = document.getElementById('vts-replay-items');

    this.lodSlider = document.getElementById('vts-replay-lod-slider');
    this.lodSlider.onchange = this.onSliderChange.bind(this, 'lod');
    this.lodSlider.oninput = this.onSliderChange.bind(this, 'lod');

    this.lodText = document.getElementById('vts-replay-lod-text');
    this.lodText.onchange = this.onTextChange.bind(this, 'lod');
    
    document.getElementById('vts-replay-lod-up').onclick = this.onSliderChange.bind(this, 'lod', 'down');
    document.getElementById('vts-replay-lod-down').onclick = this.onSliderChange.bind(this, 'lod', 'up');
    document.getElementById('vts-replay-lod-single').onclick = this.onSliderChange.bind(this, 'lod', 'single');
    
    this.timeSlider = document.getElementById('vts-replay-time-slider');
    this.timeSlider.onchange = this.onSliderChange.bind(this, 'time');
    this.timeSlider.oninput = this.onSliderChange.bind(this, 'time');

    this.timeText = document.getElementById('vts-replay-time-text');
    this.timeText.onchange = this.onTextChange.bind(this, 'time');

    this.timeInfo = document.getElementById('vts-replay-info');

    document.getElementById('vts-replay-time-up').onclick = this.onSliderChange.bind(this, 'time', 'down');
    document.getElementById('vts-replay-time-down').onclick = this.onSliderChange.bind(this, 'time', 'up');
    document.getElementById('vts-replay-time-single').onclick = this.onSliderChange.bind(this, 'time', 'single');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.infoMeshes = document.getElementById('vts-replay-info-meshes');
    this.ctxMeshes = document.getElementById('vts-replay-canvas-meshes').getContext('2d');  
    this.infoTextures = document.getElementById('vts-replay-info-textures');
    this.ctxTextures = document.getElementById('vts-replay-canvas-textures').getContext('2d');  
    this.infoTextures2 = document.getElementById('vts-replay-info-textures2');
    this.ctxTextures2 = document.getElementById('vts-replay-canvas-textures2').getContext('2d');  
    this.infoGeodata = document.getElementById('vts-replay-info-geodata');
    this.ctxGeodata = document.getElementById('vts-replay-canvas-geodata').getContext('2d');  
    this.infoMetatiles = document.getElementById('vts-replay-info-metatiles');
    this.ctxMetatiles = document.getElementById('vts-replay-canvas-metatiles').getContext('2d');  
    this.infoIntervals = document.getElementById('vts-replay-info-intervals');
    this.ctxIntervals = document.getElementById('vts-replay-canvas-intervals').getContext('2d');  
    this.infoThreads = document.getElementById('vts-replay-info-threads');
    this.ctxThreads = document.getElementById('vts-replay-canvas-threads').getContext('2d');  

    this.cameraLines = [];
    this.cameraLines2 = [];
    this.cameraLines3 = [];
    this.cameraGenarated = false;

    this.panelVisible = false;
};


InspectorReplay.prototype.showPanel = function() {
    this.buildReplayCombo();
    this.element.style.display = 'block';
    this.panelVisible = true;

    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;
    this.updateFileInfo(replay.loadedIndex);
    this.updateLoadGraphs();
};


InspectorReplay.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorReplay.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorReplay.prototype.onSliderChange = function(type, button) {
    if (type == 'lod') {
        switch (button) {
        case 'up':
            this.lodSlider.stepUp();
            this.lodText.value = this.lodSlider.value;    
            break;
            
        case 'down':
            this.lodSlider.stepDown();
            this.lodText.value = this.lodSlider.value;    
            break;

        default:
            this.lodText.value = this.lodSlider.value;    
        } 
    } else {
        switch (button) {
        case 'up':
            this.timeSlider.stepUp();
            this.timeText.value = this.timeSlider.value;    
            break;
            
        case 'down':
            this.timeSlider.stepDown();
            this.timeText.value = this.timeSlider.value;    
            break;

        default:
            this.timeText.value = this.timeSlider.value;    
        } 
    }

    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;

    if (type == 'lod') {
        replay.lod = parseFloat(this.lodText.value);
        replay.singleLod = document.getElementById('vts-replay-lod-single').checked;
    } else {
        replay.loadedIndex = parseFloat(this.timeText.value);
        replay.singleLodedIndex = document.getElementById('vts-replay-time-single').checked;
        this.updateFileInfo(replay.loadedIndex);
        this.updateLoadGraphs();
    }

    map.markDirty();
};


InspectorReplay.prototype.onTextChange = function(type) {
    if (type == 'lod') {
        this.lodSlider.value = this.lodText.value;    
    } else {
        this.timeSlider.value = this.timeText.value;    
    }

    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;

    if (type == 'lod') {
        replay.lod = parseFloat(this.lodText.value);
    } else {
        replay.loadedIndex = parseFloat(this.timeText.value);
        this.updateFileInfo(replay.loadedIndex);
        this.updateLoadGraphs();
    }

    map.markDirty();
};


InspectorReplay.prototype.generateCameraLines = function(camera) {
    var renderer = this.core.getRendererInterface();
    var p1 = camera.position;
    var p2 = camera.center;

    this.cameraLines = [p1, p2];
/*        
    var screenSize = renderer.getCanvasSize();
    
    var v1 = map.getScreenRay(0+1,0+1);
    var v2 = map.getScreenRay(screenSize[0]-1,0+1);
    var v3 = map.getScreenRay(screenSize[0]-1,screenSize[1]-1);
    var v4 = map.getScreenRay(0+1,screenSize[1]-1);
    var v5 = map.getScreenRay(screenSize[0]*0.5,screenSize[1]*0.5);
    
    var l = camera.distance;
    
    //l = map.getPositionViewExtent(pos);    
    
    vec3.scale(v1, l*10);
    //vec3.scale(v2, l);
    //vec3.scale(v3, l);
    //vec3.scale(v4, l);
    //vec3.scale(v5, l);
    
    vec3.add(v1, p1);
    //vec3.add(v2, p1);
    //vec3.add(v3, p1);
    //vec3.add(v4, p1);
    //vec3.add(v5, p1);

    this.cameraLines3 = [p1, v1]; //, p1, v2, p1, v3, p1, v4, v1, v2, v3, v4];//, v5, p1];
    */
/*
    this.cameraLines2 = [p1];
    
    for (var y = 0; y < screenSize[1]*0.5; y += 100) {
        for (var x = screenSize[0]*0.5; x < screenSize[0]; x += 100) {

            var v1 = map.getScreenRay(x,y);
            vec3.scale(v1, l);
            vec3.add(v1, p1);
            
            this.cameraLines2.push(v1);
        }
    }    
*/
    this.cameraLines2 = [[p1], [p1], [p1], [p1]];
    
    var segments = 16;

    var map2 = this.core.getMap();

    var m2 = map2.camera.getRotationviewMatrix();
    var m = mat4.create();
    mat4.inverse(m2, m);
    
    this.cameraMatrix = m;
    
    var a = Math.tan(math.radians(map2.camera.getFov()));
    var b = a * map2.camera.getAspect();
    var c = Math.sqrt(a*a + b*b);
    
    var dfov = Math.atan(c/1);
    
    var l = camera.cameraDistance / segments;
    var l2 = 0.5 * l * Math.tan(dfov);
    var l3 = l2 * map2.camera.getAspect();
    var v1, v2, v3, v4;

    for (var i = 0; i < segments; i++) {
        v1 = [-l3, -l2, -l];
        v2 = [l3, -l2, -l];
        v3 = [l3, l2, -l];
        v4 = [-l3, l2, -l];

        vec3.scale(v1, (i+1));
        vec3.scale(v2, (i+1));
        vec3.scale(v3, (i+1));
        vec3.scale(v4, (i+1));
        
        mat4.multiplyVec3(m, v1);
        mat4.multiplyVec3(m, v2);
        mat4.multiplyVec3(m, v3);
        mat4.multiplyVec3(m, v4);
    
        vec3.add(v1, p1);
        vec3.add(v2, p1);
        vec3.add(v3, p1);
        vec3.add(v4, p1);
        
        this.cameraLines2[0].push(v1);
        this.cameraLines2[1].push(v2);
        this.cameraLines2[2].push(v3);
        this.cameraLines2[3].push(v4);
    }
    
    this.cameraLines3 = [[p1], [p1], [p1], [p1]];

    segments = 256;
    l = (camera.distance + 12742000 * 1.1) / segments;
    //l = (camera.distance * 20.1) / segments;
    l2 = 0.5 * l * Math.tan(dfov);
    l3 = l2 * map2.camera.getAspect();
    
    for (i = 0; i < segments; i++) {
        v1 = [-l3, -l2, -l];
        v2 = [l3, -l2, -l];
        v3 = [l3, l2, -l];
        v4 = [-l3, l2, -l];

        vec3.scale(v1, (i+1));
        vec3.scale(v2, (i+1));
        vec3.scale(v3, (i+1));
        vec3.scale(v4, (i+1));
        
        mat4.multiplyVec3(m, v1);
        mat4.multiplyVec3(m, v2);
        mat4.multiplyVec3(m, v3);
        mat4.multiplyVec3(m, v4);
    
        vec3.add(v1, p1);
        vec3.add(v2, p1);
        vec3.add(v3, p1);
        vec3.add(v4, p1);
        
        this.cameraLines3[0].push(v1);
        this.cameraLines3[1].push(v2);
        this.cameraLines3[2].push(v3);
        this.cameraLines3[3].push(v4);
    }

    v1 = [-l3, -l2, -l];
    v2 = [l3, -l2, -l];
    v3 = [l3, l2, -l];
    v4 = [-l3, l2, -l];

    vec3.scale(v1, segments);
    vec3.scale(v2, segments);
    vec3.scale(v3, segments);
    vec3.scale(v4, segments);
    
    p1 = [0,0,0];
    
    var vertices = [ p1[0], p1[1], p1[2],
        v1[0], v1[1], v1[2],
        v2[0], v2[1], v2[2],

        p1[0], p1[1], p1[2],
        v2[0], v2[1], v2[2],
        v3[0], v3[1], v3[2],

        p1[0], p1[1], p1[2],
        v3[0], v3[1], v3[2],
        v4[0], v4[1], v4[2],

        p1[0], p1[1], p1[2],
        v4[0], v4[1], v4[2],
        v1[0], v1[1], v1[2]
    ];
                      
    var uvs = [ 0,0, 0,0, 0,0,
        0,0, 0,0, 0,0,
        0,0, 0,0, 0,0,
        0,0, 0,0, 0,0 ];

    var normals = [ 0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1,
        0,0,1, 0,0,1, 0,0,1 ];

    this.frustumState = renderer.createState({
        'blend' : true,
        'zwrite' : false,
        'ztest' : true,
        'culling' : false
    });
    
    this.frustumMesh = renderer.createMesh({ 'vertices': vertices, 'uvs': uvs, 'normals': normals });
    this.cameraGenarated = true;
};


InspectorReplay.prototype.itemButton = function(item, button) {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;    
    
    switch (item) {
    case 'DrawnTiles':
        replay.storeTiles = true;
        break;

    case 'DrawnTilesFreeLayers':
        replay.storeFreeTiles = true;
        break;

    case 'TracedNodes':
        replay.storeNodes = true;
        break;

    case 'TracedNodesFreeLayers':
        replay.storeFreeNodes = true;
        break;

    case 'LoadSequence':
        replay.storeLoaded = (button == 'S');

        if (button == 'S') {
            replay.loadedIndex = 0;
            replay.loaded = [];
        } else {
            this.updateFileInfo(replay.loadedIndex);
            this.updateLoadGraphs();
        }
        break;

    case 'Camera':

        if (button == 'S') {
            var camera = replay.camera = {
                distance : map.camera.distance,
                position : map.camera.position.slice(),
                vector : map.camera.vector.slice(),
                center : map.camera.center.slice(),
                height : map.camera.height
            };

            replay.cameraPos = map.getPosition();
            this.generateCameraLines(camera);
        } else {
            if (replay.cameraPos) {
                map.setPosition(replay.cameraPos);
            }
        }

        break;
            
    case 'Globe':
                        
        break;
    }

    map.markDirty();
};


InspectorReplay.prototype.switchItem = function(item, htmlId) {
    var element = document.getElementById(htmlId);
    //element.checked;
    //this.applyMapView();
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;

    switch (item) {
    case 'DrawnTiles':
        replay.drawTiles = element.checked;
        break;

    case 'DrawnTilesFreeLayers':
        replay.drawFreeTiles = element.checked;
        break;

    case 'TracedNodes':
        replay.drawNodes = element.checked;
        break;

    case 'TracedNodesFreeLayers':
        replay.drawFreeNodes = element.checked;
        break;

    case 'LoadSequence':
        replay.drawLoaded = element.checked;
        break;

    case 'Camera':
        
        if (!this.cameraGenarated) {
            this.itemButton('Camera');
        }
        
        this.drawCamera = element.checked;
        break;
            
    case 'Globe':
        var renderer = this.core.getRenderer();
        
        if (!this.globeTexture) {
            var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAMAAADyTj5VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Mzk4RkVFMzlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Mzk4RkVFNDlGNjUxMUU2OTBDM0I0OEM1NjU0RURBMyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjQzOThGRUUxOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjQzOThGRUUyOUY2NTExRTY5MEMzQjQ4QzU2NTRFREEzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5rvbhAAAAAZQTFRFwcHBLS0tMDfv/wAAAiZJREFUeNrs2LENAEEIA0HTf9ME5DTgIZn8ta+TnLjymzuW6kMIwIcQgA8hAAqAAmBdAM4O4E/wBPgQAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACoAAoANoBnB2AngAKgAKgACgACoB2AGcHoCeAAqAAKAAKgAKgHcDZAegJoAAoAAqAAqAAaAdwdgB6AigACoACEIAPIQAfwg7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABSAAH0IAPoQAfAgB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQALQDODsAPQEUAAVAAVAAFADtAM4OQE8ABUABUAAUAAVAO4CzA9ATQAFQABQABUAB0A7g7AD0BFAAFAAFQAFQAPxcAQYAZt2IEFFJhxsAAAAASUVORK5CYII=';        
            this.globeTexture = new GpuTexture(renderer.gpu, texture, this.core, null, true);
        }

        this.drawGlobe = element.checked;
        this.drawGlobe = this.drawGlobe;
        break;
    }

    map.markDirty();
};


InspectorReplay.prototype.updateLoadGraphs = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;
    var loaded = replay.loaded;
    var index = replay.loadedIndex;

    this.timeSlider.max = loaded.length; 

    var ctx;   
    var lx = 340;
    var ly = 30;

    this.ctxMeshes.fillStyle = '#000000';
    this.ctxMeshes.fillRect(0, 0, lx, ly);
    this.ctxTextures.fillStyle = '#000000';
    this.ctxTextures.fillRect(0, 0, lx, ly);
    this.ctxTextures2.fillStyle = '#000000';
    this.ctxTextures2.fillRect(0, 0, lx, ly);
    this.ctxGeodata.fillStyle = '#000000';
    this.ctxGeodata.fillRect(0, 0, lx, ly);
    this.ctxMetatiles.fillStyle = '#000000';
    this.ctxMetatiles.fillRect(0, 0, lx, ly);
    this.ctxIntervals.fillStyle = '#000000';
    this.ctxIntervals.fillRect(0, 0, lx, ly);
    this.ctxThreads.fillStyle = '#000000';
    this.ctxThreads.fillRect(0, 0, lx, ly);

    var i = Math.floor(replay.loadedIndex / lx) * lx, li = (lx-1);
    var shift = i, file;
    
    for (i = 0; i < li; i++) {
        file = loaded[i + shift];
        
        if (file) {
            switch(file.kind) {
            case 'mesh':       ctx = this.ctxMeshes; break;
            case 'texture-in': ctx = this.ctxTextures; break;
            case 'texture-ex': ctx = this.ctxTextures2; break;
            case 'geodata':    ctx = this.ctxGeodata; break;
            case 'metatile':   ctx = this.ctxMetatiles; break;
            default:
                continue;
            }

            var grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.duration / 300)));
            ctx.fillStyle='rgb('+grey+','+grey+','+grey+')';

            var h = (file.duration / 300) * 30;                 
            ctx.fillRect(i, ly, 1, -h);

            //interval
            grey = Math.round(Math.min(255, 60+20 * Math.max(1, file.interval / 300)));
            this.ctxIntervals.fillStyle='rgb('+grey+','+grey+','+grey+')';
            h = (file.interval / 300) * 30;                 
            this.ctxIntervals.fillRect(i, ly, 1, -h);

            //interval
            this.ctxThreads.fillStyle='rgb(80,80,80)';
            h = (file.threads / map.config.mapDownloadThreads) * 30;                 
            this.ctxThreads.fillRect(i, ly, 1, -h);
        }
    }

    var minMeshes = Number.MAX_VALUE, maxMeshes = 0, avgMeshes = 0, avgMeshesCount = 0;
    var minTextures = Number.MAX_VALUE, maxTextures = 0, avgTextures = 0, avgTexturesCount = 0;
    var minTextures2 = Number.MAX_VALUE, maxTextures2 = 0, avgTextures2 = 0, avgTextures2Count = 0;
    var minGeodata = Number.MAX_VALUE, maxGeodata = 0, avgGeodata = 0, avgGeodataCount = 0;
    var minMetatiles = Number.MAX_VALUE, maxMetatiles = 0, avgMetatiles = 0, avgMetatilesCount = 0;
    var minThreads = Number.MAX_VALUE, maxThreads = 0, avgThreads = 0, avgThreadsCount = 0;
    var minIntervals = Number.MAX_VALUE, maxIntervals = 0, avgIntervals = 0, avgIntervalsCount = 0;
    
    li = loaded.length;

    for (i = 0; i < li; i++) {
        file = loaded[i];
        
        if (file) {
            
            switch(file.kind) {
            case 'mesh':
                if (file.duration < minMeshes) minMeshes = file.duration; 
                if (file.duration > maxMeshes) maxMeshes = file.duration; 
                avgMeshes += file.duration;
                avgMeshesCount++;  
                break;
                    
            case 'texture-in':
                if (file.duration < minTextures) minTextures = file.duration; 
                if (file.duration > maxTextures) maxTextures = file.duration; 
                avgTextures += file.duration;
                avgTexturesCount++;  
                break;
                    
            case 'texture-ex':
                if (file.duration < minTextures2) minTextures2 = file.duration; 
                if (file.duration > maxTextures2) maxTextures2 = file.duration; 
                avgTextures2 += file.duration;
                avgTextures2Count++;  
                break;
                    
            case 'geodata':
                if (file.duration < minGeodata) minGeodata = file.duration; 
                if (file.duration > maxGeodata) maxGeodata = file.duration; 
                avgGeodata += file.duration;
                avgGeodataCount++;  
                break;
                    
            case 'metatile':
                if (file.duration < minMetatiles) minMetatiles = file.duration; 
                if (file.duration > maxMetatiles) maxMetatiles = file.duration; 
                avgMetatiles += file.duration;
                avgMetatilesCount++;  
                break;

            default:
                continue;
            }
                
            if (file.threads < minThreads) minThreads = file.threads; 
            if (file.threads > maxThreads) maxThreads = file.threads; 
            avgThreads += file.threads;
            avgThreadsCount++;  

            if (file.threads < minIntervals) minIntervals = file.threads; 
            if (file.threads > maxIntervals) maxIntervals = file.threads; 
            avgIntervals += file.threads;
            avgIntervalsCount++;  
        }
    }
    
    index -= shift;

    this.ctxMeshes.fillStyle = '#ff0000';
    this.ctxMeshes.fillRect(index - 1, 0, 1, ly);
    this.ctxMeshes.fillRect(index + 1, 0, 1, ly);
    this.ctxTextures.fillStyle = '#ff0000';
    this.ctxTextures.fillRect(index - 1, 0, 1, ly);
    this.ctxTextures.fillRect(index + 1, 0, 1, ly);
    this.ctxTextures2.fillStyle = '#ff0000';
    this.ctxTextures2.fillRect(index - 1, 0, 1, ly);
    this.ctxTextures2.fillRect(index + 1, 0, 1, ly);
    this.ctxGeodata.fillStyle = '#ff0000';
    this.ctxGeodata.fillRect(index - 1, 0, 1, ly);
    this.ctxGeodata.fillRect(index + 1, 0, 1, ly);
    this.ctxMetatiles.fillStyle = '#ff0000';
    this.ctxMetatiles.fillRect(index - 1, 0, 1, ly);
    this.ctxMetatiles.fillRect(index + 1, 0, 1, ly);
    this.ctxIntervals.fillStyle = '#ff0000';
    this.ctxIntervals.fillRect(index - 1, 0, 1, ly);
    this.ctxIntervals.fillRect(index + 1, 0, 1, ly);
    this.ctxThreads.fillStyle = '#ff0000';
    this.ctxThreads.fillRect(index - 1, 0, 1, ly);
    this.ctxThreads.fillRect(index + 1, 0, 1, ly);

    if (!avgMeshesCount) { minMeshes = 0, maxMeshes = 0; }
    if (!avgTexturesCount) { minTextures = 0, maxTextures = 0; }
    if (!avgTextures2Count) { minTextures2 = 0, maxTextures2 = 0; }
    if (!avgGeodataCount) { minGeodata = 0, maxGeodata = 0; }
    if (!avgMetatilesCount) { minMetatiles = 0, maxMetatiles = 0; }
    if (!avgThreadsCount) { minThreads = 0, maxThreads = 0; }
    if (!avgIntervalsCount) { minIntervals = 0, maxIntervals = 0; }

    avgMeshes = avgMeshesCount ? (avgMeshes/avgMeshesCount) : 0;
    avgTextures = avgTexturesCount ? (avgTextures/avgTexturesCount) : 0;
    avgTextures2 = avgTextures2Count ? (avgTextures2/avgTextures2Count) : 0;
    avgGeodata = avgGeodataCount ? (avgGeodata/avgGeodataCount) : 0;
    avgMetatiles = avgMetatilesCount ? (avgMetatiles/avgMetatilesCount) : 0;
    avgIntervals = avgIntervalsCount ? (avgIntervals/avgIntervalsCount) : 0;
    avgThreads = avgThreadsCount ? (avgThreads/avgThreadsCount) : 0;

    this.infoMeshes.innerHTML = 'Meshes Min/Max/Avg/Count: ' + minMeshes.toFixed(0) + '/' + maxMeshes.toFixed(0) + '/' + avgMeshes.toFixed(1) + '/' + avgMeshesCount;
    this.infoTextures.innerHTML = 'Internal Textures Min/Max/Avg/Count: ' + minTextures.toFixed(0) + '/' + maxTextures.toFixed(0) + '/' + avgTextures.toFixed(1) + '/' + avgTexturesCount;
    this.infoTextures2.innerHTML = 'External Textures Min/Max/Avg/Count: ' + minTextures2.toFixed(0) + '/' + maxTextures2.toFixed(0) + '/' + avgTextures2.toFixed(1) + '/' + avgTextures2Count;
    this.infoGeodata.innerHTML = 'Geodata Min/Max/Avg/Count: ' + minGeodata.toFixed(0) + '/' + maxGeodata.toFixed(0) + '/' + avgGeodata.toFixed(1) + '/' + avgGeodataCount;
    this.infoMetatiles.innerHTML = 'Metatiles Min/Max/Avg/Count: ' + minMetatiles.toFixed(0) + '/' + maxMetatiles.toFixed(0) + '/' + avgMetatiles.toFixed(1) + '/' + avgMetatilesCount;
    this.infoIntervals.innerHTML = 'Intervals Min/Max/Avg: ' + minIntervals.toFixed(0) + '/' + maxIntervals.toFixed(0) + '/' + avgIntervals.toFixed(1);  
    this.infoThreads.innerHTML = 'Threads Min/Max/Avg: ' + minThreads + '/' + maxThreads + '/' + avgThreads.toFixed(1);  
};


InspectorReplay.prototype.updateFileInfo = function(index) {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var replay = map.draw.replay;
    var file = replay.loaded[index];

    if (file) {
        this.timeInfo.innerHTML = ''
            + 'Resource Kind: ' + file.kind + '<br/>'
            + 'Time: ' + file.time.toFixed(2) + '<br/>'
            + 'Duration: ' + file.duration.toFixed(2) + '<br/>'
            + 'Interval: ' + file.interval.toFixed(2) + '<br/>'
            + 'Priority: ' + file.priority.toFixed(2) + '<br/>'
            + 'Threads: ' + file.threads + '<br/>'
            + '' + file.url;
    } else {
        this.timeInfo.innerHTML = '';
    }
};


InspectorReplay.prototype.buildReplayCombo = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var items = [
        ['Drawn Tiles',1],
        ['Drawn Tiles - Free Layers',1],
        ['Traced Nodes',1],
        ['Traced Nodes - Free Layers',1],
        ['Load Sequence',2],
        ['Camera',2],
        ['Globe',0]
    ];

    var keys = [
        'DrawnTiles',
        'DrawnTilesFreeLayers',
        'TracedNodes',
        'TracedNodesFreeLayers',
        'LoadSequence',
        'Camera',
        'Globe'
    ];

    var html = '', i, li, htmlId;

    for (i = 0, li = items.length; i < li; i++) {
        html += '<div id="vts-replay-item-' + keys[i] + '" class="vts-replay-item">'
                 + '<input id="vts-replay-checkbox-' + keys[i] + '" type="checkbox"/>'
                 + '<span title=' + items[i][0] + '>' + items[i][0] + '&nbsp;&nbsp;</span>';
                 
        if (items[i][1] > 0) {
            html += '<input id="vts-replay-sbutton-' + keys[i] + '" type="button" value="S"/>';
        }
        
        if (items[i][1] > 1) {
            html += '<input id="vts-replay-fbutton-' + keys[i] + '" type="button" value="' + ((keys[i] == 'Camera') ? 'R' : 'F') + '"/>';
        }
        
        html += '</div>';
    }

    this.items.innerHTML = html;
    //this.currentItem = keys[0];

    for (i = 0, li = items.length; i < li; i++) {
        htmlId = 'vts-replay-checkbox-' + keys[i];
        document.getElementById(htmlId).onchange = this.switchItem.bind(this, keys[i], htmlId);
        //var htmlId = "vts-replay-item-" + keys[i];
        //document.getElementById(htmlId).onclick = this.selectReplayItem.bind(this, keys[i]);

        if (items[i][1] > 0) {
            htmlId = 'vts-replay-sbutton-' + keys[i];
            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], 'S');
        }

        if (items[i][1] > 1) {
            htmlId = 'vts-replay-fbutton-' + keys[i];
            document.getElementById(htmlId).onclick = this.itemButton.bind(this, keys[i], ((keys[i] == 'Camera') ? 'R' : 'F'));
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (InspectorReplay);



/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core__ = __webpack_require__(13);





var InspectorStats = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorStats.prototype.init = function() {
    var inspector = this.inspector;
    inspector.addStyle(
        '#vts-stats-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 305px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'top: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-stats-panel-info {'
            + 'margin-top: 5px;'
            + 'margin-bottom: 3px;'
            + 'overflow: hidden;'
        + '}'

        + '#vts-stats-panel-info table {'
            + 'color:#000000;'
            + 'text-align: left;'
            + 'font-size: 12px;'
        + '}'

        + '#vts-stats-panel-info table td {'
            + 'vertical-align: top;'
        + '}'

        + '#vts-stats-panel-pos {'
            + 'width: 100%;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-stats-panel';
    this.element.innerHTML =
        '<span id="vts-stats-panel-title">Render statistics &nbsp;&nbsp;&nbsp;v' + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__core__["a" /* getCoreVersion */])() + '</h3>'+
        '<p id="vts-stats-panel-info"></p>'+
        '<input id="vts-stats-panel-pos" type="text">';

    this.core.element.appendChild(this.element);
    this.infoElement = document.getElementById('vts-stats-panel-info');
    this.posElement = document.getElementById('vts-stats-panel-pos');

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.panelVisible = false;
};


InspectorStats.prototype.showPanel = function() {
    this.element.style.display = 'block';
    this.panelVisible = true;
};


InspectorStats.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorStats.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorStats.prototype.updateStatsPanel = function(stats) {
    if (!this.infoElement || !this.panelVisible) {
        return;
    }
    var inspector = this.inspector;
    
    var text2 =
            'FPS: ' + Math.round(stats.fps) + '<br/>' +
            'Render time: ' + Math.round(stats.renderTime*1000) + '<br/>' +
            ' - resources: ' + Math.round(stats.gpuRenderUsed/(1024*1024)) + 'MB<br/>' +
            ' - topdown: ' + Math.round(stats.gpuNeeded/(1024*1024)) + 'MB<br/>' +
            //" - resources: " + (stats.gpuRenderUsed) + " --- " + (stats.gpuRenderUsed / stats.drawnTiles) + "<br/>" +
            'GPU Cache: ' + Math.round(stats.gpuUsed/(1024*1024)) + 'MB<br/>' +
            ' - textures: ' + Math.round(stats.gpuTextures/(1024*1024)) + 'MB<br/>' +
            ' - meshes: ' + Math.round(stats.gpuMeshes/(1024*1024)) + 'MB<br/>' +
            ' - geodata: ' + Math.round(stats.gpuGeodata/(1024*1024)) + 'MB<br/>' +
            'CPU Cache: ' + Math.round(stats.resourcesUsed/(1024*1024)) + 'MB<br/>' +
            'Metaile Cache: ' + Math.round(stats.metaUsed/(1024*1024)) + 'MB<br/>' +
//            "FOV: " + Math.round(this.core.getOption("fov")) + " deg<br/>" +
//            "viewHeight: " + Math.round(this.core.getOption("viewHeight")) + " m<br/>" +
//            "distance: " + Math.round(this.core.renderer.cameraDistance) + " m<br/>" +
            'Draw calls: ' + (stats.drawCalls) + '<br/>' +
            'Polygons: ' + (stats.drawnFaces) + '<br/><br/>' +
            'Terrain Height: ' + (stats.heightTerrain.toFixed(2)) + '<br/>' +
            '- float: ' + (stats.heightDelta.toFixed(2)) + '<br/>' +
            '- desired lod: ' + (stats.heightLod.toFixed(2)) + '<br/>' +
            '- used lod: ' + (stats.heightNode.toFixed(2)) + '<br/>' +
            '- used source: ' + ((stats.heightClass == 2 ? 'navtile' : stats.heightClass == 1 ? 'node': '---') ) + '<br/>' +
            'Terrain Radar Lod: ' + (inspector.radarLod) + '<br/><br/>' + 
            'Loaded/Errors: ' + (stats.loadedCount) + ' / ' + (stats.loadErrorCount) + '<br/>' +
            'Load time: ' + ((stats.loadLast - stats.loadFirst)*0.001).toFixed(2) + 's <br/>';

    var renderer = this.core.renderer;

    if (renderer) {
        text2 += '<br/>Render jobs: ' + renderer.totalJobs + '<br/>' +
                 'Drawn jobs: ' + renderer.drawnJobs + '<br/>' +
                 'Jobs total time: ' +  Math.round((renderer.jobsTimer2 - renderer.jobsTimer1)*1000) + '<br/>' +
                 'Jobs reduce time: ' + Math.round((renderer.jobsTimer4)*1000) + '<br/>';
    }

    if (stats.debugStr) {
        text2 += stats.debugStr + '<br/>';        
    }

    var text3 =  'PixelRatio: ' + (window.devicePixelRatio || 1).toFixed(3) +'<br/>'+
                 'BFRate: ' + Math.round(1000 / (stats.frameTime+0.00001)) +'<br/><br/>'+
                 'Metatiles: ' + (stats.processedMetatiles) +'<br/>'+
                 'Metanodes: ' + (stats.processedNodes) + ' / ' + (stats.usedNodes) + '<br/>'+
                 'GeodataTiles: ' + (stats.drawnGeodataTiles) + '<br/><br/>' +
                 //'GVGeodataTiles: ' + (stats.drawnGeodataTilesPerLayer) +'<br/><br/>' +
                 'Tiles: ' + (stats.drawnTiles) +'<br/>';

    for (var i =0, li = stats.renderedLods.length; i < li; i++) {
        if (stats.renderedLods[i]) {
            text3 += 'LOD ' + i + ': ' + (stats.renderedLods[i]) +'<br/>';
        }
    }


    var text = '<table style="width:305px"><tr><td>' + text2 + '</td><td>' + text3 + '</td></tr></table>';

    this.infoElement.innerHTML = text;

    var map = this.core.getMap();

    if (map != null) {
        var p = map.getPosition();
        var s = '';
        s += p.getViewMode() + ',';
        var c = p.getCoords();
        s += c[0] + ',' + c[1] + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';
        var o = p.getOrientation();
        s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';
        s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);
        
        //var value = JSON.stringify(p.pos);

        if (this.posElement.value != s) {
            this.posElement.value = s;
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (InspectorStats);



/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var InspectorStylesheets = function(inspector) {
    this.inspector = inspector;
    this.core = inspector.core;
};


InspectorStylesheets.prototype.init = function() {
    var inspector = this.inspector;
    inspector.addStyle(
        '#vts-stylesheets-panel * {'
            + 'all: initial;'
        + '}'

        + '#vts-stylesheets-panel {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'display: none;'
            + 'padding:15px;'
            + 'width: 1200px;'
            + 'height: 350px;'
            + 'font-size: 14px;'
            + 'position: absolute;'
            + 'right: 10px;'
            + 'bottom: 10px;'
            + 'cursor: default;'
            + 'background-color: rgba(255,255,255,0.95);'
            + 'border-radius: 5px;'
            + 'border: solid 1px #ccc;'
            + 'text-align: left;'
            + 'z-index: 7;'
            + 'padding: 10px;'
        + '}'

        + '#vts-stylesheets-panel-header {'
            + 'width: 100%;'
            + 'height: 28px;'
        + '}'

        + '#vts-stylesheets-panel-combo {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 13px;'
            + 'border: 1px solid #a9a9a9;'
            + 'width: 1070px;'
            + 'height: 17px;'
            + 'padding: 2px;'
            + 'margin-bottom: 5px;'
            + '-webkit-appearance: menulist;'
            + '-moz-appearance: menulist;'
        + '}'

        + '#vts-stylesheets-panel-combo option {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 13px;'
        + '}'

        + '#vts-stylesheets-panel-update-button {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 14px;'
            + 'float: right;'
            + 'background-color: #dedede;'
            + 'padding: 3px 2px 2px 2px;'
            + 'border: 1px solid #a0a0a0;'
            + 'border-radius: 2px;'
            + 'margin-right: 5px;'
        + '}'

        + '#vts-stylesheets-panel-hide-button {'
            + 'font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;'
            + 'font-size: 14px;'
            + 'float: right;'
            + 'background-color: #dedede;'
            + 'padding: 3px 2px 2px 2px;'
            + 'border: 1px solid #a0a0a0;'
            + 'border-radius: 2px;'
        + '}'

        + '#vts-stylesheets-panel-text {'
            + 'font-family: monospace;'
            + 'border: 1px solid #a9a9a9;'
            + 'padding: 2px 0px 0px 2px;'
            + 'width: 100%;'
            + 'height: 300px;'
            + 'resize: none;'
            + 'white-space: pre;'
        + '}'
    );

    this.element = document.createElement('div');
    this.element.id = 'vts-stylesheets-panel';
    this.element.innerHTML =
            '<div id="vts-stylesheets-panel-header">'
            + '<select id="vts-stylesheets-panel-combo"></select>'
            + '<button id="vts-stylesheets-panel-hide-button" type="button" title="Hide">Hide</button>'
            + '<button id="vts-stylesheets-panel-update-button" type="button" title="Update">Update</button>'
          + '</div>'
          + '<textarea id="vts-stylesheets-panel-text" rows="4" cols="50">aa\naa\n</textarea>';

    //this.inspectorElement.appendChild(this.element);
    this.core.element.appendChild(this.element);

    this.optionsElement = document.getElementById('vts-stylesheets-panel-combo');
    this.optionsElement.onchange = this.onComboSwitched.bind(this);

    this.textElement = document.getElementById('vts-stylesheets-panel-text');
    
    document.getElementById('vts-stylesheets-panel-update-button').onclick = this.onUpdate.bind(this);
    document.getElementById('vts-stylesheets-panel-hide-button').onclick = this.hidePanel.bind(this);

    this.element.addEventListener('mouseup', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousedown', inspector.doNothing.bind(this), true);
    this.element.addEventListener('mousewheel', inspector.doNothing.bind(this), false);
    this.element.addEventListener('dblclick', inspector.doNothing.bind(this), false);

    this.textElement.addEventListener('keyup', inspector.doNothing.bind(this), false);
    this.textElement.addEventListener('keydown', inspector.doNothing.bind(this), false);

    this.panelVisible = false;
};


InspectorStylesheets.prototype.showPanel = function() {
    this.buildStylesheetsCombo();
    this.element.style.display = 'block';
    this.panelVisible = true;
};


InspectorStylesheets.prototype.hidePanel = function() {
    this.element.style.display = 'none';
    this.panelVisible = false;
};


InspectorStylesheets.prototype.switchPanel = function() {
    if (this.panelVisible) {
        this.hidePanel();
    } else {
        this.showPanel();
    }
};


InspectorStylesheets.prototype.onComboSwitched = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var stylesheet = map.getStylesheet(this.optionsElement.value);
    this.textElement.value = this.niceStyleFormat(stylesheet);
};


InspectorStylesheets.prototype.onUpdate = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    map.setStylesheetData(this.optionsElement.value, JSON.parse(this.textElement.value));
};


InspectorStylesheets.prototype.niceStyleFormat = function(data) {
    if (!data || !data.data) {
        return '';
    }
    
    data = data.data;

    //return JSON.stringify(data, null, "  ");
    
    var tmp = '';
    tmp += '{\n';

    var elements = [];

    if (data['constants']) {
        elements.push('constants');
    } 

    if (data['bitmaps']) {
        elements.push('bitmaps');
    } 

    if (data['fonts']) {
        elements.push('fonts');
    } 

    if (data['layers']) {
        elements.push('layers');
    } 
    
    for (var j = 0, lj = elements.length; j < lj; j++) {
        var type = elements[j];
        tmp += '  "' + type + '": {\n';

        var element = data[type];

        var buff = [];
        for (var key in element) {
            buff.push(key);
        }

        for (var i = 0, li = buff.length; i < li; i++) {
            if (type == 'layers') {
                
                var element2 = element[buff[i]];
                
                var buff2 = [];
                for (var key2 in element2) {
                    buff2.push(key2);
                }

                tmp += '    "' + buff[i] + '": {\n';

                for (var k = 0, lk = buff2.length; k < lk; k++) {
                    tmp += '      "' + buff2[k] + '": ' + JSON.stringify(element2[buff2[k]]) + (k == (lk - 1) ? '' : ',') + '\n';
                }
                
                tmp += '    }'  + (i == (li - 1) ? '' : ',\n');
            } else {
                tmp += '    "' + buff[i] + '": ' + JSON.stringify(element[buff[i]]) + (i == (li - 1) ? '' : ',') + '\n';
            }
        }
        
        tmp += '\n  }' + (j == (lj - 1) ? '' : ',\n');
    }
    
    tmp += '\n}';
    
    return tmp;
};


InspectorStylesheets.prototype.buildStylesheetsCombo = function() {
    var map = this.core.getMap();
    if (!map) {
        return;
    }

    var html = '';

    var styles = map.getStylesheets();
    
    for (var i = 0, li = styles.length; i < li; i++) {
        html += '<option value="' + styles[i] + '">' + styles[i] + '</option>';
    }    
    
    this.optionsElement.innerHTML = html;
    
    var stylesheet = map.getStylesheet(styles[0]);
    this.textElement.value = this.niceStyleFormat(stylesheet);
};


/* harmony default export */ __webpack_exports__["a"] = (InspectorStylesheets);



/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapBody = function(map, json) {
    //this.map = map;
    //this.id = json["id"] || null;
    this.parse(json);
};


MapBody.prototype.parse = function(json) {
    this.class = json['class'] || '';
    this.comment = json['comment'] || '';
    this.parent = json['parent'] || '';
    this.atmosphere = json['atmosphere'] || null;

    if (this.atmosphere) {
        if (!this.atmosphere['colorHorizon']) this.atmosphere['colorHorizon'] = [0,0,0,0];
        if (!this.atmosphere['colorZenith']) this.atmosphere['colorZenith'] = [0,0,0,0];
        if (!this.atmosphere['thickness'])  this.atmosphere['thickness'] = 100000;
        if (!this.atmosphere['visibility'])  this.atmosphere['visibility'] = 100000;
    }
};


MapBody.prototype.getInfo = function() {
    return {
        'class' : this.class,
        'comment' : this.comment,
        'parent' : this.parent,
        'atmosphere' : JSON.parse(JSON.stringify(this.atmosphere)),
    };
};


/* harmony default export */ __webpack_exports__["a"] = (MapBody);

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var MapCache = function(map, maxCost) {
    this.map = map;
    this.maxCost = (maxCost != null) ? maxCost : Number.MAX_VALUE;
    this.skipCostCheck = false;
    this.last = null;
    this.first = null;

    this.totalCost = 0;
    this.totalItems = 0;
};


MapCache.prototype.updateItem = function(item) {
    if (item == null) {
        return;
    }

    if (this.first == item) {
        return;
    }

    //remove item from list
    if (item.prev != null) {
        item.prev.next = item.next;
    }

    if (item.next != null) {
        item.next.prev = item.prev;
    }

    if (this.last == item) {
        this.last = item.prev;
    }

    var first = this.first;

    //add item as first
    this.first = item;
    this.first.next = first;
    this.first.prev = null;

    first.prev = this.first;
};


MapCache.prototype.getMaxCost = function() {
    return this.maxCost;
};


MapCache.prototype.setMaxCost = function(cost) {
    this.maxCost = cost;
    this.checkCost();
};


MapCache.prototype.clear = function() {
    var item = this.first;

    while (item != null) {
        if (item.destructor != null) {
            item.destructor();
        }
        item = item.next;
    }

    this.last = null;
    this.first = null;

    this.totalCost = 0;
    this.totalItems = 0;
};


MapCache.prototype.insert = function(destructor, cost) {
    this.totalItems++;

    //console.log("insert: " + hash + " items: " + this.totalItems);

    var item = { destructor:destructor, cost:cost, prev: null, next:this.first };

    if (this.first != null) {
        this.first.prev = item;
    }

    //add item as first in list
    this.first = item;

    if (this.last == null) {
        this.last = item;
    }

    this.totalCost += cost;

    //console.log("MapCache.prototype.insert:" + this.totalCost + " / " + this.maxCost);

    this.checkCost();

    return item;
};


MapCache.prototype.remove = function(item) {
    this.totalItems++;
    var hit = false;

    if (item == this.first) {
        this.first = item.next;
        hit = true;

        if (this.first != null) {
            this.first.prev = null;
        }
    }

    if (item == this.last) {
        this.last = item.prev;
        hit = true;

        if (this.last != null) {
            this.last.next = null;
        }
    }

    if (!hit) {
    //if (item != this.last && item != this.first) {

        if (!item.prev) {
            //debugger;
        } else {
            item.prev.next = item.next;
        }
        
        if (!item.next) {
            //debugger;
        } else {
            item.next.prev = item.prev;
        }
        
    }

    this.totalCost -= item.cost;

    //destroy item
    item.destructor();

    //console.log("MapCache.prototype.remove:" + this.totalCost + " / " + this.maxCost);

    this.checkCost();
};


MapCache.prototype.checkCost = function() {
    if (this.skipCostCheck) {
        return;
    }

    while (this.totalCost > this.maxCost) {

        this.totalItems--;

        //console.log("remove: " + this.last.hash + " prev: " + this.last.prev + " items: " + this.totalItems);

        var last = this.last;

        if (last != null) {
            //set new last
            this.last = this.last.prev;

            if (this.last != null) {
                this.last.next = null;
            }

            this.totalCost -= last.cost;

            //destroy item
            last.destructor();

        } else {
            break;
        }
    }
};


MapCache.prototype.addItem = function(cost, destructor) {
    return this.insert(destructor, cost);
};


MapCache.prototype.removeItem = function(item) {
    return this.remove(item);
};


MapCache.prototype.itemUsed = function(item) {
    return this.updateItem(item);
};

/*
MapCache.prototype["addItem"] = MapCache.prototype.addItem;
MapCache.prototype["removeItem"] = MapCache.prototype.removeItem;
MapCache.prototype["itemUsed"] = MapCache.prototype.itemUsed;
*/

/* harmony default export */ __webpack_exports__["a"] = (MapCache);

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);




//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];


var MapCamera = function(map) {
    this.map = map;
    this.camera = map.renderer.camera;
    this.distance = 10;
    this.distance2 = 10;
    this.position = [0,0,0];
    this.vector = [0,0,1];
    this.vector2 = [0,0,1,1];
    this.center = [0,0,0];
    this.height = 0;
    this.terrainHeight = 0;
    this.lastTerrainHeight = 0;
    this.near = 2;
};


MapCamera.prototype.update = function() {
    var map = this.map;

    //check position orientaion ...
    map.position.check();

    //var height = 227;
    var height = map.position.getHeight();

    var lod =  map.measure.getOptimalHeightLod(map.position.getCoords(), map.position.getViewExtent(), map.config.mapNavSamplesPerViewExtent);
    //var surfaceHeight = [226,true,true]; //map.getSurfaceHeight(map.position.getCoords(), lod, true);
    var surfaceHeight = map.measure.getSurfaceHeight(map.position.getCoords(), lod, true);
    
    map.stats.heightTerrain = surfaceHeight[0];
    map.stats.heightDelta = height;

    //console.log("terrain height:" + surfaceHeight[0] + "  pos height:" + map.position.getHeight());

    if (map.position.getHeightMode() == 'float') {
        height += surfaceHeight[0];
    }

    if (map.renderer.useSuperElevation) {
        height = map.renderer.getSuperElevatedHeight(height);
    }

    var camInfo = map.measure.getPositionCameraInfo(map.position, map.getNavigationSrs().isProjected());

    this.camera.setPosition(camInfo.orbitCoords);
    this.camera.setRotationMatrix(camInfo.rotMatrix);
    this.vector = camInfo.vector;
    this.vector2 = camInfo.vector2;
    this.position = camInfo.orbitCoords;
    this.height = camInfo.orbitHeight + height;
    this.terrainHeight = this.height - surfaceHeight[0];

    //console.log(''+this.height + ' ' + this.terrainHeight + ' ' + surfaceHeight[0]);

    //get camera distance
    this.distance2 = map.position.getViewDistance();
    this.distance = Math.max(this.terrainHeight, this.distance2);
    this.distance = math.clamp(this.distance, 0.1, this.camera.getFar());

    this.distanceFactor = Math.tan(math.radians(map.position.getFov()*0.5)); 

    this.perceivedDistance = Math.max(this.terrainHeight, this.distance2 * this.distanceFactor);
    
    //this.renderer.cameraDistance = camInfo.distance; //needed for fog
    map.renderer.cameraDistance = this.distance; //needed for fog
    map.renderer.viewExtent = map.position.getViewExtent();

    this.camera.setViewHeight(map.position.getViewExtent());
    //this.camera.setOrtho(true);

    //convert nav coords to physical
    var coords = map.position.getCoords();
    var worldPos = map.convert.convertCoords([coords[0], coords[1], height], 'navigation', 'physical');
    this.center = [worldPos[0], worldPos[1], worldPos[2]];
    worldPos[0] += camInfo.orbitCoords[0];
    worldPos[1] += camInfo.orbitCoords[1];
    worldPos[2] += camInfo.orbitCoords[2];
    this.camera.setPosition([0,0,0]); //always zeros
    this.position = worldPos;

    this.vector2 = [-worldPos[0], -worldPos[1], -worldPos[2], 1];
    vec3.normalize(this.vector2);

    this.mapIsProjected = map.getNavigationSrs().isProjected();

    if (!this.mapIsProjected) { //HACK!!!!!!!!
        this.geocentDistance = vec3.length(this.position);

        var n = [0,0,0];
        vec3.normalize(this.position, n);
        this.geocentNormal = n;
    } else {
        this.vector2[3] = 0;
    }
    
    //console.log("word-pos: " + JSON.stringify(worldPos));

    //set near and far of camera by distance of orbit
    var factor = Math.max(this.height, this.distance) / 600000;

    var near = Math.max(this.near, this.near * (factor * 20));
    factor = Math.max(1.0, factor);
    var far = 600000 * (factor * 10);

    //console.log("near: " + near + "  far: " + far);

    this.camera.setParams(map.position.getFov()*0.5, near, far * 2.0);
    
    return camInfo;
};


MapCamera.prototype.getCameraHeight = function() {
    //TODO: get camera height
    //var cameraPos = this.camera.position;
    //return (this.camera.getPosition()[2] - this.planet.surfaceHeight([this.position[0] + cameraPos[0], this.position[1] + cameraPos[1]])[0]);

    //hack - distance intead of height
    //return this.cameraDistance;
    return this.cameraHeight;
};


MapCamera.prototype.getMvpMatrix = function() {
    return this.camera.getMvpMatrix();
};


MapCamera.prototype.getRotationMatrix = function() {
    return this.camera.getRotationMatrix();
};


MapCamera.prototype.getRotationviewMatrix = function() {
    return this.camera.getRotationviewMatrix();
};


MapCamera.prototype.getFar = function() {
    return this.camera.getFar();
};


MapCamera.prototype.getFov = function() {
    return this.camera.getFov();
};


MapCamera.prototype.getAspect = function() {
    return this.camera.getAspect();
};


/* harmony default export */ __webpack_exports__["a"] = (MapCamera);




/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bound_layer__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__credit__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__refframe__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__srs__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__body__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__surface__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__virtual_surface__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__stylesheet__ = __webpack_require__(52);











//get rid of compiler mess
var MapCredit = __WEBPACK_IMPORTED_MODULE_1__credit__["a" /* default */];
var MapBoundLayer = __WEBPACK_IMPORTED_MODULE_0__bound_layer__["a" /* default */];
var MapRefFrame = __WEBPACK_IMPORTED_MODULE_2__refframe__["a" /* default */];
var MapView = __WEBPACK_IMPORTED_MODULE_3__view__["a" /* default */];
var MapSrs = __WEBPACK_IMPORTED_MODULE_4__srs__["a" /* default */];
var MapBody = __WEBPACK_IMPORTED_MODULE_5__body__["a" /* default */];
var MapSurface = __WEBPACK_IMPORTED_MODULE_6__surface__["a" /* default */];
var MapVirtualSurface = __WEBPACK_IMPORTED_MODULE_7__virtual_surface__["a" /* default */];
var MapStylesheet = __WEBPACK_IMPORTED_MODULE_8__stylesheet__["a" /* default */];


var MapConfig = function(map, config) {
    this.map = map;
    this.mapConfig = config;
    this.parseConfig();
};


MapConfig.prototype.parseConfig = function() {
    if (!(this.parseSrses() && this.parseBodies() && this.parseReferenceFrame() &&
          this.parseCredits() && this.parseStylesheets() && 
          this.parseSurfaces() && this.parseGlues() && 
          this.parseVirtualSurfaces() && this.parseBoundLayers() &&
          this.parseFreeLayers() && this.parseViews() &&
          this.parseParams() && this.parseBrowserOptions() )) {
        //wrong config file
    }

    var stats = this.map.stats;
    stats.loadedCount = 0;
    stats.loadErrorCount = 0;
    stats.loadFirst = performance.now();
    stats.loadLast = this.map.loadFirst;
};


MapConfig.prototype.afterConfigParsed = function() {
    if (this.mapConfig['position'] != null) {
        this.map.setPosition(this.mapConfig['position'], false);
    }

    this.map.setView(this.map.initialView);
};


MapConfig.prototype.parseSrses = function() {
    var srses = this.mapConfig['srses'];
    this.map.srses = {};

    if (srses == null) {
        return false;
    }

    for (var key in srses) {
        this.map.addSrs(key, new MapSrs(this.map, key, srses[key]));
    }

    return true;
};


MapConfig.prototype.parseBodies = function() {
    var bodies = this.mapConfig['bodies'];
    this.map.bodies = {};

    if (bodies == null) {
        return true;//false;
    }

    for (var key in bodies) {
        this.map.addBody(key, new MapBody(this.map, bodies[key]));
    }

    return true;
};


MapConfig.prototype.parseReferenceFrame = function() {
    var rf = this.mapConfig['referenceFrame'];

    if (rf == null) {
        return false;
    }

    this.map.referenceFrame = new MapRefFrame(this.map, rf);

    if (!this.map.referenceFrame.valid) {
        return false;
    }

    return true;
};


MapConfig.prototype.parseCredits = function() {
    var credits = this.mapConfig['credits'];
    this.map.credits = {};

    if (credits == null) {
        return false;
    }

    for (var key in credits) {
        this.map.addCredit(key, new MapCredit(this.map, credits[key]));
    }

    return true;
};


MapConfig.prototype.parseSurfaces = function() {
    var surfaces = this.mapConfig['surfaces'];
    this.map.surfaces = [];

    if (surfaces == null) {
        return false;
    }

    for (var i = 0, li = surfaces.length; i < li; i++) {
        var surface = new MapSurface(this.map, surfaces[i]);
        this.map.addSurface(surface.id, surface);
    }

    return true;
};


MapConfig.prototype.parseVirtualSurfaces = function() {
    var surfaces = this.mapConfig['virtualSurfaces'];
    this.map.virtualSurfaces = [];

    if (!this.map.config.mapVirtualSurfaces) {
        return true;
    }

    if (surfaces == null) {
        return true;
    }

    for (var i = 0, li = surfaces.length; i < li; i++) {
        var surface = new MapVirtualSurface(this.map, surfaces[i]);
        this.map.virtualSurfaces[surface.strId] = surface;
    }

    return true;
};


MapConfig.prototype.parseViews = function() {
    var views = this.mapConfig['namedViews'];
    this.map.namedViews = [];

    if (views) {
        for (var key in views) {
            this.map.addNamedView(key, new MapView(this.map, views[key], true));
        }
    }

    var view = this.mapConfig['view'];

    if (typeof view === 'string') {
        view = this.map.namedViews[view];
    }

    if (!view) {
        return true;
    }

    view = new MapView(this.map, view, true);

    this.map.initialView = view.getInfo();
    return true;
};


MapConfig.prototype.parseGlues = function() {
    var glues = this.mapConfig['glue'];
    this.map.glues = [];

    if (glues == null) {
        return true;
    }

    for (var i = 0, li = glues.length; i < li; i++) {
        var surface = new MapSurface(this.map, glues[i], 'glue');
        this.map.addGlue(surface.id.join(';'), surface);
    }

    return true;
};


MapConfig.prototype.parseBoundLayers = function() {
    var layers = this.mapConfig['boundLayers'];
    this.map.boundLayers = [];

    if (layers == null) {
        return true;
    }

    for (var key in layers) {
        var layer = new MapBoundLayer(this.map, layers[key], key);
        this.map.addBoundLayer(key, layer);
    }

    return true;
};


MapConfig.prototype.parseFreeLayers = function() {
    var layers = this.mapConfig['freeLayers'];
    this.map.freeLayers = [];

    if (layers == null) {
        return true;
    }

    for (var key in layers) {
        var layer = new MapSurface(this.map, layers[key], 'free');
        this.map.addFreeLayer(key, layer);
    }

    return true;
};


MapConfig.prototype.parseStylesheets = function() {
    var styles = this.mapConfig['stylesheets'];
    this.map.stylesheets = [];

    if (styles == null) {
        return true;
    }

    for (var key in styles) {
        var style = new MapStylesheet(this.map, key, styles[key]);
        this.map.addStylesheet(key, style);
    }

    return true;
};


MapConfig.prototype.parseParams = function() {
    return true;
};


MapConfig.prototype.parseBrowserOptions = function() {
    var options = this.mapConfig['browserOptions'];
    this.map.browserOptions = {};
    
    if (options == null) {
        return true;
    }
    
    this.map.browserOptions = JSON.parse(JSON.stringify(options));
    return true;
};


MapConfig.prototype.cloneConfig = function() {
    var json = JSON.parse(JSON.stringify(this.mapConfig));
    return json;
};


/* harmony default export */ __webpack_exports__["a"] = (MapConfig);


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_geographiclib__);





//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var GeographicLib = __WEBPACK_IMPORTED_MODULE_2_geographiclib___default.a;


var MapConvert = function(map) {
    this.map = map;
    this.renderer = map.renderer;
    this.config = map.config;
    this.measure = map.measure;
    this.isProjected = this.map.getNavigationSrs().isProjected();
};


MapConvert.prototype.convertCoords = function(coords, source, destination) {
    return this.map.referenceFrame.convertCoords(coords, source, destination);
};


MapConvert.prototype.movePositionCoordsTo = function(position, azimuth, distance, azimuthCorrectionFactor) {
    var coords = position.getCoords();
    var navigationSrsInfo = this.map.getNavigationSrs().getSrsInfo();
    azimuthCorrectionFactor = (azimuthCorrectionFactor == null) ? 1 : azimuthCorrectionFactor; 

    if (this.isProjected) {
        var yaw = math.radians(azimuth);
        var forward = [-Math.sin(yaw), Math.cos(yaw)];

        position.setCoords2([coords[0] + (forward[0]*distance),
            coords[1] + (forward[1]*distance)]);
    } else {
        var geod = this.measure.getGeodesic();

        var r = geod.Direct(coords[1], coords[0], azimuth, distance);
        position.setCoords2([r.lon2, r.lat2]);

        var orientation = position.getOrientation();

        //console.log("corerction: " + (r.azi1 - r.azi2));

        orientation[0] -= (r.azi1 - r.azi2) * azimuthCorrectionFactor;
        //orientation[0] -= (r.azi1 - r.azi2); 

        //if (!skipOrientation) {
        position.setOrientation(orientation);
        //}
        
        //console.log("azimuthCorrection: " + azimuthCorrectionFactor);
        //console.log("oldpos: " + JSON.stringify(this));
        //console.log("newpos: " + JSON.stringify(pos2));
    }
    
    return position;
};


MapConvert.prototype.convertPositionViewMode = function(position, mode) {
    if (mode == position.pos[0]) {
        return position;
    }

    if (mode == 'obj') {
        if (position.getHeightMode() == 'float') {
            var covertToFloat = true;
            this.convertPositionHeightMode(position, 'fix', true);
        }
        
        var distance = position.getViewDistance(), coords;
        var orientation = position.getOrientation();
        
        //get height delta
        var pich = math.radians(-orientation[1]);
        var heightDelta = distance * Math.sin(pich);

        //reduce distance by pich
        distance *= Math.cos(pich);

        if (this.isProjected) {
            //get forward vector
            var yaw = math.radians(orientation[0]);
            var forward = [-Math.sin(yaw), Math.cos(yaw)];
    
            //get center coords 
            coords = position.getCoords();
            coords[0] = coords[0] + (forward[0] * distance);
            coords[1] = coords[1] + (forward[1] * distance);
        } else {
            this.movePositionCoordsTo(position, -orientation[0], distance);
            coords = position.getCoords();
        }
        
        coords[2] -= heightDelta;
        position.setCoords(coords);

        if (covertToFloat) {
            this.convertPositionHeightMode(position, 'float', true);
        }
        
    } else if (mode == 'subj') {
        coords = this.getPositionCameraCoords(position, position.getHeightMode());
        position.setCoords(coords);
                
        //TODO: take in accout planet ellipsoid
    }

    position.pos[0] = mode;

    return position;
};


MapConvert.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {
    if (position.pos[3] == mode) {
        return position;
    }

    var lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
    var height = this.measure.getSurfaceHeight(position.getCoords(), lod);

    if (!height[1] && !noPrecisionCheck) {
        //return null;
    }

    //set new height
    if (mode == 'float') {
        position.pos[3] = mode;
        position.pos[4] = position.pos[4] - height[0];
    } else if (mode == 'fix') {
        position.pos[3] = mode;
        position.pos[4] = position.pos[4] + height[0];
    }

    return position;
};


MapConvert.prototype.getPositionCameraCoords = function(position, heightMode) {
    var orientation = position.getOrientation();
    var rotMatrix = mat4.create();
    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(orientation[1])), rotMatrix);

    var coords, terrainHeight = 0, surfaceHeight, lod = -1;

    if (position.getViewMode() == 'obj') {
        coords = position.getCoords();

        //convert height to fix
        if (position.getHeightMode() == 'float') {
            lod = this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
            terrainHeight = surfaceHeight[0];
        }

        var camInfo = this.measure.getPositionCameraInfo(position, this.isProjected);

        if (this.isProjected) {
            //var distance = (this.getViewExtent()) / Math.tan(math.radians(this.getFov()*0.5));
            //var orbitPos = [0, -distance, 0];
            //math.mat4.multiplyVec3(rotMatrix, orbitPos);

            coords[0] += camInfo.orbitCoords[0];
            coords[1] += camInfo.orbitCoords[1];
            coords[2] += camInfo.orbitCoords[2] + terrainHeight;
        } else {
            var worldPos = this.convertCoords([coords[0], coords[1], coords[2] + terrainHeight], 'navigation', 'physical');
            worldPos[0] += camInfo.orbitCoords[0];
            worldPos[1] += camInfo.orbitCoords[1];
            worldPos[2] += camInfo.orbitCoords[2];// + terrainHeight;

            coords = this.convertCoords(worldPos, 'physical', 'navigation');
        }

        if (heightMode == 'fix') {
            return coords;
        } else {
            //get float height for new coords
            if (lod == -1) {
                lod =  this.measure.getOptimalHeightLod(coords, position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            }
            
            surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
            coords[2] -= surfaceHeight[0];

            return coords;
        }

    } else {

        if (position.getHeightMode() == heightMode) {
            return position.getCoords();
        } else {
            lod =  this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
            surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
            //height += surfaceHeight[0];

            coords = position.getCoords();

            if (heightMode == 'fix') {
                coords[2] += surfaceHeight[0];
            } else {
                coords[2] -= surfaceHeight[0];
            }

            return coords;
        }
    }
};


MapConvert.prototype.getPositionNavCoordsFromPublic = function(position, lod) {
    var coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0]; 
    }

    return this.convertCoords(coords, 'public', 'navigation');
};

MapConvert.prototype.getPositionPublicCoords = function(position, lod) {
    var coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0]; 
    }

    return this.convertCoords(coords, 'navigation', 'public');
};


MapConvert.prototype.getPositionPhysCoords = function(position, lod, includeSE) {
    var coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0]; 
    }

    if (this.renderer.useSuperElevation && includeSE) {
        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);
    }

    return this.convertCoords(coords, 'navigation', 'physical');
};


MapConvert.prototype.getPositionCameraSpaceCoords = function(position, lod) {
    var coords = position.getCoords();

    if (position.getHeightMode() == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(position.getCoords(), position.getViewExtent(), this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(position.getCoords(), lod);
        coords[2] += surfaceHeight[0]; 
    }

    if (this.renderer.useSuperElevation) {
        coords[2] = this.renderer.getSuperElevatedHeight(coords[2]);
    }

    var worldPos = this.convertCoords(coords, 'navigation', 'physical');
    var camPos = this.map.camera.position;
    worldPos[0] -= camPos[0];
    worldPos[1] -= camPos[1];
    worldPos[2] -= camPos[2];
  
    return worldPos;
};


MapConvert.prototype.getPositionCanvasCoords = function(position, lod, physical, containsSE) {
    var worldPos;
    if (physical) {
        var camPos = this.map.camera.position;
        var coords = position.getCoords();

        if (this.renderer.useSuperElevation && !containsSE) {
            coords = this.renderer.transformPointBySE(coords);
        }

        worldPos = [coords[0] - camPos[0], coords[1] - camPos[1], coords[2] - camPos[2]];
    } else {
        worldPos = this.getPositionCameraSpaceCoords(position, lod);
    }
    
    return this.map.renderer.project2(worldPos, this.map.camera.getMvpMatrix());
};


MapConvert.prototype.transformPhysCoordsBySE = function(coords) {
    if (!this.renderer.useSuperElevation) {
        return coords;
    }

    return this.renderer.transformPointBySE(coords);
};


MapConvert.prototype.convertCoordsFromPhysToNav = function(coords, mode, lod, containsSE) {
    coords = this.convertCoords(coords, 'physical', 'navigation');

    if (this.renderer.useSuperElevation && containsSE) {
        coords[2] = this.renderer.getUnsuperElevatedHeight(coords[2]);
    }

    if (mode == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(coords, 10, this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(coords, lod);
        coords[2] -= surfaceHeight[0]; 
    } 

    return coords;
};


MapConvert.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {
    var geod, r, length, azimuth, minStep, d;
    var navigationSrsInfo = this.measure.navigationSrsInfo;
    var dx = coords2[0] - coords[0];
    var dy = coords2[1] - coords[1];
    var dz = coords2[2] - coords[2];

    if (this.isProjected) {
        length = Math.sqrt(dx*dx + dy*dy + dz*dz);
        minStep = 1000000; //just big number
    } else {
        geod = this.measure.getGeodesic();
        r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);
        length = r.s12;
        azimuth = r.azi1;
        minStep = 10 * ((navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5); //aprox 100km for earth
    }

    var points = [coords];
    var distance = minStep;

    for (;distance < length; distance += minStep) {
        d = distance / length;

        if (this.isProjected) {
            points.push([ coords[0] + dx * d, coords[1] + dy * d, coords[2] + dz * d ]);
        } else {
            r = geod.Direct(coords[1], coords[0], azimuth, distance);
            points.push([r.lon2, r.lat2, coords[2] + dz * d]);
        }
    }

    points.push(coords2);

    return points;
};

/* harmony default export */ __webpack_exports__["a"] = (MapConvert);


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapDivisionNode = function(map, id, srs, extents, heightRange, partitioning) {
    this.map = map;
    this.id = id;
    this.srs = this.map.getMapsSrs(srs);
    this.extents = extents;
    this.heightRange =  heightRange;
    this.partitioning = partitioning;
    this.isPole = (id[0] == 1 && ((id[1] == 0 && id[2] == 1)||(id[1] == 1 && id[2] == 0)));
};


MapDivisionNode.prototype.getInnerCoords = function (coords) {
    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());
};


MapDivisionNode.prototype.getOuterCoords = function (coords) {
    return this.srs.convertCoordsTo(coords, this.map.getNavigationSrs());
};


MapDivisionNode.prototype.getPhysicalCoords = function (coords, skipVerticalAdjust) {
    return this.srs.convertCoordsTo(coords, this.map.getPhysicalSrs(), skipVerticalAdjust);
};


MapDivisionNode.prototype.getPhysicalCoordsFast = function (coords, skipVerticalAdjust, coords2, index, index2) {
    return this.srs.convertCoordsToFast(coords, this.map.getPhysicalSrs(), skipVerticalAdjust, coords2, index, index2);
};


MapDivisionNode.prototype.getExtents = function (coords) {
    return this.srs.convertCoordsFrom(coords, this.map.getNavigationSrs());
};


/* harmony default export */ __webpack_exports__["a"] = (MapDivisionNode);


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geodata_view__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);




//get rid of compiler mess
var MapGeodataView = __WEBPACK_IMPORTED_MODULE_0__geodata_view__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];


var MapDrawTiles = function(map, draw) {
    this.map = map;
    this.config = map.config;
    this.isProjected = this.map.getNavigationSrs().isProjected();
    this.stats = map.stats;
    this.draw = draw;
    this.debug = draw.debug;
    this.core = map.core;
    this.camera = map.camera;

    this.renderer = map.renderer;

    this.getTextSize = this.renderer.draw.getTextSize.bind(this.renderer.draw);
    this.drawText = this.renderer.draw.drawText.bind(this.renderer.draw);
};


MapDrawTiles.prototype.drawSurfaceTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    if (this.stats.gpuRenderUsed >= this.draw.maxGpuUsed) {
        return false;
    }

    tile.renderReady = false;
    
    if (tile.surface) {
        if (node.hasGeometry()) {

            if (this.debug.drawBBoxes && !preventRedener) {
                if (tile.surface.geodata || !this.debug.drawGeodataOnly) {
                    this.drawTileInfo(tile, node, cameraPos, tile.surfaceMesh, pixelSize);
                }
            }

            if (this.debug.heightmapOnly && !preventRedener) {
                if (!tile.surface.geodata) {
                    tile.drawGrid(cameraPos);
                }
                return true;
            }
           
            if (!preventRedener) {
                this.stats.renderedLods[tile.id[0]]++;
                this.stats.drawnTiles++;

                if (tile.surface.geodata && this.renderer.drawnGeodataTilesUsed) {    //used in scr-count2 !!! legacy mode, do not remove

                    var pp = this.renderer.project2(
                        [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 - cameraPos[0],
                         (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 - cameraPos[1],
                         (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 - cameraPos[2]],
                         this.camera.getMvpMatrix());

                    if (!(pp[0] < 0 || pp[1] < 0 || pp[0] > this.renderer.curSize[0] || pp[1] > this.renderer.curSize[1])) {
                        this.stats.drawnGeodataTilesPerLayer++;
                        this.stats.drawnGeodataTilesFactor += Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), 0.5);
                    }

                    this.stats.drawnGeodataTiles++;
                }
            }

            var count = 0;
           
            do {

                if (tile.resetDrawCommands) {
                    tile.drawCommands = [[], [], []];
                    tile.updateBounds = true;
            
                    if (tile.bounds) {
                        for (var key in tile.bounds) {
                            tile.bounds[key].viewCoutner = 0; 
                        }
                    }
                    
                    tile.resetDrawCommands = false;
                }

                var ret;

                if (!tile.surface.geodata) {
                    ret = this.drawMeshTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);
                } else {
                    ret = this.drawGeodataTile(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu);
                }

                //if (count > 0) console.log('loop: ' + count);

                count++;

                if (count > 10) {
                    break; //prevent infinite loop
                }

            } while(tile.resetDrawCommands);

            return ret;
        } else {
            return true;
        }
    } else {
        if (!preventRedener && tile.lastRenderState) {
            var channel = this.draw.drawChannel;
            this.draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
            this.map.applyCredits(tile);
            return true;
        }
    }
};



MapDrawTiles.prototype.drawMeshTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    var path;

    if (!tile.surfaceMesh) {
        if (tile.resourceSurface.virtual) {
            return true;
        }
        
        path = tile.resourceSurface.getMeshUrl(tile.id);
        tile.surfaceMesh = tile.resources.getMesh(path, tile);
    }

    var draw = this.draw, texture, layer, credits;
    var channel = draw.drawChannel;
    var ret = false;

    //we have commnad so we can draw them
    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
        if (!preventRedener) {
            draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
            this.map.applyCredits(tile);
        }

        tile.lastRenderState = null;
        return true;
    } else if (tile.lastRenderState){ //we do not have cammnds or command are not redy yet, so we can draw last state if present and ready

        if (tile.surfaceMesh.isReady(true, priority, doNotCheckGpu) && tile.drawCommands[channel].length > 0) {
            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                return true; // commands are generated so we can return from function here
            } // else ret = false
        } else {
            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                ret = true;
            }
        }
    }

    if (tile.drawCommands[channel].length > 0) {  //command are generated but not ready, we can return from the function

        if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {
            tile.drawGrid(cameraPos);
            return false;
        } else {
            return false;
        }
    } 

    // information about support for extarnal or internal textures are present in the mesh,  
    // so we have to wait until is mesh ready and then we can generate commands
    if (tile.surfaceMesh.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {
        var submeshes = tile.surfaceMesh.submeshes;

        tile.drawCommands = [[], [], []]; //??
        tile.imageryCredits = {};
        tile.boundsDebug = {}; //used for inspector

        var specificity = 0;
        var i, li, j, lj, k, lk, surface;

        surface = tile.resourceSurface;

        if (!surface) {
            surface = tile.surface;
        }
        
        if (surface.glue) {

            var surfaces = surface.id; 
            for (i = 0, li = surfaces.length; i < li; i++) {
                var surface2 = this.map.getSurface(surfaces[i]);
                if (surface2) {
                    specificity = Math.max(specificity, surface2.specificity);
                }
            }

            //set credits
            for (k = 0, lk = node.credits.length; k < lk; k++) {
                tile.glueImageryCredits[node.credits[k]] = specificity;  
            }

        } else {

            specificity = surface.specificity;

            //set credits
            for (k = 0, lk = node.credits.length; k < lk; k++) {
                tile.imageryCredits[node.credits[k]] = specificity;  
            }
        }


        for (i = 0, li = submeshes.length; i < li; i++) {

            var submesh = submeshes[i];
            
            //debug bbox
            if (this.debug.drawBBoxes && this.debug.drawMeshBBox && !preventRedener) {
                submesh.drawBBox(cameraPos);
            }

            if (submesh.externalUVs) {
                if (tile.updateBounds) {
                    tile.updateBounds = false;
                    
                    this.updateTileBounds(tile, submeshes);
                }
                
                surface = tile.resourceSurface;
                if (tile.resourceSurface.glue /*&& submesh.surfaceReference != 0*/) { //glue have multiple surfaces per tile
                    surface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
                }

                if (surface != null) {
                    var bounds = tile.bounds[surface.id];
                    
                    if (bounds) {
                        if (submesh.externalUVs) {

                            //draw bound layers
                            if (bounds.sequence.length > 0) {
                                if (bounds.transparent) {
                                    if (submesh.internalUVs) {  //draw surface
                                        if (tile.surfaceTextures[i] == null) {
                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                                        }
                                                
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : tile.surfaceTextures[i],
                                            material : 5
                                        });
                                    }
    
                                    tile.drawCommands[0].push({
                                        type : 1,
                                        state : draw.drawBlendedTileState
                                    });            
                                    
                                    var layers = bounds.sequence;
                                    for (j = 0, lj = layers.length; j < lj; j++) {
                                        texture = tile.boundTextures[layers[j]];
                                        if (texture) {

                                            //debug stuff
                                            if (!tile.boundsDebug[surface.id]) {
                                                tile.boundsDebug[surface.id] = [];
                                            }
                                            tile.boundsDebug[surface.id].push(layers[j]);

                                            //set credits
                                            layer = tile.boundLayers[layers[j]];
                                            credits = layer.credits;
                                            for (k = 0, lk = credits.length; k < lk; k++) {
                                                tile.imageryCredits[credits[k]] = layer.specificity;  
                                            }

                                            tile.drawCommands[0].push({
                                                type : 2,
                                                mesh : tile.surfaceMesh,
                                                submesh : i,
                                                texture : texture,
                                                alpha : bounds.alpha[layers[j]][1],
                                                material : 7,
                                                layer : layer,
                                                surface : surface
                                            });
                                        }
                                    }
                                    
                                    tile.drawCommands[0].push({
                                        type : 2,
                                        mesh : tile.surfaceMesh,
                                        submesh : i,
                                        texture : null,
                                        material : 3
                                    });                                                

                                    tile.drawCommands[0].push({
                                        type : 1,
                                        state : draw.drawTileState
                                    });  
                                } else {
                                    var layerId = bounds.sequence[bounds.sequence.length-1];
                                    texture = tile.boundTextures[layerId];
                                    if (texture) {

                                        //debug stuff
                                        if (!tile.boundsDebug[surface.id]) {
                                            tile.boundsDebug[surface.id] = [];
                                        }
                                        tile.boundsDebug[surface.id].push(layerId);
                                        
                                        //set credits
                                        layer = tile.boundLayers[layerId];
                                        credits = layer.credits;
                                        for (k = 0, lk = credits.length; k < lk; k++) {
                                            tile.imageryCredits[credits[k]] = layer.specificity;  
                                        }
                                        
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : texture,
                                            material : 6,
                                            layer : layer,
                                            surface : surface
                                        });
                                    }
                                }
                               
                            } else {
                                if (submesh.textureLayer) {
                                    
                                    layer = this.map.getBoundLayerByNumber(submesh.textureLayer);
                                    
                                    if (layer) {
                                        texture = tile.boundTextures[layer.id];
                                        
                                        if (texture) {
                                            
                                            //debug stuff
                                            if (!tile.boundsDebug[surface.id]) {
                                                tile.boundsDebug[surface.id] = [];
                                            }
                                            tile.boundsDebug[surface.id].push(layer.id);
                                            
                                            //set credits
                                            layer = tile.boundLayers[layer.id];
                                            credits = layer.credits;
                                            for (k = 0, lk = credits.length; k < lk; k++) {
                                                tile.imageryCredits[credits[k]] = layer.specificity;  
                                            }
                                            
                                            //draw mesh
                                            tile.drawCommands[0].push({
                                                type : 2,
                                                mesh : tile.surfaceMesh,
                                                submesh : i,
                                                texture : texture,
                                                material : 6,
                                                layer : layer,
                                                surface : surface
                                            });
                                        }
                                    }
                                   
                                } else {
    
                                    if (submesh.internalUVs) {  //draw surface
                                        if (tile.surfaceTextures[i] == null) {
                                            path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                            tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                                        }

                                        //draw mesh
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : tile.surfaceTextures[i],
                                            material : 4
                                        });
                                    } else {
                                        tile.drawCommands[0].push({
                                            type : 2,
                                            mesh : tile.surfaceMesh,
                                            submesh : i,
                                            texture : null,
                                            material : 2
                                        });
                                    }
    
                                }
                            }
    
                        } else if (submesh.internalUVs) {
    
                            if (tile.surfaceTextures[i] == null) {
                                path = tile.resourceSurface.getTextureUrl(tile.id, i);
                                tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                            } //else {
                            tile.drawCommands[0].push({
                                type : 2,
                                mesh : tile.surfaceMesh,
                                submesh : i,
                                texture : tile.surfaceTextures[i],
                                material : 4
                            });                                                
                            //}
                        }
                    }                            
                }
            } else if (submesh.internalUVs) {

                if (tile.surfaceTextures[i] == null) {
                    path = tile.resourceSurface.getTextureUrl(tile.id, i);
                    tile.surfaceTextures[i] = tile.resources.getTexture(path, 0, null, null, tile, true);
                } //else {
                tile.drawCommands[0].push({
                    type : 2,
                    mesh : tile.surfaceMesh,
                    submesh : i,
                    texture : tile.surfaceTextures[i],
                    material : 4
                });                                                
                //}
            }
            
            //depth path
            tile.drawCommands[1].push({
                type : 2,
                mesh : tile.surfaceMesh,
                submesh : i,
                material : 1
            });
            
        }

        if (surface.pipeline > 0) {
            this.updateTileHmap(tile, node);

            for (j = 0; j < 2; j++) {
                var commands = tile.drawCommands[j];
                for (i = 0, li = commands.length; i < li; i++) {
                    if (commands[i].type == 2) {
                        commands[i].pipeline = surface.pipeline;
                        commands[i].hmap = tile.hmap;
                    }
                }
            }
        }

        if (tile.resetDrawCommands) {
            return false;
        }

        if (draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {

            if (tile.resetDrawCommands) {
                return false;
            }

            if (!preventRedener) {
                draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
                this.map.applyCredits(tile);
            }

            tile.lastRenderState = null;
            ret = true;
        } else if (tile.lastRenderState) {

            if (this.draw.areDrawCommandsReady(tile.lastRenderState.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
                if (!preventRedener) {
                    draw.processDrawCommands(cameraPos, tile.lastRenderState.drawCommands[channel], priority, true, tile);
                    this.map.applyCredits(tile);
                }
                ret = true;
            } //else ret = false
        } else {

            if (this.config.mapHeightfiledWhenUnloaded && !preventRedener) {

                //node.drawPlane(cameraPos, tile);
                tile.drawGrid(cameraPos);
                ret = !(tile.drawCommands[channel].length > 0);
            }
        }
        
    } else {

        if (!tile.lastRenderState && this.config.mapHeightfiledWhenUnloaded && !preventRedener) {
            //node.drawPlane(cameraPos, tile);

            tile.drawGrid(cameraPos);
            ret = !(tile.drawCommands[channel].length > 0);
        }        
    }
    
    return ret;
};


MapDrawTiles.prototype.drawGeodataTile = function(tile, node, cameraPos, pixelSize, priority, preventRedener, preventLoad, doNotCheckGpu) {
    if (tile.id[0] <= 1) {
        return true;
    }

    if (tile.surfaceGeodata == null) {
        var path;
        
        if (tile.surface.geodataNavtileInfo) {  //remove this code??? no longer used
            var navtile = this.tree.findNavTile(tile.id);
            
            if (navtile && navtile.surface) {
                var navtileStr = navtile.surface.getNavUrl(navtile.id) + ';'
                                  + navtile.id[0] + '-' + navtile.id[1] + '-' + navtile.id[2] + ';'      
                                  + navtile.metanode.minHeight + ';' + navtile.metanode.maxHeight;     
                path = tile.surface.getGeodataUrl(tile.id, encodeURIComponent(navtileStr));
            }
        }
        
        if (!path) {
            path = tile.resourceSurface.getGeodataUrl(tile.id, '');
        }

        tile.surfaceGeodata = tile.resources.getGeodata(path, {tile:tile, surface:tile.surface});
    }

    var channel = this.draw.drawChannel;
    
    if (tile.geodataCounter != tile.surface.geodataCounter) {
        tile.drawCommands = [[],[],[]];

        if (tile.surfaceGeodataView != null) {
            tile.surfaceGeodataView.kill();
        }
        
        tile.surfaceGeodataView = null;
        tile.geodataCounter = tile.surface.geodataCounter;
    }

    if (tile.drawCommands[channel].length > 0 && this.draw.areDrawCommandsReady(tile.drawCommands[channel], priority, preventLoad, doNotCheckGpu)) {
        if (!preventRedener) {
            this.draw.processDrawCommands(cameraPos, tile.drawCommands[channel], priority, null, tile);
            this.map.applyCredits(tile);
        }
        tile.lastRenderState = null;
        return true;
    }

    if (!tile.surfaceGeodataView) {
        if (tile.surfaceGeodata.isReady(preventLoad, priority, doNotCheckGpu) && !preventLoad) {
            tile.surfaceGeodataView = new MapGeodataView(this.map, tile.surfaceGeodata, {tile:tile, surface:tile.surface});
        }
    }

    if (tile.surfaceGeodataView) {
        tile.mapdataCredits = {};
        
        var specificity = (tile.surface) ? tile.surface.specificity : 0;

        //set credits
        for (var k = 0, lk = node.credits.length; k < lk; k++) {
            tile.mapdataCredits[node.credits[k]] = specificity;  
        }

        tile.drawCommands[channel][0] = {
            type : 3,
            geodataView : tile.surfaceGeodataView 
        };

        return tile.surfaceGeodataView.isReady();
    }

    return false;
};


MapDrawTiles.prototype.updateTileHmap = function(tile, node) {
    if (node && node.hasNavtile() && tile.surface) { 

        if (!tile.surface || !tile.resourceSurface) { //surface.virtual) {
            return false; //is it best way how to do it?
        }
            
        if (!tile.resourceSurface.getHMapUrl) { //virtual surface is as resource surface. Is it bug??!!
            return false; //is it best way how to do it?
        }
            
        var path = tile.resourceSurface.getHMapUrl(tile.id, true);
        tile.hmap = tile.resources.getTexture(path);

        //var path = tile.surface.getNavUrl(tile.id);
        //tile.hmap = tile.resources.getTexture(path, null, null, null, tile, true);
    } else {

        //get parent with nav tile
        var parent = tile.parent;
        var extraBound = null; 

        while(parent && parent.id[0] > 0) {
            if (parent.metanode && parent.metanode.hasNavtile()) {
                extraBound = {
                    sourceTile : parent,
                    sourceTexture : null,
                    hmap : true,
                    tile : tile 
                };

                break;
            }

            parent = parent.parent;
        }

        //does parent with navtile exist
        if (extraBound) {
            var path = tile.resourceSurface.getHMapUrl(tile.id, true);
            tile.hmap = tile.resources.getTexture(path, null, extraBound, {tile: tile, hmap: true}, tile, false);

            if (tile.hmap.neverReady) {
                tile.hmap = null;
            }
        } else {
            tile.hmap = null;
        }
    }
};


MapDrawTiles.prototype.updateTileBounds = function(tile, submeshes) {
    for (var i = 0, li = submeshes.length; i < li; i++) {
        var submesh = submeshes[i];
        
        if (submesh.externalUVs) {
            var submeshSurface = tile.resourceSurface;

            //if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile
              //  submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
            //}

            if (tile.resourceSurface.glue) { //glue have multiple surfaces per tile
                submeshSurface = tile.resourceSurface.getSurfaceReference(submesh.surfaceReference);
            }

            
            if (submeshSurface) {
                var bounds = tile.bounds[submeshSurface.id];
                
                if (!bounds) {
                    bounds = {
                        sequence : [],
                        alpha : [],
                        transparent : false,
                        viewCoutner : 0
                    };
                    
                    tile.bounds[submeshSurface.id] = bounds;
                } 
                
                if (bounds.viewCoutner != tile.viewCoutner) {
                    this.updateTileSurfaceBounds(tile, submesh, submeshSurface, bounds, bounds.viewCoutner != tile.viewCoutner);
                    //bounds.viewCoutner = tile.viewCoutner;
                }  
            }
        }
    }

    for (var key in tile.bounds) {
        tile.bounds[key].viewCoutner = tile.viewCoutner;
    }
};


MapDrawTiles.prototype.getParentTile = function(tile, lod) {
    while(tile && tile.id[0] > lod) {
        tile = tile.parent;
    }
    
    return tile;
};


MapDrawTiles.prototype.getTileTextureTransform = function(sourceTile, targetTile) {
    var shift = targetTile.id[0] - sourceTile.id[0];
    var x = sourceTile.id[1] << shift;
    var y = sourceTile.id[2] << shift;
    var s = 1.0 / Math.pow(2.0, shift);
    return [ s, s, (targetTile.id[1] - x) * s, (targetTile.id[2] - y) * s ];
};


MapDrawTiles.prototype.updateTileSurfaceBounds = function(tile, submesh, surface, bound, fullUpdate) {
    var path, extraBound, layer, texture;

    if (this.config.mapNoTextures) {
        return;
    }

    //search map view
    if (surface.boundLayerSequence.length > 0) {
        if (fullUpdate) {
            bound.sequence = [];
            var sequenceFullAndOpaque = [];
            var sequenceMaskPosible = [];
            var fullAndOpaqueCounter = 0;
            
            for (var j = 0, lj = surface.boundLayerSequence.length; j < lj; j++) {
                layer = surface.boundLayerSequence[j][0];
                
                if (layer && layer.ready && layer.hasTileOrInfluence(tile.id) && surface.boundLayerSequence[j][1] > 0) {
                    extraBound = null; 
                    
                    if (tile.id[0] > layer.lodRange[1]) {
                        extraBound = {
                            sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                            sourceTexture : null,
                            layer : layer,
                            tile : tile 
                        };
                    }

                    texture = tile.boundTextures[layer.id];

                    if (!texture) { //TODO: make sure that we load only textures which we need  
                        path = layer.getUrl(tile.id);
                        texture = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);

                        if (texture.checkType == 1) {
                            texture.checkMask = true;
                        }

                        texture.isReady(true); //check for mask but do not load
                        tile.boundTextures[layer.id] = texture; 
                    } 

                    if (texture.neverReady) {
                        continue; //do not use this layer
                    }

                    var maskPosible = false;
                    var skipOther = false;

                    if (texture.isMaskPosible()) {
                        if (texture.isMaskInfoReady()) {
                            if (texture.getMaskTexture()) {
                                bound.transparent = true;
                                maskPosible = true;
                            }
                        } else {
                            skipOther = true;
                            maskPosible = true;
                        }
                    }

                    sequenceMaskPosible.push(maskPosible);
                    
                    //var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || texture.extraBound || texture.getMaskTexture() || layer.isTransparent);
                    var fullAndOpaque = !((surface.boundLayerSequence[j][1] < 1.0) || maskPosible || layer.isTransparent);
                    if (fullAndOpaque) {
                        fullAndOpaqueCounter++;
                    }
                            
                    sequenceFullAndOpaque.push(fullAndOpaque);
                    
                    bound.sequence.push(layer.id);
                    bound.alpha[layer.id] = surface.boundLayerSequence[j];
                    tile.boundLayers[layer.id] = layer;
                    if (bound.alpha[layer.id][1] < 1.0 || layer.isTransparent) {
                        bound.transparent = true;
                    }

                    if (skipOther) {
                        break; //wait until mask info is loaded
                    }
                }
            }

            //filter out extra bounds if they are not needed
            //and remove all layer after first FullAndOpaque 
            if (fullAndOpaqueCounter > 0) {
                var newSequence = [];
                
                for (var i = bound.sequence.length - 1; i >= 0; i--) {
                    var layerId = bound.sequence[i];
                    
                    if (sequenceFullAndOpaque[i]) {
                        newSequence.unshift(layerId);   
                        break;
                    } else {
                        texture = tile.boundTextures[layerId];

                        if (bound.alpha[layerId][1] < 1.0 ||
                            tile.boundLayers[layerId].isTransparent ||
                            (sequenceMaskPosible[i] /*texture.getMaskTexture() /*&& !texture.extraBound*/)) {
                            newSequence.unshift(layerId);    
                        }
                    }
                }
                
                bound.sequence = newSequence; 
            }
            
        }
    } else if (surface.textureLayer != null) { //search surface
        if (fullUpdate) {
            layer = this.map.getBoundLayerById(surface.textureLayer);
            if (layer && layer.hasTileOrInfluence(tile.id)) {
                extraBound = null; 
                
                if (tile.id[0] > layer.lodRange[1]) {
                    extraBound = {
                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                        sourceTexture : null,
                        layer : layer,
                        tile : tile 
                    };
                }

                bound.sequence.push(layer.id);
                tile.boundLayers[layer.id] = layer;
                if (!tile.boundTextures[layer.id]) {
                    path = layer.getUrl(tile.id);
                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);
                }
            }
        }
    } else { //search submeshes
        if (submesh.textureLayer != 0) {
            layer = this.map.getBoundLayerByNumber(submesh.textureLayer);

            if (layer && layer.hasTileOrInfluence(tile.id)) {
                extraBound = null; 
                
                if (tile.id[0] > layer.lodRange[1]) {
                    extraBound = {
                        sourceTile : this.getParentTile(tile, layer.lodRange[1]),
                        sourceTexture : null,
                        layer : layer,
                        tile : tile 
                    };
                }

                //submeshes[j].textureLayerId = tile.id;
                tile.boundLayers[layer.id] = layer;
                if (!tile.boundTextures[layer.id]) {
                    path = layer.getUrl(tile.id);
                    tile.boundTextures[layer.id] = tile.resources.getTexture(path, layer.dataType, extraBound, {tile: tile, layer: layer}, tile, false);
                }
            }
        }
    }
};


MapDrawTiles.prototype.drawTileInfo = function(tile, node, cameraPos, mesh) {
    var debug = this.debug, pos;

    if (!debug.drawMeshBBox) {
        node.drawBBox(cameraPos);
    }

    //get screen pos of node
    if (node.metatile.useVersion < 4) {
        var min = node.bbox.min;
        var max = node.bbox.max;
    
        pos =  this.core.getRendererInterface().getCanvasCoords(
            [(min[0] + (max[0] - min[0])*0.5) - cameraPos[0],
                (min[1] + (max[1] - min[1])*0.5) - cameraPos[1],
                (max[2]) - cameraPos[2]],
             this.camera.getMvpMatrix());
    
        pos[2] = pos[2] * 0.9992;
    } else {
        var dx = node.bbox2[3] - node.bbox2[0]; 
        var dy = node.bbox2[4] - node.bbox2[1]; 
        var dz = node.bbox2[5] - node.bbox2[2]; 
    
        var d = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
        pos =  this.core.getRendererInterface().getCanvasCoords(
            [(node.bbox2[12] + node.bbox2[15] + node.bbox2[18] + node.bbox2[21])*0.25 + node.diskNormal[0] * d*0.1 - cameraPos[0],
                (node.bbox2[13] + node.bbox2[16] + node.bbox2[19] + node.bbox2[22])*0.25 + node.diskNormal[1] * d*0.1 - cameraPos[1],
                (node.bbox2[14] + node.bbox2[17] + node.bbox2[20] + node.bbox2[23])*0.25 + node.diskNormal[2] * d*0.1 - cameraPos[2]],
             this.camera.getMvpMatrix());
        
        /*
            var pos =  this.core.getRendererInterface().getCanvasCoords(
                            [(node.diskPos[0] + node.diskNormal[0] * node.bboxHeight) - cameraPos[0],
                             (node.diskPos[1] + node.diskNormal[1] * node.bboxHeight) - cameraPos[1],
                             (node.diskPos[2] + node.diskNormal[2] * node.bboxHeight) - cameraPos[2]],
                             this.camera.getMvpMatrix());
        */
    }

    var factor = debug.debugTextSize, text, i, li,c;

    //draw lods
    if (debug.drawLods) {
        text = '' + tile.id[0]; // + ' ta:' + Math.abs(tile.tiltAngle).toFixed(3);
        //text = '' + tile.id[0] + ' c:' + (50*(Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR) / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))).toFixed(3) + 
          //     ' l:' + Math.pow(Math.abs(tile.tiltAngle * tile.texelSize), VTS_TILE_COUNT_FACTOR).toFixed(3) + ' g:' + this.renderer.drawnGeodataTilesFactor.toFixed(3);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-4*factor), 4*factor, text, [1,0,0,1], pos[2]);
    }

    //draw indices
    if (debug.drawIndices) {
        text = '' + tile.id[1] + ' ' + tile.id[2];
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-11*factor), 4*factor, text, [0,1,1,1], pos[2]);
    }

    //draw positions
    if (debug.drawPositions) {
        //text = "" + min[0].toFixed(1) + " " + min[1].toFixed(1) + " " + min[2].toFixed(1);
        //text = "" + Math.floor(node.corners[0]) + " " + Math.floor(node.corners[1]) + " " + Math.floor(node.corners[2]) + " " + Math.floor(node.corners[3]);
        
        var b = node.border2;
        if (b) {
            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);
            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);
        }

        b = node.border;
        if (b) {
            text = '' + Math.floor(b[0]) + ' ' + Math.floor(b[1]) + ' ' + Math.floor(b[2]) + ' ' + Math.floor(b[3]) + ' ' + Math.floor(b[4]) + ' ' + Math.floor(b[5]) + ' ' + Math.floor(b[6]) + ' ' + Math.floor(b[7]) + ' ' + Math.floor(b[8]);
            this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,1,1], pos[2]);
        }

        //text = 'llx:' + Math.floor(node.llx) + ' lly:' + Math.floor(node.lly) + ' urx:' + Math.floor(node.urx) + ' ury:' + Math.floor(node.ury);
        //this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+3*factor), 4*factor, text, [0,1,1,1], pos[2]);
    }

    //draw face count
    if (debug.drawFaceCount && mesh) {
        text = '' + mesh.faces + ' - ' + mesh.submeshes.length + ((tile.surface && tile.surface.glue) ? ' - 1' : ' - 0');
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    //draw geodata pixel size
    if (debug.drawGPixelSize) {
        text = '' + ((Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance * 0.70710678118) / node.displaySize).toFixed(2);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    //draw order
    if (debug.drawOrder) {
        text = '' + this.drawTileCounter + ' cmds: ' + (tile.drawCommands[0].length);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [0,1,0,1], pos[2]);
    }

    if (debug.drawSurfaces || debug.drawSurfaces2) {
        text = JSON.stringify(tile.surface.id);

        if (debug.drawSurfaces2) {
            //c = utils.getHashColor(text);
            c = utils.getHashColor2(tile.surface.surfaceCounter);
            //c = [c[0]/255,c[1]/255,c[2]/255,1];
            c = [c[0],c[1],c[2],1];
        } else {
            c = [1,1,1,1];    
        }

        if (node.alien) {
            text = '[A]' + text;
        }

        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, c, pos[2]);
    }

    if (debug.drawBoundLayers) {
        if (tile.boundsDebug) {
            var surface = tile.resourceSurface;
            if (surface.glue) { 
              
                for (i = 0, li = surface.id.length; i < li; i++) {
                    if (tile.boundsDebug[surface.id[i]]) {
                        text = '< ' + surface.id[i] + ' >';
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(10+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                        text = JSON.stringify(tile.boundsDebug[surface.id[i]]);
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*7*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                    }
                }
                
            } else if (tile.boundsDebug[surface.id]) {
                text = '< ' + surface.id + ' >';
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);
    
                text = JSON.stringify(tile.boundsDebug[surface.id]);
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,1,1,1], pos[2]);
            }
        }
    }

    if (debug.drawCredits) {
        text = '{ ';
       
        for (var key in tile.imageryCredits) {
            if (tile.imageryCredits[key]) {
                text += key + ':' + tile.imageryCredits[key] + ', ';
            }
        }

        for (key in tile.glueImageryCredits) {
            if (!tile.imageryCredits[key]) {
                text += key + ':' + tile.glueImageryCredits[key] + ', ';
                //text += key + ", ";
            }
        }

        text += '}';

        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+10*factor), 4*factor, text, [1,1,1,1], pos[2]);
    }

    //draw distance
    if (debug.drawDistance) {
        text = '' + tile.distance.toFixed(2) + '  ' + tile.texelSize.toFixed(3) + '  ' + node.pixelSize.toFixed(3);
        text += '--' + tile.texelSize2.toFixed(3); 
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+17*factor), 4*factor, text, [1,0,1,1], pos[2]);
    }

    //draw node info
    if (debug.drawNodeInfo) {
        var children = ((node.flags & ((15)<<4))>>4);
        text = 'v' + node.metatile.version + '-' + node.flags.toString(2) + '-' + ((children & 1) ? '1' : '0') + ((children & 2) ? '1' : '0') + ((children & 4) ? '1' : '0') + ((children & 8) ? '1' : '0');
        text += '-' + node.minHeight + '/' + node.maxHeight+ '-' + Math.floor(node.minZ) + '/' + Math.floor(node.maxZ)+ '-' + Math.floor(node.surrogatez);
        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]-18*factor), 4*factor, text, [1,0,1,1], pos[2]);
    }
    
    //draw texture size
    if (debug.drawTextureSize && mesh) {
        var submeshes = mesh.submeshes;
        for (i = 0, li = submeshes.length; i < li; i++) {

            if (submeshes[i].internalUVs) {
                var texture = tile.surfaceTextures[i];
                if (texture) {
                    var gpuTexture = texture.getGpuTexture();
                    if (gpuTexture) {
                        text = '[' + i + ']: ' + gpuTexture.width + ' x ' + gpuTexture.height;
                        this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
                    }
                }
            } else {
                text = '[' + i + ']: 256 x 256';
                this.drawText(Math.round(pos[0]-this.getTextSize(4*factor, text)*0.5), Math.round(pos[1]+(17+i*4*2)*factor), 4*factor, text, [1,1,1,1], pos[2]);
            }
        }
    }

};


/* harmony default export */ __webpack_exports__["a"] = (MapDrawTiles);



/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geodata__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geodata_view__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__draw_tiles__ = __webpack_require__(132);







//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var MapDrawTiles = __WEBPACK_IMPORTED_MODULE_4__draw_tiles__["a" /* default */];
var MapGeodataView = __WEBPACK_IMPORTED_MODULE_3__geodata_view__["a" /* default */];
var MapGeodata = __WEBPACK_IMPORTED_MODULE_2__geodata__["a" /* default */];

var MapDraw = function(map) {
    this.map = map;
    this.config = map.config;
    this.isProjected = map.getNavigationSrs().isProjected();
    this.isGeocent = map.isGeocent;

    this.renderer = map.renderer;
    this.stats = map.stats;
    this.camera = map.camera;
    this.tree = map.tree;

    this.ndcToScreenPixel = this.renderer.curSize[0] * 0.5;

    this.debug = {
        heightmapOnly : false,
        blendHeightmap : true,
        drawBBoxes :  false,
        drawMeshBBox : false,
        drawLods : false,
        drawPositions : false,
        drawTexelSize : false,
        drawWireframe : 0,
        drawTestMode : 0,
        drawTestData : 0,
        drawFaceCount : false,
        drawDistance : false,
        drawMaxLod : false,
        drawGeodataOnly : false,
        drawTextureSize : false,
        drawNodeInfo : false,
        drawLayers : true,
        drawBoundLayers : false,
        drawSurfaces : false,
        drawCredits : false,
        drawOrder : false,
        drawLabelBoxes : false,
        drawAllLabels : false,
        drawHiddenLabels : false,
        drawEarth : true, 
        drawGridCells : false,
        drawTileCounter : 0,
        drawPolyWires : false,
        drawFog : this.config.mapFog,
        drawGPixelSize : false,
        debugTextSize : 2.0,
        ignoreTexelSize : false,
        maxZoom : false
    };

    this.gridFlat = false;
    this.gridGlues = false;
    this.gridSkipped = false;

    this.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
    this.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];
    this.atmoHeight = 50000;
    this.atmoHeightFactor = 1; //this.atmoHeight / 50000;
    this.atmoDensity = 1; //this.atmoHeight / 50000;

    this.fogDensity = 0;
    this.zFactor = 0;
    //this.zFactor2 = 0.000012;
    this.zFactor2 = 0.003;
    this.zbufferOffset = null;    
    this.zShift = 0;
    this.zLastShift = 0;
    this.bestMeshTexelSize = 1;
    this.bestGeodataTexelSize = 1;
    this.log8 = Math.log(8);
    this.log2 = Math.log(2);

    this.geodataTilesPerLayer = 0;

    this.drawCounter = 0;
    this.drawChannel = 0;
    this.drawChannelNames = ['base', 'hit'];

    this.planetRadius = this.isGeocent ? map.getNavigationSrs().getSrsInfo()['a'] : 100;
    this.tileBuffer = new Array(500);
    this.processBuffer = new Array(60000);
    this.processBuffer2 = new Array(60000);
    this.drawBuffer = new Array(60000);
    this.tmpVec3 = new Array(3);
    this.tmpVec5 = new Array(5);
    this.bboxBuffer = new Float32Array(8*3);
    this.planeBuffer = new Float32Array(9*3);

    var gpu = this.renderer.gpu;
    this.drawTileState = gpu.createState({});
    this.drawStardomeState = gpu.createState({zwrite:false, ztest:false});
    this.drawBlendedTileState = gpu.createState({zequal:true, blend:true});
    this.drawAuraState = gpu.createState({zwrite:false, blend:true});
    this.drawAtmoState = gpu.createState({zwrite:false, ztest:false, blend:true});
    this.drawAtmoState2 = gpu.createState({zwrite:false, ztest:true, blend:false});

    this.degradeHorizonFactor = 0;
    this.degradeHorizonTiltFactor = 0;

    this.replay = {
        camera : null,
        drawnTiles : null,
        drawnFreeTiles : null,
        nodeBuffer : null,
        tracedNodes : null,
        tracedFreeNodes : null,
        storeTiles : false,
        storeFreeTiles : false,
        storeNodes : false,
        storeFreeNodes : false,
        storeLoaded : this.config.mapStoreLoadStats,
        drawGlobe : false,
        drawTiles : false,
        drawNodes : false,
        drawFreeTiles : false,
        drawFreeNodes : false,
        drawLoaded : false,
        lod : 30,
        singleLod : false,
        loadedIndex : 0,
        singleLodedIndex : 0,
        loaded : [],
        loadFirst : 0,
        loadLast : 0
    };

    this.drawTiles = new MapDrawTiles(map, this);
};


MapDraw.prototype.drawMap = function(skipFreeLayers) {
    var map = this.map;
    var renderer = this.renderer;
    var camera = this.camera;
    var replay = this.replay;
    var gpu = renderer.gpu;
    var debug = this.debug;

    if (this.drawChannel != 1) {
        gpu.setViewport();

        map.visibleCredits = {
            imagery : {},
            glueImagery : {},
            mapdata : {}
        };
    }

    var projected = this.isProjected;

    switch (this.config.mapGridMode) {
        case 'none':       this.gridSkipped = true; this.gridFlat = false; this.gridGlues = false;  break;
        case 'flat':       this.gridSkipped = false; this.gridFlat = true; this.gridGlues = false;  break;
        case 'linear':     this.gridSkipped = false; this.gridFlat = false; this.gridGlues = true;  break;
        case 'fastlinear': this.gridSkipped = false; this.gridFlat = false; this.gridGlues = false; break;
    }

    var drawTiles = this.drawTiles;
    var camInfo = camera.update();
    var renderer = this.renderer;

    renderer.debugStr = 'AsyncImageDecode: ' + this.config.mapAsyncImageDecode;
    renderer.dirty = true;
    renderer.drawFog = this.debug.drawFog;
    renderer.debug = this.debug; 
    renderer.mapHack = map;

    if (this.config.mapForceFrameTime) {
        if (this.config.mapForceFrameTime != -1) {
            renderer.frameTime = this.config.mapForceFrameTime;
        } else {
            renderer.frameTime = 0;
        }
    } else {
        renderer.frameTime = this.stats.frameTime;        
    }

    renderer.hoverFeatureCounter = 0;
    renderer.hoverFeatureList = map.hoverFeatureList;
    renderer.hoverFeature = map.hoverFeature;

    renderer.cameraPosition = camera.position;
    renderer.cameraOrientation = map.position.getOrientation();
    renderer.cameraTiltFator = Math.cos(math.radians(renderer.cameraOrientation[1]));
    renderer.cameraVector = camera.vector; 
    renderer.cameraViewExtent = map.position.getViewExtent();
    renderer.cameraViewExtent2 = Math.pow(2.0, Math.max(1.0, Math.floor(Math.log(map.position.getViewExtent()) / Math.log(2))));
    renderer.drawLabelBoxes = this.debug.drawLabelBoxes;
    renderer.drawGridCells = this.debug.drawGridCells;
    renderer.drawAllLabels = this.debug.drawAllLabels;
    renderer.drawHiddenLabels = this.debug.drawHiddenLabels;
    renderer.debug = this.debug;
    renderer.fmaxDist = Number.NEGATIVE_INFINITY;
    renderer.fminDist = Number.POSITIVE_INFINITY;


    if (projected) {
        var yaw = math.radians(renderer.cameraOrientation[0]);
        renderer.labelVector = [-Math.sin(yaw), Math.cos(yaw), 0, 0, 0];
    } else {
        var v = camInfo.vector;
        renderer.labelVector = [v[0], v[1], v[2], 0]; 
    }

    renderer.distanceFactor = 1 / Math.max(1,Math.log(camera.distance) / Math.log(1.04));
    renderer.tiltFactor = (Math.abs(renderer.cameraOrientation[1]/-90));
    renderer.localViewExtentFactor = 2 * Math.tan(math.radians(map.position.getFov()*0.5));

    this.degradeHorizonFactor = 200.0 * this.config.mapDegradeHorizonParams[0];
    this.degradeHorizonTiltFactor = 0.5*(1.0+Math.cos(math.radians(Math.min(180,Math.abs(renderer.cameraOrientation[1]*2*3)))));
   
    if (this.drawChannel != 1) {
        if (debug.drawWireframe == 2) {
            gpu.clear(true, true, [255,255,255,255]);
        } else {
            gpu.clear(true, true, [0,0,0,255]);
        }
    } else { //render depth map
        gpu.clear(true, true, [255,255,255,255]);
    }

    gpu.setState(this.drawStardomeState);

    /*
    if (this.drawChannel != 1) {
        if (debug.drawWireframe == 2) {
            renderer.draw.drawSkydome(renderer.whiteTexture, renderer.progStardome);
        } else {
            renderer.draw.drawSkydome(renderer.blackTexture, renderer.progStardome);
        }
    }*/

    gpu.setState(this.drawTileState);

    this.setupDetailDegradation();

    map.loader.setChannel(0); //0 = hires channel
    this.zFactor = 0;

    this.ndcToScreenPixel = renderer.curSize[0] * 0.5;
    this.updateFogDensity();
    this.updateGridFactors();
    this.maxGpuUsed = Math.max(32*102*1204, map.gpuCache.getMaxCost() - 32*102*1204); 
    //this.cameraCenter = this.position.getCoords();
    this.stats.renderBuild = 0;
    this.drawTileCounter = 0;
    var cameraPos = camera.position;
    var i, li, j, lj, tile, tiles, tmp, layer, drawnTiles, nodeBuffer;

    if (map.freeLayersHaveGeodata && this.drawChannel == 0) {
        renderer.draw.clearJobBuffer();
    }

    if (this.debug.drawEarth) {
        if (replay.storeNodes || replay.storeFreeNodes) {
            replay.nodeBuffer = [];
        }
        
        if (replay.drawGlobe || replay.drawTiles || replay.drawFreeTiles||
            replay.drawNodes || replay.drawFreeNodes || replay.drawLoaded) { //used only in inspector
    
            var lod = replay.lod; 
            var single = replay.singleLod; 
    
            if (replay.drawTiles && replay.drawnTiles) {
                tiles = replay.drawnTiles;
                for (i = 0, li = tiles.length; i < li; i++) {
                    if (!tiles[i][1]) { //skip grids
                        tile = tiles[i][0];
                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                        }
                    } else {
                        tile = tiles[i][0];
                        if (drawTiles.debug.drawBBoxes) {
                            drawTiles.drawTileInfo(tile, tile.metanode, cameraPos);
                        }

                        tile.drawGrid(cameraPos); 
                    }
                }
            }
            
            if (replay.drawFreeTiles && replay.drawnFreeTiles) {
                tiles = replay.drawnFreeTiles;
                for (i = 0, li = tiles.length; i < li; i++) {
                    if (!tiles[i][1]) { //skip grids
                        tile = tiles[i][0];
                        if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                            drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                        }
                    }
                }
            }
    
            if (replay.drawNodes && replay.tracedNodes) {
                tiles = replay.tracedNodes;
                tmp = debug.drawBBoxes;
                debug.drawBBoxes = true;  
                for (i = 0, li = tiles.length; i < li; i++) {
                    tile = tiles[i];
                    if (tile && ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod))) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                    }
                }
                debug.drawBBoxes = tmp;
            }
    
            if (replay.drawFreeNodes && replay.tracedFreeNodes) {
                tiles = replay.tracedFreeNodes;
                tmp = debug.drawBBoxes;
                debug.drawBBoxes = true;  
                for (i = 0, li = tiles.length; i < li; i++) {
                    tile = tiles[i];
                    if ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) {
                        drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                    }
                }
                debug.drawBBoxes = tmp;
            }
    
            var index = replay.loadedIndex; 
            var singleIndex = replay.singleLodedIndex; 
    
            if (replay.drawLoaded && replay.loaded) {
                var  loaded = replay.loaded;
                debug.drawBBoxes = true;  
                for (i = 0, li = loaded.length; i < li; i++) {
                    var file = loaded[i];
                    if (file && file.tile && file.tile.id) {
                        tile = file.tile;
                        if (((singleIndex && i == index) || (!singleIndex && i <= index)) &&
                             ((single && tile.id[0] == lod) || (!single && tile.id[0] <= lod)) ) {
                            if (tile.metanode) {
                                if (tile.metanode.hasGeometry()) {
                                    drawTiles.drawSurfaceTile(tile, tile.metanode, cameraPos, tile.pixelSize, tile.priority, false, false);
                                } else {
                                    drawTiles.drawTileInfo(tile, tile.metanode, cameraPos, tile.surfaceMesh, tile.pixelSize);
                                }
                            }
                        }
                    }
                }
                debug.drawBBoxes = tmp;
            }
    
            if ((replay.drawFreeTiles && replay.drawnFreeTiles) ||
                (replay.drawLoaded && replay.loaded)) {
                    
                if (this.freeLayersHaveGeodata && this.drawChannel == 0) {
                    renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;
                    renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;
                    renderer.draw.drawGpuJobs();
                }
            }
    
            return;
        }    
        
        for (i = 0, li = this.tileBuffer.length; i < li; i++) {  //todo remove this
            this.tileBuffer[i] = null;    
        }
    
        if (this.tree.surfaceSequence.length > 0) {
            this.tree.draw();
        }
    
        if (replay.storeTiles) { //used only in inspectors
            drawnTiles = [];
    
            for (i = 0, li = this.tileBuffer.length; i < li; i++) {
                tiles = this.tileBuffer[i];
               
                if (tiles) {
                    for (j = 0, lj = tiles.length; j < lj; j++) {
                        drawnTiles.push(tiles[j]);
                    }
                }
            }
            
            replay.cameraPos = cameraPos; 
            replay.drawnTiles = drawnTiles;
            replay.storeTiles = false; 
        }
    
        if (replay.storeNodes) { //used only in inspector
            nodeBuffer = []; 
    
            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {
                tile = replay.nodeBuffer[i];
                nodeBuffer.push(tile);
            }
    
            replay.cameraPos = cameraPos; 
            replay.tracedNodes = nodeBuffer;
            replay.storeNodes = false; 
        }
    
        //draw free layers    
        for (i = 0, li = map.freeLayerSequence.length; i < li; i++) {
            layer = map.freeLayerSequence[i];
            if (layer.ready && layer.tree && 
                (!layer.geodata || (layer.stylesheet && layer.stylesheet.isReady())) && this.drawChannel == 0) {
                
                if (layer.zFactor) {
                    this.zbufferOffset = layer.zFactor;
                }

                if (layer.type == 'geodata') {
                    this.drawMonoliticGeodata(layer);
                } else {
                    layer.tree.draw();
                }

                this.zbufferOffset = null;
            }
        }
    
        if (replay.storeFreeTiles) { //used only in inspector
            drawnTiles = [];
    
            for (i = 0, li = this.tileBuffer.length; i < li; i++) {
                tiles = this.tileBuffer[i];
               
                if (tiles) {
                    for (j = 0, lj = tiles.length; j < lj; j++) {
                        tile = tiles[j];
                        if (tile.surface && tile.surface.free) { //do no draw free layers
                            drawnTiles.push(tile);
                        }
                    }
                }
            }
            
            replay.cameraPos = cameraPos; 
            replay.drawnFreeTiles = drawnTiles;
            replay.storeFreeTiles = false; 
        }
    
        if (replay.storeFreeNodes) { //used only in inspector
            nodeBuffer = []; 
    
            for (i = 0, li = replay.nodeBuffer.length; i < li; i++) {
                tile = replay.nodeBuffer[i];
                if (tile.surface && tile.surface.free) { //do no draw free layers
                    nodeBuffer.push(tile);
                }
            }
    
            replay.cameraPos = cameraPos; 
            replay.tracedFreeNodes = nodeBuffer;
            replay.storeFreeNodes = false; 
        }
    }

    var body = map.referenceFrame.body;

    //draw skydome before geodata
    if (this.drawChannel != 1 && !projected && debug.drawFog &&
        ((body && body.atmosphere) || map.referenceFrame.id == 'melown2015' || map.referenceFrame.id == 'mars-qsc' || map.referenceFrame.id == 'earth-qsc') &&
        renderer.progAtmo.isReady() && renderer.progAtmo2.isReady()) {    

        var navigationSrsInfo = map.getNavigationSrs().getSrsInfo();
        var earthRadius =  navigationSrsInfo['a'];
        var earthRadius2 =  navigationSrsInfo['b'];
        var atmoSize = this.atmoHeight;
        renderer.earthRadius = earthRadius;
        renderer.earthRadius2 = earthRadius2;
        renderer.earthERatio = earthRadius / earthRadius2;

        var cameraPosToEarthCenter = [0,0,0,0];
        vec3.normalize(camera.position, cameraPosToEarthCenter);

        var pos = map.getPosition();
        //var orientation = pos.getOrientation();
        //var tiltFactor = (Math.max(5,-orientation[1])/90);

        //var cameraHeight = Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius);
        var heightFactor = 1-math.clamp(Math.max(atmoSize * 0.1, camera.geocentDistance - earthRadius) / (atmoSize*(10)), 0, 1);

        var params = [Math.max(2,heightFactor*128),0,0,0], params2, params3;
        
        /*
        if (cameraHeight > earthRadius*2) { //prevent foggy earth from larger distance
            params[0] = 2-Math.min(1.0, (camera.height - earthRadius*2) / (earthRadius*2));
        }*/

        //gpu.setState(this.drawAtmoState);
        //renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],
          //                       earthRadius + 3000, earthRadius2 + 3000, renderer.progAtmo2, params,  cameraPosToEarthCenter, null, this.atmoColor3, this.atmoColor2, true);// this.cameraHeight > atmoSize ? 1 : -1);
        
        var safetyFactor = 2.0; 
        params = [safetyFactor, safetyFactor * ((earthRadius + atmoSize) / earthRadius), 0.25, safetyFactor* ((earthRadius + atmoSize) / earthRadius)];
        var factor = (1 / (earthRadius) ) * safetyFactor;  
        params2 = [camera.position[0] * factor, camera.position[1] * factor, camera.position[2] * factor, 1];
        
        var distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
        var a1 = (earthRadius / (distance + earthRadius)); //get angle to horion

        //var n2 = 10.05;
        var n2 = 5.00;

        var t1 = math.mix(4.4, 1.01, a1);
        var t2 = math.mix(n2, 1.05, a1); // * 1.0176;

        params3 = [t1, 1 ,t2,0];

        //console.log("a1: " + a1 + " t2: " + t2);

        gpu.setState(this.drawAuraState);
        renderer.draw.drawBall([-camera.position[0], -camera.position[1], -camera.position[2]],
                                 earthRadius + atmoSize, earthRadius2 + atmoSize, renderer.progAtmo, params,  params2, params3, this.atmoColor, this.atmoColor2);// this.camera.height > atmoSize ? 1 : -1);

        gpu.setState(this.drawTileState);
    }

    if (debug.drawEarth) {
        if (!skipFreeLayers) {
            if (map.freeLayersHaveGeodata && this.drawChannel == 0) {
                renderer.drawnGeodataTiles = this.stats.drawnGeodataTilesPerLayer; //drawnGeodataTiles;
                renderer.drawnGeodataTilesFactor = this.stats.drawnGeodataTilesFactor;
                renderer.draw.drawGpuJobs();
            }
        }
    }

    if (this.config.mapForceFrameTime) {
        if (this.config.mapForceFrameTime != -1) {
            renderer.frameTime = 0;
            this.config.mapForceFrameTime = -1;
        }
    }
};

MapDraw.prototype.drawToTexture = function(texture) {
    this.renderer.switchToFramebuffer('texture', texture);
    this.drawChannel = 0;
    this.map.renderSlots.processRenderSlots();
    this.renderer.switchToFramebuffer('base');
};


MapDraw.prototype.drawHitmap = function() {
    this.drawChannel = 1;
    this.renderer.switchToFramebuffer('depth');
    this.map.renderSlots.processRenderSlots();
    this.renderer.switchToFramebuffer('base');

    if (this.renderer.hitmapMode > 2) {
        this.renderer.copyHitmap();
    }

    this.drawChannel = 0;
    this.map.hitMapDirty = false;
};


MapDraw.prototype.drawGeodataHitmap = function() {
    this.renderer.gpu.setState(this.drawTileState);
    this.renderer.switchToFramebuffer('geo');
    this.renderer.draw.drawGpuJobs();

    if (this.renderer.advancedPassNeeded) {
        this.renderer.switchToFramebuffer('geo2');
        this.renderer.draw.drawGpuJobs();
    }

    this.renderer.switchToFramebuffer('base');
    this.map.geoHitMapDirty = false;
};

MapDraw.prototype.getDrawCommandsGpuSize = function(commands) {
    var gpuNeeded = 0;
    
    for (var i = 0, li = commands.length; i < li; i++) {
        var command = commands[i];
        
        switch (command.type) {
        case 2:
               
            var mesh = command.mesh; 
            var texture = this.config.mapNoTextures ? 0 : command.texture; 

            if (mesh) {
                gpuNeeded += mesh.gpuSize;
            }

            if (texture) {
                gpuNeeded += texture.getGpuSize();
            }
                
            break;

        case 3:
                
            var geodataView = command.geodataView; 
                
            if (geodataView) {
                gpuNeeded += geodataView.size;
            }
                
            break;
        }
    }
    
    return gpuNeeded;
};


MapDraw.prototype.areDrawCommandsReady = function(commands, priority, doNotLoad, doNotCheckGpu) {
    var ready = true;
    var checkGpu = doNotCheckGpu ? true : false;
    
    for (var i = 0, li = commands.length; i < li; i++) {
        var command = commands[i];
        
        switch (command.type) {
        case 2:

            var pipeline = command.pipeline;
            if (pipeline) {
                var hmap = command.hmap;
    
                if (!(hmap && hmap.isReady(doNotLoad, priority))) {
                    ready = false;
                }

                if (this.debug.drawTestMode == 9) {
                    var texture = command.texture; 
                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));
                        
                    if (!textureReady) {
                        ready = false;   
                    }
                }

                break;
            }
                
            var mesh = command.mesh; 
            var texture = command.texture; 
                
            var meshReady = (mesh && mesh.isReady(doNotLoad, priority, checkGpu));
            var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority, checkGpu)));
                
            if (!(meshReady && textureReady) ) {
                ready = false;   
            }
               
            break;

        case 3:
                
            var geodataView = command.geodataView; 
                
            if (!(geodataView && geodataView.isReady(doNotLoad, priority, checkGpu))) {
                ready = false;   
            }
                
            break;
        }
    }
    
    return ready;
};


MapDraw.prototype.processDrawCommands = function(cameraPos, commands, priority, doNotLoad, tile) {
    if (commands.length > 0) {
        this.drawTileCounter++;
    }

    for (var i = 0, li = commands.length; i < li; i++) {
        var command = commands[i];
        
        switch (command.type) {
        case 1:
            this.renderer.gpu.setState(command.state);
            break;

        case 2:

            var pipeline = command.pipeline;
            if (pipeline) {
                var hmap = command.hmap;
    
                if (this.debug.drawTestMode == 9) {
                    var texture = command.texture; 
                    var textureReady = this.config.mapNoTextures ? true : (!texture  || (texture && texture.isReady(doNotLoad, priority)));
                        
                    if (textureReady) {
                        if (hmap && hmap.isReady(doNotLoad, priority)) {
                            tile.drawHmapTile(cameraPos, null, null, pipeline, texture);
                        }
                    }
                } else {
                    if (hmap && hmap.isReady(doNotLoad, priority)) {
                        tile.drawHmapTile(cameraPos, null, null, pipeline);
                    }
                }

                return;
            }

            var mesh = command.mesh; 
            var texture = command.texture;

            var meshReady = (mesh && mesh.isReady(doNotLoad, priority)), textureReady;

            if (this.config.mapNoTextures) {
                textureReady = true;
                texture = null;
            } else {
                textureReady = (!texture || (texture && texture.isReady(doNotLoad, priority)));
            }
                
            if (meshReady && textureReady) {
                    //debug bbox
                if (this.debug.drawBBoxes && this.debug.drawMeshBBox) {
                    mesh.submeshes[command.submesh].drawBBox(cameraPos);
                }
                    
                if (!texture) {
                    var material = command.material;
                    switch (material) {
                            //case "fog":
                    case 6:
                    case 4:
                        material = 2;
                        break; 
                    }
                    mesh.drawSubmesh(cameraPos, command.submesh, texture, material, command.alpha, command.layer, command.surface);
                } else {
                    //tile.renderHappen = true;
                    mesh.drawSubmesh(cameraPos, command.submesh, texture, command.material, command.alpha, command.layer, command.surface);
                }

            }
                
            break;
                
        case 3:
                
            var geodataView = command.geodataView; 
            //tile.renderHappen = true;
                
            if (geodataView && geodataView.isReady(doNotLoad, priority, true)) {
                geodataView.draw(cameraPos);
            }
                
            break;
        }
    }
};


MapDraw.prototype.drawMonoliticGeodata = function(surface) {
    if (!surface || this.drawChannel != 0) {
        return;
    }

    if (!this.camera.camera.bboxVisible(surface.extents, this.camera.position)) {
        return;
    }

    var path;

    if (surface.monoGeodata == null) {
        if (typeof surface.geodataUrl === 'object') {
            path = surface.geodataUrl;
        } else {
            path = surface.getMonoGeodataUrl(surface.id);
        }

        surface.monoGeodata = new MapGeodata(this.map, path, {tile:null, surface:surface});
    }

    if (surface.monoGeodataCounter != surface.geodataCounter) {
        surface.monoGeodataView = null;
        surface.monoGeodataCounter = surface.geodataCounter;
    }

    if (surface.monoGeodata.isReady()) {

        if (!surface.monoGeodataView) {
            surface.monoGeodataView = new MapGeodataView(this.map, surface.monoGeodata, {tile:null, surface:surface});
        }
        
        if (surface.monoGeodataView.isReady()) {
            var mapdataCredits = this.map.visibleCredits.mapdata

            for (var i = 0, li = surface.credits.length; i < li; i++) {
                var key = surface.credits[i]
                var value = 10; //fixed specificity
                var value2 = mapdataCredits[key];

                if (value2) {
                    mapdataCredits[key] = value > value2 ? value : value2;
                } else {
                    mapdataCredits[key] = value;
                }
            }

            surface.monoGeodataView.draw(this.camera.position);
        }
    }
};


MapDraw.prototype.updateFogDensity = function() {
    // the fog equation is: exp(-density*distance), this gives the fraction
    // of the original color that is still visible at some distance

    // we define visibility as a distance where only 5% of the original color
    // is visible; from this it is easy to calculate the correct fog density

    //var density = Math.log(0.05) / this.core.coreConfig.cameraVisibility;
    var pos = this.map.getPosition();
    var orientation = pos.getOrientation();
    
    var cameraVisibility = this.camera.getFar();
    
    var tiltFactor = (Math.max(5,-orientation[1])/90);
    var density = Math.log(0.05) / ((this.atmoDensity * cameraVisibility * this.atmoHeightFactor * Math.max(1,this.camera.height*0.0001))* tiltFactor);
    density *= (5.0) / (Math.min(50000, Math.max(this.camera.distance, 1000)) /5000);

    if (!this.debug.drawFog) {
        density = 0;
    }
    
    //reduce fog when camera is facing down
    //density *= 1.0 - (-this.orientation[0]/90)
    
    this.fogDensity = density;
    this.renderer.fogDensity = density; 
};


MapDraw.prototype.updateGridFactors = function() {
    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    for (var i = 0, li = nodes.length; i < li; i++) {
        var node = nodes[i]; 
        var embed = 8;

        var altitude = Math.max(10, this.camera.distance + 20);
        //var altitude = Math.max(1.1, this.cameraDistance);
        var maxDistance = (node.extents.ur[0] - node.extents.ll[0])*2;
        var gridSelect = Math.log(Math.min(maxDistance,altitude)) / this.log8;
        var gridMax = Math.log(maxDistance) / this.log8;
    
        gridSelect = gridMax - gridSelect;
    
        node.gridBlend = (gridSelect - Math.floor(gridSelect));
        
        gridSelect = Math.floor(Math.floor(gridSelect))+1;
        node.gridStep1 = Math.pow(embed, gridSelect);
        node.gridStep2 = node.gridStep1 * 8; 
    }
};


MapDraw.prototype.setupDetailDegradation = function(degradeMore) {
    var factor = 0;
    
    if (this.map.mobile) {
        factor = this.config.mapMobileDetailDegradation;
    }

    if (degradeMore) {
        factor += degradeMore;        
    }

    var dpiRatio = 1; //(window.devicePixelRatio || 1);

    this.texelSizeFit = this.config.mapTexelSizeFit * Math.pow(2,factor) * dpiRatio;      
};


/* harmony default export */ __webpack_exports__["a"] = (MapDraw);



/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geodata_geometry__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geodata_import_geojson__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geodata_import_vts_geodata__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_matrix__ = __webpack_require__(1);

//import Delaunator_ from './geodata-utils';



//import GeographicLib_ from 'geographiclib';


//get rid of compiler mess
//var Delaunator = Delaunator_;
var MapGeodataGeometry = __WEBPACK_IMPORTED_MODULE_0__geodata_geometry__["a" /* default */];
var MapGeodataImportGeoJSON = __WEBPACK_IMPORTED_MODULE_1__geodata_import_geojson__["a" /* default */];
var MapGeodataImportVTSGeodata = __WEBPACK_IMPORTED_MODULE_2__geodata_import_vts_geodata__["a" /* default */];
//var GeographicLib = GeographicLib_;
var vec3 = __WEBPACK_IMPORTED_MODULE_3__utils_matrix__["b" /* vec3 */];
var mat4 = __WEBPACK_IMPORTED_MODULE_3__utils_matrix__["e" /* mat4 */];


var MapGeodataBuilder = function(map) {
    this.map = map;
    this.groups = [];
    this.currentGroup = null;
    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];

    this.navSrs = this.map.getNavigationSrs();
    //this.navSrs = this.map.getPublicSrs();
    this.physSrs = this.map.getPhysicalSrs();

    this.heightsToProcess = 0;
    this.heightsProcessBuffer = null;
    this.heightsProcessBufferFirst = null;
    this.heightsProcessBufferLast = null;

    this.heightsLod = 8;
    this.heightsSource = "heightmap-by-precision";
    this.updateCallback = null;
    this.processingHeights = false;
    this.processHeightsCalls = [];
};


MapGeodataBuilder.prototype.addToHeightsBuffer = function(coords) {

    var item = { coords: coords, prev: null, next: this.heightsProcessBufferFirst };

    if (this.heightsProcessBufferFirst != null) {
        this.heightsProcessBufferFirst.prev = item;
    }

    //add item as first in list
    this.heightsProcessBufferFirst = item;

    if (this.heightsProcessBufferLast == null) {
        this.heightsProcessBufferLast = item;
    }
};


MapGeodataBuilder.prototype.removeFromHeightsBuffer = function(item) {
    var hit = false;

    if (item == this.heightsProcessBufferFirst) {
        this.heightsProcessBufferFirst = item.next;
        hit = true;

        if (this.heightsProcessBufferFirst != null) {
            this.heightsProcessBufferFirst.prev = null;
        }
    }

    if (item == this.heightsProcessBufferLast) {
        this.heightsProcessBufferLast = item.prev;
        hit = true;

        if (this.heightsProcessBufferLast != null) {
            this.heightsProcessBufferLast.next = null;
        }
    }

    if (!hit) {
        if (!item.prev) {
            //debugger;
        } else {
            item.prev.next = item.next;
        }
        
        if (!item.next) {
            //debugger;
        } else {
            item.next.prev = item.prev;
        }
    }
};


MapGeodataBuilder.prototype.addGroup = function(id) {
    this.groups.push({
        points: [],
        lines: [],
        polygons: [],
        id: id
    });

    this.currentGroup = this.groups[this.groups.length - 1];

    return this;
};

MapGeodataBuilder.prototype.addPoint = function(point, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    var floatHeight = (!heightMode || heightMode == "float"), coords;

    var feature = {
        id : id,
        properties : properties
    };

    if (floatHeight) {
        coords = [point[0], point[1], point[2] || 0, feature, null, null ];
        this.addToHeightsBuffer(coords);

        feature.points = [ coords ];
        feature.floatHeights = true;
        feature.srs = srs ? srs : this.navSrs;
        feature.heightsToProcess = 1;
        this.heightsToProcess++;
    } else {
        if (directCopy) {
            feature.points = [ [point[0], point[1], point[2]] ];
        } else {
            feature.points = [ this.physSrs.convertCoordsFrom(point, srs ? srs : this.navSrs) ];
        }
    }

    this.currentGroup.points.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addPointArray = function(points, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    var floatHeight = (!heightMode || heightMode == "float"), i, li, point, coords;
    srs = srs ? srs : this.navSrs;

    var feature = {
        id : id,
        properties : properties
    };

    var featurePoints = new Array(points.length);

    if (floatHeight) {
        
        for (i = 0, li = points.length; i < li; i++) {
            point = points[i];
            coords = [point[0], point[1], point[2] || 0, feature, null, null ];
            this.addToHeightsBuffer(coords);

            featurePoints[i] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = li;
        this.heightsToProcess++;
    } else {
        if (directCopy) {
            for (i = 0, li = points.length; i < li; i++) {
                point = points[i];
                featurePoints[i] = [point[0], point[1], point[2]];
            }
        } else {
            for (i = 0, li = points.length; i < li; i++) {
                featurePoints[i] = this.physSrs.convertCoordsFrom(points[i], srs);
            }
        }
    }

    feature.points = featurePoints;
    this.currentGroup.points.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addLineString = function(linePoints, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    var floatHeight = (!heightMode || heightMode == "float"), i, li, point, coords;
    srs = srs ? srs : this.navSrs;

    var feature = {
        id : id,
        properties : properties
    };

    var featurePoints = new Array(linePoints.length);

    if (floatHeight) {
        
        for (i = 0, li = linePoints.length; i < li; i++) {
            point = linePoints[i];
            coords = [point[0], point[1], point[2] || 0, feature, null, null ];
            this.addToHeightsBuffer(coords);

            featurePoints[i] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = li;
        this.heightsToProcess += li;
    } else {
        if (directCopy) {
            for (i = 0, li = linePoints.length; i < li; i++) {
                point = linePoints[i];
                featurePoints[i] = [point[0], point[1], point[2]];
            }
        } else {
            for (i = 0, li = linePoints.length; i < li; i++) {
                featurePoints[i] = this.physSrs.convertCoordsFrom(linePoints[i], srs);
            }
        }
    }

    feature.lines = [featurePoints];
    this.currentGroup.lines.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addLineStringArray = function(lines, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    var floatHeight = (!heightMode || heightMode == "float");
    var subline, points, i, li, j, lj, point, coords;
    srs = srs ? srs : this.navSrs;

    var feature = {
        id : id,
        properties : properties
    };

    var featureLines = new Array(lines.length);

    if (floatHeight) {
        var totalHeights = 0;
        
        for (i = 0, li = lines.length; i < li; i++) {
            subline = lines[i];
            points = new Array(subline.length);

            for (j = 0, lj = subline.length; j < lj; j++) {
                point = subline[j];
                coords = [point[0], point[1], point[2] || 0, feature, null, null];
                this.addToHeightsBuffer(coords);
                points[j] = coords;
            }

            totalHeights += lj;
            featureLines[i] = points;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = totalHeights;
        this.heightsToProcess += totalHeights;
    } else {

        for (i = 0, li = lines.length; i < li; i++) {
            subline = lines[i];
            points = new Array(subline.length);

            if (directCopy) {
                for (j = 0, lj = subline.length; j < lj; j++) {
                    point = subline[j];
                    points[j] = [point[0], point[1], point[2]];
                }
            } else {
                for (j = 0, lj = subline.length; j < lj; j++) {
                    points[j] = this.physSrs.convertCoordsFrom(subline[j], srs);
                }
            }

            featureLines[i] = points;
        }
    }

    feature.lines = featureLines;
    this.currentGroup.lines.push(feature);

    return this;
};


MapGeodataBuilder.prototype.addPolygon = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {
    //older versions are in github history 2.20.x
    return this.addPolygon3(shape, holes, middle, heightMode, properties, id, srs, tesselation);
};


MapGeodataBuilder.prototype.getPolygonCenter = function(shape, projected, proj) {
    if (shape && !shape.length) {
        return [0,0];
    }

    var sumX = 0, sumY = 0, sumZ = 0; //, convertLong = false;

    if (projected) {
        for (var i = 0, li = shape.length; i < li; i++) {
            var coords = shape[i];
            sumX += coords[0];
            sumY += coords[1];
            sumZ += coords[2];
        }

        return [sumX / li, sumY / li, sumZ / li];
    } else {
        for (var i = 0, li = shape.length; i < li; i++) {
            var coords = shape[i];
            var coords2 = proj.forward(coords);
            sumX += coords2[0];
            sumY += coords2[1];
            sumZ += coords2[2];
        }

        var avgX = sumX / li;
        var avgY = sumY / li;
        var avgZ = sumZ / li;

        // convert average x, y, z coordinate to latitude and longtitude

        coords = proj.inverse([avgX, avgY, avgZ]);

        return [coords[0], coords[1], 0];
    }
};


MapGeodataBuilder.prototype.insidePolygon = function(point, vertices, verticesLength) {
    // ray-casting algorithm based on
    // https://github.com/substack/point-in-polygon/blob/master/index.js
    
    var x = point[0], y = point[1];

    verticesLength = (verticesLength || Math.round(vertices.length/3));

    var inside = false;
    for (var i = 0, j = verticesLength - 1, li = verticesLength; i < li; j = i++) {
        var xi = vertices[i*3], yi = vertices[i*3+1];
        var xj = vertices[j*3], yj = vertices[j*3+1];
        
        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    
    return inside;
};    


//same as addPolygon but works on poles
/*
MapGeodataBuilder.prototype.addPolygon2 = function(shape, holes, middle, heightMode, properties, id, srs) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];

    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords, coords2, proj, holesIndices, vertices;
    var projected = true;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
        //proj = this.map.proj4(srs, '+proj=merc +lat_ts=' + center[1] + ' +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
    }

    var c = document.getElementById("dbg-canvas");
    var ctx = c.getContext("2d");
    var sx = 300;
    var fx = 300 / 7500000;


    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir;

    this.addPoint(center.slice(), 'fix', {}, 'aaa');

    var ned = this.map.measure.getNewNED(center);

    dir = ned.direction;
    north = ned.north;
    east = ned.east;

    var totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    var borders = new Array(holes.length + 1);
    var border = new Array(shape.length);
    borders[0] = border;

    ctx.beginPath();

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0]; 
        vertices[j+1] = coords[1]; 
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords= [ east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
        } else {
            coords = shape[i];
        }

        if (i ==0) {
            ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);
        } else {
            ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);
        }

        flatShape[j] = coords[0]; 
        flatShape[j+1] = coords[1]; 
        flatShape[j+2] = coords[2]; 
        j+=3;
    }

    flatHoles = new Array(holes.length);
    holesIndices = new Array(holes.length);

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        holesIndices[i] = Math.round(j/3);

        border = new Array(hole.length);
        borders[i + 1] = border;

        l = Math.floor(j /3);

        for (k = 0, lk = hole.length; k < lk; k++) {
            coords = hole[k];
            vertices[j] = coords[0]; 
            vertices[j+1] = coords[1]; 
            vertices[j+2] = coords[2]; 

            if (proj) {
                coords2 = proj.forward(hole[k]);
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
            } else {
                coords = hole[k];
            }

            if (k ==0) {
                ctx.moveTo(coords[0]*fx+sx,coords[1]*fx+sx);
            } else {
                ctx.lineTo(coords[0]*fx+sx,coords[1]*fx+sx);
            }


            flatShape[j] = coords[0]; 
            flatShape[j+1] = coords[1]; 
            flatShape[j+2] = coords[2]; 
            j+=3;
            border[k] = l++;
        }
    }

    ctx.strokeStyle = "#ff0000";
    ctx.stroke();


    var surface = vts.earcut(flatShape, holesIndices, 3);

    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);

    ctx.beginPath();

    for (i = 0, li = surface.length; i < li; i+=3) {
        var v1 = surface[i]*3;
        var v2 = surface[i+1]*3;
        var v3 = surface[i+2]*3;

        ctx.moveTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);
        ctx.lineTo(flatShape[v2]*fx+sx,flatShape[v2+1]*fx+sx);
        ctx.lineTo(flatShape[v3]*fx+sx,flatShape[v3+1]*fx+sx);
        ctx.lineTo(flatShape[v1]*fx+sx,flatShape[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#0000ff";
    ctx.stroke();

    return this;
};
*/

//same as addPolygon3 but with Delaunator sudivision
/*
MapGeodataBuilder.prototype.addPolygon4 = function(shape, holes, middle, heightMode, properties, id, srs) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];
    holes = [];

    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;
    var projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;
    var density = 20;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
    }

    var totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir, geod;

    var ned = this.map.measure.getNewNED(center);

   // dir = ned.direction;
    north = ned.direction;
    east = ned.east;

     geod = this.map.measure.getGeodesic(); 

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    var borders = new Array(holes.length + 1);
    var border = new Array(shape.length);
    borders[0] = border;


    var gcenter;

    if (proj) {
        gcenter = proj.forward(center);
    } else {
        gcenter = center;
    }

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0]; 
        vertices[j+1] = coords[1]; 
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
        } else {
            coords2 = shape[i];
            coords = coords2;
        }

        dx = coords2[0] - gcenter[0];
        dy = coords2[1] - gcenter[1];
        dz = coords2[2] - gcenter[2];
        dd = dx * dx + dy * dy + dz*dz;
        if (dd > maxDistance) {
            maxDistance = dd;
            maxDistanceCoords = shape[i]
        }

        flatShape[j] = coords[0]; 
        flatShape[j+1] = coords[1]; 
        flatShape[j+2] = coords[2]; 
        j+=3;
    }

    maxDistance = Math.sqrt(maxDistance);

    var inPoints = new Array(density * density * 3);
    var inPointsFlat = new Array(density * density * 3);
    var inPointsIndex = 0;
    var inPointsFlatIndex = 0;

    if (proj) {

        if (!projected) {
            //maxDistanceCoords = proj.inverse(maxDistanceCoords); maxDistanceCoords[2] = 0;
            maxDistance = this.map.measure.getDistance(center, maxDistanceCoords, false)[0];
        }
        
        density = Math.round(density * 0.5);

        var r, ncoords, ecoords, lastJ = j;
        var geod = this.map.measure.getGeodesic();
        
        for (i = -density; i < density; i++) {
            r = geod.Direct(center[1], center[0], 0, (maxDistance / (density)) * i);
            ncoords = [r.lon2, r.lat2];

            for (j = -density; j < density; j++) {
                r = geod.Direct(ncoords[1], ncoords[0], 90, (maxDistance / (density)) * j);

                ecoords = [r.lon2, r.lat2, 0];
                coords2 = proj.forward(ecoords);
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
               
                if (this.insidePolygon(coords, flatShape, shape.length)) {
                    //this.addPoint(ecoords.slice(), 'fix', {}, 'bbb', srs);
                    //holes.push([ecoords]);

                    inPoints[inPointsIndex] = ecoords[0];
                    inPoints[inPointsIndex+1] = ecoords[1];
                    inPoints[inPointsIndex+2] = ecoords[2];
                    inPointsIndex += 3;

                    inPointsFlat[inPointsFlatIndex] = coords[0];
                    inPointsFlat[inPointsFlatIndex+1] = coords[1];
                    inPointsFlat[inPointsFlatIndex+2] = coords[2];
                    inPointsFlatIndex += 3;

                } else {
                    //this.addPoint(ecoords.slice(), 'fix', {}, 'aaa', srs);
                }
            }
        }

        j = lastJ; 

        inPoints = inPoints.slice(0, inPointsIndex);
        inPointsFlat = inPointsFlat.slice(0, inPointsFlatIndex);

        vertices = vertices.concat(inPoints);
        flatShape = flatShape.concat(inPointsFlat);

    }

    if (false) {
        flatHoles = new Array(holes.length);
        holesIndices = new Array(holes.length);

        for (i = 0, li = holes.length; i < li; i++) {
            hole = holes[i];
            holesIndices[i] = Math.round(j/3);

            if (i < trueHolesCount) {
                border = new Array(hole.length);
                borders[i + 1] = border;
            }

            l = Math.floor(j /3);

            for (k = 0, lk = hole.length; k < lk; k++) {
                coords = hole[k];
                vertices[j] = coords[0]; 
                vertices[j+1] = coords[1]; 
                vertices[j+2] = coords[2]; 

                if (proj) {
                    coords2 = proj.forward(hole[k]);
                    coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                              north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
                } else {
                    coords = hole[k];
                }

                flatShape[j] = coords[0]; 
                flatShape[j+1] = coords[1]; 
                flatShape[j+2] = coords[2]; 
                j+=3;

                if (i < trueHolesCount) {
                    border[k] = l++;
                }
            }
        }
    }

    var flatShape2 = new Array((flatShape.length / 3) *2);

    for (i = 0, j =0, li = flatShape.length; i < li; i+=3, j+=2) {
        flatShape2[j] = flatShape[i];
        flatShape2[j+1] = flatShape[i+1];
    }

    var delaunay = new Delaunator(flatShape2);

    var surface2 = delaunay.triangles;
    var smax = 30;//vertices.length / 3;

    var surface = new Array(surface2.length);

    j = 0;

    for (i = 0, li = surface.length; i < li; i+=3) {
        var v1 = surface2[i]*2;
        var v2 = surface2[i+1]*2;
        var v3 = surface2[i+2]*2;

        var mid = [(flatShape2[v1]+flatShape2[v2]+flatShape2[v3])/3,
                   (flatShape2[v1+1]+flatShape2[v2+1]+flatShape2[v3+1])/3,0];

        if (this.insidePolygon(mid, flatShape, shape.length)) {
            surface[j] = surface2[i+2];
            surface[j+1] = surface2[i+1];
            surface[j+2] = surface2[i];
            j+=3;
        }
    }

    surface = surface.slice(0,j);

    //var surface = vts.earcut(flatShape, holesIndices, 3);
    //var surface = vts.earcut(flatShape2, holesIndices, 2);

    var c = document.getElementById("dbg-canvas");
    var ctx = c.getContext("2d");
    var sx = 300;
    var fx = 300 / 7500000; fx*=30;


    ctx.beginPath();

    for (i = 0, li = surface2.length; i < li; i+=3) {
        var v1 = surface2[i]*2;
        var v2 = surface2[i+1]*2;
        var v3 = surface2[i+2]*2;

        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);
        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);
        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#0000ff";
    ctx.stroke();


    ctx.beginPath();

    for (i = 0, li = surface.length; i < li; i+=3) {
        var v1 = surface[i]*2;
        var v2 = surface[i+1]*2;
        var v3 = surface[i+2]*2;

        ctx.moveTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
        ctx.lineTo(flatShape2[v2]*fx+sx,flatShape2[v2+1]*fx+sx);
        ctx.lineTo(flatShape2[v3]*fx+sx,flatShape2[v3+1]*fx+sx);
        ctx.lineTo(flatShape2[v1]*fx+sx,flatShape2[v1+1]*fx+sx);
    }

    ctx.strokeStyle = "#ff00ff";
    ctx.stroke();

    this.addPolygonRAW(vertices, surface, borders, middle, heightMode, properties, id, srs);

    return this;
};*/

//same as addPolygon but works on poles and is subivided
MapGeodataBuilder.prototype.addPolygon3 = function(shape, holes, middle, heightMode, properties, id, srs, tesselation) {
    srs = srs ? srs : this.navSrs.srsProj4;
    holes = holes || [];

    var flatShape = shape, flatHoles = holes, i, li, j, lj, k, lk, l, hole, coords = [], coords2 = [], proj, holesIndices, vertices;
    var projected = true, dx, dy, dz, dd, maxDistance = 0, maxDistanceCoords, flatCenter, trueHolesCount = holes.length;

    tesselation = tesselation || {};
    tesselation.mode = tesselation['mode'] || 'auto';

    if (tesselation.mode == 'by-length') {
        tesselation.length = tesselation['length'] || 200000;
    }

    var density = 19;

    //convert shape and holes to flat space
    if (srs.indexOf('+proj=longlat') != -1) {
        projected = false;
        proj = this.map.proj4(srs, '+proj=geocent +datum=WGS84 +units=m +no_defs');
        //proj = this.map.proj4(srs, '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
    }

    var totalPoints = shape.length*3;

    for (i = 0, li = shape.length; i < li; i++) {
        shape[i][2] = shape[i][2] || 0; //add third coord
    }

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        totalPoints += hole.length*3;

        for (j = 0, lj = hole.length; j < lj; j++) {
            hole[j][2] = hole[j][2] || 0; //add third coord
        }
    }

    var center = this.getPolygonCenter(shape, projected, proj), north, east, dir, geod;

    var ned = this.map.measure.getNewNED(center);

    dir = ned.direction;
    north = ned.direction;
    east = ned.east;

    flatShape = new Array(totalPoints);
    vertices = new Array(totalPoints);
    j = 0;

    var borders = new Array(holes.length + 1);
    var border = new Array(shape.length);
    borders[0] = border;

    var gcenter;

    if (proj) {
        gcenter = proj.forward(center);
    } else {
        gcenter = center;
    }

    for (i = 0, li = shape.length; i < li; i++) {
        border[i] = i;
        coords = shape[i];
        vertices[j] = coords[0]; 
        vertices[j+1] = coords[1]; 
        vertices[j+2] = coords[2];

        if (proj) {
            coords2 = proj.forward(shape[i]);
            coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                      north[0] * coords2[0] + north[1] * coords2[1] + north[2] * coords2[2], 0];
        } else {
            coords2 = shape[i];
            coords = coords2;
        }

        dx = coords2[0] - gcenter[0];
        dy = coords2[1] - gcenter[1];
        dz = coords2[2] - gcenter[2];
        dd = dx * dx + dy * dy + dz*dz;
        if (dd > maxDistance) {
            maxDistance = dd;
            maxDistanceCoords = shape[i]
        }

        flatShape[j] = coords[0]; 
        flatShape[j+1] = coords[1]; 
        flatShape[j+2] = coords[2]; 
        j+=3;
    }

    //check curve orientation (have to be clockwise)
    var angle = 0, x1, y1, x2, y2, index;
    for (i = 0, li = shape.length * 3; i < li; i+=3) {
        x1 = flatShape[i]; 
        y1 = flatShape[i+1]; 

        if (i < li - 3) {
            x2 = flatShape[i+3]; 
            y2 = flatShape[i+4]; 
        } else {
            x2 = flatShape[0]; 
            y2 = flatShape[1]; 
        }

        //angle += (x2 - x1) * (y2 + y1);
        angle += (x1 * y2);
        angle -= (x2 * y1);
    }    
    
    if (angle < 0) { //convert to clokwise
        var vertices2 = vertices.slice();
        var flatShape2 = flatShape.slice();

        for (i = 0, li = shape.length * 3; i < li; i+=3) {
            vertices[i] = vertices2[li - i - 3];
            vertices[i+1] = vertices2[li - i - 2];
            vertices[i+2] = vertices2[li - i - 1];

            flatShape[i] = flatShape2[li - i - 3];
            flatShape[i+1] = flatShape2[li - i - 2];
            flatShape[i+2] = flatShape2[li - i - 1];
        }
    }


    flatHoles = new Array(holes.length);
    holesIndices = new Array(holes.length);

    for (i = 0, li = holes.length; i < li; i++) {
        hole = holes[i];
        index = Math.round(j/3);
        holesIndices[i] = index;

        if (i < trueHolesCount) {
            border = new Array(hole.length);
            borders[i + 1] = border;
        }

        l = index;

        for (k = 0, lk = hole.length; k < lk; k++) {
            coords = hole[k];
            vertices[j] = coords[0]; 
            vertices[j+1] = coords[1]; 
            vertices[j+2] = coords[2]; 

            if (proj) {
                coords2 = proj.forward(hole[k]);
                //cords = [coords2[0], coords2[1], 0];
                coords = [east[0] * coords2[0] + east[1] * coords2[1] + east[2] * coords2[2],
                          dir[0] * coords2[0] + dir[1] * coords2[1] + dir[2] * coords2[2], 0];
            } else {
                coords = hole[k];
            }

            flatShape[j] = coords[0]; 
            flatShape[j+1] = coords[1]; 
            flatShape[j+2] = coords[2]; 
            j+=3;

            if (i < trueHolesCount) {
                border[k] = l;
                l++;
            }
        }

        //check curve orientation (have to be clockwise)
        angle = 0;
        index *= 3;
        for (k = 0, lk = hole.length * 3; k < lk; k+=3) {
            x1 = flatShape[index + k]; 
            y1 = flatShape[index + k+1]; 

            if (k < lk - 3) {
                x2 = flatShape[index + k+3]; 
                y2 = flatShape[index + k+4]; 
            } else {
                x2 = flatShape[index + 0]; 
                y2 = flatShape[index + 1]; 
            }

            //angle += (x2 - x1) * (y2 + y1);
            angle += (x1 * y2);
            angle -= (x2 * y1);
        }    
        
        if (angle > 0) { //convert to clokwise
            var vertices2 = vertices.slice();
            var flatShape2 = flatShape.slice();

            for (k = 0, lk = hole.length * 3; k < lk; k+=3) {
                vertices[index + k] = vertices2[index + lk - k - 3];
                vertices[index + k+1] = vertices2[index + lk - k - 2];
                vertices[index + k+2] = vertices2[index + lk - k - 1];

                flatShape[index + k] = flatShape2[index + lk - k - 3];
                flatShape[index + k+1] = flatShape2[index + lk - k - 2];
                flatShape[index + k+2] = flatShape2[index + lk - k - 1];
            }
        }

    }

    var surface = vts.earcut(flatShape, holesIndices, 3);

    var maxFaceLength = Number.POSITIVE_INFINITY;

    switch (tesselation.mode) {
        case 'auto':      maxFaceLength = Math.sqrt(maxDistance) / density; break;
        case 'by-length': maxFaceLength = tesselation.length; break;
    }

    var v1, v2, v3, p1, p2, p3, p4, p5, p6;

    //copy bordes
    var borders2 = new Array(borders.length), border2; 
    for (i = 0, li = borders.length; i < li; i++) {
        borders2[i] = borders[i].slice();
    }

    var sbuffer = new Array(65536*3);
    var sbuffer2 = new Array(65536*3);
    var sbuffer3 = new Array(65536*3);

    var sbufferIndex = 0, l1, l2, l3, vv1, vv2, vv3;
    var sbufferIndex2 = 0;//, i1, i2, i3;
    var sbufferIndex3 = 0;

    var vbuffer = new Array(65536*3);

    //copy vertices
    for (i = 0, li = vertices.length; i < li; i +=3) { 
        vbuffer[i] = vertices[i];
        vbuffer[i+1] = vertices[i+1];
        vbuffer[i+2] = vertices[i+2];
    }

    var m = Math.round(li / 3);


    var lastMaxFaceLength = maxFaceLength;

    for (i = 0, li = surface.length; i < li; i +=3) { 

        v1 = surface[i];
        v2 = surface[i+1];
        v3 = surface[i+2];
        sbufferIndex = 3;

        //find face edges in borders
        var edge1 = null, edge2 = null, edge3 = null;
        //var edge1, edge2, edge3;
        for (j = 0, lj = borders.length; j < lj; j++) { 
            border = borders[j];
            border2 = borders2[j];

            for (k = 0, lk = border.length; k < lk; k++) {
                var k2 = (k < border.length - 1) ? k + 1 : 0;

                if ((v1 == border[k] && v2 == border[k2]) || (v1 == border[k2] && v2 == border[k])) {
                    border2[k] = [border[k]];
                    edge1 = border2[k];
                }

                if ((v2 == border[k] && v3 == border[k2]) || (v2 == border[k2] && v3 == border[k])) {
                    border2[k] = [border[k]];
                    edge2 = border2[k];
                }

                if ((v3 == border[k] && v1 == border[k2]) || (v1 == border[k2] && v3 == border[k])) {
                    border2[k] = [border[k]];
                    edge3 = border2[k];
                }
            }
        }

        sbuffer[0] = [v1, edge1];
        sbuffer[1] = [v2, edge2];
        sbuffer[2] = [v3, edge3];

        var depth = 0, r;

        //loop until subdivision is finished
        do {

            for (j = 0, lj = sbufferIndex; j < lj; j+=3) {
                //face indices//
                vv1 = sbuffer[j][0];
                vv2 = sbuffer[j+1][0];
                vv3 = sbuffer[j+2][0];
                //face edges
                edge1 = sbuffer[j][1];
                edge2 = sbuffer[j+1][1];
                edge3 = sbuffer[j+2][1];

                /*console.log('v1: ' + vv1 + ' v2:' + vv2 + ' v3:' + vv3);
                console.log('e1: ' + (Array.isArray(edge1) ? 'a' : '') + edge1 + ' e2:' + (Array.isArray(edge2) ? 'a' : '') + edge2 + ' e3:' + (Array.isArray(edge3) ? 'a' : '') + edge3);
                */

                //get face vertices
                p1 = [vbuffer[vv1*3], vbuffer[vv1*3+1], vbuffer[vv1*3+2]];
                p2 = [vbuffer[vv2*3], vbuffer[vv2*3+1], vbuffer[vv2*3+2]];
                p3 = [vbuffer[vv3*3], vbuffer[vv3*3+1], vbuffer[vv3*3+2]];

                //covert coords to geocent
                if (proj) {
                    p1 = proj.forward(p1);
                    p2 = proj.forward(p2);
                    p3 = proj.forward(p3);
                }

                //get face edges lengths
                l1 = vec3.length([p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]]);
                l2 = vec3.length([p2[0] - p3[0], p2[1] - p3[1], p2[2] - p3[2]]);
                l3 = vec3.length([p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]]);

                //get max length
                l = Math.max(l1,l2,l3);

                //console.log('ll:' + l);

                //is length below threshold
                if (l < maxFaceLength) {  
                    //add to final buffer
                    sbuffer3[sbufferIndex3] = vv1;
                    sbuffer3[sbufferIndex3+1] = vv2;
                    sbuffer3[sbufferIndex3+2] = vv3;
                    sbufferIndex3 += 3;
                } else {

                    //crete new vertices in the midle of edges and convert coords back to long lat
                    //if (l1 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv1*3+1], vbuffer[vv1*3], vbuffer[vv2*3+1], vbuffer[vv2*3]);
                     //   r = geod.Direct(vbuffer[vv1*3+1], vbuffer[vv1*3], r.azi1, r.s12 *0.5);
                    //    p4 = [r.lon2, r.lat2, (vbuffer[vv1*3+2]+vbuffer[vv2*3+2])*0.5];
                    //} else {
                        p4 = [(p1[0]+p2[0])*0.5, (p1[1]+p2[1])*0.5, (p1[2]+p2[2])*0.5];
                    if (proj) {
                        p4 = proj.inverse(p4); p4[2] = (vbuffer[vv1 * 3 + 2] + vbuffer[vv2 * 3 + 2]) * 0.5;
                    }
                    //}

                    //if (l2 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv2*3+1], vbuffer[vv2*3], vbuffer[vv3*3+1], vbuffer[vv3*3]);
                     //   r = geod.Direct(vbuffer[vv2*3+1], vbuffer[vv2*3], r.azi1, r.s12 *0.5);
                     //   p5 = [r.lon2, r.lat2, (vbuffer[vv2*3+2]+vbuffer[vv3*3+2])*0.5];
                    //} else {
                        p5 = [(p2[0]+p3[0])*0.5, (p2[1]+p3[1])*0.5, (p2[2]+p3[2])*0.5];
                    if (proj) {
                        p5 = proj.inverse(p5); p5[2] = (vbuffer[vv2 * 3 + 2] + vbuffer[vv3 * 3 + 2]) * 0.5;
                    }
                    //}

                    //if (l3 > 200000 && !projected) {
                     //   r = geod.Inverse(vbuffer[vv3*3+1], vbuffer[vv3*3], vbuffer[vv1*3+1], vbuffer[vv1*3]);
                     //   r = geod.Direct(vbuffer[vv3*3+1], vbuffer[vv3*3], r.azi1, r.s12 *0.5);
                     //   p6 = [r.lon2, r.lat2, (vbuffer[vv3*3+2]+vbuffer[vv1*3+2])*0.5];
                    //} else {
                        p6 = [(p3[0]+p1[0])*0.5, (p3[1]+p1[1])*0.5, (p3[2]+p1[2])*0.5];
                    if (proj) {
                        p6 = proj.inverse(p6); p6[2] = (vbuffer[vv3 * 3 + 2] + vbuffer[vv1 * 3 + 2]) * 0.5;
                    }
                    //}

                    var mm = m * 3;

                    if (l1 == l) {
                        //console.log('l1');

                        //add new vertices to the buffer
                        vbuffer[mm] = p4[0];
                        vbuffer[mm+1] = p4[1];
                        vbuffer[mm+2] = p4[2];

                        //create new edges
                        if (edge1) {
                            edge1[0] = [[edge1[0]], [-m]];
                            edge1 = edge1[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1[0] : null];
                        sbuffer2[l+1] = [m, null];
                        sbuffer2[l+2] = [vv3, edge3 ? edge3 : null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + 
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/


                        sbuffer2[l+3] = [m, edge1 ? edge1[1] : null];
                        sbuffer2[l+4] = [vv2, edge2 ? edge2 : null];
                        sbuffer2[l+5] = [vv3, null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + 
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    } else if (l2 == l) {
                        //console.log('l2');

                        //add new vertices to the buffer
                        vbuffer[mm] = p5[0];
                        vbuffer[mm+1] = p5[1];
                        vbuffer[mm+2] = p5[2];

                        //create new edges
                        if (edge2) {
                            edge2[0] = [[edge2[0]], [-m]];
                            edge2 = edge2[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];
                        sbuffer2[l+1] = [vv2, edge2 ? edge2[0] : null];
                        sbuffer2[l+2] = [m, null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + 
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/

                        sbuffer2[l+3] = [m, edge2 ? edge2[1] : null];
                        sbuffer2[l+4] = [vv3, edge3 ? edge3 : null];
                        sbuffer2[l+5] = [vv1, null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + 
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    } else if (l3 == l) {
                        //console.log('l3');

                        //add new vertices to the buffer
                        vbuffer[mm] = p6[0];
                        vbuffer[mm+1] = p6[1];
                        vbuffer[mm+2] = p6[2];

                        //create new edges
                        if (edge3) {
                            edge3[0] = [[edge3[0]], [-m]];
                            edge3 = edge3[0];
                        }

                        l = sbufferIndex2;

                        //store new faces with edges
                        sbuffer2[l] = [vv1, edge1 ? edge1 : null];
                        sbuffer2[l+1] = [vv2, null];
                        sbuffer2[l+2] = [m, edge3 ? edge3[1] : null];
                        /*console.log('-v1: ' + sbuffer2[l][0] + ' v2:' + sbuffer2[l+1][0] + ' v3:' + sbuffer2[l+2][0]);
                        console.log('p1: ' + (Array.isArray(sbuffer2[l][1]) ? 'a' : '') + sbuffer2[l][1] + 
                                   ' p2:' + (Array.isArray(sbuffer2[l+1][1]) ? 'a' : '') + sbuffer2[l+1][1] +
                                   ' p3:' + (Array.isArray(sbuffer2[l+2][1]) ? 'a' : '') + sbuffer2[l+2][1]);*/

                        sbuffer2[l+3] = [m, null]; 
                        sbuffer2[l+4] =  [vv2, edge2 ? edge2 : null]; 
                        sbuffer2[l+5] = [vv3, edge3 ? edge3[0] : null];
                        /*console.log('-v1: ' + sbuffer2[l+3][0] + ' v2:' + sbuffer2[l+4][0] + ' v3:' + sbuffer2[l+5][0]);
                        console.log('p4: ' + (Array.isArray(sbuffer2[l+3][1]) ? 'a' : '') + sbuffer2[l+3][1] + 
                                   ' p5:' + (Array.isArray(sbuffer2[l+4][1]) ? 'a' : '') + sbuffer2[l+4][1] +
                                   ' p6:' + (Array.isArray(sbuffer2[l+5][1]) ? 'a' : '') + sbuffer2[l+5][1]);*/

                    }

                    m += 1;
                    sbufferIndex2 += 6;
                }
            }

            var tmp = sbuffer;
            sbuffer = sbuffer2;
            sbuffer2 = tmp;
            sbufferIndex = sbufferIndex2;
            sbufferIndex2 = 0;

            //if (sbufferIndex3 > 1000) {
                //break;
            //}

            depth++;

            //if (depth == 1) {
              //  maxFaceLength = Number.POSITIVE_INFINITY;
            //}


        } while(sbufferIndex > 0);

        maxFaceLength = lastMaxFaceLength;

    }

    var ebuffer = new Array(65536*3), ebufferIndex = 0;

    var unrollBorder = (function(borderArray) {
        for (var o = 0, lo = borderArray.length; o < lo; o++) {
            if (Array.isArray(borderArray[o])) {
                unrollBorder(borderArray[o]);
            } else {
                ebuffer[ebufferIndex] = borderArray[o];
                ebufferIndex++;
            }
        }
    });

    var lastEbufferIndex = 0;

    //unroll edges
    for (i = 0, li = borders2.length; i < li; i++) {
        unrollBorder(borders2[i]);
        borders2[i] = ebuffer.slice(lastEbufferIndex, ebufferIndex);
        lastEbufferIndex = ebufferIndex;
    }

    surface = new Array(sbufferIndex);

    for (i = 0, li = sbufferIndex3; i < li; i+=3) {
        surface[i] = sbuffer3[i];
        surface[i+1] = sbuffer3[i+1];
        surface[i+2] = sbuffer3[i+2];
    }

    vertices = new Array(m * 3);
    j = 0;

    for (i = 0, li = m*3; i < li; i+=3) {
        vertices[i] = vbuffer[i];
        vertices[i+1] = vbuffer[i+1];
        vertices[i+2] = vbuffer[i+2];
        //this.addPoint([vertices[i], vertices[i+1], vertices[i+2]], 'fix', {name:(''+j)}, 'aaa');
        j++;
    }

    this.addPolygonRAW(vertices, surface, borders2, middle, heightMode, properties, id, srs);
};


MapGeodataBuilder.prototype.addPolygonRAW = function(vertices, surface, borders, middle, heightMode, properties, id, srs, directCopy) {
    if (!this.currentGroup) {
        this.addGroup('some-group');
    }

    var floatHeight = (!heightMode || heightMode == "float");
    var i, li, j = 0, coords;
    srs = srs ? srs : this.navSrs;

    var feature = {
        id : id,
        properties : properties
    };

    var featureVertices = new Array(Math.round(vertices.length/3));

    if (floatHeight) {
        for (i = 0, li = vertices.length; i < li; i+=3) {
            coords = [vertices[i], vertices[i+1], vertices[i+2], feature, null, null];
            this.addToHeightsBuffer(coords);
            featureVertices[j++] = coords;
        }

        feature.floatHeights = true;
        feature.srs = srs;
        feature.heightsToProcess = featureVertices.length;
        this.heightsToProcess += featureVertices.length;
    } else {

        for (i = 0, li = vertices.length; i < li; i+=3) {
            coords = [vertices[i], vertices[i+1], vertices[i+2]];

            if (directCopy) {
                featureVertices[j++] = coords;
            } else {
                featureVertices[j++] = this.physSrs.convertCoordsFrom(coords, srs);
            }
        }
    }

    var featureSurface = surface.slice();
    var featureBorders = new Array(borders.length);

    for (i = 0, li = borders.length; i < li; i++) {
        featureBorders[i] = borders[i].slice();
    }

    feature.vertices = featureVertices;
    feature.surface = featureSurface;
    feature.borders = featureBorders;
    this.currentGroup.polygons.push(feature);

    return this;
};


MapGeodataBuilder.prototype.importVTSGeodata = function(json, groupIdPrefix, dontCreateGroups) {
    var importer = new MapGeodataImportVTSGeodata(this, groupIdPrefix, dontCreateGroups);
    return importer.processJSON(json);
};


MapGeodataBuilder.prototype.importGeoJson = function(json, heightMode, srs, options) {
    var importer = new MapGeodataImportGeoJSON(this, heightMode, srs, options);
    return importer.processJSON(json);
};


MapGeodataBuilder.prototype.processHeights = function(heightsSource, precision, onProcessed) {
    if (this.heightsToProcess <= 0) {
        if (onProcessed) {
            onProcessed(this);
        }

        return;
    }

    if (this.processingHeights) {
        this.processHeightsCalls.push(this.processHeights.bind(this, heightsSource, precision));
    }

    this.processingHeights = true;
    this.heightsSource = heightsSource;
    this.heightsLod = precision;

    var item = this.heightsProcessBufferFirst, lastItem;
    //var item = this.heightsProcessBuffer, lastItem;
    var p, res, nodeOnly, heightsLod, nodeOnly, coords, noSource;

    switch (heightsSource) {
        case "node-by-precision":
            nodeOnly = true;
        case "heightmap-by-precision":

            coords = item.coords;

            if (coords[3].srs) {
                p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);
            } else {
                p = coords;
            }

            heightsLod = this.map.measure.getOptimalHeightLodBySampleSize(p, precision);
            break;

        case "node-by-lod":
            nodeOnly = true;
            precision -= 8;
        case "heightmap-by-lod":
            heightsLod = precision;
            break;
        case "none":
            noSource = true;
            break;
    }

    do {
        coords = item.coords;

        if (!noSource && coords[4] == null) {
            if (coords[3].srs) {
                p = this.navSrs.convertCoordsFrom(coords, coords[3].srs);
            } else {
                p = coords;
            }

            res = this.map.measure.getSpatialDivisionNode(p);

            coords[4] = res[0];
            coords[5] = res[1];

            //coords[4] = p;
        }


        if (noSource) {
            res = [0,true,true];
        } else {
            res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);
        }

        //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);

        //console.log(JSON.stringify(res));

        //if (res[1] || res[2]) { //precisin reached or not aviable
            //res = this.map.measure.getSurfaceHeight(coords[4], heightsLod, null, null, null, null, nodeOnly);
            //res = this.map.measure.getSurfaceHeight(coords, heightsLod, null, coords[4], coords[5], null, nodeOnly);
        //}

        if (res[1] || res[2]) { //precision reached or not aviable

            //console.log(JSON.stringify(res));

            coords[2] += res[0]; //convet float height to fixed
            this.removeFromHeightsBuffer(item, lastItem);
            coords[3].heightsToProcess--;
            this.heightsToProcess--;

            if (coords[3].heightsToProcess <= 0) { //this prevents multiple conversions
                coords[3].floatHeights = false;
            }

            p = [coords[0], coords[1], coords[2]];

            //console.log(JSON.stringify(p) + "  srs  " + coords[3].srs);

            p = this.physSrs.convertCoordsFrom(p, coords[3].srs);

            coords[0] = p[0];
            coords[1] = p[1];
            coords[2] = p[2];
        }

        lastItem = item;
        item = item.next;

    } while(item);

    if (this.heightsToProcess <= 0) {
        if (this.updateCallback) {
            this.updateCallback(); //remove callback
        }

        this.processingHeights = false;

        if (onProcessed) {
            onProcessed(this);
        }

        if (this.processHeightsCalls.length > 1) {
            (this.processHeightsCalls.shift())();
        }

    } else {
        if (!this.updateCallback) {
            this.updateCallback = this.map.core.on("map-update", this.processHeights.bind(this, this.heightsSource, this.heightsLod, onProcessed));
        }
    }

};

MapGeodataBuilder.prototype.extractGeometry = function(id) {
    var feature, i, li, j, lj, points, lines,
        vertexBuffer, indexBuffer, index, p;


    for (var i = 0, li = this.groups.length; i < li; i++) {
        var group = this.groups[i];

        var groupPoints = group.points;
        var groupLines = group.lines;
        var groupPolygons = group.polygons, j, lj;

        //get group bbox
        for (j = 0, lj = groupPoints.length; j < lj; j++) {
            if (groupPoints[j].id == id) {
                feature = groupPoints[j];
            }
        }

        for (j = 0, lj = groupLines.length; j < lj; j++) {
            if (groupLines[j].id == id) {
                feature = groupLines[j];
            }
        }

        for (j = 0, lj = groupPolygons.length; j < lj; j++) {
            if (groupPolygons[j].id == id) {
                feature = groupPolygons[j];
            }
        }
    }

    if (feature) {
        if (feature.points) {

            points = feature.points;

            if (points.length > 0) {
                vertexBuffer = new Float64Array(points.length * 3);

                for (i = 0, li = points.length; i < li; i++) {
                    index = i * 3;
                    p = points[i];
                    vertexBuffer[index] = p[0];
                    vertexBuffer[index+1] = p[1];
                    vertexBuffer[index+2] = p[2];
                }
            }

            return new MapGeodataGeometry(this.map, {'type': 'point-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer });

        } else if (feature.lines) {

            lines = feature.lines;

            if (lines.length > 0) {
                
                var totalPoints = 0;

                for (i = 0, li = lines.length; i < li; i++) {
                    totalPoints += lines[i].length;
                }

                vertexBuffer = new Float64Array(totalPoints * 3);
                indexBuffer = new Uint32Array(li);
                index = 0;

                for (i = 0, li = lines.length; i < li; i++) {

                    var points = lines[i];

                    for (j = 0, lj = points.length; j < lj; j++) {
                        p = points[j];
                        vertexBuffer[index] = p[0];
                        vertexBuffer[index+1] = p[1];
                        vertexBuffer[index+2] = p[2];
                        index += 3;
                    }
                }
            }

            return new MapGeodataGeometry(this.map, {'type': 'line-geometry', 'id':feature.id, 'geometryBuffer': vertexBuffer, 'indicesBuffer': indexBuffer });
        } else if (feature.vertices) {

            /*feature.vertices = featureVertices;
            feature.surface = featureSurface;
            feature.borders = featureBorders;*/

            return new MapGeodataGeometry(this.map, {'type': 'polygon-geometry', 'id':feature.id, 'geometryBuffer': feature.vertices, 'surface': feature.surface });
        }

        return;
    }

};


MapGeodataBuilder.prototype.compileGroup = function(group, resolution) {
    var bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    var bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
    var geodataGroup = {};
    var groupPoints = group.points, points, p, feature, finalFeature;
    var groupLines = group.lines, lines, line, i, li, j, lj, k, lk;
    var groupPolygons = group.polygons, borders;

    geodataGroup.id = group.id;

    //get group bbox
    for (i = 0, li = groupPoints.length; i < li; i++) {
        points = groupPoints[i].points;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
        }
    }

    for (i = 0, li = groupLines.length; i < li; i++) {
        lines = groupLines[i].lines;

        for (j = 0, lj = lines.length; j < lj; j++) {
            line = lines[j];

            for (k = 0, lk = line.length; k < lk; k++) {
                p = line[k];

                if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
                if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
                if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

                if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
                if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
                if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
            }
        }
    }

    for (i = 0, li = groupPolygons.length; i < li; i++) {
        points = groupPolygons[i].vertices;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            if (p[0] > bboxMax[0]) { bboxMax[0] = p[0]; }
            if (p[1] > bboxMax[1]) { bboxMax[1] = p[1]; }
            if (p[2] > bboxMax[2]) { bboxMax[2] = p[2]; }

            if (p[0] < bboxMin[0]) { bboxMin[0] = p[0]; }
            if (p[1] < bboxMin[1]) { bboxMin[1] = p[1]; }
            if (p[2] < bboxMin[2]) { bboxMin[2] = p[2]; }
        }
    }

    if (!resolution) {
        var maxDelta = Math.max((bboxMax[0] - bboxMin[0]) + 1, (bboxMax[1] - bboxMin[1]) + 1, (bboxMax[2] - bboxMin[2]) + 1);

        //25cm resolution
        resolution = maxDelta / 0.25;
        resolution = Math.max(resolution, 1024);
        resolution = Math.min(resolution, (2<<20));
    }

    geodataGroup.resolution = resolution;

    //process coords to resolution
    var bboxScaleFactor = [resolution/((bboxMax[0] - bboxMin[0]) + 1),
                           resolution/((bboxMax[1] - bboxMin[1]) + 1),
                           resolution/((bboxMax[2] - bboxMin[2]) + 1)];

    geodataGroup.points = new Array(groupPoints.length);

    for (i = 0, li = groupPoints.length; i < li; i++) {
        feature = groupPoints[i]; 
        points = feature.points;

        var finalPoints = new Array(points.length);

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];

            finalPoints[j] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),
                               Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),
                               Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];
        }

        finalFeature = {
            points : finalPoints
        };

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.points[i] = finalFeature;
    }

    geodataGroup.lines = new Array(groupLines.length);

    for (i = 0, li = groupLines.length; i < li; i++) {
        feature = groupLines[i]; 
        lines = feature.lines;

        var finalLines = new Array(lines.length);

        for (j = 0, lj = lines.length; j < lj; j++) {
            line = lines[j];

            finalPoints = new Array(line.length);

            for (k = 0, lk = line.length; k < lk; k++) {
                p = line[k];

                finalPoints[k] = [ Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]),
                                   Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]),
                                   Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]) ];
            }

            finalLines[j] = finalPoints;
        }

        finalFeature = {
            lines : finalLines
        };

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.lines[i] = finalFeature;
    }


    geodataGroup.polygons = new Array(groupPolygons.length);

    for (i = 0, li = groupPolygons.length; i < li; i++) {
        feature = groupPolygons[i]; 
        points = feature.vertices;

        var finalVertices = new Array(points.length);
        k = 0;

        for (j = 0, lj = points.length; j < lj; j++) {
            p = points[j];
            finalVertices[k++] = Math.round((p[0] - bboxMin[0]) * bboxScaleFactor[0]);
            finalVertices[k++] = Math.round((p[1] - bboxMin[1]) * bboxScaleFactor[1]);
            finalVertices[k++] = Math.round((p[2] - bboxMin[2]) * bboxScaleFactor[2]);
        }

        finalFeature = {
            vertices : finalVertices,
            surface : feature.surface.slice()
        };

        borders = feature.borders;
        var finalBorders = new Array(borders.length);

        for (j = 0, lj = finalBorders.length; j < lj; j++) {
            finalBorders[j] = borders[j].slice();
        }

        finalFeature.borders = finalBorders;

        if (feature.id) {
            finalFeature.id = feature.id;
        }

        if (feature.properties) {
            finalFeature.properties = feature.properties;
        }

        geodataGroup.polygons[i] = finalFeature;
    }

    geodataGroup.bbox = [ bboxMin, bboxMax ];

    if (bboxMax[0] > this.bboxMax[0]) { this.bboxMax[0] = bboxMax[0]; }
    if (bboxMax[1] > this.bboxMax[1]) { this.bboxMax[1] = bboxMax[1]; }
    if (bboxMax[2] > this.bboxMax[2]) { this.bboxMax[2] = bboxMax[2]; }

    if (bboxMin[0] < this.bboxMin[0]) { this.bboxMin[0] = bboxMin[0]; }
    if (bboxMin[1] < this.bboxMin[1]) { this.bboxMin[1] = bboxMin[1]; }
    if (bboxMin[2] < this.bboxMin[2]) { this.bboxMin[2] = bboxMin[2]; }

    return geodataGroup;
};


MapGeodataBuilder.prototype.makeGeodata = function(resolution) {
    this.bboxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    this.bboxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];

    var geodata = {
        "version" : 1,
        "groups" : []
    }

    for (var i = 0, li = this.groups.length; i < li; i++) {
        geodata["groups"].push(this.compileGroup(this.groups[i], resolution));
    }

    return geodata;
};


MapGeodataBuilder.prototype.makeFreeLayer = function(style, resolution) {
    var geodata = this.makeGeodata(resolution);

    if (!style) {
        style = {
            "layers" : {
                "my-lines" : {
                    "filter" : ["==", "#type", "line"],
                    "line": true,
                    "line-width" : 4,
                    "line-color": [255,0,255,255],
                    "zbuffer-offset" : [-5,0,0]
                },
                "my-points" : {
                    "filter" : ["==", "#type", "point"],
                    "point": true,
                    "point-radius" : 10,
                    "point-color": [0,0,255,255],
                    "zbuffer-offset" : [-5,0,0]
                }
            }
        }        
    }

    var freeLayer = {
            'credits' : [],
            'displaySize' : 1024,
            'extents' : {
                'll' : this.bboxMin,
                'ur' : this.bboxMax
            },
            'geodata' : geodata,
            'style' : style,
            'type' : 'geodata'
        };

    return freeLayer;        
};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodataBuilder);



/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);


/*import {math as math_} from '../utils/math';*/

//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
/*var math = math_;*/


var MapGeodataGeometry = function(map, data) {
    this.map = map;
    this.data = data;
    this.camera = map.camera;
    this.renderer = map.renderer;

    switch (data.type) {
        case 'point-geometry':   
            this.type = 1;
            this.vertexBuffer = this.data.geometryBuffer;
            break;
        case 'line-geometry':
            this.type = 2;
            this.vertexBuffer = this.data.geometryBuffer;
            this.indicesBuffer = this.data.indicesBuffer;
            break;
        case 'polygon-geometry':
            this.type = 3;
            this.vertexBuffer = this.data.geometryBuffer;
            this.surface = this.data.surface;
            this.borders = this.data.borders;
            break;
    }
};

MapGeodataGeometry.prototype.getType = function() {
    switch(this.type) {
        case 1: return 'point';
        case 2: return 'line';
        case 3: return 'polygon';
    }
};

MapGeodataGeometry.prototype.getElement = function(index) {
    var v = this.vertexBuffer, i = index * 3;
    switch(this.type) {
        case 1: return [v[i], v[i+1], v[i+2]]; //point
        case 2: return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]]; //line
        case 3: 
            var s = this.surface;
            var i1 = s[i], i2 = s[i+1], i3 = s[i+2];
            return [[v[i1][0], v[i1][1], v[i1][2]],  [v[i2][0], v[i2][1], v[i2][2]],  [v[i3][0], v[i3][1], v[i3][2]]]; //polygon
    }
};

MapGeodataGeometry.prototype.getElements = function(pathIndex) {
    switch(this.type) {
        case 1: //point
        case 3: return this.surface.length / 3; //polygon
        case 2:  //line
            
            pathIndex = pathIndex || 0;
            var si = (this.indicesBuffer[pathIndex]) * 3;
            var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

            return Math.max(0, ((ei - si) / 3) - 1);
    }
};

MapGeodataGeometry.prototype.getRelationToCanvasPoint = function(index, screenX, screenY) {
    var v = this.vertexBuffer, i = index * 3;
    var c1, cv, p, r = [0,0,0];
    var a, b, c, d, e, D, sc, tc, u, v, w;

    c1 = this.camera.position;
    //cv = this.camera.vector;

    cv = this.renderer.getScreenRay(screenX, screenY);

    //console.log(JSON.stringify(c1) + "  " + JSON.stringify(cv));

    switch(this.type) {
        case 1: 

            //get point
            var p = [v[i], v[i+1], v[i+2]];

            var cp = [p[0] - c[0], p[0] - c[0],]

            //distance = vec3.coss(ray.direction, point - ray.origin).magnitude;
            vec3.cross(cv, cp, r)
            d = vec3.length(p);

            return {
                'distance' : d,
                'point' : p
            }

        case 2: 

            //line points
            var p1 = [v[i], v[i+1], v[i+2]];
            var p2 = [v[i+3], v[i+4], v[i+5]]; 

            //distance = http://geomalgorithms.com/a07-_distance.html

            u = cv;
            v = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            w = [c1[0] - p1[0], c1[1] - p1[1], c1[2] - p1[2]];
            a = vec3.dot(u,u);    // always >= 0
            b = vec3.dot(u,v);
            c = vec3.dot(v,v);    // always >= 0
            d = vec3.dot(u,w);
            e = vec3.dot(v,w);
            D = a*c - b*b;        // always >= 0

            // compute the line parameters of the two closest points
            if (D < 0.0000001) {          // the lines are almost parallel
                sc = 0.0;
                tc = (b>c ? d/b : e/c);    // use the largest denominator
            }
            else {
                sc = (b*e - c*d) / D;
                tc = (a*e - b*d) / D;
            }

            // get the difference of the two closest points
            var dP = [ w[0] + (u[0] * sc) - (v[0] * tc),
                       w[1] + (u[1] * sc) - (v[1] * tc),
                       w[2] + (u[2] * sc) - (v[2] * tc) ];

            return {
                'closest' : [ p1[0] + (v[0] * tc), p1[1] + (v[1] * tc), p1[2] + (v[2] * tc) ],
                'line-distance' : vec3.length(dP),
                'distance' : tc,
                'line' : [p1, p2]
            }
    }
};

MapGeodataGeometry.prototype.getPathElement = function(index, pathIndex) {
    if (this.type != 2) {
        return null;
    }

    var i = (this.indicesBuffer[pathIndex || 0] + index) * 3, v = this.vertexBuffer;
    return [[v[i], v[i+1], v[i+2]],  [v[i+3], v[i+4], v[i+5]]];
};

MapGeodataGeometry.prototype.getPathPoint = function(distance, pathIndex) {
    pathIndex = pathIndex || 0;

    var si = (this.indicesBuffer[pathIndex]) * 3;
    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    var totalLength = 0, delta, length, v = this.vertexBuffer;

    for (var i = si; i < (ei-3); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (totalLength + length > distance) {
            var factor =  (distance - totalLength) / length;
            return [v[i] + delta[0] * factor, v[i+1] + delta[1] * factor, v[i+2] + delta[2] * factor];
        }

        totalLength += length;    
    }

    return [v[ei-3], v[ei-2], v[ei-1]];
};

MapGeodataGeometry.prototype.getPathNED = function(distance, withoutSlope, pathIndex) {
    pathIndex = pathIndex || 0;

    var si = (this.indicesBuffer[pathIndex]) * 3;
    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    var totalLength = 0, p, delta, length, v = this.vertexBuffer;

    for (var i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (totalLength + length > distance) {
            var factor = (totalLength + length) / distance;
            p = [v[i] + d[0] * factor, v[i+1] + d[1] * factor, v[i+2] + d[2] * factor];
            break;
        }

        totalLength += length;    
    }

    if (!p) {
        p = [v[ei-3], v[ei-2], v[ei-1]];
    }

    var vv = [0, 0, 0];
    var nn = [0, 0, 0];
    var pp = [0, 0, 0];

    vec3.nomalize(delta, vv);
    vec3.nomalize(p, pp);
    vec3.cross(pp, vv, nn);    

    if (withoutSlope) {
        vec3.cross(pp, nn, vv);    
    }

    var east = nn;
    var direction = vv;
    var north = pp;

    return {
        'east'  : east, 
        'direction' : direction,
        'north' : north,
        'position' : p,
        'matrix' : [
            east[0], east[1], east[2], 0,
            north[0], north[1], north[2], 0,
            direction[0], direction[1], direction[2], 0,
            0, 0, 0, 1
        ] 
    };    
};


MapGeodataGeometry.prototype.getPathLengthToElement = function(index, pathIndex) {
    pathIndex = pathIndex || 0;

    var si = (this.indicesBuffer[pathIndex]) * 3;
    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    var totalLength = 0, delta, length, v = this.vertexBuffer, elementIndex = 0;

    for (var i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        if (index == elementIndex) {
            return {
                'lengthToElement' : totalLength,
                'elementLengh' : length
            }
        }

        elementIndex++
        totalLength += length;
    }

    return totalLength;
};


MapGeodataGeometry.prototype.getPathLength = function(pathIndex) {
    pathIndex = pathIndex || 0;

    var si = (this.indicesBuffer[pathIndex]) * 3;
    var ei = ((pathIndex + 1) >= this.indicesBuffer.length) ? this.vertexBuffer.length : (this.indicesBuffer[pathIndex] * 3);

    var totalLength = 0, delta, length, v = this.vertexBuffer;

    for (var i = si; i < (ei-5); i+=3) {
        delta = [v[i+3] - v[i], v[i+4] - v[i+1], v[i+5] - v[i+2]];
        length = vec3.length(delta);

        totalLength += length;
    }

    return totalLength;
};


MapGeodataGeometry.prototype.getPathsCount = function() {
    if (this.type != 2) {
        return 0;
    }

    return this.indicesBuffer.length;
};


MapGeodataGeometry.prototype.getSurfaceArea = function() {
    if (this.type != 3) {
        return 0;
    }

    if (!this.surfaceArea) {
        var v = this.vertexBuffer, s = this.surface;
        var p1, p2, p3, l1, l2, l3, dx, dy, dz, perimeter, area;

        this.surfaceArea = 0;
        for (var i = 0, li = s.length; i < li; i+= 3) {
            p1 = v[s[i]];
            p2 = v[s[i+1]];
            p3 = v[s[i+2]];

            dx = p2[0] - p1[0];
            dy = p2[1] - p1[1];
            dz = p2[2] - p1[2];
            l1 = Math.sqrt(dx*dx + dy*dy + dz*dz); 

            dx = p2[0] - p3[0];
            dy = p2[1] - p3[1];
            dz = p2[2] - p3[2];
            l2 = Math.sqrt(dx*dx + dy*dy + dz*dz); 

            dx = p3[0] - p1[0];
            dy = p3[1] - p1[1];
            dz = p3[2] - p1[2];
            l3 = Math.sqrt(dx*dx + dy*dy + dz*dz); 

            //Heron's formula
            perimeter = (l1 + l2 + l3)/2;
            area =  Math.sqrt(perimeter*((perimeter-l1)*(perimeter-l2)*(perimeter-l3)));

            this.surfaceArea += area;
        }
    }

    return this.surfaceArea;
};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodataGeometry);




/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapGeodataImportGeoJSON = function(builder, heightMode, srs, options) {
    this.builder = builder;
    this.map = builder.map;
    this.heightMode = heightMode || 'float';
    this.srs = srs;

    options = options || {};

    this.groupIdPrefix = options['groupIdPrefix'] || '';
    this.dontCreateGroups = options['dontCreateGroups'];
    this.tesselation = options['tesselation'];
};

MapGeodataImportGeoJSON.prototype.processGeometry = function(geometry, feature) {
    var coords = geometry['coordinates'];
    if (!coords) {
        return;
    }

    switch(geometry['type']) {
        case 'Point':
            this.builder.addPoint(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'MultiPoint':
            this.builder.addPointArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'LineString':
            this.builder.addLineString(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'MultiLineString':
            this.builder.addLineStringArray(coords, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs);
            break;

        case 'Polygon':
            if (coords.length > 0) {
                this.builder.addPolygon(coords[0], (coords.length > 1) ? coords.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);
            }
            break;

        case 'MultiPolygon':
            for (var i = 0, li = coords.length; i < li; i++) {
                var coords2 = coords[i];
                if (coords2.length > 0) {
                    this.builder.addPolygon(coords2[0], (coords2.length > 1) ? coords2.slice(1) : [], null, this.heightMode, feature['properties'], feature['properties'] ? feature['properties']['id'] : null, this.srs, this.tesselation);
                }
            }
            break;

        case 'GeometryCollection':

            var geometries = geometry['gemetries'];

            if (geometries) {
                for (var i = 0, li = geometries.length; i < li; i++) {
                    this.processGeometry(geometries[i], feature);
                }
            }
    }
};

MapGeodataImportGeoJSON.prototype.processFeature = function(json) {
    var geometry = json['geometry'];

    if (geometry) {
        this.processGeometry(geometry, json);
    }
};

MapGeodataImportGeoJSON.prototype.processCollection = function(json) {
    var features = json['features'];

    if (!features) {
        return;
    }

    for (var i = 0, li = features.length; i < li; i++) {
        this.processFeature(features[i]);
    }
};

MapGeodataImportGeoJSON.prototype.processJSON = function(json) {
    if (!json) {
        return;
    }

    if (json['type']) {

        switch (json['type']) {
            case 'FeatureCollection':

                if (!this.dontCreateGroups) {
                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);
                }

                this.processCollection(json);
                break;
            case 'Feature':

                if (!this.dontCreateGroups) {
                    this.builder.addGroup(this.groupIdPrefix != '' ? this.groupIdPrefix : null);
                }

                this.processFeature(json);
                break;
        }

    } else {

        for (var key in json) {
            var item = json[key];

            if (!this.dontCreateGroups) {
                this.builder.addGroup(this.groupIdPrefix + key);
            }

            switch (json['type']) {
                case 'FeatureCollection':
                    this.processCollection(item);
                    break;
                case 'Feature':
                    this.processFeature(item);
                    break;
            }
        }
    }

};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodataImportGeoJSON);



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapGeodataImportVTSGeodata = function(builder, groupIdPrefix, dontCreateGroups) {
    this.builder = builder;
    this.map = builder.map;
    this.groupIdPrefix = groupIdPrefix || '';
    this.dontCreateGroups = dontCreateGroups;
    //this.processJSON(json);
};

MapGeodataImportVTSGeodata.prototype.processJSON = function(json) {
    if (!json) {
        return;
    }

    var groups = json['groups'], i, li, j, lj, k, lk, p;
    var builder = this.builder, newPoints, points;

    if (!groups) {
        return;
    }

    for (i = 0, li = groups.length; i < li; i++) {
        var group = groups[i];

        var bbox = group['bbox'],
            resolution = group['resolution'];

        if (!bbox || !resolution) {
            continue;
        }

        var bboxMin = bbox[0];
        var bboxMax = bbox[1];

        if (!bboxMin || !bboxMax) {
            continue;
        }

        if (!this.dontCreateGroups) {
            builder.addGroup(this.groupIdPrefix + (group['id'] || ''));
        }

        var fx = (bboxMax[0] - bboxMin[0]) / resolution;
        var fy = (bboxMax[1] - bboxMin[1]) / resolution;
        var fz = (bboxMax[2] - bboxMin[2]) / resolution;

        //import group points
        var pointsFeatures = group['points'];
        if (pointsFeatures) {

            points = pointsFeatures['points']

            for (j = 0, lj = pointsFeatures.length; j < lj; j++) {
                var point = pointsFeatures[j];
                var subpoints = point['points'];
                var newSubpoints = new Array(subpoints.length);

                for (k = 0, lk = subpoints.length; k < lk; k++) {
                    p = subpoints[k];
                    newSubpoints[k] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];
                }

                builder.addPointArray(newSubpoints, 'fix', point['properties'], point['id'], null, true);
            }
        }

        //import group lines
        var linesFeatures = group['lines'];
        if (linesFeatures) {
            for (j = 0, lj = linesFeatures.length; j < lj; j++) {
                var line = linesFeatures[j];
                var sublines = line['lines'];
                var newSublines = new Array(sublines.length);

                for (k = 0, lk = sublines.length; k < lk; k++) {

                    points = sublines[k];
                    newPoints = new Array(points.length);

                    for (var l  = 0, ll = points.length; l < ll; l++) {
                        p = points[l];
                        newPoints[l] = [bboxMin[0] + p[0] * fx, bboxMin[1] + p[1] * fy, bboxMin[2] + p[2] * fz];
                    }

                    newSublines[k] = newPoints;
                }

                builder.addLineStringArray(newSublines, 'fix', line['properties'], line['id'], null, true);
            }
        }
    }

};

/* harmony default export */ __webpack_exports__["a"] = (MapGeodataImportVTSGeodata);




/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapGeodataProcessor = function(surface, listener) {
    this.layer = surface;
    this.map = surface.map;
    this.renderer = this.map.renderer;
    this.killed = false;
    this.listener = listener;
    this.busy = false;
    this.ready = true;
    this.waitingForStylesheet = false;
    this.stylesheet = null;
    this.fonts = {};
    this.processCounter = 0;


    // eslint-disable-next-line
    var worker = __webpack_require__(117);
    //var worker = require('worker-loader?!./worker-main');

    //debug worker
    this.processWorker = new worker;
    
    this.processWorker.onerror = function(event){
        throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');
    };

    this.processWorker.onmessage = this.onMessage.bind(this);

    this.processWorker.postMessage({'command':'config', 'data': this.map.config});
};


MapGeodataProcessor.prototype.kill = function() {
    if (this.killed) {
        return;
    }

    this.killed = true;

    if (this.processWorker != null) {
        this.processWorker.terminate();
    }
};


MapGeodataProcessor.prototype.isReady = function() {
    if (this.waitingForStylesheet) {
        this.waitingForStylesheet = !(this.stylesheet.isReady());
    }

    return ((this.ready && !this.busy) || this.killed) && !this.waitingForStylesheet;
};


MapGeodataProcessor.prototype.onMessage = function(message, direct) {
    if (this.killed) {
        return;
    }

    if (!direct) {
        message = message.data;
    }
    
    var command = message['command'];

    //console.log('onmessage ' + command);

    //if (typeof message === "string" && message == "ready") {
    if (command == 'ready') {
        this.ready = true;
        //console.log("ready");
    } else if (command == 'styleDone') {
        this.busy = false;
    } else if (command == 'loadBitmaps') {
        var bitmaps = message['bitmaps'];

        for (var key in bitmaps) {
            var bitmap = bitmaps[key];
            this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false, bitmap['hash'], true);
        }
    }

    if (this.listener != null) {
        if (command == 'packed-events') {
            var messages = message['messages'];

            for (var i = 0, li = messages.length; i < li; i++) {
                this.onMessage(messages[i], true);
            }

            return;
        } else {
            this.listener(command, message);
        }
    }
};


MapGeodataProcessor.prototype.setListener = function(listener) {
    this.listener = listener;
};


MapGeodataProcessor.prototype.sendCommand = function(command, data, tile, dpr) {
    if (this.killed) {
        return;
    }

    this.ready = false;
    
    var message = {'command': command, 'data':data};

    //console.log('sendCommand ' + command);
    
    if (tile && tile.id) { 
        message['lod'] = tile.id[0];

        if (tile.metanode) {
            message['tileSize'] = Math.tan(tile.metanode.diskAngle2A) * tile.metanode.diskDistance;
            message['pixelSize'] =  (message['tileSize'] * 0.70710678118) / tile.metanode.displaySize;
        }
    }

    if (dpr) {
        message['dpr'] = dpr;
    }

    this.processWorker.postMessage(message);
};

MapGeodataProcessor.prototype.setStylesheet = function(stylesheet, fontsOnly) {
    this.stylesheet = stylesheet;

    if (!stylesheet.isReady()) {
        this.waitingForStylesheet = true;
        return;
    }

    this.busy = true;

    var ppi = 96 * (window.devicePixelRatio || 1);
    var config = this.map.config;
    var params = config.mapFeaturesReduceParams;
    var isDef = (function(val){ return (typeof val !== 'undefined') });
    var rmode = config.mapFeaturesReduceMode;


    switch (rmode) {
        case 'scr-count1':
        case 'scr-count2':
            if (!params) {
                params = [1,50,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 1;
                params[1] = isDef(params[1]) ? params[1] : 50;
                params[2] = isDef(params[2]) ? params[2] : 0;
            }
            config.mapFeaturesSortByTop = (rmode == 'scr-count2') ? true : false;
            break;

        case 'scr-count4':
            if (!params) {
                params = [0.18,0,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 0.18;
                params[1] = isDef(params[1]) ? params[1] : 0;
                params[2] = isDef(params[2]) ? params[2] : 1;
            }
            config.mapFeaturesSortByTop = true;
            break;

        case 'scr-count5':
            if (!params) {
                params = [2,1,0];
            } else {
                params[0] = isDef(params[0]) ? params[0] : 2;
                params[1] = isDef(params[1]) ? params[1] : 1;
                params[2] = isDef(params[2]) ? params[2] : 1;
            }
            config.mapFeaturesSortByTop = true;
            break;

        case 'scr-count6':
        case 'scr-count7':
            if (!params) {
                params = [0.2,0,((rmode == 'scr-count6') ? 1 : 2), 1, 1];
            } else {
                params[0] = (isDef(params[0]) ? params[0] : 0.2);
                params[1] = isDef(params[1]) ? params[1] : 0;
                params[2] = isDef(params[2]) ? params[2] : ((rmode == 'scr-count6') ? 1 : 2);
                params[3] = isDef(params[3]) ? params[3] : 1;
                params[4] = isDef(params[4]) ? params[4] : 1;
                params[5] = ppi;
                config.mapFeaturesSortByTop = true;
            }
            break;

        case 'scr-count8':
            if (!params) {
                params = [0.2, 0.6, 11, 1, 1000, 5];
            } else {
                params[0] = (isDef(params[0]) ? params[0] : 0.2);
                params[1] = isDef(params[1]) ? params[1] : 0.6;
                params[2] = isDef(params[2]) ? params[2] : 11;
                params[3] = isDef(params[3]) ? params[3] : 1;
                params[4] = isDef(params[4]) ? params[4] : 1000;
                params[5] = isDef(params[5]) ? params[5] : 5;
                params[6] = ppi;
                config.mapFeaturesSortByTop = true;
            }
            break;

    }
    
    config.mapFeaturesReduceParams = params;
    config.mapFeaturesReduceFactor = params[2];
    config.mapFeaturesReduceFactor2 = params[3];
    config.mapFeaturesReduceFactor3 = params[4];

    //this.setFont('#default', this.renderer.font);
    this.sendCommand('setStylesheet', { 'data' : stylesheet.data,
                                        'geocent' : (!this.map.getNavigationSrs().isProjected()),
                                        'metric': config.mapMetricUnits,
                                        'language': config.mapLanguage,
                                        'reduceMode': rmode,
                                        'reduceParams': config.mapFeaturesReduceParams,
                                        'log': config.mapLogGeodataStyles } );

    var fonts = stylesheet.fonts;
    var fontMap = {}; //'#default' : '#default' };

    for (var key in fonts) {
        var fontUrl = fonts[key];
        var font = this.renderer.fonts[fontUrl];
        fontMap[key] = fontUrl;

        if (font) {
            this.setFont(fontUrl, font);
        }
    }

    this.processCounter++;
    this.sendCommand('setFontMap', { 'map' : fontMap });
};


MapGeodataProcessor.prototype.setFont = function(url, font) {
    if (!this.fonts[url]) {
        this.fonts[url] = font;
        this.sendCommand('setFont', {'url' : url, 'data': font.data}, [font.data]);
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapGeodataProcessor);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__trajectory__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bound_layer__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__surface__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__position__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geodata_builder__ = __webpack_require__(134);







//get rid of compiler mess
var MapTrajectory = __WEBPACK_IMPORTED_MODULE_0__trajectory__["a" /* default */];
var MapBoundLayer = __WEBPACK_IMPORTED_MODULE_1__bound_layer__["a" /* default */];
var MapSurface = __WEBPACK_IMPORTED_MODULE_2__surface__["a" /* default */];
var MapPosition = __WEBPACK_IMPORTED_MODULE_3__position__["a" /* default */];
var MapGeodataBuilder = __WEBPACK_IMPORTED_MODULE_4__geodata_builder__["a" /* default */];


var MapInterface = function(map) {
    this.map = map;
    this.config = map.config;
};


MapInterface.prototype.setPosition = function(position) {
    this.map.setPosition(position);
    return this;    
};


MapInterface.prototype.getPosition = function() {
    return this.map.getPosition();
};


MapInterface.prototype.setView = function(view, forceRefresh, posToFixed) {
    this.map.setView(view, forceRefresh, posToFixed);
    return this;    
};


MapInterface.prototype.getView = function() {
    return this.map.getView();
};


MapInterface.prototype.getCredits = function() {
    return this.map.getCredits();
};


MapInterface.prototype.getCurrentCredits = function() {
    return this.map.getVisibleCredits();
};


MapInterface.prototype.getCreditInfo = function(creditId) {
    var credit = this.map.getCreditById(creditId);
    return credit ? credit.getInfo() : {};
};


MapInterface.prototype.getViews = function() {
    return this.map.getNamedViews();
};


MapInterface.prototype.getViewInfo = function(viewId) {
    var view = this.map.getNamedView(viewId);
    return view ? view.getInfo() : {};
};


MapInterface.prototype.getBoundLayers = function() {
    return this.map.getBoundLayers();
};


MapInterface.prototype.getBoundLayerInfo = function(layerId) {
    return this.map.getBoundLayerInfo(layerId);
};


MapInterface.prototype.getFreeLayers = function() {
    return this.map.getFreeLayers();
};


MapInterface.prototype.getFreeLayerInfo = function(layerId) {
    var layer = this.map.getFreeLayer(layerId);
    return layer ? layer.getInfo() : {};
};


MapInterface.prototype.getSurfaces = function() {
    return this.map.getSurfaces();
};


MapInterface.prototype.getSurfaceInfo = function(surfaceId) {
    var surface = this.map.getFreeLayer(surfaceId);
    return surface ? surface.getInfo() : {};
};


MapInterface.prototype.getSrses = function() {
    return this.map.getSrses();
};


MapInterface.prototype.getSrsInfo = function(srsId) {
    var srs = this.map.getSrs(srsId);
    return srs ? srs.getInfo() : {};
};


MapInterface.prototype.getReferenceFrame = function() {
    return this.map.referenceFrame.getInfo();
};


MapInterface.prototype.addFreeLayer = function(id, options) {
    var layer = new MapSurface(this.map, options, 'free');
    this.map.addFreeLayer(id, layer);
};


MapInterface.prototype.removeFreeLayer = function(id) {
    this.map.removeFreeLayer(id); 
};


/* MapInterface.prototype.setFreeLayerOptions = function(id, options) {
    this.map.setFreeLayerOptions(id, options); 
};


MapInterface.prototype.getFreeLayerOptions = function(id) {
    return this.map.getFreeLayerOptions(id); 
}; */


MapInterface.prototype.addBoundLayer = function(id, options) {
    var layer = new MapBoundLayer(this.map, options, id);
    this.map.addBoundLayer(id, layer); 
};


MapInterface.prototype.removeBoundLayer = function(id) {
    this.map.removeBoundLayer(id); 
};


/* MapInterface.prototype.setBoundLayerOptions = function(id, options) {
    this.map.setBoundLayerOptions(id, options); 
};


MapInterface.prototype.getBoundLayerOptions = function(id) {
    return this.map.setBoundLayerOptions(id); 
};*/

MapInterface.prototype.convertPositionViewMode = function(position, mode) {
    return this.map.convert.convertPositionViewMode((new MapPosition(position)), mode);
};


MapInterface.prototype.convertPositionHeightMode = function(position, mode, noPrecisionCheck) {
    return this.map.convert.convertPositionHeightMode((new MapPosition(position)), mode, noPrecisionCheck);
};


MapInterface.prototype.convertCoords = function(sourceSrs, destinationSrs, coords) {
    var srs = this.map.getSrs(sourceSrs);
    var srs2 = this.map.getSrs(destinationSrs);
    if (!srs || !srs2) {
        return null;
    }

    return srs2.convertCoordsFrom(coords, srs);
};


MapInterface.prototype.convertCoordsFromNavToPublic = function(pos, mode, lod) {
    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionPublicCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPublicToNav = function(pos, mode, lod) {
    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionNavCoordsFromPublic((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToPublic = function(pos, containsSE) {
    if (containsSE && this.map.renderer.useSuperElevation) {
        var p = this.map.renderer.transformPointBySE(pos);
        return this.map.convert.convertCoords(p, 'physical', 'public');
    } else {
        return this.map.convert.convertCoords(pos, 'physical', 'public');
    }
};


MapInterface.prototype.convertCoordsFromNavToPhys = function(pos, mode, lod, includeSE) {
    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionPhysCoords((new MapPosition(p)), lod, includeSE);
};


MapInterface.prototype.convertCoordsFromPhysToNav = function(pos, mode, lod, containsSE) {
    return this.map.convert.convertCoordsFromPhysToNav(pos, mode, lod, containsSE);
};


MapInterface.prototype.convertCoordsFromNavToCanvas = function(pos, mode, lod) {
    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToCanvas = function(pos, containsSE) {
    var p = ['obj', pos[0], pos[1], 'fix', pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCanvasCoords((new MapPosition(p)), null, true, containsSE);
};


MapInterface.prototype.convertCoordsFromNavToCameraSpace = function(pos, mode, lod) {
    var p = ['obj', pos[0], pos[1], mode, pos[2], 0, 0, 0, 10, 45 ];
    return this.map.convert.getPositionCameraSpaceCoords((new MapPosition(p)), lod);
};


MapInterface.prototype.convertCoordsFromPhysToCameraSpace = function(pos) {
    var p = this.map.camera.position;
    return [pos[0] - p[0], pos[1] - p[1], pos[2] - p[2]];
};


MapInterface.prototype.transformPhysCoordsBySE = function(pos) {
    return this.map.convert.transformPhysCoordsBySE(pos);
};


MapInterface.prototype.getPositionCanvasCoords = function(position, lod) {
    return this.map.convert.getPositionCanvasCoords(new MapPosition(position), lod);
};


MapInterface.prototype.getPositionCameraCoords = function(position, mode) {
    return this.map.convert.getPositionCameraCoords(new MapPosition(position), mode);
};


MapInterface.prototype.movePositionCoordsTo = function(position, azimuth, distance, skipOrientation) {
    return this.map.convert.movePositionCoordsTo(new MapPosition(position), azimuth, distance, skipOrientation);
};


MapInterface.prototype.getGeodesicLinePoints = function(coords, coords2, height, density) {
    return this.map.convert.getGeodesicLinePoints(coords, coords2, height, density);
};


MapInterface.prototype.getSurfaceHeight = function(coords, precision) {
    return this.map.measure.getSurfaceHeight(coords, this.map.measure.getOptimalHeightLodBySampleSize(coords, precision));
};


MapInterface.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, callback, loadTextures) {
    var res = this.map.measure.getSurfaceAreaGeometry(coords, radius, mode, limit, true, loadTextures);
    //console.log('getSurfaceAreaGeometry');

    if (!res[0]) {
        return this.map.core.once('map-update', this.getSurfaceAreaGeometry.bind(this, coords, radius, mode, limit, callback, loadTextures), 1);
    } else {
        var buffer = res[1], ret = [], map = this.map;        

        if (map.tree) {
            map.storedTilesRes = [];
            map.tree.storeGeometry(buffer, buffer.length);
            ret = map.storedTilesRes;
            map.storedTilesRes = [];
        }

        callback(ret);
        return (function(){});
    }
};


MapInterface.prototype.getDistance = function(coords, coords2, includingHeights, usePublic) {
    return this.map.measure.getDistance(coords, coords2, includingHeights, usePublic);
};


MapInterface.prototype.getAzimuthCorrection = function(coords, coords2) {
    return this.map.measure.getAzimuthCorrection(coords, coords2);
};


MapInterface.prototype.getNED = function(coords, onlyMatrix) {
    return this.map.measure.getNewNED(coords, (onlyMatrix === false) ? false : true);
};


MapInterface.prototype.getCameraInfo = function() {
    var camera = this.map.camera;
    return {
        'projectionMatrix' : camera.camera.projection.slice(),
        'viewMatrix' : camera.camera.modelview.slice(),
        'viewProjectionMatrix' : camera.camera.mvp.slice(),
        'rotationMatrix' : camera.camera.rotationview.slice(),
        'position' : this.map.camera.position.slice(),
        'vector' : this.map.camera.vector.slice(),
        'distance' : this.map.camera.distance,
        'height' : this.map.camera.height
    };
};


MapInterface.prototype.isPointInsideCameraFrustum = function(point) {
    return this.map.camera.camera.pointVisible(point, this.map.camera.position);
};


MapInterface.prototype.isBBoxInsideCameraFrustum = function(bbox) {
    return this.map.camera.camera.bboxVisible({min:bbox[0], max:bbox[1]}, this.map.camera.position);
};


MapInterface.prototype.generateTrajectory = function(p1, p2, options) {
    p1 = new MapPosition(p1);
    p2 = new MapPosition(p2);
    return (new MapTrajectory(this.map, p1, p2, options)).generate();
};


MapInterface.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {
    var p = new MapPosition(position);
    options['distance'] = distance;
    options['azimuth'] = azimuth;
    options['distanceAzimuth'] = true;
    return (new MapTrajectory(this.map, p, p, options)).generate();
};


MapInterface.prototype.setConfigParams = function(params) {
    this.map.setConfigParams(params);
    return this;
};


MapInterface.prototype.setConfigParam = function(key, value) {
    this.map.setConfigParam(key, value);
    return this;
};


MapInterface.prototype.getConfigParam = function(key) {
    return this.map.getConfigParam(key);
};


MapInterface.prototype.redraw = function() {
    this.map.markDirty();
    return this;
};


MapInterface.prototype.addRenderSlot = function(id, callback, enabled) {
    this.map.renderSlots.addRenderSlot(id, callback, enabled);
    return this;    
};


MapInterface.prototype.moveRenderSlotBefore = function(whichId, whereId) {
    this.map.renderSlots.moveRenderSlotBefore(whichId, whereId);
    return this;    
};


MapInterface.prototype.moveRenderSlotAfter = function(whichId, whereId) {
    this.map.renderSlots.moveRenderSlotAfter(whichId, whereId);
    return this;    
};


MapInterface.prototype.removeRenderSlot = function(id) {
    this.map.renderSlots.removeRenderSlot(id);
    return this;    
};


MapInterface.prototype.setRenderSlotEnabled = function(id, state) {
    this.map.renderSlots.setRenderSlotEnabled(id, state);
    return this;    
};


MapInterface.prototype.getRenderSlotEnabled = function(id) {
    return this.map.renderSlots.getRenderSlotEnabled(id);
};


MapInterface.prototype.setLoaderSuspended = function(state) {
    this.map.loaderSuspended = state;
    return this;
};


MapInterface.prototype.getLoaderSuspended = function() {
    return this.map.loaderSuspended;
};


MapInterface.prototype.getGpuCache = function() {
    return this.map.gpuCache;
};


MapInterface.prototype.getHitCoords = function(screenX, screenY, mode, lod) {
    return this.map.getHitCoords(screenX, screenY, mode, lod);
};


MapInterface.prototype.getScreenRay = function(screenX, screenY) {
    return this.map.getScreenRay(screenX, screenY);
};


MapInterface.prototype.renderToImage = function() {
    return this.map.renderToImage();
};


MapInterface.prototype.getCurrentGeometry = function() {
    return this.map.getCurrentGeometry();
};


MapInterface.prototype.getStats = function(switches) {
    if (switches) {
        return {
            'maxZoom' : this.map.draw.debug.maxZoom
        };
    }

    var busyWorkers = 0;
    for (var i = 0, li = this.map.geodataProcessors; i < li; i++) {
        if (this.map.geodataProcessors[i].busy) {
            busyWorkers++;
        }        
    }

    return {
        'bestMeshTexelSize' : this.map.bestMeshTexelSize,
        'bestGeodataTexelSize' : this.map.bestGeodataTexelSize, 
        'downloading' : this.map.loader.downloading.length,
        'lastDownload' : this.map.loader.lastDownloadTime, 
        'surfaces' : this.map.tree.surfaceSequence.length,
        'freeLayers' : this.map.freeLayerSequence.length,
        'texelSizeFit' : this.map.texelSizeFit,
        'loadMode' : this.map.config.mapLoadMode,
        'processingTasks' : this.map.processingTasks.length,
        'busyWorkers' : busyWorkers,
        'dirty' : this.map.dirty,
        'drawnTiles' : this.map.stats.drawnTiles,
        'drawnGeodataTiles' : this.map.stats.drawnGeodataTiles,
        'renderTime' : this.map.stats.rendererTime,
        'frameTime' : this.map.stats.frameTime
    };
};


MapInterface.prototype.click = function(screenX, screenY, state) {
    this.map.click(screenX, screenY, state);
};


MapInterface.prototype.hover = function(screenX, screenY, persistent, state) {
    this.map.hover(screenX, screenY, persistent, state);
};

MapInterface.prototype.createGeodata = function() {
    return new MapGeodataBuilder(this.map);
};

MapInterface.prototype.getGeodataGeometry = function(id) {
    return this.map.renderer.geometries[id];
};

MapInterface.prototype.setGeodataSelection = function(selection) {
    this.map.renderer.geodataSelection = selection;
    this.map.markDirty();
    return this;
};

MapInterface.prototype.getGeodataSelection = function() {
    return this.map.renderer.geodataSelection;
};


/* harmony default export */ __webpack_exports__["a"] = (MapInterface);


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);



//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];


var MapLoader = function(map, maxThreads) {
    this.map = map;
    this.core = map.core;
    this.killed = false;
    this.config = map.config;

    this.maxThreads = maxThreads || 1;
    this.usedThreads = 0;
    this.maxPending = this.maxThreads * 2;
    this.fadeout = 19 / 20;

    this.pending = [[],[]];
    this.channel = 0;

    this.downloading = [];
    this.downloadingTime = [];
    this.workerTask = {};

    this.lastDownloadTime = 0;
    this.downloaded = 0;
    this.processWorker = null;
    this.updateThreadCount();

    if (this.config.mapSeparateLoader) {
        // eslint-disable-next-line
        var worker = __webpack_require__(118);

        this.processWorker = new worker;
        
        this.processWorker.onerror = function(event){
            throw new Error(event.message + ' (' + event.filename + ':' + event.lineno + ')');
        };

        this.processWorker.onmessage = this.onWorkerMessage.bind(this);

        this.processWorker.postMessage({'command':'config', 'data': this.config});
    }

};


MapLoader.prototype.updateThreadCount = function() {
    this.maxThreads = this.config.mapDownloadThreads;
    this.maxPending = Math.max(20, this.maxThreads * 2);
    this.fadeout = (this.maxPending-1) / this.maxPending;
};


MapLoader.prototype.setChannel = function(channel) {
    this.channel = channel;
};


MapLoader.prototype.onWorkerMessage = function(message, direct) {
    if (this.killed) {
        return;
    }

    if (!direct) {
        message = message.data;
    }
    
    var command = message['command'];

    if (command == 'packed-events') {
        var messages = message['messages'];

        for (var i = 0, li = messages.length; i < li; i++) {
            this.onWorkerMessage(messages[i], true);
        }

        return;
    }

    var path = message['path'];

    var task = this.workerTask[path];
    if (task) {

        switch(command) {

            case 'on-loaded':

                if (task.onLoaded) {

                    switch(task.kind) {
                        case 'direct-texture':
                            task.onLoaded(message['data'], true, message['filesize']);
                            break;

                        case 'direct-mesh':
                            task.onLoaded(message['data'], false, true, message['filesize']);
                            break;

                        case 'texture':
                            task.onLoaded(new Blob([message['data']]));
                            break;

                        default:
                            task.onLoaded(message['data']);
                    }

                }

                break;

            case 'on-error':
                if (task.onError) {
                    task.onError();
                }

                break;
        }

        /*
        if (command == 'on-loaded') {

            if (task.onLoaded) {
                if (task.kind == 'texture') {
                    task.onLoaded(new Blob([message['data']]));
                } else {
                    task.onLoaded(message['data']);
                }
            }

        } else if (command == 'on-error') {

            if (task.onError) {
                task.onError();
            }
        }*/

        delete this.workerTask[path];
    }

};


MapLoader.prototype.processLoadBinary = function(path, onLoaded, onError, responseType, kind) {
    var withCredentials = (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false);

    if (this.processWorker) {

        switch(kind) {
            case 'texture':
                if (this.config.mapAsyncImageDecode) {
                    responseType = 'blob';
                    kind = 'direct-texture';
                }
                break;

            case 'mesh':
                if (this.config.mapParseMeshInWorker) {
                    kind = 'direct-mesh';
                }
                break;
        }

        switch(kind) {
            case 'texture':
            case 'direct-texture':
            case 'mesh':
            case 'direct-mesh':
            case 'metadata':
            case 'geodata':

                //console.log("kind: " + kind + " " + "path: " + path);

                this.workerTask[path] = { onLoaded: onLoaded, onError: onError, kind: kind };
                this.processWorker.postMessage({'command':'load-binary', 'path': path, 'withCredentials':withCredentials, 'xhrParams':this.map.core.xhrParams, 'responseType':responseType, 'kind': kind});
                break;

            default:
                utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);
        }

    } else {
        if (kind == 'texture' && this.config.mapAsyncImageDecode) {
            responseType = 'blob';
        }

        utils.loadBinary(path, onLoaded, onError, withCredentials, this.map.core.xhrParams, responseType);
    }
};


MapLoader.prototype.load = function(path, downloadFunction, priority, id, kind) {
    var index = this.downloading.indexOf(path);

    if (index != -1) {
        return;
    }

    // update the pending list
    var pending = this.pending[this.channel];

   // put the request to the beginning of the pending list
    index = this.map.searchArrayIndexById(pending, path);
    if (index != -1) {
        pending[index].priority = priority; 
    } else {
        pending.unshift({id:path, call: downloadFunction, priority : (priority || 0), tile:id, kind:kind });
    }

    //sort pending list by priority
    do {
        var sorted = true;
        
        for (var i = 0, li = pending.length - 1; i < li; i++) {
            if (pending[i].priority > pending[i+1].priority) {
                var t = pending[i];
                pending[i] = pending[i+1];
                pending[i+1] = t;
    
                sorted = false;
            } 
        }
        
    } while(!sorted);

    // keep the pending list at reasonable length
    if (pending.length > this.maxPending) {
        pending.pop();
    }
};


MapLoader.prototype.remove = function(path) {
    var index = this.map.searchArrayIndexById(this.pending[this.channel], path);
    if (index != -1) {
        this.pending[this.channel].splice(index, 1);
    }
};


MapLoader.prototype.onLoaded = function(item) {
    var index = this.downloading.indexOf(item.id);
    var timer = performance.now();
    var stats = this.map.stats;
    var recordStats = this.map.draw.replay.storeLoaded;

    if (recordStats) {
        this.map.draw.replay.loaded.push({
            url : item.id,
            kind : item.kind,
            tile: item.tile,
            priority : item.priority,
            time : timer,
            duration : timer - this.downloadingTime[index],
            interval : timer - this.lastDownloadTime,
            threads : this.downloading.length
        });

        //var a = (timer - this.downloadingTime[index]);
        //if (Number.isNaN(a)) {
            //a = a; 
        //}

    }

    this.downloading.splice(index, 1);
    this.downloadingTime.splice(index, 1);
    //this.lastDownloadTime = Date.now();
    this.lastDownloadTime = timer;
    this.usedThreads--;
    this.map.markDirty();
    this.update(true);
    stats.loadedCount++;
    stats.loadLast = timer;
};


MapLoader.prototype.onLoadError = function(item) {
    var index = this.downloading.indexOf(item.id);
    var timer = performance.now();
    var stats = this.map.stats;
    var recordStats = this.map.draw.replay.storeLoaded;

    if (recordStats) {
        this.map.draw.replay.loaded.push({
            url : item.id,
            kind : item.kind,
            tile: item.tile,
            priority : item.priority,
            time : timer,
            duration : timer - this.downloadingTime[index],
            interval : timer - this.lastDownloadTime,
            threads : this.downloading.length
        });
    }

    this.downloading.splice(index, 1);
    this.downloadingTime.splice(index, 1);
    //this.lastDownloadTime = Date.now();
    this.lastDownloadTime = timer;
    this.usedThreads--;
    this.map.markDirty();
    this.update(true);
    stats.loadErrorCount++;
    stats.loadLast = timer;
};


MapLoader.prototype.updateChannel = function(channel) {
    var pending = this.pending[channel];
    this.updateThreadCount();

    //reduce priority for pending stuff
    for (var i = 0, li = pending.length; i < li; i++) {
        pending[i].priority *= this.fadeout;
    }

    var timer = performance.now();

    while (pending.length > 0 && this.usedThreads < this.maxThreads) {
        var item = pending.shift();

        if (this.downloading.indexOf(item.id) == -1 && item.call != null) {
            this.downloading.push(item.id);
            this.downloadingTime.push(timer);
            this.usedThreads++;
            this.downloaded++;

            item.call(item.id, this.onLoaded.bind(this, item), this.onLoadError.bind(this, item));
        }
    }
};


MapLoader.prototype.update = function(skipTick) {
    if (this.map.loaderSuspended || this.core.contextLost) {
        return;
    }

    if (!skipTick && this.processWorker && this.config.mapPackLoaderEvents && this.downloading.length) {
        this.processWorker.postMessage({'command':'tick'});
    }

    for (var i = this.pending.length - 1; i >= 0; i--) {
        if (this.pending[i].length > 0) {
            this.updateChannel(i);
            break;
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapLoader);



/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_platform__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__view__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__surface_tree__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__resource_tree__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__srs__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__cache__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__camera__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__convert__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__measure__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__draw__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__loader_loader__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__position__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__render_slots__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__stats__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__surface_sequence__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__url__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__renderer_gpu_texture__ = __webpack_require__(6);






















//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];
var platform = __WEBPACK_IMPORTED_MODULE_2__utils_platform__["a" /* platform */];
var MapView = __WEBPACK_IMPORTED_MODULE_3__view__["a" /* default */];
var MapSurfaceTree = __WEBPACK_IMPORTED_MODULE_4__surface_tree__["a" /* default */];
var MapResourceTree = __WEBPACK_IMPORTED_MODULE_5__resource_tree__["a" /* default */];
var MapSrs = __WEBPACK_IMPORTED_MODULE_6__srs__["a" /* default */];
var MapCache = __WEBPACK_IMPORTED_MODULE_7__cache__["a" /* default */];
var MapCamera = __WEBPACK_IMPORTED_MODULE_8__camera__["a" /* default */];
var MapConfig = __WEBPACK_IMPORTED_MODULE_9__config__["a" /* default */];
var MapConvert = __WEBPACK_IMPORTED_MODULE_10__convert__["a" /* default */];
var MapMeasure = __WEBPACK_IMPORTED_MODULE_11__measure__["a" /* default */];
var MapDraw = __WEBPACK_IMPORTED_MODULE_12__draw__["a" /* default */];
var MapLoader = __WEBPACK_IMPORTED_MODULE_13__loader_loader__["a" /* default */];
var MapPosition = __WEBPACK_IMPORTED_MODULE_14__position__["a" /* default */];
var MapRenderSlots = __WEBPACK_IMPORTED_MODULE_15__render_slots__["a" /* default */];
var MapStats = __WEBPACK_IMPORTED_MODULE_16__stats__["a" /* default */];
var MapSurfaceSequence = __WEBPACK_IMPORTED_MODULE_17__surface_sequence__["a" /* default */];
var MapUrl = __WEBPACK_IMPORTED_MODULE_18__url__["a" /* default */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_19__renderer_gpu_texture__["a" /* default */];


var Map = function(core, mapConfig, path, config, configStorage) {
    this.config = config || {};
    this.setConfigParams(config);
    this.setLoaderParams(mapConfig, configStorage);
    this.core = core;
    this.proj4 = this.core.getProj4();
    this.coreConfig = core.coreConfig;
    this.killed = false;
    this.config = config || {};
    this.loaderSuspended = false;

    this.url = new MapUrl(this, path);

    this.position = new MapPosition(['obj', 0, 0, 'fix', 0,  0, 0, 0,  0, 0]);
    this.lastPosition = this.position.clone();

    this.srses = {};
    this.bodies = {};
    this.referenceFrame = {};
    this.credits = {};
    this.creditsByNumber = {};
    this.surfaces = {};
    this.virtualSurfaces = {};
    this.glues = {};
    this.freeLayers = {};
    this.boundLayers = {};
    this.stylesheets = {};
    this.processingTasks = [];
    this.processingTasks2 = [];
    this.geodataProcessors = [];

    this.surfaceSequence = new MapSurfaceSequence(this);

    this.initialView = null;
    this.currentView = new MapView(this, {});
    this.currentViewString = '';
    this.namedViews = {};
    this.viewCounter = 0;
    this.srsReady = false;
    this.surfaceCounter = 0;

    this.freeLayerSequence = [];
    this.freeLayersHaveGeodata = false;

    this.visibleCredits = {
        imagery : {},
        glueImagery : {},
        mapdata : {}
    };
    
    this.mobile = false;
    this.metanodeBuffer = new Uint8Array(1024);
   
    this.gpuCache = new MapCache(this, this.config.mapGPUCache*1024*1024);
    this.resourcesCache = new MapCache(this, this.config.mapCache*1024*1024);
    this.metatileCache = new MapCache(this, this.config.mapMetatileCache*1024*1024);

    this.setupMobileMode(this.config.mapMobileMode);
    this.setupCache();

    this.loader = new MapLoader(this, this.config.mapDownloadThreads);

    this.renderer = this.core.renderer;
    this.camera = new MapCamera(this);

    this.stats = new MapStats(this);
    this.resourcesTree = new MapResourceTree(this);
   
    this.mapConfig = new MapConfig(this, mapConfig);
    this.convert = new MapConvert(this);
    this.measure = new MapMeasure(this);
    this.convert.measure = this.measure;

    this.isGeocent = !this.getNavigationSrs().isProjected();

    this.tree = new MapSurfaceTree(this, false);
    this.mapConfig.afterConfigParsed();

    this.updateCoutner = 0;

    this.dirty = true;
    this.dirtyCountdown = 0;
    this.hitMapDirty = true;
    this.geoHitMapDirty = true;

    this.clickEvent = null;
    this.hoverEvent = null;
    this.hoverFeature = null;
    this.hoverFeatureId = null;
    this.lastHoverFeature = null;
    this.lastHoverFeatureId = null;
    this.hoverFeatureCounter = 0;
    this.hoverFeatureList = [];
    
    this.draw = new MapDraw(this);
    this.draw.setupDetailDegradation();

    var body = this.referenceFrame.body, c;

    if (body && body.atmosphere) {
        c = body.atmosphere.colorHorizon;
        this.draw.atmoColor = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];
        c = body.atmosphere.colorZenith;
        this.draw.atmoColor2 = [c[0]/255.0, c[1]/255.0, c[2]/255.0, c[3]/255.0];
        this.draw.atmoHeight = 50000 * (body.atmosphere.thickness / 100000);
        this.draw.atmoDensity = (body.atmosphere.visibility / 100000) * (100000 / body.atmosphere.thickness);
    } else {
        switch(this.referenceFrame.id) {
            case 'melown2015':
            case 'earth-qsc':
                this.draw.atmoColor = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
                this.draw.atmoColor2 = [72.0/255.0, 154.0/255.0, 255.0/255.0, 1.0];
                //this.draw.atmoColor3 = [216.0/255.0, 232.0/255.0, 243.0/255.0, 1.0];
                this.draw.atmoHeight = 50000;
                break;

            case 'mars-qsc':
                this.draw.atmoColor = [255.0/255.0, 187.0/255.0, 157.0/255.0, 1.0];
                this.draw.atmoColor2 = [255.0/255.0, 155.0/255.0, 113.0/255.0, 1.0];
                //this.draw.atmoColor3 = [255.0/255.0, 187.0/255.0, 157.0/255.0, 0.5];
                this.draw.atmoHeight = 25000;
                this.draw.atmoDensity = 1.0 / 0.25;
                break;
        }
    }

    this.draw.atmoHeightFactor = this.draw.atmoHeight / 50000;

    this.renderSlots = new MapRenderSlots(this);
    this.renderSlots.addRenderSlot('map', this.drawMap.bind(this), true);
};


Map.prototype.kill = function() {
    this.killed = true;
    
    if (this.tree) {
        this.tree.kill();
    }

    for (var key in this.freeLayers) {
        var layer = this.freeLayers[key];
        if (layer && layer.tree) {
            layer.tree.kill();
        }
    }

    this.gpuCache.clear();
    this.resourcesCache.clear();
    this.metatileCache.clear();

    if (this.renderer != null) {
        this.renderer.kill();
        this.renderer = null;
    }
};


Map.prototype.setupMobileMode = function() {
    this.mobile = this.config.mapMobileMode;

    if (!this.mobile && this.config.mapMobileModeAutodect) {
        this.mobile = platform.isMobile();        
    }

    this.setupCache();
};


Map.prototype.setupCache = function() {
    if (!this.resourcesCache) {
        return;
    }

    var factor = 1 / (this.mobile ? Math.pow(2, Math.max(0,this.config.mapMobileDetailDegradation-1)) : 1);
    var factor2 = 1 / (this.mobile ? Math.pow(2, this.config.mapMobileDetailDegradation) : 1);
    factor = (factor + factor2) * 0.5;
    this.resourcesCache.setMaxCost(this.config.mapCache*1024*1024*factor);
    this.gpuCache.setMaxCost(this.config.mapGPUCache*1024*1024*factor);
    this.metatileCache.setMaxCost(this.config.mapMetatileCache*1024*1024*(factor < 0.8 ? 0.5 : 1));
};


Map.prototype.getCoreInterface = function() {
    return this.core.interface;
};


Map.prototype.getRendererInterface = function() {
    return this.core.interface.getRendererInterface();
};


Map.prototype.setOption = function(/*key, value*/) {
};


Map.prototype.getOption = function(/*key*/) {
};


Map.prototype.addSrs = function(id, srs) {
    this.srses[id] = srs;
};


Map.prototype.getSrs = function(srsId) {
    return this.srses[srsId];
};


Map.prototype.getSrses = function() {
    return this.getMapKeys(this.srses);
};


Map.prototype.addBody = function(id, body) {
    this.bodies[id] = body;
};


Map.prototype.getBody = function(id) {
    return this.bodies[id];
};


Map.prototype.getBodies = function() {
    return this.getMapKeys(this.bodies);
};


Map.prototype.setReferenceFrame = function(referenceFrame) {
    this.referenceFrame = referenceFrame;
};


Map.prototype.addCredit = function(id, credit) {
    this.credits[id] = credit;
    this.creditsByNumber[credit.id] = credit;
    credit.key = id;
};


Map.prototype.getCreditByNumber = function(id) {
    return this.creditsByNumber[id];
};


Map.prototype.getCreditById = function(id) {
    return this.credits[id];
};


Map.prototype.getCredits = function() {
    return this.getMapKeys(this.credits);
};


Map.prototype.getVisibleCredits = function() {
    var imagery = this.visibleCredits.imagery;
    var glueImagery = this.visibleCredits.glueImagery;
    var imageryArray = []; 
    var imagerySpecificity = [];
    var i, li, t, sorted;

    for (var key in glueImagery) {
        if (!imagery[key]) {
            imagery[key] = glueImagery[key];
        }
    }
    
    this.visibleCredits.glueImagery = {};
    
    for (key in imagery) {
        imageryArray.push(key);
        imagerySpecificity.push(imagery[key]); 
    }

    //sort imagery
    do {
        sorted = true;
        
        for (i = 0, li = imagerySpecificity.length - 1; i < li; i++) {
            if (imagerySpecificity[i] < imagerySpecificity[i+1]) {
                t = imagerySpecificity[i];
                imagerySpecificity[i] = imagerySpecificity[i+1];
                imagerySpecificity[i+1] = t;
                t = imageryArray[i];
                imageryArray[i] = imageryArray[i+1];
                imageryArray[i+1] = t;
                sorted = false;
            } 
        }
        
    } while(!sorted);

    var mapdata = this.visibleCredits.mapdata;
    var mapdataArray = []; 
    var mapdataSpecificity = []; 

    for (key in mapdata) {
        mapdataArray.push(key);
        mapdataSpecificity.push(mapdata[key]); 
    }
    
    //sort imagery
    do {
        sorted = true;
        
        for (i = 0, li = mapdataSpecificity.length - 1; i < li; i++) {
            if (mapdataSpecificity[i] < mapdataSpecificity[i+1]) {
                t = mapdataSpecificity[i];
                mapdataSpecificity[i] = mapdataSpecificity[i+1];
                mapdataSpecificity[i+1] = t;
                t = mapdataArray[i];
                mapdataArray[i] = mapdataArray[i+1];
                mapdataArray[i+1] = t;
                sorted = false;
            } 
        }
        
    } while(!sorted);

    return {
        '3D' : [], 
        'imagery' : imageryArray, 
        'mapdata' : mapdataArray 
    };
};


Map.prototype.addSurface = function(id, surface) {
    this.surfaces.push(surface);
    surface.index = this.surfaces.length - 1; 
};


Map.prototype.getSurface = function(id) {
    return this.searchArrayById(this.surfaces, id);
};


Map.prototype.getSurfaces = function() {
    var keys = [];
    for (var i = 0, li = this.surfaces.length; i < li; i++) {
        keys.push(this.surfaces[i].id);
    }
    return keys;
};


Map.prototype.addGlue = function(id, glue) {
    this.glues[id] = glue;
};


Map.prototype.getGlue = function(id) {
    return this.glues[id];
};


Map.prototype.addBoundLayer = function(id, layer) {
    this.boundLayers[id] = layer;
};


Map.prototype.setBoundLayerOptions = function(id, options) {
    if (this.boundLayers[id]) {
        this.boundLayers[id].setOptions(options);
    }
};


Map.prototype.getBoundLayerOptions = function(id) {
    if (this.boundLayers[id]) {
        return this.boundLayers[id].getOptions();
    }
    
    return null;
};


Map.prototype.removeBoundLayer = function(id) {
    if (this.boundLayers[id]) {
        this.boundLayers[id].kill();
        this.boundLayers[id] = null;
    }
};


Map.prototype.getBoundLayerByNumber = function(number) {
    var layers = this.boundLayers;
    for (var key in layers) {
        if (layers[key].numberId == number) {
            return layers[key];
        }
    }

    return null;
};


Map.prototype.getBoundLayerById = function(id) {
    return this.boundLayers[id];
};


Map.prototype.getBoundLayers = function() {
    return this.getMapKeys(this.boundLayers);
};


Map.prototype.addFreeLayer = function(id, layer) {
    this.freeLayers[id] = layer;
    this.setView(this.getView());
    this.markDirty();
};


Map.prototype.removeFreeLayer = function(id) {
    if (this.freeLayers[id]) {
        this.freeLayers[id].kill();
        this.freeLayers[id] = null;
        this.setView(this.getView());
        this.markDirty();
    }
};


Map.prototype.setFreeLayerOptions = function(id, options) {
    if (this.freeLayers[id]) {
        this.freeLayers[id].setOptions(options);
    }
};


Map.prototype.getFreeLayerOptions = function(id) {
    if (this.freeLayers[id]) {
        return this.freeLayers[id].getOptions();
    }
    
    return null;
};


Map.prototype.getFreeLayer = function(id) {
    return this.freeLayers[id];
    //return this.searchArrayById(this.freeLayers, id);
};


Map.prototype.getFreeLayers = function() {
    var keys = [];
    for (var key in this.freeLayers) {
        keys.push(key);
    }
    return keys;    
};


Map.prototype.getMapsSrs = function(srs) {
    if (srs == null) {
        return null;
    }

    //is it proj4 string?
    if (srs.indexOf('+proj') != -1) {
        return new MapSrs(this, {'srsDef':srs});
    }

    //search existing srs
    return this.srses[srs];
};


Map.prototype.addNamedView = function(id, view) {
    this.namedViews[id] = view;
};


Map.prototype.getNamedView = function(id) {
    return this.namedViews[id];
};


Map.prototype.getNamedViews = function() {
    return this.getMapKeys(this.namedViews);
};


Map.prototype.setView = function(view, forceRefresh, posToFixed) {
    if (view == null) {
        return;
    }

    if (posToFixed && this.convert) {
        var p = this.getPosition();
        p = this.convert.convertPositionHeightMode(p, 'fix', true);
        this.setPosition(p);
    }
    
    if (typeof view === 'string') {
        view = view.trim();
        
        if (view.charAt(0) == '{') {
            try {
                view = JSON.parse(view);
            } catch(e){
                return;            
            }
        } else {
            view = this.getNamedView(view);

            if (!view) {
                return;
            }
            
            //view = JSON.parse(JSON.stringify(view));
            view = view.getInfo();
        }
    }

    //construct view string without options
    var string = {};

    if (view.surfaces) {
        string.surfaces = view.surfaces;
    }

    if (view.freeLayers) {
        string.freeLayers = view.freeLayers;
    }

    string = JSON.stringify(string);

    var renderer = this.renderer;

    //process options
    if (view.options) {
        var se = view.options.superelevation;

        if (se && se[0] && se[1] && se[0].length >=2 && se[1].length >=2) {
            renderer.setSuperElevationState(true);
            renderer.setSuperElevation(se[0][0], se[1][0], se[0][1], se[1][1]);
        } else {
            renderer.setSuperElevationState(false);
        }
    } else {
        renderer.setSuperElevationState(false);        
    }

    if (string != this.currentViewString || forceRefresh) {
        this.currentView.parse(view);
        this.currentViewString = string;
        this.viewCounter++;
    }

    this.surfaceSequence.generateSurfaceSequence();
    this.surfaceSequence.generateBoundLayerSequence();

    this.refreshFreelayesInView();

    this.markDirty();
};


Map.prototype.addStylesheet = function(id, style) {
    this.stylesheets[id] = style;
};


Map.prototype.getStylesheet = function(id) {
    return this.stylesheets[id];
    //return this.searchArrayById(this.stylesheets, id);
};


Map.prototype.getStylesheets = function() {
    var keys = [];

    for (var key in this.stylesheets) {
        keys.push(key);
    }
    return keys;
};


Map.prototype.getStylesheetData = function(id) {
    var stylesheet = this.getStylesheet(id);

    if (stylesheet) {
        return {'url':stylesheet.url, 'data': stylesheet.data};
    }
    
    return {'url':null, 'data':{}};
};


Map.prototype.setStylesheetData = function(id, data) {
    var stylesheet = this.getStylesheet(id);
    
    //if (stylesheet) {
      //  stylesheet.data = data;
    //}

    this.renderer.draw.clearJobHBuffer();

    if (stylesheet) {
        if (data) {
            stylesheet.setData(data);
        }

        for (var key in this.freeLayers) {
            var freeLayer = this.getFreeLayer(key);
            if (freeLayer && freeLayer.geodata && freeLayer.stylesheet == stylesheet) {
                
                if (freeLayer.geodataProcessor) {
                    freeLayer.geodataProcessor.setStylesheet(freeLayer.stylesheet);
                }

                freeLayer.geodataCounter++;
            }
        }
    }

    this.markDirty();
        
    //TODO: reset geodatview in free layers
};


Map.prototype.getView = function() {
    return this.currentView.getInfo();
};


Map.prototype.refreshFreelayesInView = function() {
    var freeLayers = this.currentView.freeLayers;
    this.freeLayerSequence = [];

    for (var key in freeLayers) {
        var freeLayer = this.getFreeLayer(key);
        
        if (freeLayer) {
            
            freeLayer.zFactor = freeLayers[key]['depthOffset'];
            
            this.freeLayerSequence.push(freeLayer);
            
            if (freeLayers[key]['style']) {
                freeLayer.setStyle(freeLayers[key]['style']);
            } else {
                freeLayer.setStyle(freeLayer.originalStyle);
            }
            
            //TODO: generate bound layer seqence for      
        }
    }
};

Map.prototype.refreshView = function() {
    this.viewCounter++;
    this.surfaceSequence.generateSurfaceSequence();
    this.surfaceSequence.generateBoundLayerSequence();
    this.refreshFreelayesInView();
    this.markDirty();
};


Map.prototype.searchArrayIndexById = function(array, id) {
    for (var i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return i;
        }
    }

    return -1;
};


Map.prototype.searchArrayById = function(array, id) {
    for (var i = 0, li = array.length; i < li; i++) {
        if (array[i].id == id) {
            return array[i];
        }
    }

    return null;
};


Map.prototype.searchMapByInnerId = function(map, id) {
    for (var key in map) {
        if (map[key].id == id) {
            return map[key];
        }
    }

    return null;
};


Map.prototype.getMapKeys = function(map) {
    var keys = [];
    for (var key in map) {
        keys.push(key);
    }

    return keys;
};


Map.prototype.getMapIds = function(map) {
    var keys = [];
    for (var key in map) {
        keys.push(key.id);
    }

    return keys;
};


Map.prototype.setPosition = function(pos) {
    this.position = new MapPosition(pos);
    this.markDirty();
};


Map.prototype.isReferenceFrameReady = function() {
    return this.referenceFrame.model.physicalSrs.isReady() &&
           this.referenceFrame.model.publicSrs.isReady() &&
           this.referenceFrame.model.navigationSrs.isReady();
};


Map.prototype.getPhysicalSrs = function() {
    return this.referenceFrame.model.physicalSrs;
};


Map.prototype.getPublicSrs = function() {
    return this.referenceFrame.model.publicSrs;
};


Map.prototype.getNavigationSrs = function() {
    return this.referenceFrame.model.navigationSrs;
};


Map.prototype.getPosition = function() {
    return this.position.clone();
};


Map.prototype.setLoaderParams = function(mapConfig, configStorage) {
    var sources = [];

    if (mapConfig && mapConfig['browserOptions']) {
        sources.push(mapConfig['browserOptions']);
    }

    if (configStorage) {
        sources.push(configStorage);
    }

    for (var i = 0, li = sources.length; i < li; i++) {
        var source = sources[i];
        for (var key in source) {
            switch(key) {
                case 'mapSeparateLoader':
                case 'mapGeodataBinaryLoad':
                case 'mapPackLoaderEvents':
                case 'mapParseMeshInWorker':
                case 'mapPackGeodataEvents':
                    this.setConfigParam(key, source[key]);
                    break;
            }
        }
    }
};


Map.prototype.setConfigParams = function(params) {
    if (typeof params === 'object' && params !== null) {
        for (var key in params) {
            this.setConfigParam(key, params[key]);
        }
    }
};


Map.prototype.setConfigParam = function(key, value) {
    switch (key) {
    case 'map':                           this.config.map = utils.validateString(value, null); break;
    case 'mapCache':                      this.config.mapCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 900); this.setupCache(); break;
    case 'mapGPUCache':                   this.config.mapGPUCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 360); this.setupCache(); break;
    case 'mapMetatileCache':              this.config.mapMetatileCache = utils.validateNumber(value, 10, Number.MAXINTEGER, 60); this.setupCache(); break;
    case 'mapTexelSizeFit':               this.config.mapTexelSizeFit = utils.validateNumber(value, 0.0001, Number.MAXINTEGER, 1.1); break;
    case 'mapDownloadThreads':            this.config.mapDownloadThreads = utils.validateNumber(value, 1, Number.MAXINTEGER, 6); break;
    case 'mapMaxProcessingTime':          this.config.mapMaxProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 1000/20); break;
    case 'mapMaxGeodataProcessingTime':   this.config.mapMaxGeodataProcessingTime = utils.validateNumber(value, 1, Number.MAXINTEGER, 10); break;
    case 'mapMobileMode':                 this.config.mapMobileMode = utils.validateBool(value, false); this.setupMobileMode(); break;
    case 'mapMobileModeAutodect':         this.config.mapMobileModeAutodect = utils.validateBool(value, false); break;
    case 'mapMobileDetailDegradation':    this.config.mapMobileDetailDegradation = utils.validateNumber(value, 1, Number.MAXINTEGER, 2); break;
    case 'mapNavSamplesPerViewExtent':    this.config.mapNavSamplesPerViewExtent = utils.validateNumber(value, 0.00000000001, Number.MAXINTEGER, 4); break;
    case 'mapFog':                        this.config.mapFog = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawFog = this.config.mapFog; this.dirty = true; } break;
    case 'mapFlatshade':                  this.config.mapFlatshade = utils.validateBool(value, false); if(this.draw){ this.draw.debug.drawWireframe = this.config.mapFlatshade ? 3 : 0; this.dirty = true; } break;
    case 'mapIgnoreNavtiles':             this.config.mapIgnoreNavtiles = utils.validateBool(value, false); break;
    case 'mapAllowHires':                 this.config.mapAllowHires = utils.validateBool(value, true); break;
    case 'mapAllowLowres':                this.config.mapAllowLowres = utils.validateBool(value, true); break;
    case 'mapAllowSmartSwitching':        this.config.mapAllowSmartSwitching = utils.validateBool(value, true); break;
    case 'mapDisableCulling':             this.config.mapDisableCulling = utils.validateBool(value, false); break;
    case 'mapPreciseCulling':             this.config.mapPreciseCulling = utils.validateBool(value, false); break;
    case 'mapHeightLodBlend':             this.config.mapHeightLodBlend = utils.validateBool(value, true); break;
    case 'mapHeightNodeBlend':            this.config.mapHeightNodeBlend = utils.validateBool(value, true); break;
    case 'mapBasicTileSequence':          this.config.mapBasicTileSequence = utils.validateBool(value, true); break;
    case 'mapSmartNodeParsing':           this.config.mapSmartNodeParsing = utils.validateBool(value, true); break;
    case 'mapStoreLoadStats':             this.config.mapStoreLoadStats = utils.validateBool(value, true);  if (this.draw && this.draw.replay) this.draw.replay.storeLoaded = this.config.mapStoreLoadStats; break;
    case 'mapXhrImageLoad':               this.config.mapXhrImageLoad = utils.validateBool(value, false); break;
    case 'mapLoadMode':                   this.config.mapLoadMode = utils.validateString(value, 'topdown'); break;
    case 'mapGeodataLoadMode':            this.config.mapGeodataLoadMode = utils.validateString(value, 'fit'); break;
    case 'mapGridMode':                   this.config.mapGridMode = utils.validateString(value, 'linear'); break;
    case 'mapGridSurrogatez':             this.config.mapGridSurrogatez = utils.validateBool(value, false); break;
    case 'mapGridUnderSurface':           this.config.mapGridUnderSurface = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;
    case 'mapGridTextureLevel':           this.config.mapGridTextureLevel = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, -1); break;
    case 'mapGridTextureLayer':           this.config.mapGridTextureLayer = utils.validateString(value, ''); break;
    case 'mapPreciseBBoxTest':            this.config.mapPreciseBBoxTest = utils.validateBool(value, true); break;
    case 'mapPreciseDistanceTest':        this.config.mapPreciseDistanceTest = utils.validateBool(value, false); break;
    case 'mapHeightfiledWhenUnloaded':    this.config.mapHeightfiledWhenUnloaded = utils.validateBool(value, false); break;
    case 'mapForceMetatileV3':            this.config.mapForceMetatileV3 = utils.validateBool(value, false); break;
    case 'mapVirtualSurfaces':            this.config.mapVirtualSurfaces = utils.validateBool(value, true); break;
    case 'mapDegradeHorizon':             this.config.mapDegradeHorizon = utils.validateBool(value, true); break;
    case 'mapDegradeHorizonParams':       this.config.mapDegradeHorizonParams = utils.validateNumberArray(value, 4, [0,1,1,1], [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [1, 3000, 15000, 7000]); break;
    case 'mapRefreshCycles':              this.config.mapRefreshCycles = utils.validateNumber(value, 0, Number.MAXINTEGER, 3); break;
    case 'mapDefaultFont':                this.config.mapDefaultFont = utils.validateString(value, ''); break;
    case 'mapMetricUnits':                this.config.mapMetricUnits = utils.validateBool(value, true); break;
    case 'mapLanguage':                   this.config.mapLanguage = utils.validateString(value, 'en'); break;
    case 'mapNoTextures':                 this.config.mapNoTextures = this.config.mapDisableCulling = utils.validateBool(value, false); break;
    case 'mapForceFrameTime':             this.config.mapForceFrameTime = utils.validateNumber(value, -1, Number.MAXINTEGER, 0); break;
    case 'mapForcePipeline':              this.config.mapForcePipeline = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;
    case 'mapFeatureGridCells':           this.config.mapFeatureGridCells = utils.validateNumber(value, -Number.MAXINTEGER, Number.MAXINTEGER, 0); break;
    case 'mapFeaturesPerSquareInch':      this.config.mapFeaturesPerSquareInch = utils.validateNumber(value, 0.000001, Number.MAXINTEGER, 0); break;
    case 'mapFeaturesSortByTop':          this.config.mapFeaturesSortByTop = utils.validateBool(value, false); break;
    case 'mapFeaturesReduceParams':       this.config.mapFeaturesReduceParams = value; break;
    case 'mapLogGeodataStyles':           this.config.mapLogGeodataStyles = utils.validateBool(value, true); break;
    case 'map16bitMeshes':                this.config.map16bitMeshes = utils.validateBool(value, false); break;
    case 'mapOnlyOneUVs':                 this.config.mapOnlyOneUVs = utils.validateBool(value, false); break;
    case 'mapIndexBuffers':               this.config.mapIndexBuffers = utils.validateBool(value, false); break;
    case 'mapSoftViewSwitch':             this.config.mapSoftViewSwitch = utils.validateBool(value, true); break;
    case 'mapAsyncImageDecode':           this.config.mapAsyncImageDecode = (utils.validateBool(value, false) && (typeof createImageBitmap !== 'undefined')) ? true : false; break;
    case 'mapFeatureStickMode':           this.config.mapFeatureStickMode = utils.validateNumberArray(value, 2, [0,1], [Number.MAX_VALUE, Number.MAX_VALUE], [0, 1]); break;
    case 'mapSeparateLoader':             this.config.mapSeparateLoader = utils.validateBool(value, true); break;
    case 'mapGeodataBinaryLoad':          this.config.mapGeodataBinaryLoad = utils.validateBool(value, true); break;
    case 'mapPackLoaderEvents':           this.config.mapPackLoaderEvents = utils.validateBool(value, true); break;
    case 'mapParseMeshInWorker':          this.config.mapParseMeshInWorker = utils.validateBool(value, true); break;
    case 'mapPackGeodataEvents':          this.config.mapPackGeodataEvents = utils.validateBool(value, true); break;
    case 'mapSortHysteresis':             this.config.mapSortHysteresis = utils.validateBool(value, false); break;
    case 'mapHysteresisWait':             this.config.mapHysteresisWait = utils.validateNumber(value, 0, Number.MAXINTEGER, 0); break;
    case 'mapDMapSize':                   this.config.mapDMapSize = utils.validateNumber(value, 16, Number.MAXINTEGER, 512); break; 
    case 'mapDMapMode':                   this.config.mapDMapMode = utils.validateNumber(value, 1, Number.MAXINTEGER, 1); break;
    case 'mario':                         this.config.mario = utils.validateBool(value, true); break;
    case 'mapFeaturesReduceMode':         
        value = utils.validateString(value, 'scr-count4');
        if (value == 'auto') value = 'scr-count2';
        if (value == 'legacy') value = 'scr-count2';
        if (value == 'gridcells') value = 'scr-count4';
        if (value == 'singlepass') value = 'scr-count5';
        if (value == 'margin') value = 'scr-count6';
        //if (value == 'margin') value = 'scr-count7';
        this.config.mapFeaturesReduceMode = value;
        break;

    }
};


Map.prototype.getConfigParam = function(key) {
    switch (key) {
    case 'map':                           return this.config.map;
    case 'mapCache':                      return this.config.mapCache;
    case 'mapGPUCache':                   return this.config.mapGPUCache;
    case 'mapMetatileCache':              return this.config.mapMetatileCache;
    case 'mapTexelSizeFit':               return this.config.mapTexelSizeFit;
    case 'mapDownloadThreads':            return this.config.mapDownloadThreads;
    case 'mapMaxProcessingTime':          return this.config.mapMaxProcessingTime;
    case 'mapMaxGeodataProcessingTime':   return this.config.mapMaxGeodataProcessingTime;
    case 'mapMobileMode':                 return this.config.mapMobileMode;
    case 'mapMobileModeAutodect':         return this.config.mapMobileModeAutodect;
    case 'mapMobileDetailDegradation':    return this.config.mapMobileDetailDegradation;
    case 'mapNavSamplesPerViewExtent':    return this.config.mapNavSamplesPerViewExtent;
    case 'mapFog':                        return this.config.mapFog;
    case 'mapFlatshade':                  return this.config.mapFlatshade;
    case 'mapIgnoreNavtiles':             return this.config.mapIgnoreNavtiles;
    case 'mapAllowHires':                 return this.config.mapAllowHires;
    case 'mapAllowLowres':                return this.config.mapAllowLowres;
    case 'mapAllowSmartSwitching':        return this.config.mapAllowSmartSwitching;
    case 'mapDisableCulling':             return this.config.mapDisableCulling;
    case 'mapPreciseCulling':             return this.config.mapPreciseCulling;
    case 'mapHeightLodBlend':             return this.config.mapHeightLodBlend;
    case 'mapHeightNodeBlend':            return this.config.mapHeightNodeBlend;
    case 'mapBasicTileSequence':          return this.config.mapBasicTileSequence;
    case 'mapSmartNodeParsing':           return this.config.mapSmartNodeParsing;
    case 'mapStoreLoadStats':             return this.config.mapStoreLoadStats;
    case 'mapXhrImageLoad':               return this.config.mapXhrImageLoad;
    case 'mapLoadMode':                   return this.config.mapLoadMode;
    case 'mapGeodataLoadMode':            return this.config.mapGeodataLoadMode;
    case 'mapGridMode':                   return this.config.mapGridMode;
    case 'mapGridSurrogatez':             return this.config.mapGridSurrogatez;
    case 'mapGridUnderSurface':           return this.config.mapGridUnderSurface;
    case 'mapGridTextureLevel':           return this.config.mapGridTextureLevel;
    case 'mapGridTextureLayer':           return this.config.mapGridTextureLayer;
    case 'mapPreciseBBoxTest':            return this.config.mapPreciseBBoxTest;
    case 'mapPreciseDistanceTest':        return this.config.mapPreciseDistanceTest;
    case 'mapHeightfiledWhenUnloaded':    return this.config.mapHeightfiledWhenUnloaded;
    case 'mapForceMetatileV3':            return this.config.mapForceMetatileV3;
    case 'mapVirtualSurfaces':            return this.config.mapVirtualSurfaces;
    case 'mapDegradeHorizon':             return this.config.mapDegradeHorizon;
    case 'mapDegradeHorizonParams':       return this.config.mapDegradeHorizonParams;
    case 'mapRefreshCycles':              return this.config.mapRefreshCycles;
    case 'mapDefaultFont':                return this.config.mapDefaultFont;
    case 'mapMetricUnits':                return this.config.mapMetricUnits;
    case 'mapLanguage':                   return this.config.mapLanguage;
    case 'mapNoTextures':                 return this.config.mapNoTextures;
    case 'mapForceFrameTime':             return this.config.mapForceFrameTime;
    case 'mapForcePipeline':              return this.config.mapForcePipeline;
    case 'mapFeatureGridCells':           return this.config.mapFeatureGridCells;
    case 'mapFeaturesPerSquareInch':      return this.config.mapFeaturesPerSquareInch;
    case 'mapFeaturesSortByTop':          return this.config.mapFeaturesSortByTop;
    case 'mapFeaturesReduceMode':         return this.config.mapFeaturesReduceMode;
    case 'mapFeaturesReduceParams':       return this.config.mapFeaturesReduceParams;
    case 'mapLogGeodataStyles':           return this.config.mapLogGeodataStyles;
    case 'map16bitMeshes':                return this.config.map16bitMeshes;
    case 'mapOnlyOneUVs':                 return this.config.mapOnlyOneUVs;
    case 'mapIndexBuffers':               return this.config.mapIndexBuffers;
    case 'mapSoftViewSwitch':             return this.config.mapSoftViewSwitch;
    case 'mapAsyncImageDecode':           return this.config.mapAsyncImageDecode;
    case 'mapFeatureStickMode':           return this.config.mapFeatureStickMode;
    case 'mapSeparateLoader':             return this.config.mapSeparateLoader;
    case 'mapGeodataBinaryLoad':          return this.config.mapGeodataBinaryLoad;
    case 'mapPackLoaderEvents':           return this.config.mapPackLoaderEvents;
    case 'mapParseMeshInWorker':          return this.config.mapParseMeshInWorker;
    case 'mapPackGeodataEvents':          return this.config.mapPackGeodataEvents;
    case 'mapSortHysteresis':             return this.config.mapSortHysteresis;
    case 'mapHysteresisWait':             return this.config.mapHysteresisWait;
    case 'mapDMapSize':                   return this.config.mapDMapSize; 
    case 'mapDMapMode':                   return this.config.mapDMapMode;
    case 'mario':                         return this.config.mario;
    }
};


Map.prototype.click = function(screenX, screenY, state) {
    this.clickEvent = [screenX, screenY, state];
};


Map.prototype.hover = function(screenX, screenY, persistent, state) {
    this.hoverEvent = [screenX, screenY, persistent, state];
};


Map.prototype.markDirty = function() {
    this.dirty = true;
    this.hitMapDirty = true;
    this.geoHitMapDirty = true;
};


Map.prototype.getScreenRay = function(screenX, screenY) {
    return this.renderer.getScreenRay(screenX, screenY);
};


Map.prototype.renderToImage = function(texture) {
    //var renderer = this.renderer;
    var canvas = this.renderer.gpu.canvas;
    var w = canvas.width;
    var h = canvas.height;
    var w2 = utils.fitToPowerOfTwo(w);
    var h2 = utils.fitToPowerOfTwo(h);

    var data = new Uint8Array( w2 * h2 * 4 );

    var texture = new GpuTexture(this.renderer.gpu);
    texture.createFromData(w2, h2, data);
    texture.createFramebuffer(w2, h2);

    this.draw.drawToTexture(texture);

    data = texture.readFramebufferPixels(0, 0, w, h);

    texture.kill();

    //flip vertically
    var data2 = new Uint8Array( w * h * 4 );
    for (var y = 0; y < h; y++) {
        var index = y * w * 4;
        var index2 = (h - y - 1) * w * 4; 

        for (var x = 0; x < w; x++) {
            data2[index2] = data[index];
            data2[index2+1] = data[index+1];
            data2[index2+2] = data[index+2];
            data2[index2+3] = data[index+3];
            index += 4;
            index2 += 4;
        }
    }

    return { 'width': w, 'height': h, 'data': data2};
};


Map.prototype.getScreenDepth = function(screenX, screenY, useFallback) {

    if (useFallback) {

        var cameraPos = this.camera.position;
        var ray = this.renderer.getScreenRay(screenX, screenY), a, d;

        if (this.getNavigationSrs().isProjected()) { //plane fallback
            var planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];
            var planeNormal = [0,0,1];

            d = vec3.dot(planeNormal, ray); //minification is wrong there
            a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];
            t = vec3.dot(a, planeNormal) / d;

            if (t >= 0) {
                return [true, t];
            } else {
                return [false, 1];
            }

        } else { //elipsoid fallback
            var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
            var planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];
        
            var offset = [cameraPos[0], cameraPos[1], cameraPos[2]];
            a = vec3.dot(ray, ray); //minification is wrong there
            var b = 2 * vec3.dot(ray, offset);
            var c = vec3.dot(offset, offset) - planetRadius * planetRadius;
            d = b * b - 4 * a * c;
            
            if (d > 0) {
                d = Math.sqrt(d);
                var t1 = (-b - d) / (2*a);
                var t2 = (-b + d) / (2*a);
                var t = (t1 < t2) ? t1 : t2;

                return [true, t];
            } else {
                return [false, 1];
            }
        }

    } else {

        if (this.hitMapDirty) {
            var tmp1 = this.draw.ndcToScreenPixel;

            this.draw.drawHitmap();

            this.draw.ndcToScreenPixel = tmp1;

            var width = this.renderer.curSize[0], height = this.renderer.curSize[1];

            var m = new Float32Array(16);
            m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;
            m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;
            m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
            m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;

            this.renderer.imageProjectionMatrix = m;
            this.renderer.camera.update();
        }

        var res = this.renderer.getDepth(screenX, screenY);
    }

    return res;
};


Map.prototype.getHitCoords = function(screenX, screenY, mode, lod) {
    if (this.hitMapDirty) {
        this.draw.drawHitmap();
    }

    var cameraSpaceCoords = this.renderer.hitTest(screenX, screenY);
    
    var fallbackUsed = false; 
    var cameraPos = this.camera.position;
    var worldPos;

    var ray = cameraSpaceCoords[4], a, d;

    if (this.getNavigationSrs().isProjected()) { //plane fallback
        var planePos = [0,0,Math.min(-1000,this.referenceFrame.getGlobalHeightRange()[0])];
        var planeNormal = [0,0,1];

        d = vec3.dot(planeNormal, ray); //minification is wrong there
        //if (d > 1e-6) {
        a = [planePos[0] - cameraPos[0], planePos[1] - cameraPos[1], planePos[2] - cameraPos[2]];
        t = vec3.dot(a, planeNormal) / d;
            
            //var t = (vec3.dot(cameraPos, planeNormal) + (-500)) / d;            
        if (t >= 0) {
            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {
                worldPos = [ (ray[0] * t) + cameraPos[0],
                    (ray[1] * t) + cameraPos[1],
                    (ray[2] * t) + cameraPos[2] ];
    
                fallbackUsed = true;
            }
        }
        //}

    } else /*if (false)*/ { //elipsoid fallback
        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
        var planetRadius = navigationSrsInfo['b'] + this.referenceFrame.getGlobalHeightRange()[0];
    
        var offset = [cameraPos[0], cameraPos[1], cameraPos[2]];
        a = vec3.dot(ray, ray); //minification is wrong there
        var b = 2 * vec3.dot(ray, offset);
        var c = vec3.dot(offset, offset) - planetRadius * planetRadius;
        d = b * b - 4 * a * c;
        
        if (d > 0) {
            d = Math.sqrt(d);
            var t1 = (-b - d) / (2*a);
            var t2 = (-b + d) / (2*a);
            var t = (t1 < t2) ? t1 : t2;

            //console.log("hit: " + t + ",   " + cameraSpaceCoords[5]);
            
            if (!cameraSpaceCoords[3] || t < cameraSpaceCoords[5]) {
                worldPos = [ (ray[0] * t) + cameraPos[0],
                    (ray[1] * t) + cameraPos[1],
                    (ray[2] * t) + cameraPos[2] ];

                fallbackUsed = true;
            }
        }   
    }
    
    if (!cameraSpaceCoords[3] && !fallbackUsed) {
        return null;
    }
    
    if (!fallbackUsed) {
        worldPos = [ cameraSpaceCoords[0] + cameraPos[0],
            cameraSpaceCoords[1] + cameraPos[1],
            cameraSpaceCoords[2] + cameraPos[2] ];
    }

    var navCoords = this.convert.convertCoords(worldPos, 'physical', 'navigation');

    if (this.renderer.useSuperElevation) {
        navCoords[2] = this.renderer.getUnsuperElevatedHeight(navCoords[2]);
    }

    if (mode == 'float') {
        lod =  (lod != null) ? lod : this.measure.getOptimalHeightLod(navCoords, 100, this.config.mapNavSamplesPerViewExtent);
        var surfaceHeight = this.measure.getSurfaceHeight(navCoords, lod);
        navCoords[2] -= surfaceHeight[0]; 
    }

    return navCoords;
};


Map.prototype.hitTestGeoLayers = function(screenX, screenY, mode) {
    if (this.geoHitMapDirty) {
        if (this.freeLayersHaveGeodata) {
            this.draw.drawGeodataHitmap();
        }
    }

    if (!this.freeLayersHaveGeodata) {
        this.lastHoverFeature = null;
        this.lastHoverFeatureId = null;
        this.hoverFeature = null;
        this.hoverFeatureId = null;

        return [null, false, []];
    }

    var res = this.renderer.hitTestGeoLayers(screenX, screenY);
    var relatedEvents, elementIndex;

    if (res[0]) { //do we hit something?
        //console.log(JSON.stringify([id, JSON.stringify(this.hoverFeatureList[id])]));
       
        var id = (res[1]) + (res[2]<<8);
		
        var feature = this.hoverFeatureList[id];

        if (!feature) {
            return [null, false, [], elementIndex];
        }

        if (feature[6]) { //advanced hit feature?
            res = this.renderer.hitTestGeoLayers(screenX, screenY, true);
        
            if (res[0]) { //do we hit something?
                elementIndex = (res[1]) + (res[2]<<8);
            }
        }

        if (mode == 'hover') {
            this.lastHoverFeature = this.hoverFeature;
            this.lastHoverFeatureId = this.hoverFeatureId;
            
            if (feature && feature[3]) {
                this.hoverFeature = feature;
                this.hoverFeatureId = (feature != null) ? feature[0]['#id'] : null;
            } else {
                this.hoverFeature = null;
                this.hoverFeatureId = null;
            }

            relatedEvents = [];

            if (this.hoverFeatureId != this.lastHoverFeatureId) {
                if (this.lastHoverFeatureId != null) {
                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);
                }

                if (this.hoverFeatureId != null) {
                    relatedEvents.push(['enter', this.hoverFeature, this.hoverFeatureId]);
                }

                this.dirty = true;
            }

            if (this.hoverFeature != null && this.hoverFeature[3]) {
                return [this.hoverFeature, true, relatedEvents, elementIndex];
            } else {
                return [null, false, relatedEvents, elementIndex];
            }
        }

        if (mode == 'click') {
            if (feature != null && feature[2]) {
                return [feature, true, [], elementIndex];
            } else {
                return [null, false, [], elementIndex];
            }
        }
    } else {
        relatedEvents = [];

        if (mode == 'hover') {
            this.lastHoverFeature = this.hoverFeature;
            this.lastHoverFeatureId = this.hoverFeatureId;
            this.hoverFeature = null;
            this.hoverFeatureId = null;

            if (this.lastHoverFeatureId != null) {
                if (this.lastHoverFeatureId != null) {
                    relatedEvents.push(['leave', this.lastHoverFeature, this.lastHoverFeatureId]);
                }

                this.dirty = true;
            }
        }

        return [null, false, relatedEvents, elementIndex];
    }
};

Map.prototype.getCurrentGeometry = function() {
    if (this.draw.tree.surfaceSequence.length > 0) {
        this.draw.tree.draw(true);
        var res = this.storedTilesRes;
        this.storedTilesRes = [];
        return res;
    }

    return res;
};

Map.prototype.applyCredits = function(tile) {
    var value, value2;
    for (var key in tile.imageryCredits) {
        value = tile.imageryCredits[key];
        value2 = this.visibleCredits.imagery[key];

        if (value2) {
            this.visibleCredits.imagery[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.imagery[key] = value;
        }
    }
    for (key in tile.glueImageryCredits) {
        value = tile.glueImageryCredits[key];
        value2 = this.visibleCredits.imagery[key];

        if (value2) {
            this.visibleCredits.glueImagery[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.glueImagery[key] = value;
        }
    }
    for (key in tile.mapdataCredits) {
        value = tile.mapdataCredits[key];
        value2 = this.visibleCredits.mapdata[key];

        if (value2) {
            this.visibleCredits.mapdata[key] = value > value2 ? value : value2;
        } else {
            this.visibleCredits.mapdata[key] = value;
        }
    }
    
    /*if (this.drawBBoxes) {
        console.log(JSON.stringify(tile.id) + " " + JSON.stringify(this.visibleCredits));
    }*/
};


Map.prototype.drawMap = function() {
    this.draw.drawMap(null);
};


Map.prototype.processProcessingTasks = function() {
    while (this.processingTasks.length > 0) {
        if (this.stats.renderBuild > this.config.mapMaxProcessingTime) {
            this.markDirty();
            return;
        }

        this.processingTasks[0]();
        this.processingTasks.shift();
    }

    while (this.processingTasks2.length > 0) {
        if (this.processingTasks2[0]() != -123) {
            this.processingTasks2.shift();
        } else {
            break;
        }
    }

};


Map.prototype.addProcessingTask = function(task) {
    this.processingTasks.push(task);
};

Map.prototype.addProcessingTask2 = function(task) {
    this.processingTasks2.push(task);
};

/*
Map.prototype.updateGeodataProcessors = function(task) {
    var processors = this.map.geodataProcessors;
    for (var i = 0, li = processors.length; i < li; i++) {
        var processor = processors[i];

        if (!processor.ready && processor.processing) {
            processor.
        }
    }
};*/


Map.prototype.update = function() {
    if (this.killed) {
        return;
    }

    if (this.core.tokenExpiration) {
        if (Date.now() > (this.core.tokenExpiration - (1000*60))) {
            this.core.tokenExpirationCallback();
        }
    }

    if (!this.srsReady) {
        this.loader.update();
        return;
    }

    if (this.div && this.div.style.visibility == 'hidden'){
        //loop heartbeat
        //window.requestAnimFrame(this.update.bind(this));
        return;
    }

    if (!this.position.isSame(this.lastPosition)) {
        this.core.callListener('map-position-changed', {'position':this.position.toArray(), 'last-position':this.lastPosition.toArray()});
    }

    if (this.camera.lastTerrainHeight != this.camera.terrainHeight) {
        this.core.callListener('map-position-fixed-height-changed', {'height':this.camera.terrainHeight, 'last-height':this.camera.lastTerrainHeight});
    }

    this.lastPosition = this.position.clone();
    this.camera.lastTerrainHeight = this.camera.terrainHeight;
    this.drawFog = this.config.mapFog;

    var rect = this.renderer.div.getBoundingClientRect();
    var renderer = this.renderer, p;
    var camPos = renderer.cameraPosition;

    if (renderer.curSize[0] != rect.width || renderer.curSize[1] != rect.height) {
        renderer.onResize();
        this.dirty = true;
    }

    var dirty = (this.dirty || this.dirtyCountdown > 0), result;
    this.stats.begin(dirty);

    this.loader.update();

    //this.updateGeodataProcessors();

    this.processProcessingTasks();

    if (dirty) {
        if (this.dirty) {
            this.dirtyCountdown = this.config.mapRefreshCycles;
        } else {
            this.dirtyCountdown--;
        }

        this.dirty = false;
        this.bestMeshTexelSize = 0;//Number.MAX_VALUE;
        this.bestGeodataTexelSize = 0;//Number.MAX_VALUE;
        
        this.renderSlots.processRenderSlots();

        this.loader.update();
        
        this.core.callListener('map-update', {});

        //this.renderer.gpu.setState(this.drawTileState);
        //this.renderer.gpu.gl.disable(this.renderer.gpu.gl.BLEND);
        //this.renderer.drawImage(300, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);
        //this.renderer.drawImage(558, 0, 256, 256, this.renderer.hitmapTexture, null, null, null, null, false);

        //console.log("" + this.stats.gpuRenderUsed);
    }

    //hover and click events
    if (this.clickEvent != null || this.hoverEvent != null) {
        //this.updateGeoHitmap = this.dirty;

        if (this.hoverEvent != null) {
            result = this.hitTestGeoLayers(this.hoverEvent[0], this.hoverEvent[1], 'hover');

            var relatedEvents = result[2];

            if (relatedEvents != null) {
                for(var i = 0, li = relatedEvents.length; i < li; i++) {
                    var event = relatedEvents[i];

                    switch(event[0]) {
                    case 'enter':
                        p = event[1][1];
                        this.core.callListener('geo-feature-enter', {'feature': event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),
                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });
                        break;

                    case 'leave':
                        p = event[1][1];
                        this.core.callListener('geo-feature-leave', {'feature':event[1][0], 'canvas-coords':renderer.project2(event[1][1], renderer.camera.mvp, camPos),
                            'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3] });
                        break;
                    }
                }
            }

            if (result[1] && result[0] != null) {
                p = result[0][1];
                this.core.callListener('geo-feature-hover', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),
                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.hoverEvent[3], 'element': result[3]});
            }

            //is it persistent event?
            if (this.hoverEvent[2] !== true) {
                this.hoverEvent = null;
            }
        }

        if (this.clickEvent != null) {
            result = this.hitTestGeoLayers(this.clickEvent[0], this.clickEvent[1], 'click');

            if (result[1] && result[0] != null) {
                p = result[0][1];
                this.core.callListener('geo-feature-click', {'feature': result[0][0], 'canvas-coords':renderer.project2(result[0][1], renderer.camera.mvp, camPos),
                    'physical-coords':[p[0] + camPos[0], p[1] + camPos[1], p[2] + camPos[2]], 'state': this.clickEvent[2], 'element': result[3] });
            }

            this.clickEvent = null;
        }

    }


    this.stats.end(dirty);
};

/* harmony default export */ __webpack_exports__["a"] = (Map);


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_geographiclib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_geographiclib__);





//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var GeographicLib = __WEBPACK_IMPORTED_MODULE_2_geographiclib___default.a;


var MapMeasure = function(map) {
    this.map = map;
    this.config = map.config;
    this.convert = map.convert;
    this.getPhysicalSrs = this.map.getPhysicalSrs();
    this.navigationSrs = this.map.getNavigationSrs();
    this.publicSrs = this.map.getPublicSrs();
    this.navigationSrsInfo = this.navigationSrs.getSrsInfo();
    this.isProjected = this.navigationSrs.isProjected();

    var res = this.getSpatialDivisionNodeDepths();

    this.minDivisionNodeDepth = res[0];
    this.maxDivisionNodeDepth = res[1];
};

MapMeasure.prototype.getSurfaceAreaGeometry = function(coords, radius, mode, limit, loadMeshes, loadTextures) {
    var tree = this.map.tree;

    if (tree.surfaceSequence.length == 0) {
        reurn [true, []];
    }

    var center = this.convert.convertCoords(coords, 'navigation', 'physical');
    var coneVec = [0,0,0];

    vec3.normalize(center, coneVec);

    var distance = vec3.length(center);
    var coneAngle = Math.atan(Math.tan(radius / distance));

    tree.params = {
        coneVec : coneVec,
        coneAngle : coneAngle,
        mode : mode,
        limit : limit,
        loaded : true,
        areaTiles : [],
        loadMeshes: (loadMeshes === true),
        loadTextures: (loadTextures === true)
    };

    //priority = 0, noReadInly = false
    tree.traceAreaTiles(tree.surfaceTree, 0, false);

    return [tree.params.loaded, tree.params.areaTiles];
};

MapMeasure.prototype.getSurfaceHeight = function(coords, lod, storeStats, node, nodeCoords, coordsArray, useNodeOnly) {
    var tree = this.map.tree;

    if (tree.surfaceSequence.length == 0) {
        return [0, true, true, null, null, null];
    }

    if (!node) {
        var result = this.getSpatialDivisionNode(coords);
        node = result[0];
        nodeCoords = result[1];
    }
    
    if (!this.config.mapHeightLodBlend) {
        lod = Math.floor(lod);
    }

    if (useNodeOnly || this.config.mapIgnoreNavtiles) {
        return this.getSurfaceHeightNodeOnly(null, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);        
    }

    if (node != null && lod !== null) {
        var root = tree.findSurfaceTile(node.id);

        var extents = {
            ll : node.extents.ll.slice(),
            ur : node.extents.ur.slice()
        };
        var params = {
            coords : nodeCoords,
            desiredLod : Math.ceil(lod),
            extents : extents,
            metanode : null,
            heightMap : null,
            heightMapExtents : null,
            traceHeight : true,
            waitingForNode : false,
            finalNode : false,
            bestHeightMap : 999
        };

        tree.traceHeight(root, params, false);

        var metanode = params.metanode, i, li, height;

        if (params.heightMap) {
            if (storeStats) {
                var stats = this.map.stats;
                stats.heightClass = 2;
                stats.heightLod = lod;
                stats.heightNode = metanode.id[0];                        
            }
            
            var res = metanode.id[0] >= Math.ceil(lod);
            var arrayRes, height1, height2;
           
            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&
                params.parent && params.parent.heightMap && lod <= metanode.id[0]) {
                height1 = this.getHeightmapValue(nodeCoords, params.parent.metanode, params.parent);  
                height2 = this.getHeightmapValue(nodeCoords, metanode, params);  
                var factor = lod - Math.floor(lod);
                height = height1 + (height2 - height1) * factor;

                if (coordsArray) {
                    arrayRes = new Array(coordsArray.length);
                    
                    for (i = 0, li = coordsArray.length; i < li; i++) {
                        var nodeCoords2 = coordsArray[i];//node.getInnerCoords(coordsArray[i]);
                        height1 = this.getHeightmapValue(nodeCoords2, params.parent.metanode, params.parent);  
                        height2 = this.getHeightmapValue(nodeCoords2, metanode, params);  

                        arrayRes[i] = [height1 + (height2 - height1) * factor, res, true];
                    }
                }
                
                //console.log("lod: " + lod + " h1: " + height1 + " h2: " + height2 + " h: " + height);  
            } else {
                height = this.getHeightmapValue(nodeCoords, metanode, params);  

                if (coordsArray) {
                    arrayRes = new Array(coordsArray.length);
                    
                    for (i = 0, li = coordsArray.length; i < li; i++) {
                        height2 = this.getHeightmapValue(coordsArray[i], metanode, params);  

                        arrayRes[i] = [height2, res, true];
                    }
                }
            }

            return [height, res, true, null, null, arrayRes];

        } else if (metanode /*&& metanode.id[0] == lod && !metanode.hasNavtile()*/){
            res = this.getSurfaceHeightNodeOnly(coords, lod + 8, storeStats, lod, null, node, nodeCoords, coordsArray);

            //console.log("lod2: " + lod + " h: " + height[0]);  
            //return [res[0], res[1], true, null, null, res[5]];

            return [res[0], res[1], res[2], null, null, res[5]];
        }

        /*
        if (metanode != null) {
            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;
            return [height, metanode.id[0] >= lod, true];
        }*/
    }

    return [0, false, false, null, null, null];
};


MapMeasure.prototype.getSurfaceHeightNodeOnly = function(coords, lod, storeStats, statsLod, deltaSample, node, nodeCoords, coordsArray) {
    var arrayRes, height, stats = this.map.stats; 

    var tree = this.map.tree;

    if (tree.surfaceSequence.length == 0) {
        return [0, true, true, null, null, null];
    }
    
    if (!deltaSample) {
        if (!node) {
            var result = this.getSpatialDivisionNode(coords);
            node = result[0];
            nodeCoords = result[1];
        }
        
        if (coordsArray) {
            arrayRes = new Array(coordsArray.length);
            
            for (var i = 0, li = coordsArray.length; i < li; i++) {
                arrayRes[i] = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, deltaSample, node, coordsArray[i]);
            }
        }
        
    } else {
        node = deltaSample[0];
        nodeCoords = deltaSample[1];
    }

    if (!this.config.mapHeightLodBlend) {
        lod = Math.floor(lod);
    }

    if (!deltaSample && this.config.mapHeightNodeBlend) {
        var res1 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1], nodeCoords[2]]]);
        
        if (res1[2]) {
            var sx = res1[3].ur[0] - res1[3].ll[0];
            var sy = res1[3].ur[1] - res1[3].ll[1];
            
            var fx = (nodeCoords[0] - res1[3].ll[0]) / sx;
            var fy = (nodeCoords[1] - res1[3].ll[1]) / sy;
            
            /*
            var c2 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]);
            var c3 = node.getOuterCoords([nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]);
            var c4 = node.getOuterCoords([nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]);
    
            var res2 = this.getSurfaceHeightNodeOnly(c2, lod, storeStats, statsLod, true);
            var res3 = this.getSurfaceHeightNodeOnly(c3, lod, storeStats, statsLod, true);
            var res4 = this.getSurfaceHeightNodeOnly(c4, lod, storeStats, statsLod, true);
            */
            
            var res2 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1], nodeCoords[2]]]);
            var res3 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0], nodeCoords[1] + sy, nodeCoords[2]]]);
            var res4 = this.getSurfaceHeightNodeOnly(null, lod, storeStats, statsLod, [node, [nodeCoords[0] + sx, nodeCoords[1] + sy, nodeCoords[2]]]);

            var w0 = (res1[0] + (res2[0] - res1[0])*fx);
            var w1 = (res3[0] + (res4[0] - res3[0])*fx);
            height = (w0 + (w1 - w0)*fy);
            
            //console.log("h: " + height + "fx: " + fx + "fy: " + fy + "s1234: " + res1[0] + " "  + res2[0] + " "  + res3[0] + " "  + res4[0]);            
            /*
            if (res1[4] && res2[4] && res3[4] && res4[4]){
                console.log("h: " + height + "fx: " + fx + "fy: " + fy + "s1234: " + JSON.stringify(res1[4].id) + " "  + JSON.stringify(res2[4].id) + " "  + JSON.stringify(res3[4].id) + " "  + JSON.stringify(res4[4].id));            
            }*/

            return [height, res1[1], res1[2], res1[3], null, arrayRes];                
        } else {
            return [res1[0], res1[1], res1[2], res1[3], null, arrayRes];                
        }
        //convert new coords to nav coords
        //blend values
    }

    if (node != null && lod !== null) {
        var root = tree.findSurfaceTile(node.id);

        var extents = {
            ll : node.extents.ll.slice(),
            ur : node.extents.ur.slice()
        };
        var params = {
            coords : nodeCoords,
            desiredLod : Math.ceil(lod),
            extents : extents,
            metanode : null,
            heightMap : null,
            heightMapExtents : null,
            traceHeight : true,
            waitingForNode : false,
            finalNode : false,
            bestHeightMap : 999
        };

        tree.traceHeight(root, params, true);

        var metanode = params.metanode, center, center2;

        if (metanode != null) { // && metanode.id[0] == lod){

            if (metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small
                center = metanode.bbox.center();
                center = this.convert.convertCoords(center, 'physical', 'navigation');
            } else {
                center = [0,0,nodeCoords[2]];
            }

            //console.log("lod2: " + lod + " nodelod: " + metanode.id[0] + " h: " + center[2]/1.55);  

            if (storeStats) {
                stats.heightClass = 1;
                stats.heightLod = statsLod;
                stats.heightNode = metanode.id[0];                        
            }

            if (this.config.mapHeightLodBlend && metanode.id[0] > 0 &&
                params.parent && params.parent.metanode) {

                if (params.parent.metanode.bbox.maxSize < 8000) { // use bbox only when bbox is reasonable small
                    center2 = this.convert.convertCoords(params.parent.metanode.bbox.center(), 'physical', 'navigation');
                } else {
                    center2 = [0,0,nodeCoords[2]];
                }

                var factor = lod - Math.floor(lod);
                height = center[2] + (center2[2] - center[2]) * factor;
               
                //extetnts = params.extents;
                //return [height, true, true, params.extents, metanode, arrayRes];

                return [height, (metanode.id[0] >= Math.floor(lod) || params.finalNode), 
                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        params.extents, metanode, arrayRes];
                                      

                //console.log("lod: " + lod + " h1: " + center[2] + " h2: " + center2[2] + " h: " + height);  
            } else {
                return [center[2], (metanode.id[0] >= Math.floor(lod) || params.finalNode), 
                        (!params.waitingForNode || metanode.id[0] >= Math.floor(lod) || params.finalNode),
                        params.extents, metanode, arrayRes];

                //return [center[2], true, true, params.extents, metanode, arrayRes];
            }
        }

        /*
        if (metanode != null) {
            var height = metanode.minHeight + (metanode.maxHeight - metanode.minHeight) * 0.5;
            return [height, metanode.id[0] >= lod, true];
        }*/
    }

    //coords
    //console.log("lod3: " + lod + " h: 0");  

    if (storeStats) {
        stats.heightClass = 0;
        stats.heightLod = statsLod;
        stats.heightNode = 0;                        
    }


    return [0, false, false, null, null, arrayRes];
};


MapMeasure.prototype.getHeightmapValue = function(coords, node, params) {
    var heightMap = params.heightMap;
    var data = heightMap.getImageData();
    var dataExtents = heightMap.getImageExtents();
    var mapExtents = params.heightMapExtents;

    //relative tile coords
    var x = coords[0] - mapExtents.ll[0];
    //var y = nodeCoords[1] - mapExtents.ll[1];
    var y = mapExtents.ur[1] - coords[1];

    var maxX = (dataExtents[0]-1);
    var maxY = (dataExtents[1]-1);
    
    //data coords
    x = (maxX) * (x / (mapExtents.ur[0] - mapExtents.ll[0]));
    y = (maxY) * (y / (mapExtents.ur[1] - mapExtents.ll[1]));

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    var ix = Math.floor(x);
    var iy = Math.floor(y);
    var fx = x - ix;
    var fy = y - iy;

    var index = iy * dataExtents[0];
    var index2 = (iy == maxY) ? index : index + dataExtents[0];
    var ix2 = (ix == maxX) ? ix : ix + 1; 
    var h00 = data[(index + ix)*4];
    var h01 = data[(index + ix2)*4];
    var h10 = data[(index2 + ix)*4];
    var h11 = data[(index2 + ix2)*4];
    var w0 = (h00 + (h01 - h00)*fx);
    var w1 = (h10 + (h11 - h10)*fx);
    var height = (w0 + (w1 - w0)*fy);

    height = node.minHeight + (node.maxHeight - node.minHeight) * (height/255);
    
    return height;
};


MapMeasure.prototype.getSpatialDivisionNode = function(coords) {
    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    var bestNode = null;
    var bestLod = -1;
    var bestCoords = [0,0];

    for (var i = 0, li = nodes.length; i < li; i++) {
        var node = nodes[i];
        var nodeCoords = node.getInnerCoords(coords);
        var extents = node.extents;

        if (nodeCoords[0] >= extents.ll[0] && nodeCoords[0] <= extents.ur[0] &&
            nodeCoords[1] >= extents.ll[1] && nodeCoords[1] <= extents.ur[1]) {

            if (node.id[0] > bestLod) {
                bestNode = node;
                bestLod = node.id[0];
                bestCoords = nodeCoords;
            }
        }
    }

    return [bestNode, bestCoords];
};


MapMeasure.prototype.getSpatialDivisionNodeAndExtents = function(id) {
    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();

    var bestNode = null;
    //var bestLod = -1;
    var bestNodeCoords = [0,0], shift;
    //var bestExtents = {ll:[0,0], ur:[1,1]};

    for (var i = 0, li = nodes.length; i < li; i++) {
        var node = nodes[i];
        
        //has division node this tile node 
        //var shift = node.id[0] - this.lodRange[0];
        shift = id[0] - node.id[0];

        if (shift >= 0) {
            var x = id[1] >> shift;
            var y = id[2] >> shift;
            
            if (node.id[1] == x && node.id[2] == y) {
                bestNode = node;
                //bestLod = node.id[0];
                //bestExtents = node.extents;
                bestNodeCoords = [node.id[1] << shift, node.id[2] << shift];                
            }
        }
    }
    
    if (!bestNode) {
        return null;
    }
    
    shift = id[0] - bestNode.id[0];
    
    var factor = 1.0 / Math.pow(2, shift);
    var ur = bestNode.extents.ur;
    var ll = bestNode.extents.ll;
    
    //extents ll ur but tiles are ul lr!!!! 
    
    var dx = (ur[0] - ll[0]) * factor; 
    var dy = (ll[1] - ur[1]) * factor;
    
    var nx = id[1] - bestNodeCoords[0];
    var ny = id[2] - bestNodeCoords[1];

    return [bestNode, [[ll[0] + dx * nx, ur[1] + dy * ny], [ll[0] + dx * (nx+1), ur[1] + dy * (ny+1)] ]];
};


MapMeasure.prototype.getSpatialDivisionNodeFromId = function(id) {
    var shift = id[0] - this.maxDivisionNodeDepth;
    var nx = id[1] >> shift;
    var ny = id[2] >> shift;
    
    return this.map.referenceFrame.nodesMap['' + this.maxDivisionNodeDepth + '.'  + nx + '.' + ny];
};


MapMeasure.prototype.getSpatialDivisionNodeAndExtents2 = function(id, res, divisionNode) {
    if (!divisionNode) {
        return [null, 0,0,0,0];
    }
    
    var shift = id[0] - divisionNode.id[0];
    var factor = 1.0 / Math.pow(2, shift);
    var ur = divisionNode.extents.ur;
    var ll = divisionNode.extents.ll;
    
    //extents ll ur but tiles are ul lr!!!! 
    
    var dx = (ur[0] - ll[0]) * factor; 
    var dy = (ll[1] - ur[1]) * factor;
    
    var nx = id[1] - (divisionNode.id[1] << shift);
    var ny = id[2] - (divisionNode.id[2] << shift);
    
    res[0] = divisionNode;
    res[1] = ll[0] + dx * nx;
    res[2] = ur[1] + dy * ny;
    res[3] = ll[0] + dx * (nx+1);
    res[4] = ur[1] + dy * (ny+1);
};


MapMeasure.prototype.getSpatialDivisionNodeDepths = function() {
    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();
    var maxLod = -1;
    var minLod = Number.MAX_VALUE;

    for (var i = 0, li = nodes.length; i < li; i++) {
        var node = nodes[i];

        if (node.id[0] < minLod) {
            minLod = node.id[0];
        } 
        
        if (node.id[0] > maxLod) {
            maxLod = node.id[0];
        } 
    }

    return [minLod, maxLod];
};


MapMeasure.prototype.getOptimalHeightLodBySampleSize = function(coords, desiredSamplesSize) {
    var result = this.getSpatialDivisionNode(coords);
    var node = result[0];

    if (node != null) {
        var nodeLod = node.id[0];
        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];

        var lod = Math.log(nodeExtent / desiredSamplesSize) / Math.log(2);
        //lod = Math.round(lod) - 8 + nodeLod;
        lod = lod - 8 + nodeLod;

        return Math.max(0, lod);
    }

    return null;
};


MapMeasure.prototype.getOptimalHeightLod = function(coords, viewExtent, desiredSamplesPerViewExtent) {
    var result = this.getSpatialDivisionNode(coords);
    var node = result[0];

    if (node != null) {
        var nodeLod = node.id[0];
        var nodeExtent = node.extents.ur[1] - node.extents.ll[1];

        var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / Math.log(2);
        //lod = Math.round(lod) - 8 + nodeLod;
        lod = lod - 8 + nodeLod;

        return Math.max(0, lod);
    }

    return null;
};


MapMeasure.prototype.getDistance = function(coords, coords2, includingHeight, usePublic) {
    var sourceSrs = usePublic ? this.publicSrs : this.navigationSrs;
    var p1 = this.getPhysicalSrs.convertCoordsFrom(coords,  sourceSrs);
    var p2 = this.getPhysicalSrs.convertCoordsFrom(coords2, sourceSrs);
    var d = 0;

    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var dz = p2[2] - p1[2];

    var dd = Math.sqrt(dx*dx + dy*dy + dz*dz);
    var navigationSrsInfo = this.navigationSrsInfo;

    if (!this.isProjected) {
        var geod = this.getGeodesic(); //new GeographicLib["Geodesic"]["Geodesic"](navigationSrsInfo["a"],
                                       //                   (navigationSrsInfo["a"] / navigationSrsInfo["b"]) - 1.0);

        var r = geod.Inverse(coords[1], coords[0], coords2[1], coords2[0]);

        if (r.s12 > (navigationSrsInfo['a'] * 2 * Math.PI) / 4007.5) { //aprox 10km for earth
            if (includingHeight) {
                return [Math.sqrt(r.s12*r.s12 + dz*dz), -r.azi1, dd];
            } else {
                return [r.s12, -r.azi1, dd];
            }
        } else {
            if (includingHeight) {
                return [Math.sqrt(dx*dx + dy*dy + dz*dz), -r.azi1, dd];
            } else {
                return [r.s12, -r.azi1, dd];
            }
        }

    } else {
        return [Math.sqrt(dx*dx + dy*dy), math.degrees(Math.atan2(dx, dy)), dd];
    }
};


MapMeasure.prototype.getGeodesic = function() {
    var navigationSrsInfo = this.navigationSrsInfo;

    var geodesic = new GeographicLib.Geodesic.Geodesic(navigationSrsInfo['a'],
                                                      (navigationSrsInfo['a'] / navigationSrsInfo['b']) - 1.0);

    return geodesic;
};


MapMeasure.prototype.getAzimuthCorrection = function(coords, coords2) {
    if (!this.getNavigationSrs().isProjected()) {
        var geodesic = this.getGeodesic();
        var r = geodesic.Inverse(coords[0], coords[1], coords2[0], coords2[1]);
        var ret = (r.azi1 - r.azi2);
        if (isNaN(ret)) {
            ret = 0;
        } 
        return ret; 
    }
    return 0;
};


MapMeasure.prototype.getNED = function(coords) {
    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');
    var upCoords, rightCoords;

    if (this.isProjected) {
        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');
        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');
    } else {
        var cy = (coords[1] + 90) - 0.0001;
        var cx = (coords[0] + 180) + 0.0001;

        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated
            var geodesic = this.getGeodesic();
        
            //up coords
            var r = geodesic.Direct(coords[1], coords[0], 0, -100);
            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
    
            //right coords
            r = geodesic.Direct(coords[1], coords[0], 90, 100);
            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
        } else {
            // substraction instead of addition is probably case of complicated view matrix calculation
            upCoords = this.convert.convertCoords([coords[0], coords[1] - 0.0001, 0], 'navigation', 'physical');
            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');
        }
    }

    var up = [upCoords[0] - centerCoords[0],
        upCoords[1] - centerCoords[1],
        upCoords[2] - centerCoords[2]]; 

    var right = [rightCoords[0] - centerCoords[0],
        rightCoords[1] - centerCoords[1],
        rightCoords[2] - centerCoords[2]]; 

    var dir = [0,0,0];
    vec3.normalize(up);
    vec3.normalize(right);
    vec3.cross(up, right, dir);
    vec3.normalize(dir);

    return {
        east  : right, 
        direction : up,
        north : dir        
    };
};

MapMeasure.prototype.getNewNED = function(coords, returnMatrix) {
    var centerCoords = this.convert.convertCoords([coords[0], coords[1], 0], 'navigation', 'physical');
    var upCoords, rightCoords;

    if (this.isProjected) {
        upCoords = this.convert.convertCoords([coords[0], coords[1] + 100, 0], 'navigation', 'physical');
        rightCoords = this.convert.convertCoords([coords[0] + 100, coords[1], 0], 'navigation', 'physical');
    } else {
        //get NED for latlon coordinates
        //http://www.mathworks.com/help/aeroblks/directioncosinematrixeceftoned.html
        /*        
        var coords = this.position.getCoords();
        var lon = math.radians(coords[0]);
        var lat = math.radians(coords[1]);

        //NED vectors for sphere
        var east = [-Math.sin(lat)*Math.cos(lon), -Math.sin(lat)*Math.sin(lon), Math.cos(lat)];
        var direction = [-Math.sin(lon), Math.cos(lon), 0];
        var north = [-Math.cos(lat)*Math.cos(lon), -Math.cos(lat)*Math.sin(lon), -Math.sin(lat)];

        north = vec3.negate(north);
        east  = vec3.negate(east);
        
        //get elipsoid factor
        var navigationSrsInfo = this.getNavigationSrs().getSrsInfo();
        var factor = navigationSrsInfo["b"] / navigationSrsInfo["a"];

        //flaten vectors
        north[2] *= factor;
        east[2] *= factor;
        direction[2] *= factor;

        //normalize vectors
        north = vec3.normalize(north);
        east  = vec3.normalize(east);
        direction = vec3.normalize(direction);
        */

        var cy = (coords[1] + 90) + 0.0001;
        var cx = (coords[0] + 180) + 0.0001;

        if (cy < 0 || cx > 180) { //if we are out of bounds things start to be complicated
            var geodesic = this.getGeodesic();
        
            //up coords
            var r = geodesic.Direct(coords[1], coords[0], 0, -100);
            upCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
    
            //right coords
            r = geodesic.Direct(coords[1], coords[0], 90, -100);
            rightCoords = this.convert.convertCoords([r.lon2, r.lat2, 0], 'navigation', 'physical');
        } else {
            // substraction instead of addition is probably case of complicated view matrix calculation
            upCoords = this.convert.convertCoords([coords[0], coords[1] + 0.0001, 0], 'navigation', 'physical');
            rightCoords = this.convert.convertCoords([coords[0] + 0.0001, coords[1], 0], 'navigation', 'physical');
        }
    }

    var up = [upCoords[0] - centerCoords[0],
        upCoords[1] - centerCoords[1],
        upCoords[2] - centerCoords[2]]; 

    var right = [rightCoords[0] - centerCoords[0],
        rightCoords[1] - centerCoords[1],
        rightCoords[2] - centerCoords[2]]; 

    var dir = [0,0,0];
    vec3.normalize(up);
    vec3.normalize(right);
    vec3.cross(up, right, dir);
    vec3.normalize(dir);

    if (returnMatrix) {
        var east = right;
        var direction = up;
        var north = dir;

        return [
            east[0], east[1], east[2], 0,
            north[0], north[1], north[2], 0,
            direction[0], direction[1], direction[2], 0,
            0, 0, 0, 1
        ];        
    }

    return {
        east  : right, 
        direction : up,
        north : dir        
    };
};

//TODO: use getNewNED 
MapMeasure.prototype.getPositionCameraInfo = function(position, projected, clampTilt) {
    //var position = [0,0,0];
    var orientation = position.getOrientation();
    var distance = position.getViewDistance();
    
    if (clampTilt) { //used for street labels
        orientation[1] = math.clamp(orientation[1], -89.0, 90.0);
    }

    var roty = math.clamp(orientation[1], -89.5, 89.5);

    var tmpMatrix = mat4.create();
    mat4.multiply(math.rotationMatrix(2, math.radians(-orientation[0])), math.rotationMatrix(0, math.radians(roty)), tmpMatrix);
    var orbitPos, ned, north, east, direction, spaceMatrix, rotationMatrix;
    var east2, north2, direction2, dir, up, right;

    if (position.getViewMode() == 'obj') {
        orbitPos = [0, -distance, 0];
        mat4.multiplyVec3(tmpMatrix, orbitPos);
    } else {
        orbitPos = [0, 0, 0];
    }

    //this.cameraVector = [0, 0, 1];
    //mat4.multiplyVec3(this.updateCameraMatrix, this.cameraVector);

    var ret = {
        orbitCoords : null,
        distance : distance,
        rotMatrix : null,
        vector : null,
        orbitHeight : orbitPos[2]  
    };

    var coords = position.getCoords();

    if (projected) {
        
        tmpMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), tmpMatrix);

        ned = this.getNED(coords);
        north = ned.north;
        east  = ned.east;
        direction = ned.direction;

        spaceMatrix = [
            east[0], east[1], east[2], 0,
            direction[0], direction[1], direction[2], 0,
            north[0], north[1], north[2], 0,
            0, 0, 0, 1
        ];
        
        east2  = [1,0,0];
        direction2 = [0,1,0];
        north2 = [0,0,1];

        dir = [1,0,0];
        up = [0,0,-1];
        right = [0,0,0];
        vec3.cross(dir, up, right);

        //rotate vectors according to eulers
        mat4.multiplyVec3(tmpMatrix, north2);
        mat4.multiplyVec3(tmpMatrix, east2);
        mat4.multiplyVec3(tmpMatrix, direction2);

        mat4.multiplyVec3(tmpMatrix, dir);
        mat4.multiplyVec3(tmpMatrix, up);
        mat4.multiplyVec3(tmpMatrix, right);

        var t = 0;
        t = dir[0]; dir[0] = dir[1]; dir[1] = t;
        t = up[0]; up[0] = up[1]; up[1] = t;
        t = right[0]; right[0] = right[1]; right[1] = t;
        
        dir[2] = -dir[2];
        up[2] = -up[2];
        right[2] = -right[2];

        /*
        mat4.multiplyVec3(spaceMatrix, north2);
        mat4.multiplyVec3(spaceMatrix, east2);
        mat4.multiplyVec3(spaceMatrix, direction2);
        */

        //get rotation matrix
        rotationMatrix = [
            east2[0], east2[1], east2[2], 0,
            direction2[0], direction2[1], direction2[2], 0,
            north2[0], north2[1], north2[2], 0,
            0, 0, 0, 1
        ];

       // mat4.multiplyVec3(spaceMatrix, orbitPos);
/*
        //get rotation matrix
        var rotationMatrix = [
            east[0], east[1], east[2], 0,
            direction[0], direction[1], direction[2], 0,
            north[0], north[1], north[2], 0,
            0, 0, 0, 1
        ];
*/
        ret.vector = vec3.normalize([-orbitPos[0], -orbitPos[1], -orbitPos[2]]); 
        ret.vector2 = ret.vector; //vector2 is probably hack for tree.js bboxVisible 
        
        ret.orbitCoords = orbitPos;
        ret.rotMatrix = rotationMatrix; 

    } else { //geographics

      
        ned = this.getNED(coords);
        north = ned.north;
        east  = ned.east;
        direction = ned.direction;
        

        spaceMatrix = [
            east[0], east[1], east[2], 0,
            direction[0], direction[1], direction[2], 0,
            north[0], north[1], north[2], 0,
            0, 0, 0, 1
        ];
        
        //spaceMatrix = mat4.inverse(spaceMatrix);
        
        var localRotMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians(-roty - 90.0)), math.rotationMatrix(2, math.radians(orientation[0])), localRotMatrix);

        east2  = [1,0,0];
        direction2 = [0,1,0];
        north2 = [0,0,1];

        coords = position.getCoords();
        var latlonMatrix = mat4.create();
        mat4.multiply(math.rotationMatrix(0, math.radians((coords[1] - 90.0))), math.rotationMatrix(2, math.radians((-coords[0]-90))), latlonMatrix);
//      mat4.multiply(math.rotationMatrix(2, math.radians((coords[0]-90))), math.rotationMatrix(0, math.radians((coords[1] - 90.0))), latlonMatrix);


        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(-(coords[0]+90))), latlonMatrix);
        //mat4.multiply(math.rotationMatrix(0, math.radians(0)), math.rotationMatrix(2, math.radians(0)), latlonMatrix);

        //rotate vectors according to latlon
        mat4.multiplyVec3(latlonMatrix, north2);
        mat4.multiplyVec3(latlonMatrix, east2);
        mat4.multiplyVec3(latlonMatrix, direction2);


        spaceMatrix = [
            east2[0], east2[1], east2[2], 0,
            direction2[0], direction2[1], direction2[2], 0,
            north2[0], north2[1], north2[2], 0,
            0, 0, 0, 1
        ];

        right = [1,0,0];
        dir = [0,1,0];
        up = [0,0,1];
        //vec3.cross(dir, up, right);

        //rotate vectors according to eulers
        //mat4.multiplyVec3(this.updateCameraMatrix, north2);
        //mat4.multiplyVec3(this.updateCameraMatrix, east2);
        //mat4.multiplyVec3(this.updateCameraMatrix, direction2);

        mat4.multiplyVec3(spaceMatrix, dir);
        mat4.multiplyVec3(spaceMatrix, up);
        mat4.multiplyVec3(spaceMatrix, right);

        mat4.multiplyVec3(localRotMatrix, right);
        mat4.multiplyVec3(localRotMatrix, dir);
        mat4.multiplyVec3(localRotMatrix, up);
        
        //mat4.multiplyVec3(spaceMatrix, north2);
        //mat4.multiplyVec3(spaceMatrix, east2);
        //mat4.multiplyVec3(spaceMatrix, direction2);


        //get rotation matrix
/*        
        var rotationMatrix = [
            east2[0], east2[1], east2[2], 0,
            direction2[0], direction2[1], direction2[2], 0,
            north2[0], north2[1], north2[2], 0,
            0, 0, 0, 1
        ];
*/        

        rotationMatrix = [
            right[0], right[1], right[2], 0,
            dir[0], dir[1], dir[2], 0,
            up[0], up[1], up[2], 0,
            0, 0, 0, 1
        ];

        //get orbit pos
        spaceMatrix = mat4.inverse(spaceMatrix);
        mat4.multiplyVec3(spaceMatrix, orbitPos);

        //ret.vector2 = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; //vector2 is probably hack for tree.js bboxVisible 
        ret.vector = [-rotationMatrix[2], -rotationMatrix[6], -rotationMatrix[10]];

        //var ray = this.map.renderer.getScreenRay(800,400);

        //get camera direction
        //mat4.inverse(rotationMatrix, spaceMatrix);
        //ret.vector = [-spaceMatrix[8], -spaceMatrix[9], -spaceMatrix[10]]; 
        
        //console.log("cam vec: " + JSON.stringify(this.cameraVector));
         
        //this.position.setHeight(0); !!!!!!!!!!!!!!!
    }

    ret.orbitCoords = orbitPos;
    ret.rotMatrix = rotationMatrix;
    return ret; 
};


/* harmony default export */ __webpack_exports__["a"] = (MapMeasure);



/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__submesh__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__renderer_gpu_program__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__renderer_gpu_shaders__ = __webpack_require__(59);








//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var BBox = __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__["a" /* default */];
var MapSubmesh = __WEBPACK_IMPORTED_MODULE_2__submesh__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];
var GpuProgram = __WEBPACK_IMPORTED_MODULE_4__renderer_gpu_program__["a" /* default */];
var GpuShaders = __WEBPACK_IMPORTED_MODULE_5__renderer_gpu_shaders__["a" /* default */];

var MapMesh = function(map, url, tile) {
    this.generateLines = true;
    this.map = map;
    this.stats = map.stats;
    this.mapLoaderUrl  = url;
    this.tile = tile; // used only for stats
    this.use16bit = map.config.map16bitMeshes;

    this.bbox = new BBox();
    this.size = 0;
    this.gpuSize = 0;
    this.fileSize = 0;
    this.faces = 0;

    this.cacheItem = null;  //store killSubmeshes
    this.gpuCacheItem = null; //store killGpuSubmeshes

    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;

    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);

    this.submeshes = [];
    this.gpuSubmeshes = [];
    this.submeshesKilled = false;
};


MapMesh.prototype.kill = function() {
    this.bbox = null;
    this.killSubmeshes();
    this.killGpuSubmeshes();
};


MapMesh.prototype.killSubmeshes = function(killedByCache) {
    for (var i = 0, li = this.submeshes.length; i < li; i++) {
        this.submeshes[i].kill();
    }
    //this.submeshes = [];
    this.submeshesKilled = true;

    if (killedByCache !== true && this.cacheItem) {
        this.map.resourcesCache.remove(this.cacheItem);
        //this.tile.validate();
    }

    if (this.gpuSubmeshes.length == 0) {
        this.loadState = 0;
    }

    this.cacheItem = null;
};


MapMesh.prototype.killGpuSubmeshes = function(killedByCache) {
    var size = 0;
    for (var i = 0, li = this.gpuSubmeshes.length; i < li; i++) {
        this.gpuSubmeshes[i].kill();
        size += this.gpuSubmeshes[i].getSize();
    }

    if (li > 0) {
        this.stats.gpuMeshes -= size;
        this.stats.graphsFluxMesh[1][0]++;
        this.stats.graphsFluxMesh[1][1] += size;
    }

    this.gpuSubmeshes = [];

    if (killedByCache !== true && this.gpuCacheItem) {
        this.map.gpuCache.remove(this.gpuCacheItem);
        //this.tile.validate();
    }

    //console.log("kill: " + this.stats.counter + "   " + this.mapLoaderUrl);

//    if (this.submeshes.length == 0) {
    if (this.submeshesKilled) {
        this.loadState = 0;
    }

    this.gpuCacheItem = null;
};


MapMesh.prototype.isReady = function(doNotLoad, priority, doNotCheckGpu) {
    var doNotUseGpu = (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed);
    doNotLoad = doNotLoad || doNotUseGpu;
    
    //if (doNotUseGpu) {
      //  doNotUseGpu = doNotUseGpu;
    //}
    
    //if (this.mapLoaderUrl == "https://cdn.vts.com/mario/proxy/melown2015/surface/vts/cz10/12-1107-688.bin?0") {
      //  this.mapLoaderUrl = this.mapLoaderUrl;
    //}    

    if (this.loadState == 2) { //loaded
        if (this.cacheItem) {
            this.map.resourcesCache.updateItem(this.cacheItem);
        }
        
        if (doNotCheckGpu) {
            return true;
        }

        if (this.gpuSubmeshes.length == 0) {
            if (this.map.stats.gpuRenderUsed >= this.map.draw.maxGpuUsed) {
                return false;
            }

            /*if (this.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
                this.map.markDirty();
                return false;
            }*/

            if (doNotUseGpu) {
                return false;
            }

            var t = performance.now();
            this.buildGpuSubmeshes();
            this.stats.renderBuild += performance.now() - t; 
        }

        if (!doNotLoad && this.gpuCacheItem) {
            this.map.gpuCache.updateItem(this.gpuCacheItem);
        }
        return true;
    } else {
        if (this.loadState == 0) { 
            if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            } else {
                //not loaded
                //add to loading queue or top position in queue
                this.scheduleLoad(priority);
            }
        } else if (this.loadState == 3) { //loadError
            if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {
    
                this.scheduleLoad(priority);                    
            }
        } //else load in progress
    }

    return false;
};


MapMesh.prototype.scheduleLoad = function(priority) {
    if (!this.mapLoaderUrl) {
        this.mapLoaderUrl = this.map.url.makeUrl(this.tile.resourceSurface.meshUrl, {lod:this.tile.id[0], ix:this.tile.id[1], iy:this.tile.id[2] });
    }

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), priority, this.tile, 'mesh');
};


MapMesh.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'mesh');
    this.loadState = 1;
};


MapMesh.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;
    
    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { 
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }    
    
    this.mapLoaderCallError();
};


MapMesh.prototype.onLoaded = function(data, task, direct) {
    if (this.map.killed){
        return;
    }

    if (!task) {
        //this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
        this.map.markDirty();
        this.map.addProcessingTask(this.onLoaded.bind(this, data, true, direct));
        return;
    }

    var t = performance.now();

    if (direct) {
        this.parseWorkerData(data);
    } else {
        this.fileSize = data.byteLength;
        var stream = {data: new DataView(data), buffer:data, index:0};
        this.parseMapMesh(stream);
    }

    this.map.stats.renderBuild += performance.now() - t; 
    
    this.submeshesKilled = false;

    this.cacheItem = this.map.resourcesCache.insert(this.killSubmeshes.bind(this, true), this.size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


// Returns RAM usage in bytes.
//MapMesh.prototype.getSize = function () {
  //  return this.size;
//};

//MapMesh.prototype.fileSize = function () {
    //return this.fileSize;
//};


MapMesh.prototype.parseWorkerData = function (data) {
    this.faces = data['faces'];
    this.gpuSize = data['gpuSize'];
    this.meanUndulation = data['meanUndulation'];
    this.numSubmeshes = data['numSubmeshes'];
    this.size = data['size'];
    this.version = data['version'];
    this.submeshes = [];

    var submeshes = data['submeshes'];

    for (var i = 0, li = submeshes.length; i < li; i++) {
        var submesh = new MapSubmesh(this);
        var submeshData = submeshes[i];

        submesh.bbox.min = submeshData['bboxMin'];
        submesh.bbox.max = submeshData['bboxMax'];
        submesh.externalUVs = submeshData['externalUVs'];
        submesh.faces = submeshData['faces'];
        submesh.flags = submeshData['flags'];
        submesh.gpuSize = submeshData['gpuSize'];
        submesh.indices = submeshData['indices'];
        submesh.internalUVs = submeshData['internalUVs'];
        submesh.size = submeshData['size'];
        submesh.surfaceReference = submeshData['surfaceReference'];
        submesh.textureLayer = submeshData['textureLayer'];
        submesh.textureLayer2 = submeshData['textureLayer2'];
        submesh.vertices = submeshData['vertices'];

        this.submeshes.push(submesh); 
    }

    this.bbox.updateMaxSize();
};

MapMesh.prototype.parseMapMesh = function (stream) {
/*
    struct MapMesh {
        struct MapMeshHeader {
            char magic[2];                // letters "ME"
            ushort version;               // currently 1
            double meanUndulation;        // read more about undulation below
            ushort numSubmeshes;          // number of submeshes
        } header;
        struct Submesh submeshes [];      // array of submeshes, size of array is defined by numSubmeshes property
    };
*/
    this.killSubmeshes(); //just in case

    //parase header
    var streamData = stream.data;
    var magic = '';

    if (streamData.length < 2) {
        return false;
    }

    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;
    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;

    if (magic != 'ME') {
        return false;
    }

    this.version = streamData.getUint16(stream.index, true); stream.index += 2;

    if (this.version > 3) {
        return false;
    }
    
    //if (this.version >= 3) {
    stream.uint8Data = new Uint8Array(stream.buffer);
    //}

    this.meanUndulation = streamData.getFloat64(stream.index, true); stream.index += 8;
    this.numSubmeshes = streamData.getUint16(stream.index, true); stream.index += 2;

    this.submeshes = [];
    this.gpuSize = 0; 
    this.faces = 0;

    for (var i = 0, li = this.numSubmeshes; i < li; i++) {
        var submesh = new MapSubmesh(this, stream);
        if (submesh.valid) {
            this.submeshes.push(submesh); 
            this.size += submesh.getSize();
            this.faces += submesh.faces;

            //aproximate size
            this.gpuSize += submesh.getSize();
        }
    }
    
    this.numSubmeshes = this.submeshes.length;
};


MapMesh.prototype.addSubmesh = function(submesh) {
    this.submeshes.push(submesh);
    this.size += submesh.size;
    this.faces += submesh.faces;
};


MapMesh.prototype.buildGpuSubmeshes = function() {
    var size = 0;
    this.gpuSubmeshes = new Array(this.submeshes.length);

    for (var i = 0, li = this.submeshes.length; i < li; i++) {
        this.gpuSubmeshes[i] = this.submeshes[i].buildGpuMesh();
        size += this.gpuSubmeshes[i].getSize();
    }

    this.stats.gpuMeshes += size;
    this.stats.graphsFluxMesh[0][0]++;
    this.stats.graphsFluxMesh[0][1] += size;

    this.gpuCacheItem = this.map.gpuCache.insert(this.killGpuSubmeshes.bind(this, true), size);
    this.gpuSize = size;

    //console.log("build: " + this.stats.counter + "   " + this.mapLoaderUrl);
};


MapMesh.prototype.drawSubmesh = function (cameraPos, index, texture, type, alpha, layer, surface) {
    if (this.gpuSubmeshes[index] == null && this.submeshes[index] != null && !this.submeshes[index].killed) {
        this.gpuSubmeshes[index] = this.submeshes[index].buildGpuMesh();
    }

    var submesh = this.submeshes[index];
    var gpuSubmesh = this.gpuSubmeshes[index];

    if (!gpuSubmesh) {
        return;
    }

    var renderer = this.map.renderer;
    var draw = this.map.draw;
    var program = null;
    var gpuMask = null; 

    var texcoordsAttr = null;
    var texcoords2Attr = null;
    var drawWireframe = draw.debug.drawWireframe;
    var useSuperElevation = renderer.useSuperElevation;
    //var attributes = (drawWireframe != 0) ?  ['aPosition', 'aBarycentric'] : ['aPosition'];
    var attributes = ['aPosition'];

    if (type == 1) {
        program = useSuperElevation ? renderer.progDepthTileSE : renderer.progDepthTile;
        //texcoordsAttr = "aTexCoord";
    } else if (type == 2) {
        program = renderer.progFlatShadeTile;
    } else {
        if (drawWireframe > 0 && type == 3) {
            return;
        }

        if (drawWireframe == 1 || drawWireframe == 3) {
            program = useSuperElevation ? renderer.progFlatShadeTileSE : renderer.progFlatShadeTile;
        } else {
            switch(type) {
            case 4:
            case 5:
                program = useSuperElevation ? renderer.progTileSE : renderer.progTile;
                texcoordsAttr = 'aTexCoord';
                attributes.push('aTexCoord');
                break;
    
            case 6:
            case 7:

                program = useSuperElevation ? renderer.progTile2SE : renderer.progTile2;
                    
                if (texture) {
                    gpuMask = texture.getGpuMaskTexture();
                    if (gpuMask) {
                        program = useSuperElevation ? renderer.progTile3SE : renderer.progTile3;
                    }
                } 
                
                if (layer && (layer.shaderFilters || layer.shaderFilter)) {
                    var filter, id, flatShade;

                    if (surface && layer.shaderFilters) {
                        filter = layer.shaderFilters[surface.id];

                        if (filter) {
                            if (filter.varFlatShade) {
                                flatShade = true;
                            }

                            filter = filter.filter;
                        }
                    }

                    if (!filter) {
                        filter = layer.shaderFilter;
                    }

                    if (filter) {
                        var id = (gpuMask) ? 'progTile3' : 'progTile2';
                        var renderer = this.map.renderer;

                        if (useSuperElevation) {
                            id += 'se';
                        }

                        if (flatShade) {
                            id += 'fs';
                        }

                        id += filter;

                        program = renderer.progMap[id];

                        if (!program) {
                            var gpu = renderer.gpu, pixelShader;
                            var vertexShader = '#define externalTex\n' + ((useSuperElevation) ? '#define applySE\n' : '') + GpuShaders.tileVertexShader;

                            if (gpuMask) {
                                pixelShader = '#define externalTex\n#define mask\n' + GpuShaders.tileFragmentShader;
                            } else {
                                pixelShader = '#define externalTex\n' + GpuShaders.tileFragmentShader;
                            }

                            if (flatShade) {
                                pixelShader =  '#extension GL_OES_standard_derivatives : enable\n#define flatShadeVar\n' + pixelShader;
                                vertexShader = '#define flatShadeVar\n' + vertexShader;

                                //if (this.map.mobile) {
                                    //pixelShader = '#define flatShadeVarFallback\n' + pixelShader;
                                    pixelShader = pixelShader.replace('mediump', 'highp');
                                //}
                            }
     
                            program = new GpuProgram(gpu, vertexShader, pixelShader.replace('__FILTER__', filter));
                            renderer.progMap[id] = program;
                        }
                    }
                }
                    
                texcoords2Attr = 'aTexCoord2';  
                attributes.push('aTexCoord2');
                break;
    
            case 3:
                program = renderer.progFogTile;
                break;
            }
        }
    }

    if (!program || !program.isReady()) {
        return;
    }

    renderer.gpu.useProgram(program, attributes, gpuMask);
 
    if (texture) {
        var gpuTexture = texture.getGpuTexture();
        
        if (gpuTexture) {
            if (texture.statsCoutner != this.stats.counter) {
                texture.statsCoutner = this.stats.counter;
                this.stats.gpuRenderUsed += gpuTexture.getSize();
            }
            
            renderer.gpu.bindTexture(gpuTexture);

            if (gpuMask) {
                renderer.gpu.bindTexture(gpuMask, 1);
            }
            
        } else {
            return;
        }
    } else if (type != 3 && type != 1 && type != 2) {
        return;
    }

    var mv = this.mBuffer, m = this.mBuffer2, v = this.vBuffer;

    if (useSuperElevation) {

        var m = this.mBuffer;
        var se = renderer.superElevation;

        m[0] = submesh.bbox.min[0];
        m[1] = submesh.bbox.min[1];
        m[2] = submesh.bbox.min[2];

        m[3] = submesh.bbox.side(0);
        m[4] = submesh.bbox.side(1);
        m[5] = submesh.bbox.side(2);

        //m[6] = 0;
        //m[7] = 0;
        //m[8] = 0;

        m[9] = se[0]; // h1
        m[10] = se[1]; // f1
        m[11] = se[2]; // h2
        m[12] = se[6]; // inv dh
        m[13] = se[5]; // df

        m[14] = renderer.earthRadius;
        m[15] = renderer.earthERatio;

        program.setMat4('uParamsSE', m);

        //mv = renderer.camera.getModelviewFMatrix(); 
        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrixSE(cameraPos, m), mv);

    } else {
        mat4.multiply(renderer.camera.getModelviewFMatrix(), submesh.getWorldMatrix(cameraPos, m), mv);
    }


    var proj = renderer.camera.getProjectionFMatrix();

    program.setMat4('uMV', mv);

    if (draw.zbufferOffset) {
        program.setMat4('uProj', proj, renderer.getZoffsetFactor(draw.zbufferOffset));
    } else {
        program.setMat4('uProj', proj);
    }

    if (drawWireframe == 0) {
        var cv = this.map.camera.vector2, c = draw.atmoColor, t, bmin = submesh.bbox.min, bmax = submesh.bbox.max;

        switch(type) {
        case 4:
        case 3:
        case 5:

            m[0] = draw.zFactor, m[1] = (type == 5) ? 0 : draw.fogDensity;
            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],
            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],
            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];

            program.setMat4('uParams', m);

            v[0] = c[0], v[1] = c[1], v[2] = c[2];
            program.setVec4('uParams2', v);
            break;

        case 6:
        case 7:

            t = texture.getTransform();

            m[0] = draw.zFactor, m[1] = (type == 6) ? draw.fogDensity : 0;
            m[2] = bmax[0] - bmin[0], m[3] = bmax[1] - bmin[1],
            m[4] = cv[0], m[5] = cv[1], m[6] = cv[2], m[7] = cv[3],
            m[8] = t[0], m[9] = t[1], m[10] = t[2], m[11] = t[3],
            m[12] = bmax[2] - bmin[2], m[13] = bmin[0], m[14] = bmin[1], m[15] = bmin[2];

            program.setMat4('uParams', m);

            v[0] = c[0], v[1] = c[1], v[2] = c[2]; v[3] = (type == 6) ? 1 : alpha;
            program.setVec4('uParams2', v);
            break;
        }
    }

    if (submesh.statsCoutner != this.stats.counter) {
        submesh.statsCoutner = this.stats.counter;
        this.stats.gpuRenderUsed += gpuSubmesh.getSize();
    } 

    gpuSubmesh.draw(program, 'aPosition', texcoordsAttr, texcoords2Attr, drawWireframe != 0 ? 'aBarycentric' : null, (drawWireframe == 2));


    if (drawWireframe == 1 || drawWireframe == 2) { //very slow debug only

        program = useSuperElevation ? renderer.progWireFrameBasicSE : renderer.progWireFrameBasic;
        renderer.gpu.useProgram(program, attributes, gpuMask);

        if (useSuperElevation) {
            program.setMat4('uParamsSE', m);
        }

        program.setMat4('uMV', mv);
        program.setVec4('uColor', [0,0,0,1]);

        program.setMat4('uProj', proj, renderer.getZoffsetFactor([-0.001,0,0]));

        var gl = gpuSubmesh.gl;

        if (gpuSubmesh.indexBuffer) {
            for (var i = 0, li = gpuSubmesh.indexBuffer.numItems*2; i < li; i+=3) {
                gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i);
            }
        }  else {
            for (var i = 0, li = gpuSubmesh.vertexBuffer.numItems*2; i < li; i+=3) {
                gl.drawArrays(gl.LINE_LOOP, i, 3);
            }
        }
    }

    this.stats.drawnFaces += this.faces;
    this.stats.drawCalls ++;
};


/* harmony default export */ __webpack_exports__["a"] = (MapMesh);



/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__ = __webpack_require__(5);






//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var BBox = __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_2__utils_math__["a" /* math */];
var utils = __WEBPACK_IMPORTED_MODULE_1__utils_utils__["a" /* utils */];


var MapMetanode = function(metatile, id, stream, divisionNode) {
    this.metatile = metatile;
    this.map = metatile.map;
    this.id = id;
    this.credits = [];
    this.alien = false;
    this.ready = false;
    this.heightReady = false;
    this.divisionNode = divisionNode;

    this.diskPos = new Array(3);
    this.diskDistance = 1; 
    this.diskNormal = new Array(3); 
    this.diskAngle = 1;
    this.diskAngle2 = 1;
    this.diskAngle2A = 1;
    //this.bboxHeight = 1;
    this.bbox2 = new Array(24);

    //this.flagsGeometryPresent =  1;
    //this.flagsNavtilePresent =  3;
    //this.flagsInternalTexturePresent =  7;
    //this.flagsCoarsenessControl =  15;
    //this.flagsChildShift =  3;

    if (stream) {
        this.parseMetanode(stream);
    }
};


MapMetanode.prototype.kill = function() {
};


MapMetanode.prototype.hasChild = function(index) {
    return ((this.flags & (1<<(index+4))) != 0);
};


MapMetanode.prototype.hasChildById = function(id) {
    var ix = id[1] - (this.id[1]<<1); 
    var iy = id[2] - (this.id[2]<<1);
    
    //ul,ur,ll,lr
    return this.hasChild((iy<<1) + ix); 
};


MapMetanode.prototype.hasChildren = function() {
    return ((this.flags & ((15)<<4)) != 0);
};


MapMetanode.prototype.parseExtentBits = function(extentBytes, extentBits, index) {
    var value = 0;

    for (var i = 0, li = extentBits; i < li; i++) {
        var byteIndex = index >> 3;
        var bitIndex = index & 0x7;

        if (extentBytes[byteIndex] & (1 << (7-bitIndex))) {
            value = value | (1 << (li - i - 1));
        }

        index ++;
    }

    value /= (1 << li) - 1;
//    value *= maxExtent;

    return value;
};


MapMetanode.prototype.hasGeometry = function() {
    return ((this.flags & 1) != 0);
};


MapMetanode.prototype.hasNavtile = function() {
    return ((this.flags & (1 << 1)) != 0);
};


MapMetanode.prototype.usedTexelSize = function() {
    return ((this.flags & (1 << 2)) != 0);
};


MapMetanode.prototype.usedDisplaySize = function() {
    return ((this.flags & (1 << 3)) != 0);
};

MapMetanode.prototype.parseMetanode = function(stream) {

/*
struct Metanode {
    char flags;                   // #0 - geometry present, #1 - navtile present #2 - applyTexelSize,
                                  // #3 - applyPixelSize, #4,5,6,7 - ul,ur,ll,lr child exists
    char geomExtents[];           // a packed array of 6 bit sequences, each lod+2 long, in the following order:
                                  // minx,maxx,miny,maxy,minz,maxz, undefined if no geometry present
    uchar internalTextureCount;   // number of internal textures in geometry
    hfloat texelSize;             // internal texel size in physical srs units, undef unless applyTexelSize is set
    ushort displaySize;           // desired display size, undef unless applyDisplay size is set
    short minHeight, maxHeight;   // navigation tile value range, undef if no navtile present
}
*/

    var streamData = stream.data;
    //var lastIndex = stream.index;
    var version = this.metatile.version;

    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;

    if (version < 5) {
        var extentsSize = (((this.id[0] + 2) * 6 + 7) >> 3);
        var extentsBytes = this.map.metanodeBuffer;//new Uint8Array(extentsSize);
    
        for (var i = 0, li = extentsSize; i < li; i++) {
            extentsBytes[i] = streamData.getUint8(stream.index, true); stream.index += 1;
        }
    
        var extentBits = this.id[0] + 2;
    
        var minExtents = [0,0,0];
        var maxExtents = [0,0,0];
    
        var index = 0;
        var spaceExtentSize = this.map.spaceExtentSize;
        var spaceExtentOffset = this.map.spaceExtentOffset;
    
        for (i = 0; i < 3; i++) {
            minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];
            //minExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);
            index += extentBits;
            maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index) * spaceExtentSize[i] + spaceExtentOffset[i];
            //maxExtents[i] = this.parseExtentBits(extentsBytes, extentBits, index, 1.0);
            index += extentBits;
        }
    
        //check zero bbox
        var extentsBytesSum = 0;
        for (i = 0, li = extentsBytes.length; i < li; i++) {
            extentsBytesSum += extentsBytes[i];
        }
        
        //extent bytes are empty and therefore bbox is empty also
        if (extentsBytesSum == 0 ) {
            //console.log("empty-node: id: " + JSON.stringify(this.id));
            //console.log("empty-node: surafce: " + this.metatile.surface.id);
    
            minExtents[0] = Number.POSITIVE_INFINITY;
            minExtents[1] = Number.POSITIVE_INFINITY;
            minExtents[2] = Number.POSITIVE_INFINITY;
            maxExtents[0] = Number.NEGATIVE_INFINITY;
            maxExtents[1] = Number.NEGATIVE_INFINITY;
            maxExtents[2] = Number.NEGATIVE_INFINITY;
        }
    
        this.bbox = new BBox(minExtents[0], minExtents[1], minExtents[2], maxExtents[0], maxExtents[1], maxExtents[2]);
    }    

    //this.surrogatezHeight = 0;

    if (version >= 4) {
        this.minZ = streamData.getFloat32(stream.index, true); stream.index += 4;
        this.maxZ = streamData.getFloat32(stream.index, true); stream.index += 4;
        this.surrogatez = streamData.getFloat32(stream.index, true); stream.index += 4;

        //if (!(this.minZ > this.maxZ || this.surrogatez == Number.NEGATIVE_INFINITY)) {
          //  this.surrogatezHeight = this.surrogatez; //have to converted to nav srs height
        //}
    }



    this.internalTextureCount = streamData.getUint8(stream.index, true); stream.index += 1;

    this.pixelSize = utils.decodeFloat16( streamData.getUint16(stream.index, true) ); stream.index += 2;
    this.displaySize = streamData.getUint16(stream.index, true); stream.index += 2;
    this.displaySize = this.metatile.surface.displaySize; //1024;
    if ((this.flags & (1 << 2)) == 0) {
        this.pixelSize = Number.POSITIVE_INFINITY;
    }

    if ((this.flags & (1 << 3)) == 0) {
        this.displaySize = 256;
    }

    this.minHeight = streamData.getInt16(stream.index, true); stream.index += 2;
    this.maxHeight = streamData.getInt16(stream.index, true); stream.index += 2;

    if (version < 4) {
        this.minZ = this.minHeight;
        this.maxZ = this.maxHeight;
        this.surrogatez =this.minHeight;
    }

    this.minZ2 = this.minZ;
    this.maxZ2 = this.maxZ;

    
    if (this.metatile.version >= 3) {
        if (this.metatile.flags & (1<<7)) {
            this.sourceReference = streamData.getUint16(stream.index, true); stream.index += 2;
        } else if (this.metatile.flags & (1<<6)) {
            this.sourceReference = streamData.getUint8(stream.index, true); stream.index += 1;
        }
    }

    this.heightReady = this.hasNavtile();
    
    this.alien = false;

    //var nodeSize2 = stream.index - lastIndex;

    //if (!this.map.config.mapSmartNodeParsing) {
    this.generateCullingHelpers();
    //}    
};


MapMetanode.prototype.clone = function() {
    var node = new  MapMetanode(this.metatile, this.id);
    node.flags = this.flags;
    node.minHeight = this.minHeight;
    node.maxHeight = this.maxHeight;
    node.minZ = this.minZ;
    node.maxZ = this.maxZ;
    node.minZ2 = this.minZ2;
    node.maxZ2 = this.maxZ2;
    node.llx = this.llx;
    node.lly = this.lly;
    node.urx = this.urx;
    node.ury = this.ury;
    node.surrogatez = this.surrogatez;
    node.internalTextureCount = this.internalTextureCount;
    node.pixelSize = this.pixelSize;
    node.displaySize = this.displaySize;
    node.ready = this.ready;
    node.stream = this.stream;
    node.heightReady = this.heightReady;
    
    //copy credits
    node.credits = new Array(this.credits.length);
    
    for (var i = 0, li = this.credits.length; i < li; i++) {
        node.credits[i] = this.credits[i];
    }

    if (this.bbox) {
        node.bbox = this.bbox.clone();
    }


//    if (this.map.config.mapGeocentCulling) {
    node.diskPos = this.diskPos;
    node.diskNormal = this.diskNormal; 
    node.diskAngle = this.diskAngle;
    node.diskAngle2 = this.diskAngle2;
    node.diskAngle2A = this.diskAngle2A;
    node.diskDistance = this.diskDistance; 
    node.bbox2 = this.bbox2;  

    node.divisionNode = this.divisionNode;

 //   }

    if (this.plane) {
        node.plane = this.plane.slice();
    }

    return node;
};


MapMetanode.prototype.generateCullingHelpers = function(virtual) {
    this.ready = true;
    
    var map = this.map;
    var draw = map.draw;
    var geocent = map.isGeocent;
    var version = this.metatile.useVersion;

    if (this.id[0] < map.measure.minDivisionNodeDepth || (!geocent && version < 4)) {
        return;
    }

    if (map.config.mapPreciseCulling || version >= 4) { //use division node srs
        if (virtual) {
            return; //result is same for each tile id
        }

        var divisionNode;
        var llx, lly, urx, ury;
        var pos = draw.tmpVec3;
        
        if (this.id[0] > map.measure.maxDivisionNodeDepth) {
            var pos2 = draw.tmpVec5;
            
            divisionNode = map.measure.getSpatialDivisionNodeFromId(this.id);

            if (!divisionNode) {
                return;
            }

            map.measure.getSpatialDivisionNodeAndExtents2(this.id, pos2, divisionNode);
            //var node = pos2[0]; 
            llx = pos2[1];
            lly = pos2[2];
            urx = pos2[3];
            ury = pos2[4];

            this.divisionNode = divisionNode;

            /*if (this.id[0] == 2 && this.id[1] == 0 && this.id[2] == 2) {
                var res = this.map.measure.getSpatialDivisionNodeAndExtents(this.id);
                res = res;
            }*/
            
        } else {
            var res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
            divisionNode = res ? res[0] : null; 

            if (!divisionNode) {
                return;
            }
                        
            llx = res[1][0][0];
            lly = res[1][0][1];
            urx = res[1][1][0];
            ury = res[1][1][1];
            this.divisionNode = divisionNode;
        }

        this.llx = llx;
        this.lly = lly;
        this.urx = urx;
        this.ury = ury;
        
        var h = this.minZ;
        //var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5, h];
        //var normal = [0,0,0];
        
        pos[0] = (urx + llx)* 0.5; 
        pos[1] = (ury + lly)* 0.5; 
        pos[2] = h; 
        
        divisionNode.getPhysicalCoordsFast(pos, true, this.diskPos, 0, 0);
        
        if (geocent) {
            this.diskDistance = vec3.length(this.diskPos); 
            vec3.normalize(this.diskPos, this.diskNormal);
        } else {
            this.diskNormal[0] = 0;
            this.diskNormal[1] = 0;
            this.diskNormal[2] = 1;
        }
        //this.diskNormal = normal;   
        var normal = this.diskNormal;
        
        
        //if (divisionNode.id[0] == 1 && divisionNode.id[1] ==  1 && divisionNode.id[2] == 0) {   //???? debug?????
          //  var res = this.map.getSpatialDivisionNodeAndExtents(this.id);
          //  node = node;
        //}
        
        pos[0] = urx; 
        pos[1] = ury; 
        pos[2] = h; 

        /*if (this.id[0] == 17 && this.id[1] == 53306 && this.id[2] == 30754) {
            normal = normal;
        }*/
        
        var bbox = this.bbox2;

        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 0);

        pos[1] = lly; 
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 3);
        
        pos[0] = llx; 
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 6);
        
        pos[1] = ury; 
        divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 9);

        var height;

        if (!geocent) {
            height = this.maxZ - h;
            
            bbox[12] = bbox[0];
            bbox[13] = bbox[1];
            bbox[14] = bbox[2] + height;
            
            bbox[15] = bbox[3];
            bbox[16] = bbox[4];
            bbox[17] = bbox[5] + height;
        
            bbox[18] = bbox[6];
            bbox[19] = bbox[7];
            bbox[20] = bbox[8] + height;
        
            bbox[21] = bbox[9];
            bbox[22] = bbox[10];
            bbox[23] = bbox[11] + height;
            return;        
        }

        var normalize;
        var dot = vec3.dot;
        var d1, d2, d3, d4, maxDelta;

        if (map.config.mapPreciseBBoxTest || version >= 4) { 
        //if (true) { 
            height = this.maxZ - h;

            if (this.id[0] <= 3) { //get aabbox for low lods
                normalize = vec3.normalize2; 

                normalize(bbox, 0, pos);
                d1 = dot(normal, pos);
                
                normalize(bbox, 3, pos);
                d2 = dot(normal, pos);
        
                normalize(bbox, 6, pos);
                d3 = dot(normal, pos);
        
                normalize(bbox, 9, pos);
                d4 = dot(normal, pos);

                maxDelta = Math.min(d1, d2, d3, d4);

                pos[0] = (urx + llx)* 0.5; 
                pos[1] = ury; 
                pos[2] = h; 
                
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);

                pos[1] = lly; 
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);

                pos[0] = urx; 
                pos[1] = (ury + lly)* 0.5; 
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);

                pos[0] = llx; 
                divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);

                var mpos = this.diskPos;
                var maxX = Math.max(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);
                var minX = Math.min(bbox[0], bbox[3], bbox[6], bbox[9], bbox[12], bbox[15], bbox[18], bbox[21], mpos[0]);
                
                var maxY = Math.max(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);
                var minY = Math.min(bbox[1], bbox[4], bbox[7], bbox[10], bbox[13], bbox[16], bbox[19], bbox[22], mpos[1]);
                
                var maxZ = Math.max(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);
                var minZ = Math.min(bbox[2], bbox[5], bbox[8], bbox[11], bbox[14], bbox[17], bbox[20], bbox[23], mpos[2]);
                
                if (this.id[0] <= 1) {
                    pos[0] = urx + (llx-urx )* 0.25; 
                    pos[1] = (ury + lly)* 0.5; 
                    
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 12);
    
                    pos[0] = urx + (llx-urx )* 0.75; 
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 15);
    
                    pos[0] = (urx + llx)* 0.5; 
                    pos[1] = ury + (lly-ury )* 0.25; 
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 18);
    
                    pos[1] = ury + (lly-ury )* 0.75; 
                    divisionNode.getPhysicalCoordsFast(pos, true, bbox, 0, 21);

                    maxX =  Math.max(maxX, bbox[12], bbox[15], bbox[18], bbox[21]);
                    minX =  Math.min(minX, bbox[12], bbox[15], bbox[18], bbox[21]);
                    
                    maxY =  Math.max(maxY, bbox[13], bbox[16], bbox[19], bbox[22]);
                    minY =  Math.min(minY, bbox[13], bbox[16], bbox[19], bbox[22]);
                    
                    maxZ =  Math.max(maxZ, bbox[14], bbox[17], bbox[20], bbox[23]);
                    minZ =  Math.min(minZ, bbox[14], bbox[17], bbox[20], bbox[23]);

                    maxDelta = -1;//full circle;
                }

                bbox[0] = minX; bbox[1] = minY; bbox[2] = minZ;
                bbox[3] = maxX; bbox[4] = minY; bbox[5] = minZ;
                bbox[6] = maxX; bbox[7] = maxY; bbox[8] = minZ;
                bbox[9] = minX; bbox[10] = maxY; bbox[11] = minZ;

                bbox[12] = minX; bbox[13] = minY; bbox[14] = maxZ;
                bbox[15] = maxX; bbox[16] = minY; bbox[17] = maxZ;
                bbox[18] = maxX; bbox[19] = maxY; bbox[20] = maxZ;
                bbox[21] = minX; bbox[22] = maxY; bbox[23] = maxZ;
            } else {

                normalize = vec3.normalize3; 
                dot = vec3.dot2;

                normalize(bbox, 0, bbox, 12);
                d1 = dot(normal, bbox, 12);
                
                normalize(bbox, 3, bbox, 15);
                d2 = dot(normal, bbox, 15);
        
                normalize(bbox, 6, bbox, 18);
                d3 = dot(normal, bbox, 18);
        
                normalize(bbox, 9, bbox, 21);
                d4 = dot(normal, bbox, 21);
    
                maxDelta = Math.min(d1, d2, d3, d4);

                if (this.id[0] <= 8) { //extend bbox because of lon curvature
                    pos = this.diskPos;

                    var expand = 0.12 / (9-4) * (5-(this.id[0]-4));

                    bbox[0] += (bbox[0] - pos[0]) * expand;
                    bbox[1] += (bbox[1] - pos[1]) * expand;
                    bbox[2] += (bbox[2] - pos[2]) * expand;

                    bbox[3] += (bbox[3] - pos[0]) * expand;
                    bbox[4] += (bbox[4] - pos[1]) * expand;
                    bbox[5] += (bbox[5] - pos[2]) * expand;

                    bbox[6] += (bbox[6] - pos[0]) * expand;
                    bbox[7] += (bbox[7] - pos[1]) * expand;
                    bbox[8] += (bbox[8] - pos[2]) * expand;

                    bbox[9] += (bbox[9] - pos[0]) * expand;
                    bbox[10] += (bbox[10] - pos[1]) * expand;
                    bbox[11] += (bbox[11] - pos[2]) * expand;
                }

                //extend bbox height by tile curvature 
                height += draw.planetRadius - (draw.planetRadius * maxDelta);  
                
                bbox[12] = bbox[0] + bbox[12] * height;
                bbox[13] = bbox[1] + bbox[13] * height;
                bbox[14] = bbox[2] + bbox[14] * height;
                
                bbox[15] = bbox[3] + bbox[15] * height;
                bbox[16] = bbox[4] + bbox[16] * height;
                bbox[17] = bbox[5] + bbox[17] * height;
            
                bbox[18] = bbox[6] + bbox[18] * height;
                bbox[19] = bbox[7] + bbox[19] * height;
                bbox[20] = bbox[8] + bbox[20] * height;
            
                bbox[21] = bbox[9] + bbox[21] * height;
                bbox[22] = bbox[10] + bbox[22] * height;
                bbox[23] = bbox[11] + bbox[23] * height;
            }
        
        } else {
            normalize = vec3.normalize2; 

            normalize(bbox, 0, pos);
            d1 = dot(normal, pos);
            
            normalize(bbox, 3, pos);
            d2 = dot(normal, pos);
    
            normalize(bbox, 6, pos);
            d3 = dot(normal, pos);
    
            normalize(bbox, 9, pos);
            d4 = dot(normal, pos);

            maxDelta = Math.min(d1, d2, d3, d4);
        }

        //get cos angle based at 90deg
        this.diskAngle = Math.cos(Math.max(0,(Math.PI * 0.5) - Math.acos(maxDelta)));
        this.diskAngle2 = maxDelta;
        this.diskAngle2A = Math.acos(maxDelta); //optimalization

        //shift center closer to earth
        //var factor = this.bbox.maxSize * 0.2; 
        //this.diskPos = [this.diskPos[0] - normal[0] * factor, this.diskPos[1]  - normal[1] * factor, this.diskPos[2] - normal[2] * factor];   
    } 
};


MapMetanode.prototype.getWorldMatrix = function(geoPos, matrix) {
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    var m = matrix;

    if (m != null) {
        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);
    }

    return m;
};


MapMetanode.prototype.drawBBox = function(cameraPos) {
    if (this.metatile.useVersion >= 4) {
        return this.drawBBox2(cameraPos);
    }

    var renderer = this.map.renderer;

    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);

    var mvp = mat4.create();
    var mv = mat4.create();

    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);

    var proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, mvp);

    renderer.progBBox.setMat4('uMVP', mvp);

    //draw bbox
    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');
};


MapMetanode.prototype.drawBBox2 = function() {
    //var spoints = []; 
    //for (var i = 0, li = this.bbox2.length; i < li; i++) {
        //var pos = this.bbox2[i];
        //pos = ["obj", pos[0], pos[1], "fix", pos[2], 0, 0, 0, 10, 90 ];
        
    var bbox = this.bbox2;
    var buffer = this.map.draw.bboxBuffer;
    var camPos = this.map.camera.position;
    var renderer = this.map.renderer;
    var prog = renderer.progBBox2;

    for (var i = 0, li = 8*3; i < li; i+=3) {
        //var pos = ["obj", bbox[i], bbox[i+1], "fix", bbox[i+2], 0, 0, 0, 10, 90 ];
        //var coords = this.map.convert.getPositionCameraCoords((new MapPosition(pos)), null, true);

        buffer[i] = bbox[i] - camPos[0];
        buffer[i+1] = bbox[i+1] - camPos[1];
        buffer[i+2] = bbox[i+2] - camPos[2];
    }
    

    renderer.gpu.useProgram(prog, ['aPosition']);

    prog.setFloatArray('uPoints', buffer);

    //var mvp = mat4.create();
    //var mv = mat4.create();

    //mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);

    //var proj = renderer.camera.getProjectionMatrix();
    //mat4.multiply(proj, mv, mvp);

    var mvp = renderer.camera.getMvpMatrix();

    prog.setMat4('uMVP', mvp);

    //draw bbox
    renderer.bboxMesh2.draw(prog, 'aPosition');
};

MapMetanode.prototype.drawPlane = function(cameraPos, tile) {
    var renderer = this.map.renderer;
    var buffer = this.map.draw.planeBuffer;
    var points = this.plane;
    
    if (!points) {
        return;
    }

    renderer.gpu.useProgram(renderer.progPlane, ['aPosition', 'aTexCoord']);

    var mvp = mat4.create();
    var mv = renderer.camera.getModelviewMatrix();
    var proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, mvp);
    
    var sx = cameraPos[0];
    var sy = cameraPos[1];
    var sz = cameraPos[2];

    for (var i = 0; i < 9; i++) {
        var index = i*3;
        buffer[index] = points[index] - sx; 
        buffer[index+1] = points[index+1] - sy; 
        buffer[index+2] = points[index+2] - sz; 
    }
    
    var prog = renderer.progPlane; 

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);

    //var minTile = 32;
    var embed = 8;
    var altitude = Math.max(10, tile.distance + 20);
    var gridSelect = (Math.log(altitude) / Math.log(embed));
    var step1 = 4;//(Math.pow(embed, Math.floor(gridSelect)));
    var step2 = 8;//(Math.pow(embed, Math.ceil(gridSelect)));
    var blend = (gridSelect - Math.floor(gridSelect));
    //var blend = 0;

    //prog.setVec4("uParams", [0,0,1/15,0]);
    //prog.setVec4("uParams", [(minTile / step1),0,1/15,(minTile / step2)]);
    prog.setVec4('uParams', [step1, 0, 1/15, step2]);

    //prog.setVec4("uParams2", [(minTile / step1), (minTile / step2), blend, 0]);
    prog.setVec4('uParams2', [0, 0, blend, 0]);

    renderer.gpu.bindTexture(renderer.heightmapTexture);
    
    //draw bbox
    renderer.planeMesh.draw(renderer.progPlane, 'aPosition', 'aTexCoord');
};


MapMetanode.prototype.getGridHeight = function(coords, data, dataWidth) {
    var x = coords[0] - this.llx;
    //var y = this.ury - coords[1];
    var y = coords[1]  - this.lly;
    var maxX = (dataWidth-1);
    var maxY = (dataWidth-1);
    
    //data coords
    x = (maxX) * (x / (this.urx - this.llx));
    y = (maxY) * (y / (this.ury - this.lly));

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    var ix = Math.floor(x);
    var iy = Math.floor(y);
    var fx = x - ix;
    var fy = y - iy;

    var index = iy * dataWidth;
    var index2 = (iy == maxY) ? index : index + dataWidth;
    var ix2 = (ix == maxX) ? ix : ix + 1; 
    var h00 = data[index + ix];
    var h01 = data[index + ix2];
    var h10 = data[index2 + ix];
    var h11 = data[index2 + ix2];
    var w0 = (h00 + (h01 - h00)*fx);
    var w1 = (h10 + (h11 - h10)*fx);
    var height = (w0 + (w1 - w0)*fy);

    return height;
};

/* harmony default export */ __webpack_exports__["a"] = (MapMetanode);



/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__metanode__ = __webpack_require__(144);




//get rid of compiler mess
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];
var MapMetanode = __WEBPACK_IMPORTED_MODULE_1__metanode__["a" /* default */];


var MapMetatile = function(metaresources, surface, tile) {
    this.metaresources= metaresources; //this is metastorage tile
    this.map = metaresources.map;
    this.surface = surface;
    this.id = metaresources.id;
    this.tile = tile; // used only for stats
    this.nodes = [];
    this.drawCounter = 0;
    this.loadState = 0;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.size = 0;
    this.cacheItem = null;
};


MapMetatile.prototype.kill = function(killedByCache) {
    if (killedByCache !== true && this.cacheItem != null) {
        this.map.metatileCache.remove(this.cacheItem);
    }

    if (this.metaresources) {
        this.metaresources.removeMetatile(this);
        //this.metaresources.validate();
        //this.metaresources = null;
    }

    this.loadState = 0;
    this.surface = 0;
    this.cacheItem = null;

    this.nodes = [];
};


MapMetatile.prototype.clone = function(surface) {
    var metatile = new MapMetatile(this.metaresources, surface);
    metatile.nodes = this.nodes;
    metatile.loadState = this.loadState;
    metatile.nodes = this.nodes;
    metatile.size = this.size;

    metatile.lod = this.lod;
    metatile.metatileIdx = this.metatileIdx;
    metatile.metatileIdy = this.metatileIdy;
    metatile.offsetx = this.offsetx;
    metatile.offsety = this.offsety;
    metatile.sizex = this.sizex;
    metatile.sizey = this.sizey;
    metatile.version = this.version;
    metatile.credits = this.credits;

    if (this.version < 2) {
        metatile.nodeSize = this.nodeSize;
    } else {
        metatile.flags = this.flags;
        metatile.creditCount = this.creditCount;
        metatile.flagPlanes = this.flagPlanes;
    }

    metatile.cacheItem= this.map.metatileCache.insert(metatile.kill.bind(metatile, true), metatile.size);
    return metatile;
};


MapMetatile.prototype.isReady = function (/*doNotLoad,*/ priority) {
    //if (this.id[0] == 18 &&
    //    this.id[1] == 130400 &&
    //    this.id[2] == 129088) {
    //    debugger;
    //}

    if (this.loadState == 2) { //loaded
        return true;
    } else {

        if (this.loadState == 0) { 
            //if (doNotLoad) {
                //remove from queue
                //if (this.mapLoaderUrl) {
                  //  this.map.loader.remove(this.mapLoaderUrl);
                //}
            //} else {
                //not loaded
                //add to loading queue or top position in queue
            if (this.loadState == 3) { //loadError
                if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount &&
                        performance.now() > this.loadErrorTime + this.map.config.mapLoadErrorRetryTime) {

                    this.scheduleLoad(priority);                    
                }
            } else {
                this.scheduleLoad(priority);
            }
            //}
        } //else load in progress
        
        return false;
    }
};


MapMetatile.prototype.used = function() {
    if (this.cacheItem != null) {
        this.map.metatileCache.updateItem(this.cacheItem);
    }
};


MapMetatile.prototype.getNode = function(id) {
    var x = id[1] - this.id[1] - this.offsetx;
    var y = id[2] - this.id[2] - this.offsety;
    
    if (x < 0 || y < 0 || x >= this.sizex || y >= this.sizey) {
        return null;
    }
    
    var node = this.nodes[this.sizex * y + x];

    if (!node) {
        var index = this.sizex * y + x;
        var stream = {data:this.data, index:this.metanodesIndex + (index * this.metanodeSize)};
        node = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, this.divisionNode)); 
        this.nodes[index] = node;
        this.applyMetanodeCredits(x, y);
        this.applyMetatanodeBitplanes(x, y); 
    }

/*    
    if (!node.ready) {
        node.generateCullingHelpers();
        node.ready = true;
    }
*/
    
    return node;
};


MapMetatile.prototype.scheduleLoad = function() {
    if (this.mapLoaderUrl == null) {
        this.mapLoaderUrl = this.surface.getMetaUrl(this.id);
    }

    this.map.loader.load(this.mapLoaderUrl, this.onLoad.bind(this), null, this.tile, 'metatile');
};


MapMetatile.prototype.onLoad = function(url, onLoaded, onError) {
    this.mapLoaderCallLoaded = onLoaded;
    this.mapLoaderCallError = onError;

    this.map.loader.processLoadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), null, 'metadata');
    //utils.loadBinary(url, this.onLoaded.bind(this), this.onLoadError.bind(this), (utils.useCredentials ? (this.mapLoaderUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
    this.loadState = 1;
};


MapMetatile.prototype.onLoadError = function() {
    if (this.map.killed){
        return;
    }

    this.loadState = 3;
    this.loadErrorTime = performance.now();
    this.loadErrorCounter ++;

    //make sure we try to load it again
    if (this.loadErrorCounter <= this.map.config.mapLoadErrorMaxRetryCount) { 
        setTimeout((function(){ if (!this.map.killed) { this.map.markDirty(); } }).bind(this), this.map.config.mapLoadErrorRetryTime);
    }    

    this.mapLoaderCallError();
};


MapMetatile.prototype.onLoaded = function(data, task) {
    if (this.map.killed){
        return;
    }

    if (!task) {
    //if (this.map.stats.renderBuild > this.map.config.mapMaxProcessingTime) {
        this.map.markDirty();
        this.map.addProcessingTask(this.onLoaded.bind(this, data, true));
        return;
    }

    data = new DataView(data);

    this.size += data.byteLength * 4;
    
    this.data = data;

    var t = performance.now();
    this.parseMetatatile({data:data, index: 0});
    this.map.stats.renderBuild += performance.now() - t; 

    this.cacheItem= this.map.metatileCache.insert(this.kill.bind(this, true), this.size);

    this.map.markDirty();
    this.loadState = 2;
    this.loadErrorTime = null;
    this.loadErrorCounter = 0;
    this.mapLoaderCallLoaded();
};


MapMetatile.prototype.parseMetatatile = function(stream) {

/*
    struct Header {

        char magic[2];                         // letters "MT"
        ushort version;                        // version
        uchar lod;                             // common lod
        uint metatileIdx, metatileIdy;         // id of upper left tile corner (reflected in tile name)
        ushort offsetx, offsety;               // offset of valid data block
        ushort sizex, sizey;                   // dimensions of metanode grid
        uchar nodeSize;                        // size of a metanode in bytes
        uchar creditCount;                     // total number of credit blocks (= number of attributions used by nodes)
        ushort creditSize;                     // size of credit block in bytes
    };
*/

    var streamData = stream.data;
    var magic = '';

    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;
    magic += String.fromCharCode(streamData.getUint8(stream.index, true)); stream.index += 1;

    if (magic != 'MT') {
        return;
    }

    this.version = streamData.getUint16(stream.index, true); stream.index += 2;

    if (this.version > 5) {
        return;
    }

    this.lod = streamData.getUint8(stream.index, true); stream.index += 1;

    this.metatileIdx = streamData.getUint32(stream.index, true); stream.index += 4;
    this.metatileIdy = streamData.getUint32(stream.index, true); stream.index += 4;

    this.offsetx = streamData.getUint16(stream.index, true); stream.index += 2;
    this.offsety = streamData.getUint16(stream.index, true); stream.index += 2;

    this.sizex = streamData.getUint16(stream.index, true); stream.index += 2;
    this.sizey = streamData.getUint16(stream.index, true); stream.index += 2;
    
    this.flagPlanes = new Array(8);

    if (this.version < 2) {
        this.nodeSize = streamData.getUint8(stream.index, true); stream.index += 1;
    } else {
        this.flags = streamData.getUint8(stream.index, true); stream.index += 1;
        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;
        this.parseFlagPlanes(stream);
    }

    this.parseMetatatileCredits(stream);
    this.parseMetatatileNodes(stream);
    
    this.useVersion = (this.map.config.mapForceMetatileV3 && this.version < 5) ? 3 : this.version; 
};


MapMetatile.prototype.parseFlagPlanes = function(stream) {
    var streamData = stream.data;

    //rounded to bytes
    var bitplaneSize = ((this.sizex * this.sizey + 7) >> 3);

    for (var i = 0; i < 6; i++) {
        if ((this.flags & (1 << i)) != 0) {

            var bitplane = new Uint8Array(bitplaneSize);
    
            for (var j = 0; j < bitplaneSize; j++) {
                bitplane[j] = streamData.getUint8(stream.index, true); stream.index += 1;
            }
    
            this.flagPlanes[i] = bitplane; 
        }
    }
};


MapMetatile.prototype.parseMetatatileCredits = function(stream) {

/*
    struct CreditBlock {
       ushort creditId;       // numerical creditId
       char creditMask[];     // bitfield of size header.sizex * header.sizey, row major, row padded
    };
*/

    var streamData = stream.data;
    
    if (this.version < 2) {
        this.creditCount = streamData.getUint8(stream.index, true); stream.index += 1;
        this.creditSize = streamData.getUint16(stream.index, true); stream.index += 2;
    }
    
    if (this.creditCount == 0) {
        this.credits = [];
        return;
    }

    //rounded to bytes
    var bitfieldSize = ((this.sizex * this.sizey + 7) >> 3);

    this.credits = new Array(this.creditCount);

    for (var i = 0, li = this.credits.length; i < li; i++) {
        var creditId = streamData.getUint16(stream.index, true); stream.index += 2;
        var bitfield = new Uint8Array(bitfieldSize);

        for (var j = 0; j < bitfieldSize; j++) {
            bitfield[j] = streamData.getUint8(stream.index, true); stream.index += 1;
        }
    
        var credit = this.map.getCreditByNumber(creditId);
        var stringId = credit ? credit.key : null;

        this.credits[i] = { creditId : stringId, creditMask: bitfield};
    }
};


MapMetatile.prototype.applyMetatatileBitplanes = function() {
    for (var i = 0; i < 1; i++) {
        if (this.flagPlanes[i]) {
            
            var bitplane = this.flagPlanes[i]; 
    
            for (var y = 0; y < this.sizey; y++) {
                for (var x = 0; x < this.sizex; x++) {
                    var byteIndex = this.sizex * y + x;
                    var bitIndex = byteIndex & 7;
                    var bitMask = 1 << bitIndex;
                    byteIndex >>= 3;
                    
                    if (bitplane[byteIndex] & bitMask) {
                        switch(i) {
                        case 0:
                            this.nodes[y*this.sizex+x].alien = true;
                            break;       
                        }
                    }
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetatanodeBitplanes = function(x, y) {
    for (var i = 0; i < 1; i++) {
        if (this.flagPlanes[i]) {
            var bitplane = this.flagPlanes[i]; 
            var byteIndex = this.sizex * y + x;
            var bitIndex = byteIndex & 7;
            var bitMask = 1 << bitIndex;
            byteIndex >>= 3;
            
            if (bitplane[byteIndex] & bitMask) {
                switch(i) {
                case 0:
                    this.nodes[y*this.sizex+x].alien = true;
                    break;       
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetatatileCredits = function() {
    for (var y = 0; y < this.sizey; y++) {
        for (var x = 0; x < this.sizex; x++) {
            var byteIndex = this.sizex * y + x;
            var bitIndex = byteIndex & 7;
            var bitMask = 1 << bitIndex;
            byteIndex >>= 3;

            for (var i = 0, li = this.credits.length; i < li; i++) {
                if (this.credits[i].creditMask[byteIndex] & bitMask) {
                    var id = this.credits[i].creditId;
                    if (id) {
                        this.nodes[y*this.sizex+x].credits.push(id);
                    }
                }
            }
        }
    }
};


MapMetatile.prototype.applyMetanodeCredits = function(x, y) {
    var byteIndex = this.sizex * y + x;
    var bitIndex = byteIndex & 7;
    var bitMask = 1 << bitIndex;
    byteIndex >>= 3;

    for (var i = 0, li = this.credits.length; i < li; i++) {
        if (this.credits[i].creditMask[byteIndex] & bitMask) {
            var id = this.credits[i].creditId;
            if (id) {
                this.nodes[y*this.sizex+x].credits.push(id);
            }
        }
    }
};


MapMetatile.prototype.parseMetatatileNodes = function(stream) {
    this.metanodesIndex = stream.index;
    this.metanodeSize = 1 + 1 + 2 + 2 + 2 + 2;
    
    if (this.version >= 5) {
        this.metanodeSize += 3 * 4;
    } else {
        this.metanodeSize += Math.floor((6 * (this.id[0] + 2) + 7) / 8);

        if (this.version == 4) {
            this.metanodeSize += 3 * 4;
        }
    }

    if (this.version >= 3) {
        if (this.flags & (1<<7)) {
            this.metanodeSize += 2;
        } else if (this.flags & (1<<6)) {
            this.metanodeSize += 1;
        }
    }

    if (this.lod >= this.map.measure.minDivisionNodeDepth) {
        this.divisionNode = this.map.measure.getSpatialDivisionNodeAndExtents([this.lod, this.metatileIdx + this.offsetx, this.metatileIdy + this.offsety]);
        if (this.divisionNode) {
            this.divisionNode = this.divisionNode[0];
        }
    } else {
        this.divisionNode = null;
    }
    
    this.nodes = new Array(this.sizex*this.sizey);
    
    /*
    var index = 0;

    for (var y = 0; y < this.sizey; y++) {
        for (var x = 0; x < this.sizex; x++) {
            this.nodes[index] = (new MapMetanode(this, [this.lod, this.metatileIdx + this.offsetx + x, this.metatileIdy + this.offsety + y], stream, divisionNode));
            index++;
        }
    }
    
    this.applyMetatatileCredits();
    this.applyMetatatileBitplanes();
    */
};


/* harmony default export */ __webpack_exports__["a"] = (MapMetatile);


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__division_node__ = __webpack_require__(131);



//get rid of compiler mess
var MapDivisionNode = __WEBPACK_IMPORTED_MODULE_0__division_node__["a" /* default */];


var MapRefFrame = function(map, json) {
    this.map = map;
    this.proj4 = map.proj4;
    this.valid = false;
    this.id = json['id'] || null;
    this.description = json['description'] || '';
    this.nodesMap = [];

    var model = json['model'];

    if (model == null) {
        return;
    }

    this.model = {
        physicalSrs : map.getMapsSrs(model['physicalSrs']),
        navigationSrs : map.getMapsSrs(model['navigationSrs']),
        publicSrs : map.getMapsSrs(model['publicSrs'])
    };

    this.body = json['body'] ? map.getBody(json['body']) : null;

    this.params = {};

    if (json['parameters'] != null) {
        var params = json['parameters'];
        this.params.metaBinaryOrder = params['metaBinaryOrder'] || 1;
        this.params.navDelta = params['navDelta'] || 8;
    }

    var division = json['division'];

    if (division == null) {
        return;
    }

    this.division = {
        rootLod : division['rootLod'] || 0,
        arity : division['arity'] || null,
        heightRange : division['heightRange'] || [0,1]
    };

    var extents = this.parseSpaceExtents(division['extents']);
    this.division.extents = extents;

    map.spaceExtentSize = [extents.ur[0] - extents.ll[0], extents.ur[1] - extents.ll[1], extents.ur[2] - extents.ll[2]];
    map.spaceExtentOffset = extents.ll;

    var divisionNodes = division['nodes'];
    this.division.nodes = [];

    if (divisionNodes == null) {
        return;
    }

    this.hasPoles = (divisionNodes.length == 4); 

    for (var i = 0, li = divisionNodes.length; i < li; i++) {
        var node = this.parseNode(divisionNodes[i]);
        this.nodesMap['' + node.id[0] + '.'  + node.id[1] + '.' + node.id[2]] = node;
        this.division.nodes.push(node);
    }

    this.valid = true;
};


MapRefFrame.prototype.getInfo = function() {
    return {
        'id' : this.id,
        'physicalSrs' : this.model.physicalSrs.id,
        'navigationSrs' : this.model.navigationSrs.id,
        'publicSrs' : this.model.publicSrs.id
    };
};


MapRefFrame.prototype.getGlobalHeightRange = function() {
    return this.division.heightRange;     
};


MapRefFrame.prototype.parseNode = function(nodeData) {
    var node = {
        srs : nodeData['srs'],
        partitioning : nodeData['partitioning']
    };

    node.extents = this.parseExtents(nodeData['extents']);

    var nodeId = nodeData['id'];

    if (nodeId == null) {
        return;
    }

    node.id = {
        lod : nodeId['lod'] || 0,
        position : nodeId['position'] || [0,0]
    };

    return new MapDivisionNode(this.map, [node.id.lod, node.id.position[0], node.id.position[1]],
                                           node.srs, node.extents, this.heightRange, node.partitioning);
};


MapRefFrame.prototype.parseExtents = function(extentsData) {
    if (extentsData == null) {
        return { ll : [0,0], ur : [1,1] };
    }

    return {
        ll : extentsData['ll'] || [0,0],
        ur : extentsData['ur'] || [1,1]
    };
};


MapRefFrame.prototype.parseSpaceExtents = function(extentsData) {
    if (extentsData == null) {
        return { ll : [0,0,0], ur : [1,1,1] };
    }

    return {
        ll : extentsData['ll'] || [0,0,0],
        ur : extentsData['ur'] || [1,1,1]
    };
};


MapRefFrame.prototype.getSpatialDivisionNodes = function() {
    return this.division.nodes;
};


MapRefFrame.prototype.convertCoords = function(coords, source, destination) {
    var sourceSrs, destinationSrs;

    switch(source) {
    case 'public':     sourceSrs = this.model.publicSrs;     break;
    case 'physical':   sourceSrs = this.model.physicalSrs;   break;
    case 'navigation': sourceSrs = this.model.navigationSrs; break;
    }

    switch(destination) {
    case 'public':     destinationSrs = this.model.publicSrs;     break;
    case 'physical':   destinationSrs = this.model.physicalSrs;   break;
    case 'navigation': destinationSrs = this.model.navigationSrs; break;
    }

    return sourceSrs.convertCoordsTo(coords, destinationSrs);
};


/* harmony default export */ __webpack_exports__["a"] = (MapRefFrame);




/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var MapRenderSlots = function(map) {
    this.map = map;
    this.draw = map.draw;
    this.renderer = map.renderer;
    this.config = map.config;
    this.renderSlots = [];
};


MapRenderSlots.prototype.createRenderSlot = function(id, callback, enabled) {
    return { id:id,
        callback:callback,
        enabled : enabled
    };
};


MapRenderSlots.prototype.addRenderSlot = function(id, callback, enabled) {
    this.renderSlots.push(this.createRenderSlot(id, callback, enabled));
};


MapRenderSlots.prototype.getRenderSlotIndex = function(id) {
    return this.map.searchArrayIndexById(this.renderSlots, id); 
};


MapRenderSlots.prototype.checkRenderSlotId = function(id) {
    if (id == 'after-map-render') {
        return 'map'; 
    } else {
        return id;
    }
};


MapRenderSlots.prototype.moveRenderSlotBefore = function(whichId, whereId) {
    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));
    var to = this.getRenderSlotIndex(whereId);
    if (from != -1 && to != -1 && to != from-1) { 
        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);
    }
};


MapRenderSlots.prototype.moveRenderSlotAfter = function(whichId, whereId) {
    var from = this.getRenderSlotIndex(this.checkRenderSlotId(whichId));
    var to = this.getRenderSlotIndex(whereId);
    if (from != -1 && to != -1 && to != from+1) {
        to++; 
        this.renderSlots.splice(to, 0, this.renderSlots.splice(from, 1)[0]);
    }
};


MapRenderSlots.prototype.removeRenderSlot = function(id) {
    var index = this.getRenderSlotIndex(id);
    if (index != -1) {
        this.renderSlots.splice(index, 1);
    }
};


MapRenderSlots.prototype.setRenderSlotEnabled = function(id, state) {
    var index = this.getRenderSlotIndex(id);
    if (index != -1) {
        this.renderSlots[index].enabled = state;
    }
};


MapRenderSlots.prototype.getRenderSlotEnabled = function(id) {
    var index = this.getRenderSlotIndex(id);
    if (index != -1) {
        return this.renderSlots[index].enabled;
    }
    
    return false;
};


MapRenderSlots.prototype.processRenderSlots = function() {
    if (this.draw.drawChannel != 1) {
        this.renderer.gpu.setViewport(); //just in case
    }

    for (var i = 0, li = this.renderSlots.length; i < li; i++) {
        var slot = this.renderSlots[i];

        if (slot.enabled && slot.callback) {
            this.renderer.gpu.setState(this.draw.drawTileState);
            slot.callback(this.draw.drawChannelNames[this.draw.drawChannel]);
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapRenderSlots);



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__texture__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__subtexture__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__metatile__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mesh__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geodata__ = __webpack_require__(50);







//get rid of compiler mess
var MapTexture = __WEBPACK_IMPORTED_MODULE_0__texture__["a" /* default */];
var MapSubtexture = __WEBPACK_IMPORTED_MODULE_1__subtexture__["a" /* default */];
var MapMetatile = __WEBPACK_IMPORTED_MODULE_2__metatile__["a" /* default */];
var MapMesh = __WEBPACK_IMPORTED_MODULE_3__mesh__["a" /* default */];
var MapGeodata = __WEBPACK_IMPORTED_MODULE_4__geodata__["a" /* default */];


var MapResourceNode = function(map, parent, id) {
    this.map = map;
    this.id = id;
    this.parent = parent;

    this.metatiles = {};
    this.meshes = {};
    this.textures = {};
    this.subtextures = {};
    this.geodata = {};
    this.credits = {};

    this.children = [null, null, null, null];
};


MapResourceNode.prototype.kill = function() {
    //kill children
    for (var i = 0; i < 4; i++) {
        if (this.children[i] != null) {
            this.children[i].kill();
        }
    }

    this.children = [null, null, null, null];

    var parent = this.parent;
    this.parent = null;

    if (parent != null) {
        parent.removeChild(this);
    }
    
    //kill resources?
};


MapResourceNode.prototype.addChild = function(index) {
    if (this.children[index]) {
        return;
    }
    
    var id = this.id;
    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];

    switch (index) {
    case 1: childId[1]++; break;
    case 2: childId[2]++; break;
    case 3: childId[1]++; childId[2]++; break;
    }

    this.children[index] = new MapResourceNode(this.map, this, childId);
};


MapResourceNode.prototype.removeChildByIndex = function(index) {
    if (this.children[index] != null) {
        this.children[index].kill();
        this.children[index] = null;
    }
};


MapResourceNode.prototype.removeChild = function(tile) {
    for (var i = 0; i < 4; i++) {
        if (this.children[i] == tile) {
            this.children[i].kill();
            this.children[i] = null;
        }
    }
};


// Meshes ---------------------------------

MapResourceNode.prototype.getMesh = function(path, tile) {
    var mesh = this.meshes[path];
    
    if (!mesh) {
        mesh = new MapMesh(this.map, path, tile);
        this.meshes[path] = mesh;
    }
    
    return mesh;
};


// Geodata ---------------------------------

MapResourceNode.prototype.getGeodata = function(path, extraInfo) {
    var geodata = this.geodata[path];
    
    if (!geodata) {
        geodata = new MapGeodata(this.map, path, extraInfo);
        this.geodata[path] = geodata;
    }
    
    return geodata;
};


// Textures ---------------------------------

MapResourceNode.prototype.getTexture = function(path, type, extraBound, extraInfo, tile, internal) {
    var texture;
    if (extraInfo && (extraInfo.layer || extraInfo.hmap)) {
        var id = path + (extraInfo.hmap ? '' : extraInfo.layer.id);
        texture = this.textures[id];
        
        if (!texture) {
            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);
            this.textures[id] = texture;
        }
    } else {
        texture = this.textures[path];
        
        if (!texture) {
            texture = new MapTexture(this.map, path, type, extraBound, extraInfo, tile, internal);
            this.textures[path] = texture;
        }
    }
    
    return texture;
};


// SubTextures ---------------------------------

MapResourceNode.prototype.getSubtexture = function(texture, path, type, extraBound, extraInfo, tile, internal) {
    texture = this.subtextures[path];
    
    if (!texture) {
        texture = new MapSubtexture(this.map, path, type, extraBound, extraInfo, tile, internal);
        this.subtextures[path] = texture;
    }
    
    return texture;
};


// Metatiles ---------------------------------

MapResourceNode.prototype.addMetatile = function(path, metatile) {
    this.metatiles[path] = metatile;
};


MapResourceNode.prototype.removeMetatile = function(metatile) {
    for (var key in this.metatiles) {
        if (this.metatiles[key] == metatile) {
            delete this.metatiles[key];
        }
    }
};


MapResourceNode.prototype.getMetatile = function(surface, allowCreation, tile) {
    var metatiles = this.metatiles, metatile; 
    for (var key in metatiles) {
        if (metatiles[key].surface == surface) {
            return metatiles[key];
        } 
    }
    
    var path = surface.getMetaUrl(this.id);

    if (metatiles[path]) {
        metatile = metatiles[path].clone(surface);
        this.addMetatile(path, metatile);
        return metatile;
    }

    if (allowCreation) {
        metatile = new MapMetatile(this, surface, tile);
        this.addMetatile(path, metatile);
        return metatile; 
    } else {
        return null;
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapResourceNode);




/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__resource_node__ = __webpack_require__(148);



//get rid of compiler mess
var MapResourceNode = __WEBPACK_IMPORTED_MODULE_0__resource_node__["a" /* default */];


var MapResourceTree = function(map) {
    this.map = map;
    this.tree = new MapResourceNode(map, null, [0,0,0]); 
};


MapResourceTree.prototype.kill = function() {
    this.tree.kill();
};


MapResourceTree.prototype.findNode = function(id, createNonexisted) {
    var node = this.tree; //TODO: fix is it same way as findNavTile

    //console.log("--------------findNode: " + JSON.stringify(id));

//    for (var lod = 1; lod <= id[0]; lod++) {
    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;

        if ((id[1] & mask) != 0) {
            index += 1;
        }

        if ((id[2] & mask) != 0) {
            index += 2;
        }
        
        if (!node.children[index]) {
            if (createNonexisted) {
                node.addChild(index);
                //console.log("addNode: " + JSON.stringify(node.children[index].id));
            } else {
                return null;
            }
        } 

        node = node.children[index];
    }
    
    return node;
};


MapResourceTree.prototype.findAgregatedNode = function(id, agregation, createNonexisted) {
    //var rootLod = 0;  //TODO: fix is it same way as findNavTile
    var node = this.tree;
    var ix = ((id[1] >> agregation) << agregation);
    var iy = ((id[2] >> agregation) << agregation);


//    for (var lod = id[0]; lod > rootLod; lod--) {
//        var i = lod - rootLod;
//        var index = 0;
//        var mask = 1 << (i-1);

    for (var lod = id[0]; lod > 0; lod--) {
        var mask = 1 << (lod-1);
        var index = 0;

        if ((ix & mask) != 0) {
            index += 1;
        }

        if ((iy & mask) != 0) {
            index += 2;
        }

        if (!node.children[index]) {
            if (createNonexisted) {
                node.addChild(index);
            } else {
                return null;
            }
        } 

        node = node.children[index];
    }

    return node;
};


/* harmony default export */ __webpack_exports__["a"] = (MapResourceTree);




/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapStats = function(map) {
    this.map = map;
    this.core = map.core;
    this.inspector = map.core.inspector;
    this.drawnTiles = 0;
    this.drawnGeodataTiles = 0;
    this.drawnGeodataTilesFactor = 0;
    this.drawnGeodataTilesPerLayer = 0;
    this.drawnFaces = 0;
    this.drawCalls = 0;    
    this.usedNodes = 0;    
    this.processedNodes = 0;    
    this.processedMetatiles = 0;    
    this.counter = 0;
    this.statsCycle = 0;
    this.fps = 0;
    this.frameTime = 0;
    this.renderTime = 0;
    this.renderTimeTmp = 0;
    this.renderTimeBegin = 0;
    this.renderBuild = 0;
    this.lastRenderTime = 0;
    this.lastFrameTime = 0;
    this.renderedLods = new Array(32);
    this.debugIds = {};

    this.recordGraphs = false;
    this.graphsTimeIndex = 0;
    this.graphsLastTimeIndex = 0;
    this.graphsTimeSamples = 900;
    this.graphsRenderTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateMeshTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateGpuMeshTimes = new Array(this.graphsTimeSamples);
    this.graphsCreateTextureTimes = new Array(this.graphsTimeSamples);
    this.graphsFrameTimes = new Array(this.graphsTimeSamples);
    this.graphsCpuMemoryMetatiles = new Array(this.graphsTimeSamples);
    this.graphsCpuMemoryUsed = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryTextures = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryMeshes = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryGeodata = new Array(this.graphsTimeSamples);
    this.graphsGpuMemoryRender = new Array(this.graphsTimeSamples);
    this.graphsPolygons = new Array(this.graphsTimeSamples);
    this.graphsLODs = new Array(this.graphsTimeSamples);
    this.graphsBuild = new Array(this.graphsTimeSamples);
    this.graphsFluxTextures = new Array(this.graphsTimeSamples);
    this.graphsFluxMeshes = new Array(this.graphsTimeSamples);
    this.graphsFluxGeodatas = new Array(this.graphsTimeSamples);
    this.graphsFluxTexture = [[0,0],[0,0]];
    this.graphsFluxMesh = [[0,0],[0,0]];
    this.graphsFluxGeodata = [[0,0],[0,0]];
    this.graphsCreateTextureTime = 0;
    this.graphsCreateGpuMeshTime = 0;
    this.graphsCreateMeshTime = 0;
    this.resetGraphs();

    this.gpuMeshes = 0;
    this.gpuTextures = 0;
    this.gpuGeodata = 0;
    this.gpuUsed = 0;
    this.resourcesUsed = 0;
    this.metaUsed = 0;
    this.gpuRenderUsed = 0;
    this.loadedCount = 0;
    this.loadErrorCount = 0;
    this.loadFirst = 0;
    this.loadLast = 0;
    this.gpuNeeded = 0;
    this.gpuNeeded2 = 0;

    this.heightClass = 0;
    this.heightLod = 0;
    this.heightNode = 0;
    this.heightTerrain = 0;
    this.heightDelta = 0;
    this.debugStr = null;
};

//Object.defineProperty(MapStats.prototype, 'gpuNeeded', {
    //get: function() { return this.gpuNeeded2; /*console.log(""+this.gpuNeeded);*/ },
    //set: function(value) { 
        //this.gpuNeeded2 = value; console.log(""+this.gpuNeeded);
    //}
//});


MapStats.prototype.resetGraphs = function() {
    this.graphsTimeIndex = 0;

    for (var i = 0; i < this.graphsTimeSamples; i++) {
        this.graphsRenderTimes[i] = 0;
        this.graphsCreateMeshTimes[i] = 0;
        this.graphsCreateGpuMeshTimes[i] = 0;
        this.graphsCreateTextureTimes[i] = 0;
        this.graphsFrameTimes[i] = 0;
        this.graphsCpuMemoryUsed[i] = 0;
        this.graphsCpuMemoryMetatiles[i] = 0;
        this.graphsGpuMemoryTextures[i] = 0;
        this.graphsGpuMemoryMeshes[i] = 0;
        this.graphsGpuMemoryGeodata[i] = 0;
        this.graphsGpuMemoryRender[i] = 0;
        this.graphsPolygons[i] = 0;
        this.graphsLODs[i] = [0,[]];
        this.graphsBuild[i] = 0;
        this.graphsFluxTextures[i] = [[0,0],[0,0]];
        this.graphsFluxMeshes[i] = [[0,0],[0,0]];
        this.graphsFluxGeodatas[i] = [[0,0],[0,0]];
    }
};


MapStats.prototype.begin = function(dirty) {
    if (dirty) {
        this.drawnTiles = 0;
        this.drawnGeodataTiles = 0;
        this.drawnGeodataTilesFactor = 0;
        this.drawnGeodataTilesPerLayer = 0;
        this.drawCalls = 0;        
        this.drawnFaces = 0;
        this.gpuRenderUsed = 0;
        this.gpuNeeded = 0;
        this.usedNodes = 0;    
        this.processedNodes = 0;    
        this.processedMetatiles = 0;    

        for (var i = 0, li = this.renderedLods.length; i < li; i++) {
            this.renderedLods[i] = 0;
        } 
    }

    this.debugIds = {};

    this.counter++;
    this.statsCycle++;

    this.renderTimeBegin = performance.now();

    if (dirty) {
        if (this.lastFrameTime) {
            this.frameTime = this.renderTimeBegin - this.lastFrameTime;
        }

        this.lastFrameTime = this.renderTimeBegin;
    }
};


MapStats.prototype.end = function(dirty) {
    var timer = performance.now();

    var renderTime = timer - this.renderTimeBegin;
    //var frameTime = timer - this.frameTime;
    //this.frameTime = timer;
    if (dirty) { 
        this.renderTimeTmp += renderTime;
        this.lastRenderTime = renderTime;
    } else {
        this.renderTimeTmp += this.lastRenderTime;
    }

    if (this.recordGraphs) {
        var i = this.graphsTimeIndex;

        this.graphsRenderTimes[i] = renderTime;
        this.graphsCreateMeshTimes[i] = 0;
        this.graphsCreateGpuMeshTimes[i] = 0;
        this.graphsCreateTextureTimes[i] = 0;
        this.graphsFrameTimes[i] = this.frameTime;
        this.graphsCpuMemoryUsed[i] = this.map.resourcesCache.totalCost;
        this.graphsCpuMemoryMetatiles[i] = this.map.metatileCache.totalCost;
        this.graphsGpuMemoryTextures[i] = this.gpuTextures;
        this.graphsGpuMemoryMeshes[i] = this.gpuMeshes;
        this.graphsGpuMemoryGeodata[i] = this.gpuGeodata;
        this.graphsGpuMemoryRender[i] = this.gpuRenderUsed;
        this.graphsPolygons[i] = this.drawnFaces;
        this.graphsFluxTextures[i] = [[this.graphsFluxTexture[0][0], this.graphsFluxTexture[0][1]], [this.graphsFluxTexture[1][0], this.graphsFluxTexture[1][1]] ];
        this.graphsFluxMeshes[i] = [[this.graphsFluxMesh[0][0], this.graphsFluxMesh[0][1]], [this.graphsFluxMesh[1][0], this.graphsFluxMesh[1][1]] ];
        this.graphsFluxGeodatas[i] = [[this.graphsFluxGeodata[0][0], this.graphsFluxGeodata[0][1]], [this.graphsFluxGeodata[1][0], this.graphsFluxGeodata[1][1]] ];
        this.graphsLODs[i] = [this.drawnTiles, this.renderedLods.slice()];
        this.graphsBuild[i] = this.renderBuild;

        this.graphsTimeIndex = (this.graphsTimeIndex + 1) % this.graphsTimeSamples;
        
        if (this.inspector && this.inspector.graphs) {
            this.inspector.graphs.updateGraphs(this);
        }
    }


    if ((this.statsCycle % 50) == 0) {
        this.renderTime = this.renderTimeTmp / 100;
        this.fps = 1000 / this.renderTime;
        this.renderTimeTmp = 0;

        if (this.inspector && this.inspector.stats) {
            this.gpuUsed = this.map.gpuCache.totalCost;
            this.resourcesUsed = this.map.resourcesCache.totalCost;
            this.metaUsed = this.map.metatileCache.totalCost;

            this.inspector.stats.updateStatsPanel(this);
        }
    }
    
    //do not reset flux data in begin function, because we to collect data from events which     
    this.graphsFluxTexture = [[0,0],[0,0]];
    this.graphsFluxMesh = [[0,0],[0,0]];
    this.graphsFluxGeodata = [[0,0],[0,0]];
    this.debugStr = this.map.renderer.debugStr;
};


/* harmony default export */ __webpack_exports__["a"] = (MapStats);



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__renderer_gpu_mesh__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__ = __webpack_require__(5);
// An index-less mesh. Each triangle has three items in the array 'vertices'.






//get rid of compiler mess
var mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var GpuMesh = __WEBPACK_IMPORTED_MODULE_2__renderer_gpu_mesh__["a" /* default */];
var BBox = __WEBPACK_IMPORTED_MODULE_3__renderer_bbox__["a" /* default */];


var MapSubmesh = function(mesh, stream) {
    this.generateLines = true;
    this.map = mesh.map;
    this.vertices = null;
    this.internalUVs = null;
    this.externalUVs = null;
    this.indices = null;
    this.mesh = mesh;
    this.statsCounter = 0;
    this.valid = true;
    this.killed = false;
    this.use16bit = mesh.use16bit;

    this.bbox = new BBox();
    this.size = 0;
    this.faces = 0;

    this.flagsInternalTexcoords =  1;
    this.flagsExternalTexcoords =  2;
    this.flagsPerVertexUndulation =  4;
    this.flagsTextureMode =  8;

    if (stream) {
        this.parseSubmesh(stream);
    }
};


MapSubmesh.prototype.kill = function () {
    this.killed = true;
    this.vertices = null;
    this.internalUVs = null;
    this.externalUVs = null;
    this.indices = null;
};


// Reads the mesh from the binary representation.
MapSubmesh.prototype.parseSubmesh = function (stream) {

/*
struct MapSubmesh {
    struct MapSubmeshHeader header;
    struct VerticesBlock vertices;
    struct TexcoordsBlock internalTexcoords;   // if header.flags & ( 1 << 0 )
    struct FacesBlock faces;
};
*/
    this.parseHeader(stream);
    if (this.mesh.version >= 3) {
        this.parseVerticesAndFaces2(stream);
    } else {
        this.parseVerticesAndFaces(stream);
    }
};


MapSubmesh.prototype.parseHeader = function (stream) {

/*
struct MapSubmeshHeader {
    char flags;                    // bit 0 - contains internal texture coords
                                   // bit 1 - contains external texture coords
                                   // bit 2 - contains per vertex undulation
                                   // bit 3 - texture mode (0 - internal, 1 - external)
    
    uchar surfaceReference;        // reference to the surface of origin, see bellow
    ushort textureLayer;           // applicable if texture mode is external: texture layer numeric id
    double boundingBox[2][3];      // read more about bounding box bellow
};
*/

    var streamData = stream.data;

    this.flags = streamData.getUint8(stream.index, true); stream.index += 1;

    if (this.mesh.version > 1) {
        this.surfaceReference = streamData.getUint8(stream.index, true); stream.index += 1;
    } else {
        this.surfaceReference = 0;
    }

    this.textureLayer = streamData.getUint16(stream.index, true); stream.index += 2;
    this.textureLayer2 = this.textureLayer; //hack for presentation

    var bboxMin = this.bbox.min;
    var bboxMax = this.bbox.max;

    bboxMin[0] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMin[1] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMin[2] = streamData.getFloat64(stream.index, true); stream.index += 8;

    bboxMax[0] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMax[1] = streamData.getFloat64(stream.index, true); stream.index += 8;
    bboxMax[2] = streamData.getFloat64(stream.index, true); stream.index += 8;
    
    this.bbox.updateMaxSize();
};


MapSubmesh.prototype.parseVerticesAndFaces = function (stream) {
/*
struct VerticesBlock {
    ushort numVertices;              // number of vertices

    struct Vertex {                  // array of vertices, size of array is defined by numVertices property
        // vertex coordinates
        ushort x;
        ushort y;
        ushort z;

        // if header.flags & ( 1 << 1 ): external texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort eu;
        ushort ev;

        // if header.flags & ( 1 << 2 ): undulation delta
        float16 undulationDelta;
    } vertices[];
};
*/

    var data = stream.data;
    var index = stream.index;
    var uint8Data = stream.uint8Data;

    var numVertices = data.getUint16(index, true); index += 2;

    if (!numVertices) {
        this.valid = false;
    }

    var internalUVs = null;
    var externalUVs = null;
    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);

    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));

    if (this.flags & this.flagsExternalTexcoords) {
        if (onlyOneUVs) {
            externalUVs = true;
        } else {
            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));
        }
    }

    var uvfactor = this.use16bit ? 1.0 : (1.0 / 65535);
    var vindex = 0;
    var uvindex = 0;
    var i, li;

    for (i = 0; i < numVertices; i++) {
        vertices[vindex] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;
        vertices[vindex+1] = (uint8Data[index+2] + (uint8Data[index + 3]<<8)) * uvfactor;
        vertices[vindex+2] = (uint8Data[index+4] + (uint8Data[index + 5]<<8)) * uvfactor;
        vindex += 3;

        if (externalUVs) {
            if (!onlyOneUVs) {
                externalUVs[uvindex] = (uint8Data[index+6] + (uint8Data[index + 7]<<8)) * uvfactor;
                externalUVs[uvindex+1] = (65535 - (uint8Data[index+8] + (uint8Data[index + 9]<<8))) * uvfactor;
                uvindex += 2;
            }
            index += 10;
        } else {
            index += 6;
        }
    }


    this.tmpVertices = vertices;
    this.tmpExternalUVs = externalUVs;
   
/*
struct TexcoorsBlock {
    ushort numTexcoords;              // number of texture coordinates

    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property

        // internal texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort u;
        ushort v;
    } texcoords[];
};
*/

    if (this.flags & this.flagsInternalTexcoords) {
        var numUVs = data.getUint16(index, true); index += 2;
    
        internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));
        //var uvfactor = 1.0 / 65535;
    
        for (i = 0, li = numUVs * 2; i < li; i+=2) {
            internalUVs[i] = (uint8Data[index] + (uint8Data[index + 1]<<8)) * uvfactor;
            internalUVs[i+1] = (65535 - (uint8Data[index+2] + (uint8Data[index + 3]<<8))) * uvfactor;
            index += 4;
        }
    
        this.tmpInternalUVs = internalUVs;
    }

/*
struct FacesBlock {
    ushort numFaces;              // number of faces

    struct Face {                 // array of faces, size of array is defined by numFaces property

        ushort v[3]; // array of indices to stored vertices
        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords

    } faces[];
};
*/

    var numFaces = data.getUint16(index, true); index += 2;
    var indices = null;

    internalUVs = null;
    externalUVs = null;

    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));
    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));
    var onlyIndices = onlyExternalIndices || onlyInternalIndices;

    if (onlyIndices) {
        indices = new Uint16Array(numFaces * 3);
    } else {
        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));

        if (this.flags & this.flagsInternalTexcoords) {
            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }

        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {
            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }
    }

    var vtmp = this.tmpVertices;
    var eUVs = this.tmpExternalUVs;
    var iUVs = this.tmpInternalUVs;
    var v1, v2, v3, vv1, vv2, vv3, sindex;

    if (onlyExternalIndices) {
        vertices = this.tmpVertices;
        externalUVs = this.tmpExternalUVs;
    }

    if (onlyInternalIndices) {
        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));
        internalUVs = this.tmpInternalUVs;
    }

    for (i = 0; i < numFaces; i++) {
        v1 = (uint8Data[index] + (uint8Data[index + 1]<<8));
        v2 = (uint8Data[index+2] + (uint8Data[index + 3]<<8));
        v3 = (uint8Data[index+4] + (uint8Data[index + 5]<<8));

        if (onlyIndices) {
            vindex = i * 3;

            if (internalUVs != null) {
                vv1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));
                vv2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));
                vv3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));

                vertices[vv1*3] = vtmp[v1*3];
                vertices[vv1*3+1] = vtmp[v1*3+1];
                vertices[vv1*3+2] = vtmp[v1*3+2];

                vertices[vv2*3] = vtmp[v2*3];
                vertices[vv2*3+1] = vtmp[v2*3+1];
                vertices[vv2*3+2] = vtmp[v2*3+2];

                vertices[vv3*3] = vtmp[v3*3];
                vertices[vv3*3+1] = vtmp[v3*3+1];
                vertices[vv3*3+2] = vtmp[v3*3+2];

                indices[vindex] = vv1;
                indices[vindex+1] = vv2;
                indices[vindex+2] = vv3;

                index += 12;
            } else {
                indices[vindex] = v1;
                indices[vindex+1] = v2;
                indices[vindex+2] = v3;

                index += 6;
            }

        } else {
            vindex = i * (3 * 3);

            sindex = v1 * 3;
            vertices[vindex] = vtmp[sindex];
            vertices[vindex+1] = vtmp[sindex+1];
            vertices[vindex+2] = vtmp[sindex+2];

            sindex = v2 * 3;
            vertices[vindex+3] = vtmp[sindex];
            vertices[vindex+4] = vtmp[sindex+1];
            vertices[vindex+5] = vtmp[sindex+2];

            sindex = v3 * 3;
            vertices[vindex+6] = vtmp[sindex];
            vertices[vindex+7] = vtmp[sindex+1];
            vertices[vindex+8] = vtmp[sindex+2];

            if (externalUVs != null) {
                vindex = i * (3 * 2);
                externalUVs[vindex] = eUVs[v1*2];
                externalUVs[vindex+1] = eUVs[v1*2+1];
                externalUVs[vindex+2] = eUVs[v2*2];
                externalUVs[vindex+3] = eUVs[v2*2+1];
                externalUVs[vindex+4] = eUVs[v3*2];
                externalUVs[vindex+5] = eUVs[v3*2+1];
            }

            if (internalUVs != null) {
                v1 = (uint8Data[index+6] + (uint8Data[index + 7]<<8));
                v2 = (uint8Data[index+8] + (uint8Data[index + 9]<<8));
                v3 = (uint8Data[index+10] + (uint8Data[index + 11]<<8));
                index += 12;

                vindex = i * (3 * 2);
                internalUVs[vindex] = iUVs[v1*2];
                internalUVs[vindex+1] = iUVs[v1*2+1];
                internalUVs[vindex+2] = iUVs[v2*2];
                internalUVs[vindex+3] = iUVs[v2*2+1];
                internalUVs[vindex+4] = iUVs[v3*2];
                internalUVs[vindex+5] = iUVs[v3*2+1];
            } else {
                index += 6;
            }
        }
    }

    this.vertices = vertices;
    this.internalUVs = internalUVs;
    this.externalUVs = externalUVs;
    this.indices = indices;

    this.tmpVertices = null;
    this.tmpInternalUVs = null;
    this.tmpExternalUVs = null;

    stream.index = index;

    this.size = this.vertices.byteLength;
    if (this.internalUVs) this.size += this.internalUVs.byteLength;
    if (this.externalUVs) this.size += this.externalUVs.byteLength;
    if (this.indices) this.size += this.indices.byteLength;
    this.faces = numFaces;
};


MapSubmesh.prototype.parseWord = function (data, res) {
    var value = data[res[1]];
    
    if (value & 0x80) {
        res[0] = (value & 0x7f) | (data[res[1]+1] << 7);
        res[1] += 2;
    } else {
        res[0] = value;
        res[1] ++;
    }
};


MapSubmesh.prototype.parseDelta = function (data, res) {
    var value = data[res[1]];
    
    if (value & 0x80) {
        value = (value & 0x7f) | (data[res[1]+1] << 7);

        if (value & 1) {
            res[0] = -((value >> 1)+1); 
            res[1] += 2;
        } else {
            res[0] = (value >> 1); 
            res[1] += 2;
        }
    } else {
        if (value & 1) {
            res[0] = -((value >> 1)+1); 
            res[1] ++;
        } else {
            res[0] = (value >> 1); 
            res[1] ++;
        }
    }
};


MapSubmesh.prototype.parseVerticesAndFaces2 = function (stream) {
/*
struct VerticesBlock {
    ushort numVertices;              // number of vertices
    ushort geomQuantCoef;            // geometry quantization coefficient

    struct Vertex {                  // array of vertices, size of array is defined by numVertices property
        // vertex coordinates
        delta x;
        delta y;
        delta z;
    } vertices[];
};
*/

    var data = stream.data;
    var index = stream.index;
    var uint8Data = stream.uint8Data;
    var onlyOneUVs = this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords);

    var numVertices = data.getUint16(index, true); index += 2;
    var quant = data.getUint16(index, true); index += 2;

    if (!numVertices) {
        this.valid = false;
    }

    var center = this.bbox.center();
    var scale = this.bbox.maxSize;

    var multiplier = 1.0 / quant;
    var externalUVs = null;

    var vertices = this.use16bit ? (new Uint16Array(numVertices * 3)) : (new Float32Array(numVertices * 3));
    var vindex;
    
    var x = 0, y = 0,z = 0;
    var cx = center[0], cy = center[1], cz = center[2];
    var mx = this.bbox.min[0];
    var my = this.bbox.min[1];
    var mz = this.bbox.min[2];
    var sx = 1.0 / (this.bbox.max[0] - this.bbox.min[0]);
    var sy = 1.0 / (this.bbox.max[1] - this.bbox.min[1]);
    var sz = 1.0 / (this.bbox.max[2] - this.bbox.min[2]);
    
    var res = [0, index];
    var i, li, t;

    if (this.use16bit) {
        for (i = 0; i < numVertices; i++) {
            this.parseDelta(uint8Data, res);
            x += res[0];
            this.parseDelta(uint8Data, res);
            y += res[0];
            this.parseDelta(uint8Data, res);
            z += res[0];
            
            vindex = i * 3;
            t = ((x * multiplier * scale + cx) - mx) * sx;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex] = t * 65535;
            t = ((y * multiplier * scale + cy) - my) * sy;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex+1] = t * 65535;
            t = ((z * multiplier * scale + cz) - mz) * sz;
            if (t < 0) t = 0; if (t > 1.0) t = 1.0;
            vertices[vindex+2] = t * 65535;
        }
    } else {
        for (i = 0; i < numVertices; i++) {
            this.parseDelta(uint8Data, res);
            x += res[0];
            this.parseDelta(uint8Data, res);
            y += res[0];
            this.parseDelta(uint8Data, res);
            z += res[0];
            
            vindex = i * 3;
            vertices[vindex] = ((x * multiplier * scale + cx) - mx) * sx;
            vertices[vindex+1] = ((y * multiplier * scale + cy) - my) * sy;
            vertices[vindex+2] = ((z * multiplier * scale + cz) - mz) * sz;
        }
    }
    
    index = res[1];

    if (this.flags & this.flagsExternalTexcoords) {
        quant = data.getUint16(index, true); index += 2;
        res[1] = index;

        if (onlyOneUVs) {

            for (i = 0; i < numVertices; i++) {
                this.parseDelta(uint8Data, res);
                this.parseDelta(uint8Data, res);
            }

        } else {
            multiplier = (this.use16bit) ? (65535 / quant) : (1.0 / quant);
            externalUVs = this.use16bit ? (new Uint16Array(numVertices * 2)) : (new Float32Array(numVertices * 2));
            x = 0, y = 0;

            if (this.use16bit) {
                for (i = 0; i < numVertices; i++) {
                    this.parseDelta(uint8Data, res);
                    x += res[0];
                    this.parseDelta(uint8Data, res);
                    y += res[0];

                    var uvindex = i * 2;
                    t = x * multiplier;
                    if (t < 0) t = 0; if (t > 65535) t = 65535;
                    externalUVs[uvindex] = t;
                    t = y * multiplier;
                    if (t < 0) t = 0; if (t > 65535) t = 65535;
                    externalUVs[uvindex+1] = 65535 - t;
                }
            } else {
                for (i = 0; i < numVertices; i++) {
                    this.parseDelta(uint8Data, res);
                    x += res[0];
                    this.parseDelta(uint8Data, res);
                    y += res[0];

                    var uvindex = i * 2;
                    externalUVs[uvindex] = x * multiplier;
                    externalUVs[uvindex+1] = 1 - (y * multiplier);
                }
            }
        }
    }

    index = res[1];

    this.tmpVertices = vertices;
    this.tmpExternalUVs = externalUVs;
    
/*
struct TexcoorsBlock {
    ushort numTexcoords;              // number of texture coordinates

    struct TextureCoords {            // array of texture coordinates, size of array is defined by numTexcoords property

        // internal texture coordinates
        // values in 2^16^ range represents the 0..1 normalized texture space
        ushort u;
        ushort v;
    } texcoords[];
};
*/

    if (this.flags & this.flagsInternalTexcoords) {
        var numUVs = data.getUint16(index, true); index += 2;
        var quantU = data.getUint16(index, true); index += 2;
        var quantV = data.getUint16(index, true); index += 2;
        var multiplierU = (this.use16bit) ? (65536.0 / quantU) : (1.0 / quantU);
        var multiplierV = (this.use16bit) ? (65536.0 / quantV) : (1.0 / quantV);
        x = 0, y = 0;
    
        var internalUVs = this.use16bit ? (new Uint16Array(numUVs * 2)) : (new Float32Array(numUVs * 2));
        res[1] = index;7

        if (this.use16bit) {
            for (i = 0, li = numUVs * 2; i < li; i+=2) {
                this.parseDelta(uint8Data, res);
                x += res[0];
                this.parseDelta(uint8Data, res);
                y += res[0];

                t = x * multiplierU;
                if (t < 0) t = 0; if (t > 65535) t = 65535;
                internalUVs[i] = t;
                t = y * multiplierV;
                if (t < 0) t = 0; if (t > 65535) t = 65535;
                internalUVs[i+1] = 65535 - t;
            }
        } else {
            for (i = 0, li = numUVs * 2; i < li; i+=2) {
                this.parseDelta(uint8Data, res);
                x += res[0];
                this.parseDelta(uint8Data, res);
                y += res[0];

                internalUVs[i] = x * multiplierU;
                internalUVs[i+1] = 1 - (y * multiplierV);
            }
        }

        index = res[1];
    
        this.tmpInternalUVs = internalUVs;
    }

/*
struct FacesBlock {
    ushort numFaces;              // number of faces

    struct Face {                 // array of faces, size of array is defined by numFaces property

        ushort v[3]; // array of indices to stored vertices
        ushort t[3]; // if header.flags & ( 1 << 0 ): array of indices to stored internal texture coords

    } faces[];
};
*/

    var numFaces = data.getUint16(index, true); index += 2;
    var indices = null;

    internalUVs = null;
    externalUVs = null;

    var onlyExternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && !(this.flags & this.flagsInternalTexcoords));
    var onlyInternalIndices = (this.map.config.mapIndexBuffers && this.map.config.mapOnlyOneUVs && (this.flags & this.flagsInternalTexcoords));
    var onlyIndices = onlyExternalIndices || onlyInternalIndices;

    if (onlyIndices) {
        indices = new Uint16Array(numFaces * 3);
    } else {
        vertices = this.use16bit ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));

        if (this.flags & this.flagsInternalTexcoords) {
            internalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }

        if (!onlyOneUVs && (this.flags & this.flagsExternalTexcoords)) {
            externalUVs = this.use16bit ? (new Uint16Array(numFaces * 3 * 2)) : (new Float32Array(numFaces * 3 * 2));
        }
    }

    var vtmp = this.tmpVertices;
    var eUVs = this.tmpExternalUVs;
    var iUVs = this.tmpInternalUVs;
    var high = 0;
    var v1, v2, v3, vv1, vv2, vv3;
    res[1] = index;

    for (i = 0; i < numFaces; i++) {
        this.parseWord(uint8Data, res);
        v1 = high - res[0];
        if (!res[0]) { high++; }

        this.parseWord(uint8Data, res);
        v2 = high - res[0];
        if (!res[0]) { high++; }

        this.parseWord(uint8Data, res);
        v3 = high - res[0];
        if (!res[0]) { high++; }

        if (onlyIndices) {
            vindex = i * 3;
            indices[vindex] = v1;
            indices[vindex+1] = v2;
            indices[vindex+2] = v3;
        } else {
            vindex = i * (3 * 3);
            var sindex = v1 * 3;
            vertices[vindex] = vtmp[sindex];
            vertices[vindex+1] = vtmp[sindex+1];
            vertices[vindex+2] = vtmp[sindex+2];

            sindex = v2 * 3;
            vertices[vindex+3] = vtmp[sindex];
            vertices[vindex+4] = vtmp[sindex+1];
            vertices[vindex+5] = vtmp[sindex+2];

            sindex = v3 * 3;
            vertices[vindex+6] = vtmp[sindex];
            vertices[vindex+7] = vtmp[sindex+1];
            vertices[vindex+8] = vtmp[sindex+2];

            if (externalUVs != null) {
                vindex = i * (3 * 2);
                externalUVs[vindex] = eUVs[v1*2];
                externalUVs[vindex+1] = eUVs[v1*2+1];
                externalUVs[vindex+2] = eUVs[v2*2];
                externalUVs[vindex+3] = eUVs[v2*2+1];
                externalUVs[vindex+4] = eUVs[v3*2];
                externalUVs[vindex+5] = eUVs[v3*2+1];
            }
        }
    }

    if (onlyExternalIndices) {
        vertices = this.tmpVertices;
        externalUVs = this.tmpExternalUVs;
    }

    if (onlyInternalIndices) {
        vertices = this.use16bit ? (new Uint16Array((iUVs.length / 2) * 3)) : (new Float32Array((iUVs.length / 2) * 3));
        internalUVs = this.tmpInternalUVs;
    }

    high = 0;

    if (internalUVs != null) {
        for (i = 0; i < numFaces; i++) {
            this.parseWord(uint8Data, res);
            v1 = high - res[0];
            if (!res[0]) { high++; }
    
            this.parseWord(uint8Data, res);
            v2 = high - res[0];
            if (!res[0]) { high++; }
    
            this.parseWord(uint8Data, res);
            v3 = high - res[0];
            if (!res[0]) { high++; }

            if (onlyInternalIndices) {
                vindex = i * 3;

                vv1 = indices[vindex] * 3;
                vv2 = indices[vindex+1] * 3;
                vv3 = indices[vindex+2] * 3;

                vertices[v1*3] = vtmp[vv1];
                vertices[v1*3+1] = vtmp[vv1+1];
                vertices[v1*3+2] = vtmp[vv1+2];

                vertices[v2*3] = vtmp[vv2];
                vertices[v2*3+1] = vtmp[vv2+1];
                vertices[v2*3+2] = vtmp[vv2+2];

                vertices[v3*3] = vtmp[vv3];
                vertices[v3*3+1] = vtmp[vv3+1];
                vertices[v3*3+2] = vtmp[vv3+2];

                indices[vindex] = v1;
                indices[vindex+1] = v2;
                indices[vindex+2] = v3;
            } else {
                vindex = i * (3 * 2);
                internalUVs[vindex] = iUVs[v1*2];
                internalUVs[vindex+1] = iUVs[v1*2+1];
                internalUVs[vindex+2] = iUVs[v2*2];
                internalUVs[vindex+3] = iUVs[v2*2+1];
                internalUVs[vindex+4] = iUVs[v3*2];
                internalUVs[vindex+5] = iUVs[v3*2+1];
            }
        }
    }

    index = res[1];

    this.vertices = vertices;
    this.internalUVs = internalUVs;
    this.externalUVs = externalUVs;
    this.indices = indices;

    this.tmpVertices = null;
    this.tmpInternalUVs = null;
    this.tmpExternalUVs = null;

    stream.index = index;

    this.size = this.vertices.byteLength;
    if (this.internalUVs) this.size += this.internalUVs.byteLength;
    if (this.externalUVs) this.size += this.externalUVs.byteLength;
    if (this.indices) this.size += this.indices.byteLength;
    this.faces = numFaces;
};


// Returns RAM usage in bytes.
MapSubmesh.prototype.getSize = function () {
    return this.size;
};


MapSubmesh.prototype.getFileSize = function () {
    return this.fileSize;
};


MapSubmesh.prototype.buildGpuMesh = function () {
    return new GpuMesh(this.map.renderer.gpu, {
        bbox: this.bbox,
        vertices: this.vertices,
        uvs: this.internalUVs,
        uvs2: this.externalUVs,
        indices: this.indices
    }, 1, this.map.core, true, this.use16bit);
};


MapSubmesh.prototype.getWorldMatrix = function(geoPos, matrix) {
    // Note: the current camera geographic position (geoPos) is not necessary
    // here, in theory, but for numerical stability (OpenGL ES is float only)
    // we get rid of the large UTM numbers in the following subtractions. The
    // camera effectively stays in the position [0,0] and the tiles travel
    // around it. (The Z coordinate is fine and is not handled in this way.)

    var m = matrix;

    if (m) {
        m[0] = this.bbox.side(0); m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = this.bbox.side(1); m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = this.bbox.side(2); m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = mat4.create();

        mat4.multiply( math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]),
                       math.scaleMatrix(this.bbox.side(0), this.bbox.side(1), this.bbox.side(2)), m);
    }

    return m;
};


MapSubmesh.prototype.getWorldMatrixSE = function(geoPos, matrix) {
    var m = matrix;

    if (m) {
        m[0] = 1; m[1] = 0; m[2] = 0; m[3] = 0;
        m[4] = 0; m[5] = 1; m[6] = 0; m[7] = 0;
        m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
        m[12] = this.bbox.min[0] - geoPos[0]; m[13] = this.bbox.min[1] - geoPos[1]; m[14] = this.bbox.min[2] - geoPos[2]; m[15] = 1;
    } else {
        m = math.translationMatrix(this.bbox.min[0] - geoPos[0], this.bbox.min[1] - geoPos[1], this.bbox.min[2] - geoPos[2]);
    }

    return m;
};


MapSubmesh.prototype.drawBBox = function(cameraPos) {
    var renderer = this.map.renderer;

    renderer.gpu.useProgram(renderer.progBBox, ['aPosition']);

    var mvp = mat4.create();
    var mv = mat4.create();

    mat4.multiply(renderer.camera.getModelviewMatrix(), this.getWorldMatrix(cameraPos), mv);

    var proj = renderer.camera.getProjectionMatrix();
    mat4.multiply(proj, mv, mvp);

    renderer.progBBox.setMat4('uMVP', mvp);

    //draw bbox
    renderer.bboxMesh.draw(renderer.progBBox, 'aPosition');
};


/* harmony default export */ __webpack_exports__["a"] = (MapSubmesh);


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var MapSurfaceSequence = function(map) {
    this.map = map;
};


MapSurfaceSequence.prototype.generateSurfaceSequence = function() {
    var view = this.map.currentView;
    var tree = this.map.tree;
    
    if (!tree) {
        return;
    }
    
    tree.surfaceSequence = [];
    tree.surfaceSequenceIndices = []; //probably not used
    tree.surfaceOnlySequence = [];

    var vsurfaces = {}, surface, glue; 
    var vsurfaceCount = 0;
    var list = [], listId, i, li, j , lj, key;
    var strId = [];
        
    //add surfaces to the list
    for (key in view.surfaces) {
        surface = this.map.getSurface(key);
        
        if (surface) {
            strId.push(surface.id);
            vsurfaceCount++;
            vsurfaces[key] = surface.index + 1; //add one to avoid zero 
            //list.push(["" + (surface.index + 1), surface, true]);    
            list.push([ [(surface.index + 1)], surface, true, false]); //[surfaceId, surface, isSurface, isAlien]    
        }
    }


    if (vsurfaceCount >= 1) { //do we have virtual surface?
        strId.sort(); 
        strId = strId.join(';');

        surface = this.map.virtualSurfaces[strId];
        if (surface) {
            list = [ [ [(surface.index + 1)], surface, true, false] ]; //[surfaceId, surface, isSurface, isAlien]    
            vsurfaceCount = 1;
        }
    }
    
    if (vsurfaceCount > 1) {
        
        var glues = [];
    
        //add proper glues to the list
        for (key in this.map.glues) {
            glue = this.map.glues[key];

            //add only glue which contains desired surfaces

            if (!glue || !glue.id) continue;

            var id = glue.id; 
            if (id.length <= vsurfaceCount) {
    
                var missed = false;
                for (j = 0, lj = id.length; j < lj; j++) {
                    if (!vsurfaces[id[j]]) {
                        missed = true;
                        break;
                    }
                }
    
                if (!missed) {
                    //var listId = "";
                    listId = [];
                    
                    //create glue id in reverse order for sorting
                    for (j = 0, lj = id.length; j < lj; j++) {
                        //listId = vsurfaces[id[j]] + (j ? "." : "") + listId;
                        listId.unshift(vsurfaces[id[j]]);
                    }
    
                    glues.push([listId, glue, false, false]); //[surfaceId, surface, isSurface, isAlien]   
                }
            }
        }
    
        //process glue flags
        for (i = 0, li = glues.length; i < li; i++) {
            var item = glues[i];
            glue = item[1];
    
            glue.flagProper = true;
            glue.flagAlien = true;
    
            if (glue.flagProper) {
                list.push(item);  
            }
                    
            if (glue.flagAlien) {
                //remove first surface from id
                listId = item[0].slice(1);
                            
                //add same glue as alien
                list.push([listId, item[1], false, true]); //[surfaceId, surface, isSurface, isAlien]   
            }
        }
    
        //sort list alphabetically
        do {
            var sorted = true;
            
            for (i = 0, li = list.length - 1; i < li; i++) {
                var a1 = list[i][0];
                var a2 = list[i+1][0];
                
                var lesser = false;
                
                for (j = 0, lj = Math.min(a1.length, a2.length); j < lj; j++) {
                    if (a1[j] < a2[j] || (j == (lj -1) && a1[j] == a2[j] && a2.length > a1.length)) {
                        lesser = true;
                        break;                    
                    }
                }
                
                if (lesser) {
                    var t = list[i];
                    list[i] = list[i+1];
                    list[i+1] = t;
                    sorted = false;
                } 
            }
            
        } while(!sorted);
   
        var lastIndex = vsurfaceCount - 1;
    
        //convert list to surface sequence
        for (i = 0, li = list.length; i < li; i++) {
            tree.surfaceSequence.push([list[i][1], list[i][3]]); //[surface, isAlien]
            //this.surfaceSequence.push(list[i][1]); 
            list[i][1].viewSurfaceIndex = lastIndex; 
            
            if (list[i][2]) {
                lastIndex--;
                tree.surfaceOnlySequence.push(list[i][1]);
            }
        }
    
        //this.generateSurfaceSequenceOld();
        
    } else {
        if (vsurfaceCount == 1) {
            tree.surfaceSequence.push([list[0][1], list[0][3]]); //[surface, isAlien]
            list[0][1].viewSurfaceIndex = vsurfaceCount - 1;
            tree.surfaceOnlySequence = [list[0][1]];
        }
    }

    this.map.freeLayersHaveGeodata = false;

    //free layers
    for (key in view.freeLayers) {
        var freeLayer = this.map.getFreeLayer(key);
        if (freeLayer) {
            freeLayer.surfaceSequence = [freeLayer];
            freeLayer.surfaceOnlySequence = [freeLayer];
            
            if (freeLayer.geodata) {
                this.map.freeLayersHaveGeodata = true;
            }
        }
    }    

    //just in case
    this.map.renderer.draw.clearJobBuffer();
};


MapSurfaceSequence.prototype.generateBoundLayerSequence = function() {
    var view = this.map.currentView;
    var key, item, layer, alpha, i, li, item2;
    
    //zero bound layer filters
    var layers = this.map.boundLayers;
    for (var key in layers) {
        layers[key].shaderFilters = null;
    }

    //surfaces
    for (key in view.surfaces) {
        var surfaceLayers = view.surfaces[key];
        var surface = this.map.getSurface(key);
        if (surface != null) {
            surface.boundLayerSequence = [];
            
            for (i = 0, li = surfaceLayers.length; i < li; i++) {
                item = surfaceLayers[i];
        
                if (typeof item === 'string') {
                    layer = this.map.getBoundLayerById(item);
                    if (layer) {
                        surface.boundLayerSequence.push([layer, 1]);
                    }
                } else {
                    layer = this.map.getBoundLayerById(item['id']);
                    if (layer) {

                        alpha = 1;
                        if (typeof item['alpha'] !== 'undefined') {
                            alpha = parseFloat(item['alpha']);
                        }

                        surface.boundLayerSequence.push([layer, alpha]);

                        item2 = item['options'] || item;

                        if (item2['shaderVarFlatShade']) {
                            if (!layer.shaderFilters) {
                                layer.shaderFilters = {};
                            }
                            
                            if (!layer.shaderFilters[surface.id]) {
                                layer.shaderFilters[surface.id] = {};
                            }

                            layer.shaderFilters[surface.id].varFlatShade = item2['shaderVarFlatShade'];
                        }

                        if (item2['shaderFilter']) {
                            if (!layer.shaderFilters) {
                                layer.shaderFilters = {};
                            }
                            
                            if (!layer.shaderFilters[surface.id]) {
                                layer.shaderFilters[surface.id] = {};
                            }

                            layer.shaderFilters[surface.id].filter = item2['shaderFilter'];
                        }
                    }
                }
            }
        }
    }

    //free layers
    for (key in view.freeLayers) {
        var freeLayersProperties = view.freeLayers[key];
        var freeLayer = this.map.getFreeLayer(key);
        if (freeLayer != null && freeLayer.ready) {
            freeLayer.boundLayerSequence = [];
            
            var boundLayers = freeLayersProperties['boundLayers'];
            
            if (boundLayers && Array.isArray(boundLayers)) {

                for (i = 0, li = boundLayers.length; i < li; i++) {
                    item = boundLayers[i];
            
                    if (typeof item === 'string') {
                        layer = this.map.getBoundLayerById(item);
                        if (layer) {
                            freeLayer.boundLayerSequence.push([layer, 1]);
                        }
                    } else {
                        layer = this.map.getBoundLayerById(item['id']);
                        if (layer) {
    
                            alpha = 1;
                            if (typeof item['alpha'] !== 'undefined') {
                                alpha = parseFloat(item['alpha']);
                            }
    
                            freeLayer.boundLayerSequence.push([layer, alpha]);

                            if (item['shaderVarFlatShade']) {
                                if (!layer.shaderFilters) {
                                    layer.shaderFilters = {};
                                }
                                
                                if (!layer.shaderFilters[surface.id]) {
                                    layer.shaderFilters[surface.id] = {};
                                }

                                layer.shaderFilters[surface.id].varFlatShade = item['shaderVarFlatShade'];
                            }

                            if (item['shaderFilter']) {
                                if (!layer.shaderFilters) {
                                    layer.shaderFilters = {};
                                }
                                
                                if (!layer.shaderFilters[surface.id]) {
                                    layer.shaderFilters[surface.id] = {};
                                }

                                layer.shaderFilters[surface.id].filter = item['shaderFilter'];
                            }
                        }
                    }
                }
            }  
        }
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapSurfaceSequence);



/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer_gpu_texture__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_math__ = __webpack_require__(4);





//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_1__renderer_gpu_texture__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_2__utils_math__["a" /* math */];

 var tileBorderTable = [
    [-1, -1, 0, 0],
    [0, -1, 0.5, 1], //
    [1, -1, 1, 0],

    [-1, 0, 0, 0.5],
    [0, 0, 0.5, 0.5],
    [1, 0, 1, 0.5],

    [-1, 1, 0, 1],
    [0, 1, 0.5, 0], //
    [1, 1, 1, 1]
];

var tileCornerTable = [
    [0,1,3],
    [2,1,5],
    [6,3,7],
    [8,7,5]
];


var MapSurfaceTile = function(map, parent, id) {
    this.map = map;
    this.id = id;
    this.parent = parent;
    this.viewCounter = map.viewCounter;
    this.drawCounter = 0;
    this.childrenReadyCount = 0;
    this.renderReady = false;
    this.geodataCounter = 0;
    this.gridRenderCounter = 0; //draw grid only once
    this.texelSize = 1;
    this.texelSize2 = 1;
    this.distance = 1;
    this.tiltAngle = 1;
    this.seCounter = 0;

    this.metanode = null;  //[metanode, cacheItem]
    this.lastMetanode = null;
    this.boundmetaresources = null; //link to bound layers metatile storage

    this.surface = null; //surface or glue
    this.surfaceMesh = null;
    this.surfaceGeodata = null;     //probably only used in free layers
    this.surfaceGeodataView = null; //probably only used in free layers
    this.surfaceTextures = [];
    this.resourceSurface = null; //surface directing to resources

    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];
    
    this.resetDrawCommands = false;
    this.drawCommands = [[], [], []];

    this.bounds = {};
    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;

    this.hmap = null;
    this.heightMap = null;
    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};
    
    this.resources = this.map.resourcesTree.findNode(id, true);   // link to resource tree
    this.metaresources = this.map.resourcesTree.findAgregatedNode(id, 5, true); //link to meta resource tree
    this.boundresources = this.map.resourcesTree.findAgregatedNode(id, 8, true); //link to meta resource tree
    
    this.children = [null, null, null, null];
};


MapSurfaceTile.prototype.kill = function() {
    //kill children
    for (var i = 0; i < 4; i++) {
        if (this.children[i] != null) {
            this.children[i].kill();
        }
    }
/*
    if (this.surfaceMesh != null) {
        this.surfaceMesh.kill();
    }

    for (var key in this.surfaceTextures) {
        if (this.surfaceTextures[key] != null) {
            this.surfaceTextures[key].kill();
        }
    }

    if (this.surfaceGeodata != null) {
        this.surfaceGeodata.kill();
    }

    if (this.surfaceGeodataView != null) {
        this.surfaceGeodataView.kill();
    }

    if (this.heightMap != null) {
        this.heightMap.kill();
    }

    for (var key in this.boundTextures) {
        if (this.boundTextures[key] != null) {
            this.boundTextures[key].kill();
        }
    }
*/
    this.resources = null;
    this.metaresources = null;
    this.metanode = null;

    this.surface = null;
    this.surfaceMesh = null;
    this.surfaceTextures = [];
    this.surfaceGeodata = null;
    this.surfaceGeodataView = null;
    this.resourceSurface = null;

    this.bounds = {};
    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;

    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];

    this.renderReady = false;
    this.lastSurface = null;
    this.lastState = null;
    this.lastRenderState = null;
        
    this.hmap = null;
    this.heightMap = null;
    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};

    this.verifyChildren = false;
    this.children = [null, null, null, null];

    var parent = this.parent;
    this.parent = null;

    if (parent != null) {
        parent.removeChild(this);
    }
};


MapSurfaceTile.prototype.validate = function() {
    //is tile empty?
    if (this.metaresources == null || !this.metaresources.getMetatile(this.surface, null, this)) {
        //this.kill();
    }
};


MapSurfaceTile.prototype.viewSwitched = function() {
    //store last state for view switching
    this.lastSurface = this.surface;
    this.lastState = {
        surfaceMesh : this.surfaceMesh,
        surfaceTextures : this.surfaceTextures,
        boundTextures : this.boundTextures,
        surfaceGeodata : this.surfaceGeodata,
        surfaceGeodataView : this.surfaceGeodataView,
        resourceSurface : this.resourceSurface 
    };    

    if (this.drawCommands[0].length > 0) {  // check only visible chanel
        this.lastRenderState = {
            drawCommands : this.drawCommands,
            imageryCredits : this.imageryCredits,
            mapdataCredits : this.mapdataCredits
        };
    } else {
        this.lastRenderState = null;
    }
    
    //zero surface related data    
    this.verifyChildren = true;
    this.renderReady = false;
    this.lastMetanode = this.metanode;
    this.metanode = null; //quick hack for switching virtual surfaeces //keep old value for smart switching

    if (!this.map.config.mapSoftViewSwitch) {

        if (this.metanode) {
            this.metanode.border = null;
            this.metanode.border2 = null;
            this.metanode.border3 = null;
            this.metanode.borderNodes = null;
            this.metanode.borderReady = null;
        }

        this.lastState = null;
        this.lastRenderState = null;
        this.lastMetanode = null;
        this.metanode = null;
        this.gridPoints = null;
    }

    //this.lastMetanode = null;
    //this.metanode = null;

    for (var key in this.bounds) {
        this.bounds[key] = {
            sequence : [],
            alpha : [],
            transparent : false,
            viewCoutner : 0
        };
    }

    this.boundLayers = {};
    this.boundTextures = {};
    this.updateBounds = true;
    this.transparentBounds = false;

    this.surface = null;
    this.surfaceMesh = null;
    this.surfaceTextures = [];
    this.surfaceGeodata = null;
    this.surfaceGeodataView = null;
    this.resourceSurface = null;
    
    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];
    this.virtualSurfacesUncomplete = false;
    
    this.drawCommands = [[], [], []];
    this.imageryCredits = {};
    this.glueImageryCredits = {};
    this.mapdataCredits = {};
};


MapSurfaceTile.prototype.restoreLastState = function() {
    if (!this.lastState) {
        return;
    }
    this.surfaceMesh = this.lastState.surfaceMesh;
    this.surfaceTextures = this.lastState.surfaceTextures; 
    this.boundTextures = this.lastState.boundTextures;
    this.surfaceGeodata = this.lastState.surfaceGeodata;
    this.surfaceGeodataView = this.lastState.surfaceGeodataView;
    this.resourceSurface = this.lastState.resourceSurface; 
    this.lastSurface = null;
    this.lastState = null;
    this.lastResourceSurface = null;
};


MapSurfaceTile.prototype.addChild = function(index) {
    if (this.children[index]) {
        return;
    }
    
    var id = this.id;
    var childId = [id[0] + 1, id[1] << 1, id[2] << 1];

    switch (index) {
    case 1: childId[1]++; break;
    case 2: childId[2]++; break;
    case 3: childId[1]++; childId[2]++; break;
    }

    this.children[index] = new MapSurfaceTile(this.map, this, childId);
};


MapSurfaceTile.prototype.removeChildByIndex = function(index) {
    if (this.children[index] != null) {
        this.children[index].kill();
        this.children[index] = null;
    }
    
    //remove resrource node?
};


MapSurfaceTile.prototype.removeChild = function(tile) {
    for (var i = 0; i < 4; i++) {
        if (this.children[i] == tile) {
            this.children[i].kill();
            this.children[i] = null;
        }
    }
};


MapSurfaceTile.prototype.isMetanodeReady = function(tree, priority, preventLoad) {

    //has map view changed?
    if (this.map.viewCounter != this.viewCoutner) {
        this.viewSwitched();
        this.viewCoutner = this.map.viewCounter;
        this.map.markDirty(); 
    }
        
    if (!preventLoad) {
   
        //provide surface for tile
        if (this.virtualSurfacesUncomplete || (this.surface == null && this.virtualSurfaces.length == 0) ) { //|| this.virtualSurfacesUncomplete) {
            this.checkSurface(tree, priority);
        }
   
        //provide metanode for tile
        if (this.metanode == null || this.lastMetanode) {
            
            if (!this.virtualSurfacesUncomplete) {
                var ret = this.checkMetanode(tree, priority);
                
                if (!ret && !(this.metanode != null && this.lastMetanode)) { //metanode is not ready yet
                    return false;
                }
            }
            
            /*if (this.lastMetanode) {
                processFlag2 = true;
            }*/
        }
        
    }

    if (this.metanode == null) { // || processFlag3) { //only for wrong data
        return false;
    }

    this.metanode.metatile.used();

    if (this.lastSurface && this.lastSurface == this.surface) {
        this.lastSurface = null;
        this.restoreLastState();
        //return;
    }

    if (this.surface) {
        if (this.surface.virtual) {
            this.resourceSurface = this.surface.getSurface(this.metanode.sourceReference);
            if (!this.resourceSurface) {
                this.resourceSurface = this.surface;
            }
        } else {
            this.resourceSurface = this.surface;
        }
    }

    if (this.seCounter != this.map.renderer.seCounter) {
        var renderer = this.map.renderer;
        this.seCounter = renderer.seCounter;
        var node = this.metanode;

        if (renderer.useSuperElevation) {
            node.minZ = renderer.getSuperElevatedHeight(node.minZ2);
            node.maxZ = renderer.getSuperElevatedHeight(node.maxZ2);
        } else {
            node.minZ = node.minZ2;
            node.maxZ = node.maxZ2;
        }

        if (renderer.seCounter > 0) {
            this.gridPoints = null;
            node.border = null;
            node.border2 = null;
            node.border3 = null;
            node.borderReady = false;
     
            node.generateCullingHelpers();
        }
    }

    return true;
};


MapSurfaceTile.prototype.checkSurface = function(tree, priority) {
    this.surface = null;
    this.virtual = false;
    this.virtualReady = false;
    this.virtualSurfaces = [];
    this.virtualSurfacesUncomplete = false;
    
    if (tree.freeLayerSurface) {  //free layer has only one surface
        this.surface = tree.freeLayerSurface;
        return; 
    }

    var sequence = tree.surfaceSequence;

    //multiple surfaces
    //build virtual surfaces array
    //find surfaces with content
    for (var i = 0, li = sequence.length; i < li; i++) {
        var surface = sequence[i][0];
        var alien = sequence[i][1];

        var res = surface.hasTile2(this.id);
        if (res[0]) {
            
            //check if tile exist
            if (this.id[0] > 0) { //surface.lodRange[0]) {
                // removed for debug !!!!!
                // ????????
                var parent = this.parent;
                if (parent) { 
                    
                    if (parent.virtualSurfacesUncomplete) {
                        this.virtualSurfacesUncomplete = true;
                        this.virtualSurfaces = [];
                        return;
                    }
                    
                    var metatile = parent.metaresources.getMetatile(surface, null, this);
                    if (metatile) {
                        
                        if (!metatile.isReady(priority)) {
                            this.virtualSurfacesUncomplete = true;
                            continue;
                        }
                        
                        var node = metatile.getNode(parent.id);
                        if (node) {
                            if (!node.hasChildById(this.id)) {
                                continue;
                            }
                        } else {
                            continue;
                        }
                    } else {
                        continue;
                    }
                }
            }
    
            //store surface
            this.virtualSurfaces.push([surface, alien]);        
        }
    }

    if (this.virtualSurfaces.length > 1) {
        this.virtual = true;
    } else {
        this.surface = (this.virtualSurfaces[0]) ? this.virtualSurfaces[0][0] : null;
    }
};


MapSurfaceTile.prototype.checkMetanode = function(tree, priority) {
    if (this.virtual) {
        if (this.isVirtualMetanodeReady(tree, priority)) {
            this.metanode = this.createVirtualMetanode(tree, priority);
            this.lastMetanode = null;
            this.map.markDirty();
        } else {
            return false;
        }
    }

    var surface = this.surface;

    if (surface == null) {
        return false;
    }

    var metatile = this.metaresources.getMetatile(surface, true, this);

    if (metatile.isReady(priority)) {

        if (!this.virtual) {
            this.metanode = metatile.getNode(this.id);
            this.lastMetanode = null;
            this.map.markDirty(); 
        }

        if (this.metanode != null) {
            this.metanode.tile = this; //used only for validate
            this.lastMetanode = null;
            this.map.markDirty(); 

            for (var i = 0; i < 4; i++) {
                if (this.metanode.hasChild(i)) {
                    this.addChild(i);
                } else {
                    this.removeChildByIndex(i);
                }
            }
        }

    } else {
        return false;
    }
    
    return true;
};


MapSurfaceTile.prototype.isVirtualMetanodeReady = function(tree, priority) {
    var surfaces = this.virtualSurfaces;
    var readyCount = 0;

    for (var i = 0, li = surfaces.length; i < li; i++) {
        var surface = surfaces[i][0];
        var metatile = this.metaresources.getMetatile(surface, true, this);

        if (metatile.isReady(priority)) {
            readyCount++;
        }
    }
    
    if (readyCount == li) {
        return true;        
    } else {
        return false;
    }
};


MapSurfaceTile.prototype.createVirtualMetanode = function(tree, priority) {
    var surfaces = this.virtualSurfaces;
    var node = null, i, li, surface, metatile, metanode;

    //get top most existing surface
    for (i = 0, li = surfaces.length; i < li; i++) {
        surface = surfaces[i][0];
        var alien = surfaces[i][1];
        metatile = this.metaresources.getMetatile(surface, null, this);

        if (metatile.isReady(priority)) {
            metanode = metatile.getNode(this.id);

            if (metanode != null) {
                if (alien != metanode.alien) {
                    continue;
                }

                //does metanode have surface reference?
                //internalTextureCount is reference to surface
                if (!alien && surface.glue && !metanode.hasGeometry() &&
                    metanode.internalTextureCount > 0) {
                    
                    var desiredSurfaceIndex = metanode.internalTextureCount - 1;
                    desiredSurfaceIndex = this.map.getSurface(surface.id[desiredSurfaceIndex]).viewSurfaceIndex;
                    
                    var jump = false; 
                        
                    for (var j = i; j < li; j++) {
                        if (surfaces[j].viewSurfaceIndex <= desiredSurfaceIndex) {
                            jump = (j > i);
                            i = j - 1;
                            break;
                        }
                    }
                    
                    if (jump) {
                        continue;
                    }                         
                }
                
                if (metanode.hasGeometry()) {
                    node = metanode.clone();
                    this.surface = surface;
                    break;
                }
            }
        }
    }

    //extend bbox, credits and children flags by other surfaces
    for (i = 0, li = surfaces.length; i < li; i++) {
        surface = surfaces[i][0];
        metatile = this.metaresources.getMetatile(surface, null, this);

        if (metatile.isReady(priority)) {
            metanode = metatile.getNode(this.id);

            if (metanode != null) {
                //does metanode have surface reference?
                //internalTextureCount is reference to surface
                /*
                if (surface.glue && !metanode.hasGeometry() &&
                    metanode.internalTextureCount > 0) {
                    i = this.map.surfaceSequenceIndices[metanode.internalTextureCount - 1] - 1;
                    continue;
                }*/

                if (!node) { //just in case all surfaces are without geometry
                    node = metanode.clone();
                    this.surface = surface;
                } else {
                    node.flags |= metanode.flags & ((15)<<4); 

                    /*
                    for (var j = 0, lj = metanode.credits.length; j <lj; j++) {
                        if (node.credits.indexOf(metanode.credits[j]) == -1) {
                            node.credits.push(metanode.credits[j]);
                        } 
                    }*/
                   
                    if (metatile.useVersion < 4) {
                        // removed for debug !!!!!
                        node.bbox.min[0] = Math.min(node.bbox.min[0], metanode.bbox.min[0]); 
                        node.bbox.min[1] = Math.min(node.bbox.min[1], metanode.bbox.min[1]); 
                        node.bbox.min[2] = Math.min(node.bbox.min[2], metanode.bbox.min[2]); 
                        node.bbox.max[0] = Math.max(node.bbox.max[0], metanode.bbox.max[0]); 
                        node.bbox.max[1] = Math.max(node.bbox.max[1], metanode.bbox.max[1]); 
                        node.bbox.max[2] = Math.max(node.bbox.max[2], metanode.bbox.max[2]);
                    }
                }
            }
        }
    }
    
    if (node) {
        node.generateCullingHelpers(true);
    }
    
    return node;
};


MapSurfaceTile.prototype.bboxVisible = function(id, bbox, cameraPos, node) {
    var map = this.map;
    var camera = map.camera;
    if (id[0] < map.measure.minDivisionNodeDepth) {
        return true;
    }
    
    var skipGeoTest = map.config.mapDisableCulling;
    if (!skipGeoTest && map.isGeocent) {
        if (node) {
            //if (true) {  //version with perspektive
            var p2 = node.diskPos;
            var p1 = camera.position;
            var rayVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            var distance = vec3.normalize4(rayVec) * camera.distanceFactor;
                //vec3.normalize(camVec);
                
            var a = vec3.dot(rayVec, node.diskNormal);
            //} else { //version without perspektive
            //    var a = vec3.dot(camera.vector, node.diskNormal);
            //}
            this.tiltAngle = a;
            
            if (distance > 150000 && a > node.diskAngle) {
                return false;
            }
        }
    }

    if (node.metatile.useVersion >= 4) {
        return camera.camera.pointsVisible(node.bbox2, cameraPos);
    } else {
        if (!(map.isGeocent && (map.config.mapPreciseBBoxTest)) || id[0] < 4) {
            return camera.camera.bboxVisible(bbox, cameraPos);
        } else {
            return camera.camera.pointsVisible(node.bbox2, cameraPos);
        }
    }
};

MapSurfaceTile.prototype.insideCone = function(coneVec, angle, node) {

    if (this.map.isGeocent) { // && node.diskPos && node.diskNormal) {
        var a = Math.acos(vec3.dot(coneVec, node.diskNormal));

        return (a < angle + node.diskAngle2A);
    }

    return false;
};


MapSurfaceTile.prototype.getPixelSize = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {
    var min = bbox.min;
    var max = bbox.max;
    var tilePos1x = min[0] - cameraPos[0];
    var tilePos1y = min[1] - cameraPos[1];
    var tilePos2x = max[0] - cameraPos[0];
    var tilePos2y = min[1] - cameraPos[1];
    var tilePos3x = max[0] - cameraPos[0];
    var tilePos3y = max[1] - cameraPos[1];
    var tilePos4x = min[0] - cameraPos[0];
    var tilePos4y = max[1] - cameraPos[1];
    var h1 = min[2] - cameraPos[2];
    var h2 = max[2] - cameraPos[2];
    
    //camera inside bbox
    if (cameraPos[0] > min[0] && cameraPos[0] < max[0] &&
        cameraPos[1] > min[1] && cameraPos[1] < max[1] &&
        cameraPos[2] > min[2] && cameraPos[2] < max[2]) {

        if (returnDistance) {
            return [Number.POSITIVE_INFINITY, 0.1];
        }
    
        return Number.POSITIVE_INFINITY;
    }

    var factor = 0;
    var camera = this.map.camera.camera;

    //find bbox sector
    if (0 < tilePos1y) { //top row - zero means camera position in y
        if (0 < tilePos1x) { // left top corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos1x, tilePos1y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos1x, tilePos1y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos1x, tilePos1y, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos2x) { // right top corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos2x, tilePos2y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos2x, tilePos2y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos2x, tilePos2y, (h1 + h2)*0.5], returnDistance);
            }
        } else { //top side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, tilePos2y, (h1 + h2)*0.5], returnDistance);
            }
        }
    } else if (0 > tilePos4y) { //bottom row
        if (0 < tilePos4x) { // left bottom corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos4x, tilePos4y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos4x, tilePos4y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos4x, tilePos4y, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos3x) { // right bottom corner
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos3x, tilePos3y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos3x, tilePos3y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos3x, tilePos3y, (h1 + h2)*0.5], returnDistance);
            }
        } else { //bottom side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos4x + tilePos3x)*0.5, tilePos3y, (h1 + h2)*0.5], returnDistance);
            }
        }
    } else { //middle row
        if (0 < tilePos4x) { // left side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos1x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        } else if (0 > tilePos3x) { // right side
            if (0 > h2) { // hi
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([tilePos2x, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        } else { //center
            if (0 > h2) { // hi
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h2], returnDistance);
            } else if (0 < h1) { // low
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, h1], returnDistance);
            } else { // middle
                factor = camera.scaleFactor([(tilePos1x + tilePos2x)*0.5, (tilePos2y + tilePos3y)*0.5, (h1 + h2)*0.5], returnDistance);
            }
        }
    }

    //console.log("new: " + (factor * screenPixelSize) + " old:" + this.tilePixelSize2(node) );

    if (returnDistance) {
        return [(factor[0] * screenPixelSize), factor[1]];
    }

    return (factor * screenPixelSize);
};


MapSurfaceTile.prototype.getPixelSize3Old = function(node, screenPixelSize, factor) {
    var camera = this.map.camera;
    var d = (camera.geocentDistance*factor) - node.diskDistance;
    if (d < 0) {
        d = -d;
        //return [Number.POSITIVE_INFINITY, 0.1];
    } 

    var a = vec3.dot(camera.geocentNormal, node.diskNormal);
    
    if (a < node.diskAngle2) {
        var a2 = Math.acos(a); 
        var a3 = Math.acos(node.diskAngle2);
        a2 = a2 - a3; 

        var l1 = Math.tan(a2) * node.diskDistance;
        d = Math.sqrt(l1*l1 + d*d);
    }

    factor = camera.camera.scaleFactor2(d);
    return [factor * screenPixelSize, d];
};


MapSurfaceTile.prototype.getPixelSize3 = function(node, screenPixelSize) {
    //if (this.map.drawIndices) {
      //  return this.getPixelSize3Old(node, screenPixelSize, factor);
    //}
    var camera = this.map.camera;
    var cameraDistance = camera.geocentDistance;// * factor;

    var a = vec3.dot(camera.geocentNormal, node.diskNormal); //get angle between tile normal and cameraGeocentNormal
    var d = cameraDistance - (node.diskDistance + (node.maxZ - node.minZ)), d2; //vertical distance from top bbox level

    if (a < node.diskAngle2) { //is camera inside tile conus?
        
        //get horizontal distance
        var a2 = Math.acos(a); 
        var a3 = node.diskAngle2A;
        a2 = a2 - a3; 
        var l1 = Math.tan(a2) * node.diskDistance;// * factor;

        if (d < 0) { //is camera is belown top bbox level?
            d2 = cameraDistance - node.diskDistance;
            if (d2 < 0) { //is camera is belown bottom bbox level?
                d = -d2;
                d = Math.sqrt(l1*l1 + d*d);
            } else { //is camera inside bbox
                d = l1;
            }
        } else {
            d = Math.sqrt(l1*l1 + d*d);
        }

    } else {
        if (d < 0) { //is camera is belown top bbox level?
            d2 = cameraDistance - node.diskDistance;
            if (d2 < 0) { //is camera is belown bottom bbox level?
                d = -d2;
            } else { //is camera inside bbox
                return [Number.POSITIVE_INFINITY, 0.1];
            }
        } 
    }

    return [camera.camera.scaleFactor2(d) * screenPixelSize, d];
};

/*

MapSurfaceTile.prototype.getPixelSize22 = function(bbox, screenPixelSize, cameraPos, worldPos, returnDistance) {
    var min = bbox.min;
    var max = bbox.max;
    var p1 = bbox.center();
    bbox.updateMaxSize();
    var d = bbox.maxSize * 0.5; 
    
    var dd = [cameraPos[0]-p1[0],
               cameraPos[1]-p1[1],
               cameraPos[2]-p1[2]]; 

    var d2 = vec3.length(dd) - (bbox.maxSize * 0.5);

    var factor = this.camera.scaleFactor2(d2);

    if (returnDistance) {
        return [(factor[0] * screenPixelSize), factor[1]];
    }

    return (factor * screenPixelSize);
};
*/

MapSurfaceTile.prototype.updateTexelSize = function() {
    var pixelSize, factor, v, p;
    var map = this.map;
    var draw = map.draw;
    var camera = map.camera;
    var texelSizeFit = draw.texelSizeFit;
    var node = this.metanode;
    var cameraPos = map.camera.position;
    var preciseDistance = (map.isGeocent && (map.config.mapPreciseDistanceTest || node.metatile.useVersion >= 4));  

    if (node.hasGeometry()) {
        var screenPixelSize = Number.POSITIVE_INFINITY;

        if (node.usedTexelSize()) {
            screenPixelSize = draw.ndcToScreenPixel * node.pixelSize;
        } else if (node.usedDisplaySize()) {
            screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);
        }

        if (camera.camera.ortho) {
            var height = camera.camera.getViewHeight();
            pixelSize = [(screenPixelSize*2.0) / height, height];
        } else {
            
            if (node.usedDisplaySize()) { 
               
                if (!preciseDistance) {
                    screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256);

                    factor = (node.displaySize / 256) * camera.distance;
                    //var factor = (256 / 256) * this.map.cameraDistance;
                    
                    v = camera.vector; //move camera away hack
                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];

                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);
                } else {
                    if (draw.isGeocent) {
                        //screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 2 * 0.70710678118) / 256) * (256 / node.displaySize);
                        screenPixelSize = draw.ndcToScreenPixel * ((node.diskAngle2A * draw.planetRadius * 1.41421356236) / node.displaySize);
                    } else {
                        //screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / 256) * (256 / node.displaySize);
                        screenPixelSize = draw.ndcToScreenPixel * (node.bbox.maxSize / node.displaySize);
                    }

                    pixelSize = this.getPixelSize3(node, screenPixelSize);
                }
            } else {
                
                if (!preciseDistance && texelSizeFit > 1.1) {
                    screenPixelSize = draw.ndcToScreenPixel * node.pixelSize * (texelSizeFit / 1.1);
                    factor = (texelSizeFit / 1.1) * camera.distance;
                    
                    v = camera.vector; //move camera away hack
                    p = [cameraPos[0] - v[0] * factor, cameraPos[1] - v[1] * factor, cameraPos[2] - v[2] * factor];
                    
                    pixelSize = this.getPixelSize(node.bbox, screenPixelSize, p, p, true);
                } else {
                    if (preciseDistance) {
                        pixelSize = this.getPixelSize3(node, screenPixelSize);
                    } else {
                        pixelSize = this.getPixelSize(node.bbox, screenPixelSize, cameraPos, cameraPos, true);
                    }
                }
            }
        }
    } else {
        if (preciseDistance) {
            pixelSize = this.getPixelSize3(node, 1, 1);
        } else {
            pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);
        }

        //pixelSize = this.getPixelSize(node.bbox, 1, cameraPos, cameraPos, true);
        pixelSize[0] = Number.POSITIVE_INFINITY;
    }

    this.texelSize = pixelSize[0];
    this.distance = pixelSize[1];

    //degrade horizont
    if (!map.config.mapDegradeHorizon || draw.degradeHorizonFactor < 1.0) {
        return;
    }

    var degradeHorizon = map.config.mapDegradeHorizonParams;
    var degradeFadeStart = degradeHorizon[1];
    var degradeFadeEnd = degradeHorizon[2];

    //reduce degrade factor by tilt
    var degradeFactor = draw.degradeHorizonFactor * draw.degradeHorizonTiltFactor; 
    var distance = this.distance * camera.distanceFactor;

    //apply degrade factor smoothly from specified tile distance
    if (distance < degradeFadeStart) {
        degradeFactor = 1.0;
    } else if (distance > degradeFadeStart && distance < degradeFadeEnd) {
        degradeFactor = 1.0 + (degradeFactor-1.0) * ((distance - degradeFadeStart) / (degradeFadeEnd - degradeFadeStart));
    }

    degradeFactor = Math.max(degradeFactor, 1.0);

    //reduce degrade factor by observed distance
    var observerDistance = camera.perceivedDistance;
    var distanceFade = degradeHorizon[3];

    if (observerDistance > distanceFade) {
        degradeFactor = 1.0;
    } else if (observerDistance < distanceFade && degradeFactor > 1.0) {
        degradeFactor = 1.0 + ((degradeFactor - 1.0) * (1.0-(observerDistance / distanceFade)));
    }

    //console.log("degrade: " + degradeFactor);

    this.texelSize /= degradeFactor;
};


MapSurfaceTile.prototype.drawGrid = function(cameraPos, divNode, angle, onlySetBorderData, subdiv) {
    /* if (!(subdiv || onlySetBorderData)) {
        if (this.gridRenderCounter != this.map.draw.drawCounter) {
            this.gridRenderCounter = this.map.draw.drawCounter;
        } else {
            return; //prevent rendering same grid more then on time
        }
    } */

    if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {
        return;
    }
    
    if (!this.metanode) {
        return;
    }

    var map = this.map, node, ll, ur, res;

    if (map.draw.gridSkipped) {
        return;
    }


    if (divNode) {
        node = divNode[0]; 
        ll = divNode[1][0];
        ur = divNode[1][1];
    } else {
        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
        node = res[0]; 
        ll = res[1][0];
        ur = res[1][1];
    }
   
    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];

    var hasPoles = map.referenceFrame.hasPoles;

    angle = angle || this.metanode.diskAngle2;
    
    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {
        angle = Math.cos(Math.acos(angle) * 0.5); 
        
        this.drawGrid(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle, false, true);
        this.drawGrid(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle, false, true);

        this.drawGrid(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle, false, true);
        this.drawGrid(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle, false, true);
       
        return;
    }
     
    var desiredSamplesPerViewExtent = 5;
    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];
    var viewExtent = this.distance ;//* 0.1;
    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;
    lod = Math.max(0,lod - 8 + node.id[0]);
   
    var h, factor, prog, draw = map.draw; 

    var sx = cameraPos[0];
    var sx = cameraPos[0];
    var sy = cameraPos[1];
    var sz = cameraPos[2];
    var buffer = draw.planeBuffer;
    var flatGrid = draw.gridFlat;
    var joinGrids = draw.gridGlues; //this.map.draw.debug.drawFog;
    var gridPoints = this.gridPoints;
    var useSurrogatez = map.config.mapGridSurrogatez;

    if (!gridPoints) {

        h = useSurrogatez ? this.metanode.surrogatez : this.metanode.minZ;
        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);
        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);
        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);
        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);
        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);
        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);
        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);
        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);

        middle[2] = h;
        middle = node.getPhysicalCoords(middle, true);

        if (!divNode) {

            var gridPoints = [
                n4[0], n4[1], n4[2],
                mtop[0], mtop[1], mtop[2],
                n1[0], n1[1], n1[2],

                mleft[0], mleft[1], mleft[2],
                middle[0], middle[1], middle[2],
                mright[0], mright[1], mright[2],
                
                n3[0], n3[1], n3[2],
                mbottom[0], mbottom[1], mbottom[2],
                n2[0], n2[1], n2[2]
            ];

            this.gridPoints = gridPoints;

        } else {
            buffer[0] = n4[0] - sx;
            buffer[1] = n4[1] - sy;
            buffer[2] = n4[2] - sz;
            
            buffer[3] = mtop[0] - sx;
            buffer[4] = mtop[1] - sy;
            buffer[5] = mtop[2] - sz;

            buffer[6] = n1[0] - sx;
            buffer[7] = n1[1] - sy;
            buffer[8] = n1[2] - sz;

            buffer[9] = mleft[0] - sx;
            buffer[10] = mleft[1] - sy;
            buffer[11] = mleft[2] - sz;
                    
            buffer[12] = middle[0] - sx;
            buffer[13] = middle[1] - sy;
            buffer[14] = middle[2] - sz;
                    
            buffer[15] = mright[0] - sx;
            buffer[16] = mright[1] - sy;
            buffer[17] = mright[2] - sz;
                
            buffer[18] = n3[0] - sx;
            buffer[19] = n3[1] - sy;
            buffer[20] = n3[2] - sz;
            
            buffer[21] = mbottom[0] - sx;
            buffer[22] = mbottom[1] - sy;
            buffer[23] = mbottom[2] - sz;
            
            buffer[24] = n2[0] - sx;
            buffer[25] = n2[1] - sy;
            buffer[26] = n2[2] - sz;
        }
     }


    if (!flatGrid) {

        var mnode = this.metanode; 
           
        var border = mnode.border, borderNodes = mnode.borderNodes;
        var i, li, n, tree = map.tree, id = this.id;
        
        if (!border) {
            mnode.border = new Array(9);
            mnode.borderNodes = new Array(9);
            border = mnode.border, borderNodes = mnode.borderNodes;
            border[4] = useSurrogatez ? mnode.surrogatez : mnode.minZ;
        }
        

        var borderTable = tileBorderTable;
        var skip = false;

        if (!mnode.borderReady) {
            
            for (i = 0; i < 9; i++) {
                if (i != 4 && !borderNodes[i]) {
                    n = tree.getNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], true);

                    if (n) {
                        borderNodes[i] = n;
                        border[i] = (useSurrogatez ? n.surrogatez : n.minZ);
                    } else {
                        border[i] = border[4];
                        skip = true;
                    }
                }
            }
           
        }

        var border2 = mnode.border2;
        h = useSurrogatez ? mnode.surrogatez : mnode.minZ

        if (!border2 || !mnode.borderReady) {
            border2 = [
                ((border[0] + border[1] + border[3] + border[4]) * 0.25) - h, 
                ((border[1] + border[4]) * 0.5) - h,
                ((border[2] + border[1] + border[5] + border[4]) * 0.25) - h,

                ((border[3] + border[4]) * 0.5) - h,
                border[4] - h,
                ((border[5] + border[4]) * 0.5) - h,

                ((border[6] + border[7] + border[3] + border[4]) * 0.25) - h,
                ((border[7] + border[4]) * 0.5) - h,
                ((border[8] + border[7] + border[5] + border[4]) * 0.25) - h
            ];

            mnode.border2 = border2;
        }

        if (!skip) {
            mnode.borderReady = true;
        }

        if (onlySetBorderData) {
            return;
        }

        if (joinGrids) {
            var cornerTable = tileCornerTable;
            var nodeTable = this.nodeTable;

            if (!nodeTable) {
                nodeTable = new Array(9);
                this.nodeTable = nodeTable;
            }

            //get bodrer nodes
            for (i = 0, li = borderTable.length; i < li; i++) {
                if (i != 4) {
                    nodeTable[i] = tree.getRenderedNodeById([id[0], id[1] + borderTable[i][0], id[2] + borderTable[i][1]], draw.drawCounter);
                }
            }

            var border3 = mnode.border3;

            if (!border3) {
                border3 = new Array(9);
                mnode.border3 = border3;
            }

            //solve corners
            for (i = 0, li = cornerTable.length; i < li; i++) {
                var lowestNode = nodeTable[cornerTable[i][0]];

                for (var j = 1; j < 3; j++) {
                    n = nodeTable[cornerTable[i][j]];

                    if (n) {
                        if (lowestNode) {
                            if (n.id[0] < lowestNode.id[0]) {
                                lowestNode = n;
                            } 
                        } else {
                            lowestNode = n;
                        }
                    }
                }

                nodeTable[cornerTable[i][0]] = lowestNode;
            }

            for (i = 0, li = borderTable.length; i < li; i++) {
                n = nodeTable[i];

                if (i != 4 && (n && n.id[0] < id[0])) {
                    var bcoords;

                    switch(i) {
                        case 0:  bcoords = [mnode.llx, mnode.lly]; break;
                        case 1:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.lly]; break;
                        case 2:  bcoords = [mnode.urx, mnode.lly]; break;
                        
                        case 3:  bcoords = [mnode.llx, (mnode.ury+mnode.lly)*0.5]; break;
                        case 5:  bcoords = [mnode.urx, (mnode.ury+mnode.lly)*0.5]; break;

                        case 6:  bcoords = [mnode.llx, mnode.ury]; break;
                        case 7:  bcoords = [(mnode.urx+mnode.llx)*0.5, mnode.ury]; break;
                        case 8:  bcoords = [mnode.urx, mnode.ury]; break;
                    }

                    if (!n.border2) {
                        n.tile.drawGrid(cameraPos, divNode, angle, true);
                    }

                    if (n.border2) {
                        mnode.border3[i] = (n.getGridHeight(bcoords, n.border2, 3) + (useSurrogatez ? n.surrogatez : n.minZ))  - h; 
                    } else {
                        border2[i];
                    }
                } else {
                    mnode.border3[i] = border2[i];
                }
            }
        }                     
    }

    var renderer = map.renderer;
    var mv = renderer.camera.getModelviewMatrix();
    var proj = renderer.camera.getProjectionMatrix();

    if (gridPoints) {
        buffer[0] = gridPoints[0] - sx;
        buffer[1] = gridPoints[1] - sy;
        buffer[2] = gridPoints[2] - sz;
        
        buffer[3] = gridPoints[3] - sx;
        buffer[4] = gridPoints[4] - sy;
        buffer[5] = gridPoints[5] - sz;

        buffer[6] = gridPoints[6] - sx;
        buffer[7] = gridPoints[7] - sy;
        buffer[8] = gridPoints[8] - sz;

        buffer[9] = gridPoints[9] - sx;
        buffer[10] = gridPoints[10] - sy;
        buffer[11] = gridPoints[11] - sz;
                
        buffer[12] = gridPoints[12] - sx;
        buffer[13] = gridPoints[13] - sy;
        buffer[14] = gridPoints[14] - sz;
                
        buffer[15] = gridPoints[15] - sx;
        buffer[16] = gridPoints[16] - sy;
        buffer[17] = gridPoints[17] - sz;
            
        buffer[18] = gridPoints[18] - sx;
        buffer[19] = gridPoints[19] - sy;
        buffer[20] = gridPoints[20] - sz;
        
        buffer[21] = gridPoints[21] - sx;
        buffer[22] = gridPoints[22] - sy;
        buffer[23] = gridPoints[23] - sz;
        
        buffer[24] = gridPoints[24] - sx;
        buffer[25] = gridPoints[25] - sy;
        buffer[26] = gridPoints[26] - sz;
    }

    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {
        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);
        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); 
        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); 
    }

    factor = 1;

    var useTexture = (map.config.mapGridTextureLayer != '');

    if (useTexture) {
        if (!this.gridTexture) {

            var layer = map.boundLayers[map.config.mapGridTextureLayer];
            var sourceTile = this;

            if (!layer || sourceTile < layer.lodRange[0]) {
                useTexture = false;
            } else {
                var sourceLod = math.clamp(sourceTile.id[0] - map.config.mapGridTextureLevel, layer.lodRange[0], layer.lodRange[3]);

                while (sourceTile.id[0] > sourceLod) {
                    sourceTile = sourceTile.parent;
                }

                //(path, type, extraBound, extraInfo, tile, internal)
                this.gridTexture = this.resources.getTexture("gmap#"+map.config.mapGridTextureLayer, null, {sourceTile: sourceTile, layer:layer, tile: this }, null, null, null);
                //this.gridTexture.isReady(false, 0, false);
            }

        }

        if (useTexture && !this.gridTexture.isReady(false, 0, false)) {  //TODO: set params with max priority
            useTexture = false;       
        }     
    }

    var hitmapRender = renderer.onlyDepth;

    if (hasPoles && node.isPole) {
        factor = map.poleRadiusFactor; 
        prog = hitmapRender ? renderer.progPlane2D :renderer.progPlane2; 
        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);
    } else {

        if (!flatGrid) {
            prog = hitmapRender ? renderer.progPlane3D : renderer.progPlane3; 
            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);

            var border;

            if (joinGrids) {
                border =  mnode.border3;
            } else {
                border = mnode.border2;
            }

            prog.setFloatArray('uHeights', border);
            prog.setVec3('uVector', mnode.diskNormal);

        } else {
            prog = hitmapRender ? renderer.progPlane : renderer.progPlane; 
            renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        }
    }

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);
    
    /*
    var lx = (ur[0] - ll[0]);
    var ly = (ll[1] - ur[1]);
    var px = (ll[0] - node.extents.ll[0]) / lx;
    var py = (ur[1] - node.extents.ll[1]) / ly;
    
    var llx = (node.extents.ur[0] - node.extents.ll[0]) / lx;
    var lly = (node.extents.ur[1] - node.extents.ll[1]) / ly;

    px = px / llx;
    py = py / lly;
    llx = 1.0/llx;
    lly = 1.0/lly;
    
    llx *= step1;
    lly *= step1;
    px *= step1;
    py *= step1;
    */

    var step1 = node.gridStep1 * factor;

    var lx = 1.0 / (ur[0] - ll[0]);
    var ly = 1.0 / (ll[1] - ur[1]);
    var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);
    var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);
    var px = (ll[0] - node.extents.ll[0]) * lx * llx;
    var py = (ur[1] - node.extents.ll[1]) * ly * lly;


    if (useTexture) {
        renderer.gpu.bindTexture(this.gridTexture.getGpuTexture());
        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);

        var tt = this.gridTexture.getTransform();

//        prog.setVec4('uParams3', [tt[2], tt[3]+tt[1], tt[0], tt[1]]);
        prog.setVec4('uParams3', [tt[2], tt[3], tt[0], tt[1]]);

        //prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly*0.5, llx*0.5]);
        prog.setVec4('uParams2', [0, 0, 0, 0]);
    } else {
        renderer.gpu.bindTexture(renderer.heightmapTexture);       
        prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/15, node.gridStep2 * factor]);
        prog.setVec4('uParams3', [(py - Math.floor(py)), (px - Math.floor(px)), lly, llx]);
        prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);
    }
    
    prog.setVec4('uFogColor', draw.atmoColor);

    //draw bbox
    renderer.planeMesh.draw(prog, 'aPosition', 'aTexCoord');    

    this.map.stats.drawnFaces += renderer.planeMesh.polygons;
}; 


MapSurfaceTile.prototype.drawHmapTile = function(cameraPos, divNode, angle, pipeline, texture) {
    //if ((this.texelSize == Number.POSITIVE_INFINITY || this.texelSize > 4.4) && this.metanode && this.metanode.hasChildren()) {
      //  return;
    //}
    
    if (!this.metanode) {
        return;
    }

    var map = this.map, node, ll, ur, res;
    var renderer = map.renderer;

    if (!renderer.progHmapPlane) {
        renderer.initProceduralShaders();
    }

    if (divNode) {
        node = divNode[0]; 
        ll = divNode[1][0];
        ur = divNode[1][1];
    } else {
        res = map.measure.getSpatialDivisionNodeAndExtents(this.id);
        node = res[0]; 
        ll = res[1][0];
        ur = res[1][1];
    }
   
    var middle = [(ur[0] + ll[0])* 0.5, (ur[1] + ll[1])* 0.5];
    var hasPoles = map.referenceFrame.hasPoles;
    angle = angle || this.metanode.diskAngle2;
    
    if ((hasPoles && !node.isPole) &&  Math.acos(angle) > Math.PI*0.1) {
        angle = Math.cos(Math.acos(angle) * 0.5); 
        
        this.drawHmapTile(cameraPos, [node, [ [ll[0], ll[1]],  [middle[0], middle[1]] ] ], angle);
        this.drawHmapTile(cameraPos, [node, [ [middle[0], ll[1]],  [ur[0], middle[1]] ] ], angle);

        this.drawHmapTile(cameraPos, [node, [ [ll[0], middle[1]],  [middle[0], ur[1]] ] ], angle);
        this.drawHmapTile(cameraPos, [node, [ [middle[0], middle[1]],  [ur[0], ur[1]] ] ], angle);
       
        return;
    }
     
    var desiredSamplesPerViewExtent = 5;
    var nodeExtent = node.extents.ur[1] - node.extents.ll[1];
    var viewExtent = this.distance ;//* 0.1;
    var lod = Math.log((desiredSamplesPerViewExtent * nodeExtent) / viewExtent) / map.log2;
    lod = Math.max(0,lod - 8 + node.id[0]);
   
    var h, factor, prog, draw = map.draw; 

    var sx = cameraPos[0];
    var sx = cameraPos[0];
    var sy = cameraPos[1];
    var sz = cameraPos[2];
    var buffer = draw.planeBuffer;
    var gridPoints = this.gridPoints;
    var useSurrogatez = map.config.mapGridSurrogatez;

    if (!gridPoints) {

//        h = this.metanode.minZ;
        h = 0;//this.metanode.minHeight;
        var n1 = node.getPhysicalCoords([ur[0], ur[1], h], true);
        var n2 = node.getPhysicalCoords([ur[0], ll[1], h], true);
        var n3 = node.getPhysicalCoords([ll[0], ll[1], h], true);
        var n4 = node.getPhysicalCoords([ll[0], ur[1], h], true);
        var mtop = node.getPhysicalCoords([middle[0], ur[1], h], true);
        var mbottom = node.getPhysicalCoords([middle[0], ll[1], h], true);
        var mleft = node.getPhysicalCoords([ll[0], middle[1], h], true);
        var mright = node.getPhysicalCoords([ur[0], middle[1], h], true);

        middle[2] = h;
        middle = node.getPhysicalCoords(middle, true);

        if (!divNode) {

            var gridPoints = [
                n4[0], n4[1], n4[2],
                mtop[0], mtop[1], mtop[2],
                n1[0], n1[1], n1[2],

                mleft[0], mleft[1], mleft[2],
                middle[0], middle[1], middle[2],
                mright[0], mright[1], mright[2],
                
                n3[0], n3[1], n3[2],
                mbottom[0], mbottom[1], mbottom[2],
                n2[0], n2[1], n2[2]
            ];

            this.gridPoints = gridPoints;

        } else {
            buffer[0] = n4[0] - sx;
            buffer[1] = n4[1] - sy;
            buffer[2] = n4[2] - sz;
            
            buffer[3] = mtop[0] - sx;
            buffer[4] = mtop[1] - sy;
            buffer[5] = mtop[2] - sz;

            buffer[6] = n1[0] - sx;
            buffer[7] = n1[1] - sy;
            buffer[8] = n1[2] - sz;

            buffer[9] = mleft[0] - sx;
            buffer[10] = mleft[1] - sy;
            buffer[11] = mleft[2] - sz;
                    
            buffer[12] = middle[0] - sx;
            buffer[13] = middle[1] - sy;
            buffer[14] = middle[2] - sz;
                    
            buffer[15] = mright[0] - sx;
            buffer[16] = mright[1] - sy;
            buffer[17] = mright[2] - sz;
                
            buffer[18] = n3[0] - sx;
            buffer[19] = n3[1] - sy;
            buffer[20] = n3[2] - sz;
            
            buffer[21] = mbottom[0] - sx;
            buffer[22] = mbottom[1] - sy;
            buffer[23] = mbottom[2] - sz;
            
            buffer[24] = n2[0] - sx;
            buffer[25] = n2[1] - sy;
            buffer[26] = n2[2] - sz;
        }
     }

    var mv = renderer.camera.getModelviewMatrix();
    var proj = renderer.camera.getProjectionMatrix();

    if (gridPoints) {
        buffer[0] = gridPoints[0] - sx;
        buffer[1] = gridPoints[1] - sy;
        buffer[2] = gridPoints[2] - sz;
        
        buffer[3] = gridPoints[3] - sx;
        buffer[4] = gridPoints[4] - sy;
        buffer[5] = gridPoints[5] - sz;

        buffer[6] = gridPoints[6] - sx;
        buffer[7] = gridPoints[7] - sy;
        buffer[8] = gridPoints[8] - sz;

        buffer[9] = gridPoints[9] - sx;
        buffer[10] = gridPoints[10] - sy;
        buffer[11] = gridPoints[11] - sz;
                
        buffer[12] = gridPoints[12] - sx;
        buffer[13] = gridPoints[13] - sy;
        buffer[14] = gridPoints[14] - sz;
                
        buffer[15] = gridPoints[15] - sx;
        buffer[16] = gridPoints[16] - sy;
        buffer[17] = gridPoints[17] - sz;
            
        buffer[18] = gridPoints[18] - sx;
        buffer[19] = gridPoints[19] - sy;
        buffer[20] = gridPoints[20] - sz;
        
        buffer[21] = gridPoints[21] - sx;
        buffer[22] = gridPoints[22] - sy;
        buffer[23] = gridPoints[23] - sz;
        
        buffer[24] = gridPoints[24] - sx;
        buffer[25] = gridPoints[25] - sy;
        buffer[26] = gridPoints[26] - sz;
    }

    if (hasPoles && !map.poleRadius && node.id[0] == 1 && !node.isPole) {
        var p = node.getPhysicalCoords([node.extents.ur[0], node.extents.ur[1], 0]);
        map.poleRadius = Math.sqrt(p[0]*p[0]+p[1]*p[1]); 
        map.poleRadiusFactor = 8 * Math.pow(2.0, 552058 / map.poleRadius); 
    }

    var mnode = this.metanode; 
    var testMode = draw.debug.drawTestMode;

    factor = 1;

    if (hasPoles && node.isPole) {
        factor = map.poleRadiusFactor; 
        prog = renderer.progPlane2; 
        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        prog.setVec4('uParams4', [-sx, -sy, map.poleRadius, 0]);
    } else {

        switch(testMode) {
            default:
            case 0: prog = renderer.progHmapPlane; break;
            case 1: prog = renderer.progHmapPlane2; break;
            case 2: prog = renderer.progHmapPlane5; break;
            case 3: prog = renderer.progHmapPlane6; break;
            case 4: prog = renderer.progHmapPlane7; break;

            case 8: prog = renderer.progHmapPlane4; break;
            case 9: prog = pipeline == 1 ? renderer.progHmapPlane3 : renderer.progHmapPlane8; break;
        }


        if (testMode == 3 || testMode == 4) {
            if (!renderer.ntextures) {
                renderer.ntextures = [ 
                    new GpuTexture(renderer.gpu, './textures/test/test001.png', renderer.core, null), //0
                    new GpuTexture(renderer.gpu, './textures/test/test002.png', renderer.core, null), //1
                    new GpuTexture(renderer.gpu, './textures/test003.jpg', renderer.core, null),      //2
                    new GpuTexture(renderer.gpu, './textures/download.png', renderer.core, null),     //3
                    new GpuTexture(renderer.gpu, './textures/test009.jpg', renderer.core, null),      //4
                    new GpuTexture(renderer.gpu, './textures/test004.jpg', renderer.core, null),      //5
                    new GpuTexture(renderer.gpu, './textures/test005.jpg', renderer.core, null),      //6
                    new GpuTexture(renderer.gpu, './textures/nor_sand.jpg', renderer.core, null),     //7
                    new GpuTexture(renderer.gpu, './textures/test007.jpg', renderer.core, null),      //8
                    new GpuTexture(renderer.gpu, './textures/test008.jpg', renderer.core, null),      //9

                    new GpuTexture(renderer.gpu, './textures/download (1).png', renderer.core, null),  //10
                    new GpuTexture(renderer.gpu, './textures/test010.jpg', renderer.core, null),      //11
                    new GpuTexture(renderer.gpu, './textures/test011.jpg', renderer.core, null),      //12
                    new GpuTexture(renderer.gpu, './textures/test012.jpg', renderer.core, null),      //13
                    new GpuTexture(renderer.gpu, './textures/test013.jpg', renderer.core, null),      //14
                    new GpuTexture(renderer.gpu, './textures/test014.jpg', renderer.core, null),      //15
                    new GpuTexture(renderer.gpu, './textures/test015.jpg', renderer.core, null),      //16
                    new GpuTexture(renderer.gpu, './textures/test016.jpg', renderer.core, null),      //17
                    new GpuTexture(renderer.gpu, './textures/test017.jpg', renderer.core, null),      //18
                    new GpuTexture(renderer.gpu, './textures/test018.jpg', renderer.core, null)      //18

                    ];
            }
        }

//        renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aBarycentric']);
        //renderer.gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
        renderer.gpu.useProgram(prog, ['aPosition']);
        prog.setVec3('uVector', mnode.diskNormal);

        //prog.setVec3('uRight', mnode.diskNormal);

        if (gridPoints) {
            var vecRight = [gridPoints[15] - gridPoints[12], gridPoints[16] - gridPoints[13], gridPoints[17] - gridPoints[14]];
            var vecTop = [gridPoints[21] - gridPoints[12], gridPoints[22] - gridPoints[13], gridPoints[23] - gridPoints[14]];

            vec3.normalize(vecRight);
            vec3.normalize(vecTop);

            var vecDir = mnode.diskNormal.slice();
            //vecDir = [-vecDir[0], -vecDir[1], -vecDir[2]];

            //prog.setVec3('uRight', vecRight);
            //prog.setVec3('uTop', vecTop);


            var mv = map.camera.camera.modelview;
            var mv2 = vts.mat3.create();

            vts.mat4.toInverseMat3(mv, mv2);

            //vts.mat4.toMat3(mv, mv2);
            vts.mat3.transpose(mv2);

            vts.mat3.multiplyVec3(mv2, vecTop);
            vts.mat3.multiplyVec3(mv2, vecDir);
            vts.mat3.multiplyVec3(mv2, vecRight);

            var space = [
                vecRight[0], vecRight[1], vecRight[2],
                vecTop[0], vecTop[1], vecTop[2],
                vecDir[0], vecDir[1], vecDir[2],
            ];

            /*
            var mv3 = vts.mat3.toMat4(mv2);
            vts.mat4.multiply(mv3, vts.mat3.toMat4(space), mv3);
            prog.setMat3('uSpace', vts.mat4.toMat3(mv3));
            */
            
            prog.setMat3('uSpace', space);
        }
    }

    prog.setMat4('uMV', mv);
    prog.setMat4('uProj', proj);
    prog.setFloatArray('uPoints', buffer);
    

    var step1 = node.gridStep1 * factor;
    prog.setVec4('uParams', [step1 * factor, draw.fogDensity, 1/127, node.gridStep2 * factor]);

    if (testMode >= 3 && testMode <= 4) {
        prog.setVec4('uParams3', [1,1,0,0]);
    } else {
        if (texture) {
            prog.setVec4('uParams3', texture.getTransform());
        } else {
            var lx = 1.0 / (ur[0] - ll[0]);
            var ly = 1.0 / (ll[1] - ur[1]);
            var llx = step1 / ((node.extents.ur[0] - node.extents.ll[0]) * lx);
            var lly = step1 / ((node.extents.ur[1] - node.extents.ll[1]) * ly);
            var px = (ll[0] - node.extents.ll[0]) * lx * llx;
            var py = (ur[1] - node.extents.ll[1]) * ly * lly;

            prog.setVec4('uParams3', [lly, llx, (py - Math.floor(py)), (px - Math.floor(px))]);
        }
    }

    prog.setVec4('uParams2', [0, 0, node.gridBlend, 0]);
    prog.setVec4('uFogColor', draw.atmoColor);


    if (this.hmap.extraBound) {
        //get height form parent
        mnode = this.hmap.extraBound.sourceTile.metanode;
        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);
        prog.setVec4('uTransform', this.hmap.getTransform());
    } else {
        prog.setVec3('uHeights', [mnode.minHeight, mnode.maxHeight, (1.0/mnode.pixelSize)]);
        prog.setVec4('uTransform', [1,1,0,0]);
    }

    if (testMode >= 3 && testMode <= 4) {
        if (!renderer.ntextures[draw.debug.drawTestData].loaded) {
            return;
        }
        renderer.gpu.bindTexture(renderer.ntextures[draw.debug.drawTestData]);
    } else {
        if (texture) {
            renderer.gpu.bindTexture(texture.getGpuTexture());
        } else {
            renderer.gpu.bindTexture(renderer.heightmapTexture);
        }
    }

    prog.setSampler('uSampler', 0);    

//    if(this.hmap) {
        renderer.gpu.bindTexture(this.hmap.getGpuTexture(), 1);
  //  } else {
        //renderer.gpu.bindTexture(renderer.blackTexture, 1);
  //      renderer.gpu.bindTexture(renderer.blackTexture2, 1);
   // }

    prog.setSampler('uSampler2', 1);    

    //draw bbox
    //renderer.planeMesh2.draw(prog, 'aPosition', 'aTexCoord');    
    renderer.planeMesh2.draw(prog, 'aPosition');    

    /*
    if (vecRight && gridPoints) {
        //renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);
        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[15], gridPoints[16], gridPoints[17]]], false, 4, [1,0,0,1], null, false, false, false, false);
        renderer.draw.drawLineString([[gridPoints[12], gridPoints[13], gridPoints[14]], [gridPoints[21], gridPoints[22], gridPoints[23]]], false, 4, [0,0,1,1], null, false, false, false, false);

        renderer.draw.drawLineString([[0, 0, 0], [9000000, 0, 0]], false, 4, [1,0,0,1], null, false, false, false, false);
        renderer.draw.drawLineString([[0, 0, 0], [0, 9000000, 0, 0]], false, 4, [0,1,0,1], null, false, false, false, false);
        renderer.draw.drawLineString([[0, 0, 0], [0, 0, 9000000]], false, 4, [0,0,1,1], null, false, false, false, false);
    }*/


    this.map.stats.drawnFaces += renderer.planeMesh2.polygons;
}; 


/* harmony default export */ __webpack_exports__["a"] = (MapSurfaceTile);




/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_math__ = __webpack_require__(4);



//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_0__utils_math__["a" /* math */];


var MapTrajectory = function(map, p1, p2, options) {
    this.map = map;
    this.p1 = p1.clone();
    this.p2 = p2.clone();
    this.op2 = p2.clone();

    var hm1 = this.p1.getHeightMode();
    var hm2 = this.p2.getHeightMode();
    
    if (hm1 == 'fix' && hm2 == 'float') {
        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'float', true);
    } else if (hm1 == 'float' && hm2 == 'fix') {
        this.p1 = this.map.convert.convertPositionHeightMode(this.p1, 'fix', true);
    } 
    
    var vm1 = this.p1.getViewMode();
    var vm2 = this.p2.getViewMode();

    if (vm1 == 'subj' && vm2 == 'obj') {
        this.p2 = this.map.convert.convertPositionViewMode(this.p2, 'subj');
    } else if (vm1 == 'obj' && vm2 == 'subj') {
        this.p1 = this.map.convert.convertPositionViewMode(this.p1, 'subj');
    } 
    
    this.p1.pos[5] = this.p1.pos[5] < 0 ? (360 + (this.p1.pos[5] % 360)) : (this.p1.pos[5] % 360);  
    this.p2.pos[5] = this.p2.pos[5] < 0 ? (360 + (this.p2.pos[5] % 360)) : (this.p2.pos[5] % 360);  
    
    this.pp1 = this.p1.clone();

    this.mode = options['mode'] || 'auto';
    this.submode = options['submode'] || 'none';
    this.submode = 'none';
    this.maxHeight = options['maxHeight'] || 1000000000;
    this.minDuration = options['minDuration'] || 0;
    this.maxDuration = options['maxDuration'] || 10000;
    this.samplePeriod = options['samplePeriod'] || 10;
    this.fade = options['fade'] || 'none';
    this.fadePower = options['fadePower'] || 1;
    this.yawInterpolation = options['yawInterpolation'] || 'shortest';

    this.pv = options['pv'] || 0.15;

    if (!this.map.getNavigationSrs().isProjected()) {
        this.geodesic = this.map.measure.getGeodesic();
    } 
    
    if (options['distanceAzimuth']) {
        this.distanceAzimuth = true;
        
        this.pp2 = this.p1.clone();
        if (options['destHeight']) {
            this.pp2.setHeight(options['destHeight']);
        }

        if (options['destOrientation']) {
            this.pp2.setHeight(options['destOrientation']);
        }
        
        if (options['destFov']) {
            this.pp2.setHeight(options['destFov']);
        }

        this.geoAzimuth = options['azimuth'] || 0; 
        this.geoDistance = options['distance'] || 100;
        this.distance = this.geoDistance; 
        this.azimuth = this.geoAzimuth % 360;
        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;

    } else {
        this.distanceAzimuth = false;
            
        this.pp2 = this.p2.clone();

        //get distance and azimut
        var res = this.map.measure.getDistance(this.pp1.getCoords(), this.pp2.getCoords());
        this.distance = res[0];
        this.azimuth = (res[1] + 90) % 360;
        this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;

        if (!this.map.getNavigationSrs().isProjected()) {
            res = this.geodesic.Inverse(this.pp1.pos[2], this.pp1.pos[1], this.pp2.pos[2], this.pp2.pos[1]);
            this.geoAzimuth = res.azi1; 
            this.geoDistance = res.s12;
            this.azimuth = this.geoAzimuth % 360;
            this.azimuth = (this.azimuth < 0) ? (360 + this.azimuth) : this.azimuth;
        }
    }
    
    //console.log("azim: " + Math.round(this.azimuth) + " p1: " + this.p1.pos[5]  + " p2: " + this.p2.pos[5]);

    this.detectMode();
    this.detectDuration();
    this.detectFlightHeight(options['height']);
};


MapTrajectory.prototype.detectFlightHeight = function(flightHeight) {
    if (this.mode == 'ballistic') {
        this.flightHeight = Math.max(this.pp1.getHeight(), this.pp2.getHeight());
        this.flightHeight += flightHeight || (this.distance * 0.5);
        this.flightHeight = Math.min(this.flightHeight, this.maxHeight);
        this.flightHeight -= Math.max(this.pp1.getHeight(), this.pp2.getHeight());
    }
};


MapTrajectory.prototype.detectMode = function() {
    if (this.mode == 'auto') {
        this.mode = (this.distance > 2000) ? 'ballistic' : 'direct';
    }
};


MapTrajectory.prototype.detectDuration = function() {
    this.duration = 0;
    this.headingDuration = 1000;
    
    if (this.distance < 500) {
        this.duration = 1000;
    } else if (this.distance < 2000) {
        this.duration = 2000;
    } else {
        this.duration = this.distance / 100;

        if (this.duration < 300) {
            this.duration = 3000;
        } else {
            this.headingDuration = 1500;
        }
        
        if (this.duration < 6000) {
            this.duration = 6000;
        }

        if (this.duration > 10000) {
            this.duration = 10000;
        }

        if (this.mode != 'direct') {
            this.duration *= 1.8;
            this.headingDuration *= 1.8;
        }
    }
    
    if (this.mode != 'direct') {
        var minDuration = 3 * this.headingDuration; 
        this.duration = Math.max(this.duration, minDuration);
        
        if (this.maxDuration < minDuration) {
            this.duration = this.maxDuration;
            this.headingDuration = this.maxDuration / 3;
        }   
    }    
    
    this.duration = Math.min(this.duration, this.maxDuration);
    this.duration = Math.max(this.duration, this.minDuration);
};

    
MapTrajectory.prototype.generate = function() {
    var samples = new Array(Math.ceil(this.duration / this.samplePeriod)+(this.distanceAzimuth?0:1));
    var index = 0;
    
    for (var time = 0; time <= this.duration; time += this.samplePeriod) {
        var factor = time / this.duration;

        var p = this.pp1.clone(), x, coords;
        
        if (this.mode == 'direct') {

            x = factor;
            
            switch(this.fade) {
            case 'in':
                switch(this.fadePower) {
                case 1: factor = x*x; break;
                case 2: factor = x*x*x; break;
                case 3: factor = x*x*x*x; break;
                case 4: factor = x*x*x*x*x; break;
                case 5: factor = x*x*x*x*x*x; break;
                case 6: factor = x*x*x*x*x*x*x; break;
                }
                break;

            case 'out':
                x = 1 - x;
                switch(this.fadePower) {
                case 1: factor = 1 - (x*x); break;
                case 2: factor = 1 - (x*x*x); break;
                case 3: factor = 1 - (x*x*x*x); break;
                case 4: factor = 1 - (x*x*x*x*x); break;
                case 5: factor = 1 - (x*x*x*x*x*x); break;
                case 6: factor = 1 - (x*x*x*x*x*x*x); break;
                }
                break;

            case 'inout':
                switch(this.fadePower) {
                case 1: factor = x*x*(3 - 2*x); break;
                case 2: factor = x*x*x * (x * (6*x - 15) + 10); break;
                case 3: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;
                case 4: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;
                case 5: factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); x = factor; factor = x*x*(3 - 2*x); break;
                case 6: factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); x = factor; factor = x*x*x * (x * (6*x - 15) + 10); break;
                }
                break;
            }
            
            p.setCoords(this.getInterpolatedCoords(factor));
            p.setHeight(this.getInterpolatedHeight(factor));
            
            var o1 = this.pp1.getOrientation(); 
            var o2 = this.pp2.getOrientation(); 

            p.setOrientation(this.getInterpolatedOrinetation(o1, o2, factor));
            p.setFov(this.getInterpolatedFov(factor));
            p.setViewExtent(this.getInterpolatedViewExtent(factor));
            
            samples[index] = p.pos;
            index++;
        } else {

            //http://en.wikipedia.org/wiki/Smoothstep
            x = factor;
            factor =  x*x*(3 - 2*x);
            x = factor;
            factor =  x*x*(3 - 2*x);

            //factor2 includes slow start and end of flight
            var factor2 =  this.getSmoothFactor(time);
            
            if (this.submode == 'piha') {
                
                var distanceFactor = (this.distance / this.duration * (time - this.duration / (2 * Math.PI) * Math.sin(2 * Math.PI / this.duration * time))) / this.distance;

                //var f = (time / this.duration) * Math.PI * 2;
                //var distanceFactor = ((f - Math.sin(f)) / (2 * Math.PI));
                
                var pv = this.pv;
                var h1 = this.pp1.getCoords()[2]; 
                var h2 = this.pp2.getCoords()[2]; 

                var height = this.distance / ((this.duration*0.001) * pv * Math.tan(math.radians(this.pp1.getFov()) * 0.5))
                              * (1 - Math.cos(2 * Math.PI * time / this.duration))
                              + h1 + (h2 - h1) * time  / this.duration;

                coords = this.getInterpolatedCoords(distanceFactor);

                p.setCoords(coords);
                p.setHeight(height);            
            } else {

                coords = this.getInterpolatedCoords(factor2);
    
                p.setCoords(coords);
                p.setHeight(this.getSineHeight(factor));            
            }
            
            if (coords[3] != null) { //used for correction in planet mode
                this.azimuth = -coords[3];
            }

            p.setOrientation(this.getFlightOrienation(time));
            p.setFov(this.getInterpolatedFov(factor));
            p.setViewExtent(this.getInterpolatedViewExtent(factor));
            
            //p.convertViewMode("subj");
            //console.log("pos: " + p.toString());

            samples[index] = p.pos;
            samples[index] = p.pos;
            index++;
        }
    }
    
    if (!this.distanceAzimuth) {
        samples[index] = this.op2.clone().pos;
    }

    //console.log("pos2: " + this.p2.toString());

    return samples;
};


MapTrajectory.prototype.getInterpolatedCoords = function(factor) {
    var c1 = this.pp1.getCoords(); 
    var c2 = this.pp2.getCoords(); 

    if (!this.map.getNavigationSrs().isProjected()) {
        var res = this.geodesic.Direct(c1[1], c1[0], this.geoAzimuth, this.geoDistance * factor);

        var azimut = res.azi1 - res.azi2;

        //var azimut = (azimut - 90) % 360;
        azimut = (this.azimuth < 0) ? (360 + azimut) : azimut;

        //azimut = this.azimuth;


        return [ res.lon2, res.lat2,
            c1[2] + (c2[2] - c1[2]) * factor, azimut];

    } else {
        return [ c1[0] + (c2[0] - c1[0]) * factor,
            c1[1] + (c2[1] - c1[1]) * factor,
            c1[2] + (c2[2] - c1[2]) * factor ];
    }
};


MapTrajectory.prototype.getInterpolatedOrinetation = function(o1, o2, factor) {
    var od1 = o2[0] - o1[0];
    var od2 = o2[1] - o1[1];
    var od3 = o2[2] - o1[2];

    if (this.yawInterpolation == 'shortest') {
        if (Math.abs(od1) > 180) {
            if (od1 > 0) {
                od1 = -(360 - od1);
            } else {
                od1 = 360 - Math.abs(od1);
            }
        }
    }

    return [ o1[0] + od1 * factor,
        o1[1] + od2 * factor,
        o1[2] + od3 * factor ];
};


MapTrajectory.prototype.getInterpolatedFov = function(factor) {
    var f1 = this.pp1.getFov(); 
    var f2 = this.pp2.getFov(); 
    return f1 + (f2 - f1) * factor;
};


MapTrajectory.prototype.getInterpolatedViewExtent = function(factor) {
    var v1 = this.pp1.getViewExtent(); 
    var v2 = this.pp2.getViewExtent(); 
    return v1 + (v2 - v1) * factor;
};


MapTrajectory.prototype.getInterpolatedHeight = function(factor) {
    var h1 = this.pp1.getHeight(); 
    var h2 = this.pp2.getHeight(); 
    return h1 + (h2 - h1) * factor;
};


MapTrajectory.prototype.getSineHeight = function(factor) {
    var c1 = this.pp1.getCoords(); 
    var c2 = this.pp2.getCoords(); 

    return c1[2] + (c2[2] - c1[2]) * factor +
           Math.sin(Math.PI * factor) * this.flightHeight;
};


MapTrajectory.prototype.getSmoothFactor = function(time) {
    var x = 0;

    if (time < this.headingDuration) {
        x = 0;
    } else if (time > (this.duration - this.headingDuration)) {
        x = 1.0;
    } else {
        x = Math.min(1.0, (time-this.headingDuration) / (this.duration - this.headingDuration*2));
    }

    x = x*x*(3 - 2*x);
    return x*x*(3 - 2*x);
};


MapTrajectory.prototype.getFlightOrienation = function(time) {
    var o1 = null;
    var o2 = null;
    var fo = [0, -90, 0]; //flight orientation
    var factor = 0;

    //get fly direction angle
    fo[0] = this.azimuth % 360;

    if (fo[0] < 0) {
        fo[0] = 360 - Math.abs(fo[0]);
    }

    if (time <= this.headingDuration) { //start sequence
        factor = time / this.headingDuration;
        o1 = this.pp1.getOrientation();
        o2 = fo;
    } else if (time >= this.duration - this.headingDuration) { //end sequence
        factor = (time - (this.duration - this.headingDuration)) / this.headingDuration;
        o1 = fo;
        o2 = this.pp2.getOrientation();
    } else { //fly sequence
        factor = 0;
        o1 = fo;
        o2 = fo;
    }    
    
    return this.getInterpolatedOrinetation(o1, o2, factor);
};


/* harmony default export */ __webpack_exports__["a"] = (MapTrajectory);





/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_url__ = __webpack_require__(12);




//get rid of compiler mess
var utilsUrl = __WEBPACK_IMPORTED_MODULE_1__utils_url__["a" /* utilsUrl */];
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];


var MapUrl = function(map, path) {
    this.map = map;

    path = path.trim();
    this.baseUrl = utilsUrl.getBase(path);
    this.baseUrlSchema = utilsUrl.getSchema(path);
    this.baseUrlOrigin = utilsUrl.getOrigin(path); 

    this.urlCounter = 0;
};


MapUrl.prototype['quad'] = function(lod, ix, iy) {
    var quadKey = '';
    //ty = Math.pow(2,zoom - 1) - ty;
    for (var i = lod; i > 0; i--) {
        var digit = 0;
        var mask = 1 << (i-1);
        if ((ix & mask) != 0) {
            digit += 1;
        }

        if ((iy & mask) != 0) {
            digit += 2;
        }

        quadKey += digit;
    }

    return quadKey;
};


MapUrl.prototype['msDigit'] = function(iy, ix) {
    return (((iy & 3) << 1) + (ix & 1));
};


MapUrl.prototype.hex = function(v) {
    var s = v.toString(16);
    while (s.length < 8) {
        s = '0' + s;
    }
    return s;
};


MapUrl.prototype['ppx'] = function(lod, ix) {
    return this.hex(ix << (28 - lod), 7);
};


MapUrl.prototype['ppy'] = function(lod, iy) {
    return this.hex((1 << 28) - ((iy + 1) << (28 - lod)), 7);
};


MapUrl.prototype.processUrlFunction = function(id, counter, string) {
    var string2, fc;
    if (typeof string == 'string') {
        if (string.indexOf('quad') != -1) {
            string2 = '(function(lod,x,y,loclod,locx,locy){' + string.replace('quad', 'return this.quad') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.ix, id.iy, id.loclod, id.locx, id.locy);
            } catch(e) {
                return string;
            }
        } else if (string.indexOf('msdigit') != -1) {
            string2 = '(function(x,y,loclod,locx,locy){' + string.replace('msdigit', 'return this.msDigit') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.ix, id.iy, id.loclod, id.locx, id.locy);
            } catch(e) {
                return string;
            }

        } else if (string.indexOf('alt') != -1) {
            var result = /\(([^)]*)\)/.exec(string);

            if (result && result[1]) {
                var strings = result[1].match(/([^,]+)/g);

                if (strings.length > 0) {
                    return strings[(counter % strings.length)];
                }
            }

            return string;

        } else if (string.indexOf('ppx') != -1) {
            string2 = '(function(lod,x,loclod,locx){' + string.replace('ppx', 'return this.ppx') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.ix, id.loclod, id.locx);
            } catch(e) {
                return string;
            }

        } else if (string.indexOf('ppy') != -1) {
            string2 = '(function(lod,y,loclod,locy){' + string.replace('ppy', 'return this.ppy') + '})';

            try {
                fc = eval(string2).bind(this);
                return fc(id.lod, id.iy, id.loclod, id.locy);
            } catch(e) {
                return string;
            }

        } else {
            return string;
        }

    } else {
        return string;
    }
};


MapUrl.prototype.findLocalRoot = function(id) {
    var nodes = this.map.referenceFrame.getSpatialDivisionNodes();
    var validNodes = [];  

    for (var i = 0, li = nodes.length; i < li; i++) {
        var node = nodes[i];
        
        var delta = id[0] - node.id[0];
        var ix = id[1] >> delta;
        var iy = id[2] >> delta;
        
        if (ix == node.id[1] && iy == node.id[2]) {
            validNodes.push(node);           
        }
    }

    var bestNode = null;
    var bestLod = -1;
    
    for (i = 0, li = validNodes.length; i < li; i++) {
        if (validNodes[i].id[0] > bestLod) {
            bestNode = validNodes[i]; 
        }
    }
    
    if (bestNode) {
        return bestNode.id.slice();
    } else {
        return [0,0,0];
    }
};


MapUrl.prototype.makeUrl = function(templ, id, subId, skipBaseUrl) {
    //if (templ.indexOf("jpg") != -1) {
       //templ = "{lod}-{easting}-{northing}.jpg?v=4";
       //templ = "{lod}-{x}-{y}.jpg?v=4";
       //templ = "{quad(lod,x,y)}.jpg?v=4";
       //templ = "{quad(lod,x+1,y*2)}.jpg?v=4";
       //templ = "{lod}-{msdigit(x,y)}.jpg?v=4";
    //}
    //templ = "maps{alt(1,2,3,4)}.irist-test.citationtech.net/map/{lod}-{x}-{y}.jpg?v=4";

    var locx = 0;
    var locy = 0;
    var loclod = 0;

    if (id.lod) {
        var localRoot = this.findLocalRoot([id.lod, id.ix, id.iy]);    
        loclod = id.lod - localRoot[0];
        var mask = (1 << loclod) - 1;
        locx = id.ix & mask;
        locy = id.iy & mask;        
    }
    
    var id2 = {
        lod: id.lod,
        ix : id.ix,
        iy : id.iy,
        loclod: loclod,
        locx : locx,
        locy : locy
    };

    //remove white spaces from template
    templ = templ.replace(/ /g, '');

    var url = utils.simpleFmtObjOrCall(templ, {'lod':id.lod,  'x':id.ix, 'y':id.iy, 'sub': subId,
        'locx':locx, 'locy':locy, 'loclod':loclod, 'geonavtile': subId,
        'hereappid': 'abcde', 'hereappcode':'12345'},
                                               this.processUrlFunction.bind(this, id2, this.urlCounter));

    this.urlCounter++;

    skipBaseUrl = (url.indexOf('//') != -1);

    /* //useful for debug
    var tmp;

    if (skipBaseUrl) {
        tmp =  url;
    } else {
        tmp = this.baseUrl + url;
    }
    */

    if (skipBaseUrl) {
        if (url.indexOf('//') == 0) {
            return this.baseUrlSchema + url;
        } else {
            return url;
        }
    } else {
        return this.baseUrl + url;
    }
};


MapUrl.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }
    
    url = url.trim();

    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url; 
    }
};


/* harmony default export */ __webpack_exports__["a"] = (MapUrl);



/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__renderer_bbox__ = __webpack_require__(5);




//get rid of compiler mess
var BBox = __WEBPACK_IMPORTED_MODULE_1__renderer_bbox__["a" /* default */];
var utils = __WEBPACK_IMPORTED_MODULE_0__utils_utils__["a" /* utils */];


var MapVirtualSurface = function(map, json) {
    this.map = map;
    this.id = null;
    this.metaUrl = '';
    this.mappingUrl = '';
    this.baseUrl = this.map.url.baseUrl;
    this.baseUrlSchema = this.map.url.baseUrlSchema;
    this.baseUrlOrigin = this.map.url.baseUrlOrigin;
    this.lodRange = [0,0];
    this.tileRange = [[0,0],[0,0]];
    this.surfaces = [];
    this.parseJson(json);
    this.virtual = true;
    this.ready = false;
};


MapVirtualSurface.prototype.parseJson = function(json) {
    this.id = json['id'] || null;
    this.metaUrl = this.processUrl(json['metaUrl'], '');
    this.mappingUrl = this.processUrl(json['mapping'], '');
    this.lodRange = json['lodRange'] || [0,0];
    this.tileRange = json['tileRange'] || [[0,0],[0,0]];
    this.strId = this.id ? this.id.join(';') : null;

    if (this.id) {
        var tmp = this.id.slice();
        tmp.sort(); 
        this.strId = tmp.join(';');
    }

    if (json['extents']) {
        var ll = json['extents']['ll'];
        var ur = json['extents']['ur'];
        this.extents = new BBox(ll[0], ll[1], ll[2], ur[0], ur[1], ur[2]);
    } else {
        this.extents = new BBox(0,0,0,1,1,1);
    }

    this.specificity = Math.pow(2,this.lodRange[0]) / ((this.tileRange[1][0] - this.tileRange[1][0]+1)*(this.tileRange[1][1] - this.tileRange[1][1]+1));    

    utils.loadBinary(this.mappingUrl, this.onMappingFileLoaded.bind(this), this.onMappingFileLoadError.bind(this), (utils.useCredentials ? (this.jsonUrl.indexOf(this.map.url.baseUrl) != -1) : false), this.map.core.xhrParams);
};


MapVirtualSurface.prototype.onMappingFileLoaded = function(data) {
    this.parseMappingFile(new DataView(data));            
    this.ready = true;
    this.map.refreshView();
};


MapVirtualSurface.prototype.onMappingFileLoadError = function() {
};


MapVirtualSurface.prototype.parseMappingFile = function(data) {
    var index = 0;

    var magic = '';
    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;
    magic += String.fromCharCode(data.getUint8(index, true)); index += 1;

    if (magic != 'TM') {
        return false;
    }

    var count = data.getUint16(index, true); index += 2;

    for (var i = 0; i < count; i++) {
        var size = data.getUint8(index, true); index += 1;
        var id = [];

        for (var j = 0; j < size; j++) {
            var s = data.getUint16(index, true); index += 2;
            s = this.id[s];
            
            if (s) {
                id.push(s);
            }
        }
        
        if (id.length == 1) { //get surface
            this.surfaces.push(this.map.getSurface(id[0]));
        } else { //get glue
            this.surfaces.push(this.map.getGlue(id.join(';')));
        }
    }

    return true;    
};


MapVirtualSurface.prototype.getInfo = function() {
    return {
        'metaUrl' : this.metaUrl,
        'mapping' : this.mappingUrl,
        'lodRange' : this.lodRange,
        'tileRange' : this.tileRange
    };
};


MapVirtualSurface.prototype.processUrl = function(url, fallback) {
    if (!url) {
        return fallback;
    }

    url = url.trim();
    
    if (url.indexOf('://') != -1) { //absolute
        return url;
    } else if (url.indexOf('//') == 0) {  //absolute without schema
        return this.baseUrlSchema + url;
    } else if (url.indexOf('/') == 0) {  //absolute without host
        return this.baseUrlOrigin + url;
    } else {  //relative
        return this.baseUrl + url; 
    }
};


MapVirtualSurface.prototype.hasTile = function(id) {
    var shift = id[0] - this.lodRange[0];

    if (shift < 0) {
        return false;
    }

    var x = id[1] >> shift;
    var y = id[2] >> shift;

    if (id[0] < this.lodRange[0] || id[0] > this.lodRange[1] ||
        x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
        y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
        return false;
    }

    return true;
};


MapVirtualSurface.prototype.hasTile2 = function(id) {
    var shift = id[0] - this.lodRange[0];
    var above = (shift < 0);

    if (id[0] < this.lodRange[0]) {
        shift = -shift;
        var x1 = this.tileRange[0][0] >> shift;
        var y1 = this.tileRange[0][1] >> shift;
        var x2 = this.tileRange[1][0] >> shift;
        var y2 = this.tileRange[1][1] >> shift;
    
        if (id[0] > this.lodRange[1] ||
            id[1] < x1 || id[1] > x2 ||
            id[2] < y1 || id[2] > y2 ) {
            return [false , false];
        }
    } else {
        var x = id[1] >> shift;
        var y = id[2] >> shift;
    
        if (id[0] > this.lodRange[1] ||
            x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return [false , false];
        }
    }

    return [true, above];
};


MapVirtualSurface.prototype.hasMetatile = function(id) {
    if (id[0] > this.lodRange[1]) {
        return false;
    }

    var shift = id[0] - this.lodRange[0];

    if (shift >= 0) {
        var x = id[1] >> shift;
        var y = id[2] >> shift;

        if (x < this.tileRange[0][0] || x > this.tileRange[1][0] ||
            y < this.tileRange[0][1] || y > this.tileRange[1][1] ) {
            return false;
        }

    } else {
        shift = -shift;

        if (id[1] < (this.tileRange[0][0]>>shift) || id[1] > (this.tileRange[1][0]>>shift) ||
            id[2] < (this.tileRange[0][1]>>shift) || id[2] > (this.tileRange[1][1]>>shift) ) {
            return false;
        }
    }

    return true;
};


//used only for glues
MapVirtualSurface.prototype.getSurface = function(index) {
    return this.surfaces[index - 1];
};


MapVirtualSurface.prototype.getMetaUrl = function(id, skipBaseUrl) {
    return this.map.url.makeUrl(this.metaUrl, {lod:id[0], ix:id[1], iy:id[2] }, null, skipBaseUrl);
};


/* harmony default export */ __webpack_exports__["a"] = (MapVirtualSurface);



/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);




//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], vec4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["c" /* vec4 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];


var Camera = function(parent, fov, near, far) {
    this.parent = parent;
    this.position = [0,0,0];
    this.orientation = [0,0,0];
    this.aspect = 1;
    this.fov = fov;
    this.fovTan = Math.tan(fov * Math.PI / 180.0);
    this.fovDist = 1;
    this.near = near;
    this.far = far;
    this.rotationByMatrix = false;

    // derived quantities, calculated from camera parameters by update()
    this.modelview = mat4.create();
    this.rotationview = mat4.create();
    this.projection = mat4.create();
    this.mvp = mat4.create();
    this.mvp32 = new Float32Array(16);
    this.modelview32 = new Float32Array(16);
    this.rotationview32 = new Float32Array(16);
    this.projection32 = new Float32Array(16);

    this.frustumPlanes = [ [0,0,0,0], [0,0,0,0], [0,0,0,0],
                           [0,0,0,0], [0,0,0,0], [0,0,0,0] ];
    this.bboxPoints = [
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ],
        [ 0, 0, 0, 1 ]
    ];

    //reduce garbage collection
    this.scaleFactorVec = [0,0,0,0];
    this.dirty = true;
};


Camera.prototype.setPosition = function(position) {
    this.position = position;
    this.dirty = true;
};


Camera.prototype.setOrientation = function(orientation) {
    this.rotationByMatrix = false;
    this.orientation = orientation;
    this.dirty = true;
};


Camera.prototype.setRotationMatrix = function(matrix){
    this.rotationByMatrix = true;
    this.rotationview = matrix.slice();
    this.dirty = true;
};


// Sets the viewport aspect ratio (width / height). Should be called
// whenever the rendering viewport changes.
Camera.prototype.setAspect = function(aspect) {
    this.aspect = aspect;
    this.dirty = true;
};


Camera.prototype.setViewHeight = function(height) {
    this.viewHeight = height;
    this.dirty = true;
};


Camera.prototype.setOrtho = function(state) {
    this.ortho = state;
    this.dirty = true;
};


Camera.prototype.setParams = function(fov, near, far) {
    this.fov = fov;
    this.near = near;
    this.far = far;
    this.dirty = true;
};


Camera.prototype.clone = function(newFov) {
    var camera = new Camera(this. parent, (newFov != null) ? newFov : this.getFov(), this.getNear(), this.getFar());

    camera.setPosition(this.getPosition());
    camera.setOrientation(this.getOrientation());
    camera.setAspect(this.getAspect());
    camera.update();

    return camera;
};


// simple getters
Camera.prototype.getPosition = function(){ return [this.position[0], this.position[1], this.position[2]]; };
Camera.prototype.getOrientation = function(){ return [this.orientation[0], this.orientation[1], this.orientation[2]]; };
Camera.prototype.getAspect = function(){ return this.aspect; };
Camera.prototype.getFov = function(){ return this.fov; };
Camera.prototype.getNear = function(){ return this.near; };
Camera.prototype.getFar = function(){ return this.far; };
Camera.prototype.getViewHeight = function(){ return this.viewHeight; };
Camera.prototype.getOrtho = function(){ return this.ortho; };


// Returns rotation matrix
Camera.prototype.getRotationviewMatrix = function() {
    if (this.dirty) this.update();
    return this.rotationview;
};

Camera.prototype.getRotationviewFMatrix = function() {
    if (this.dirty) this.update();
    return this.rotationview32;
};

// Returns a matrix that transforms the world space to camera space.
Camera.prototype.getModelviewMatrix = function(){
    if (this.dirty) this.update();
    return this.modelview;
};

Camera.prototype.getModelviewFMatrix = function(){
    if (this.dirty) this.update();
    return this.modelview32;
};


// Returns a matrix that transforms the camera space to screen space.
Camera.prototype.getProjectionMatrix = function() {
    if (this.dirty) this.update();
    return this.projection;
};

Camera.prototype.getProjectionFMatrix = function() {
    if (this.dirty) this.update();
    return this.projection32;
};


// Returns projectionMatrix() * modelviewMatrix()
Camera.prototype.getMvpMatrix = function() {
    if (this.dirty) this.update();
    return this.mvp;
};

Camera.prototype.getMvpFMatrix = function() {
    if (this.dirty) this.update();
    return this.mvp32;
};

// Returns how much a length unit located at a point in world space is
// stretched when projected to the sceen space.
Camera.prototype.scaleFactor = function(worldPos, returnDist) {
    if (this.dirty) this.update();

    //var camPos = vec4.create();
    //mat4.multiplyVec4(this.modelview, worldPos, camPos);
    mat4.multiplyVec3(this.modelview, worldPos, this.scaleFactorVec);
    var dist = vec3.length(this.scaleFactorVec); // distance from camera

    // the expression "projection(0,0) / depth" is the derivative of the
    // screen X position by the camera space X coordinate.

    // ('dist' is used instead of camera depth (camPos(2)) to make the tile
    // resolution independent of camera rotation)

    if (returnDist) {
        if (dist < this.near) return [Number.POSITIVE_INFINITY, dist];
        return [this.projection[0] / dist, dist]; 
        //return [(this.projection[5]*0.5) / dist, dist]; //projection by sy
    }

    if (dist < this.near) return Number.POSITIVE_INFINITY;
    return this.projection[0] / dist;
    //return (this.projection[5]*0.5) / dist; //projection by sy
};


Camera.prototype.scaleFactor2 = function(dist) {
    if (this.dirty) this.update();

    if (dist < this.near) return Number.POSITIVE_INFINITY;
    return this.projection[0] / dist;
    //return (this.projection[5]*0.5) / dist; //projection by sy
};


Camera.prototype.distance = function(worldPos) {
    var delta = vec3.create();
    vec3.subtract(this.position, worldPos, delta);
    return vec3.length(delta);
};


// Returns true if point is inside camera frustum.
Camera.prototype.pointVisible = function(point, shift) {
    if (this.dirty) this.update();

    var p;

    if (shift) {
        p = [ point[0] - shift[0], point[1] - shift[1], point[2] - shift[2], 1 ];
    } else {
        p = [ point[0], point[1], point[2], 1 ];
    }

    // test all frustum planes quickly
    for (var i = 0; i < 6; i++) {
        // check if point lie on the negative side of the frustum plane
        if (vec4.dot(this.frustumPlanes[i], p) < 0) {
            return false;
        }
    }

    // the box might be inside - further testing should be done here - TODO!
    return true;
};


// Returns true if the box intersects the camera frustum.
Camera.prototype.pointsVisible = function(points, shift) {
    if (this.dirty) this.update();
   
    var planes = this.frustumPlanes;
    var lj = points.length, sx, sy, sz;

    if (shift) {
        sx = shift[0];
        sy = shift[1];
        sz = shift[2];
    } else {
        sx = 0;
        sy = 0;
        sz = 0;
    }
        
    var dot = vec4.dot3;

    // test all frustum planes quickly
    for (var i = 0; i < 6; i++) {
        // check if all points lie on the negative side of the frustum plane
        var negative = true;
        var plane = planes[i];
        for (var j = 0; j < lj; j+=3) {
            if (dot(plane, points, j, sx, sy, sz) >= 0) {
                //return false;
                negative = false;
                break;
            }
        }
        if (negative) return false;
    }

    return true;
};


// Returns true if the box intersects the camera frustum.
Camera.prototype.bboxVisible = function(bbox, shift) {
    if (this.dirty) this.update();

    var min = bbox.min;
    var max = bbox.max;
    var points = this.bboxPoints;
    var p, minX, minY, minZ, maxX, maxY, maxZ;

    if (shift) {
        minX = min[0] - shift[0];        
        minY = min[1] - shift[1];        
        minZ = min[2] - shift[2];        
       
        maxX = max[0] - shift[0];        
        maxY = max[1] - shift[1];        
        maxZ = max[2] - shift[2];        
    } else {
        minX = min[0];        
        minY = min[1];        
        minZ = min[2];        

        maxX = max[0];        
        maxY = max[1];        
        maxZ = max[2];        
    }

    p = points[0];
    p[0] = minX;  p[1] = minY; p[2] = minZ; 
    p = points[1];
    p[0] = minX;  p[1] = minY; p[2] = maxZ; 
    p = points[2];
    p[0] = minX;  p[1] = maxY; p[2] = minZ; 
    p = points[3];
    p[0] = minX;  p[1] = maxY; p[2] = maxZ; 

    p = points[4];
    p[0] = maxX;  p[1] = minY; p[2] = minZ; 
    p = points[5];
    p[0] = maxX;  p[1] = minY; p[2] = maxZ; 
    p = points[6];
    p[0] = maxX;  p[1] = maxY; p[2] = minZ; 
    p = points[7];
    p[0] = maxX;  p[1] = maxY; p[2] = maxZ; 


    var dot = vec4.dot2;
    var planes = this.frustumPlanes;

    // test all frustum planes quickly
    for (var i = 0; i < 6; i++) {
        // check if all points lie on the negative side of the frustum plane
        var negative = true;
        var plane = planes[i];
        for (var j = 0; j < 8; j++) {
            if (dot(plane, points[j]) >= 0) {
                //return false;
                negative = false;
                break;
            }
        }
        if (negative) return false;
    }

    // the box might be inside - further testing should be done here - TODO!
    return true;
};


Camera.prototype.update = function(zoffset) {
    // modelview matrix, this is essentially the inverse of a matrix that
    // brings the camera from the origin to its world position (the inverse
    // is trivial here -- negative angles, reverse order of transformations)
    //this.modelview = mat4.create();

    if (!this.rotationByMatrix) {
        mat4.multiply(math.rotationMatrix(2, math.radians(-this.orientation[2])), math.rotationMatrix(0, math.radians(-this.orientation[1] - 90.0)), this.rotationview);
        mat4.multiply(this.rotationview, math.rotationMatrix(2, math.radians(-this.orientation[0])), this.rotationview);
    }

    mat4.multiply(this.rotationview, math.translationMatrix(-this.position[0], -this.position[1], -this.position[2]), this.modelview);

    if (this.ortho) {
        this.projection = math.orthographicMatrix(this.viewHeight, this.aspect, this.near, this.far);
    } else {
        this.projection = math.perspectiveMatrix(this.fov, this.aspect, this.near, this.far);
    }

    mat4.multiply(this.projection, this.modelview, this.mvp);

    // prepare frustum planes (in normalized device coordinates)
    this.frustumPlanes[0] = [ 0, 0, 1, 1 ]; // far
    this.frustumPlanes[1] = [ 0, 0,-1, 1 ]; // near
    this.frustumPlanes[2] = [ 1, 0, 0, 1 ]; // left
    this.frustumPlanes[3] = [-1, 0, 0, 1 ]; // right
    this.frustumPlanes[4] = [ 0, 1, 0, 1 ]; // bottom
    this.frustumPlanes[5] = [ 0,-1, 0, 1 ]; // top

    // transform the frustum planes to the world space, remember that
    // planes in homogeneous coordinates transform as p' = M^{-T} * p, where
    // M^{-T} is the transpose of inverse of M
    var mvpt = mat4.create();
    mat4.transpose(this.mvp, mvpt); //without zoffset
    for (var i = 0; i < 6; i++) {
        this.frustumPlanes[i] = mat4.multiplyVec4(mvpt, this.frustumPlanes[i]);
    }

    this.mvp32.set(this.mvp);
    this.projection32.set(this.projection);
    this.modelview32.set(this.modelview);
    this.rotationview32.set(this.rotationview);

    this.fovDist = (this.parent.curSize[1] *0.5) / this.fovTan;

    // the derived quantities are now in sync with the parameters
    this.dirty = false;
};


/* harmony default export */ __webpack_exports__["a"] = (Camera);


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gmap__ = __webpack_require__(160);





//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], mat3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["d" /* mat3 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var math = __WEBPACK_IMPORTED_MODULE_1__utils_math__["a" /* math */];
var processGMap = __WEBPACK_IMPORTED_MODULE_2__gmap__["a" /* processGMap */];
var processGMap4 = __WEBPACK_IMPORTED_MODULE_2__gmap__["b" /* processGMap4 */];
var processGMap5 = __WEBPACK_IMPORTED_MODULE_2__gmap__["c" /* processGMap5 */];
var processGMap6 = __WEBPACK_IMPORTED_MODULE_2__gmap__["d" /* processGMap6 */];
var processGMap7 = __WEBPACK_IMPORTED_MODULE_2__gmap__["e" /* processGMap7 */];
var radixDepthSortFeatures = __WEBPACK_IMPORTED_MODULE_2__gmap__["f" /* radixDepthSortFeatures */];


var RendererDraw = function(renderer) {
    this.renderer = renderer;
    this.core = renderer.core;
    this.gpu = renderer.gpu;
    this.gl = renderer.gpu.gl;
    this.rmap = renderer.rmap;
    this.mBuffer = new Float32Array(16);
    this.mBuffer2 = new Float32Array(16);
    this.vBuffer = new Float32Array(4);
};


RendererDraw.prototype.drawSkydome = function(texture, shader) {
    if (!texture) {
        return;
    }

    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;
    
    var lower = 400; // put the dome a bit lower
    var normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    var domeMat = mat4.create();

    var pos = renderer.camera.getPosition();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2] - lower), math.scaleMatrixf(Math.min(renderer.camera.getFar()*0.9,600000)), domeMat);

    var mvp = mat4.create();
    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);
    mat4.multiply(mvp, normMat, mvp);


    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uMVP', mvp);

    gl.depthMask(false);

    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');

    gl.depthMask(true);
    gl.enable(gl.CULL_FACE);

    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();
};


RendererDraw.prototype.drawTBall = function(position, size, shader, texture, size2, nocull) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    if (nocull) {
        //gl.disable(gl.CULL_FACE);
    }

    var normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    var pos = [position[0], position[1], position[2] ];

    size = (size != null) ? size : 1.5;

    var domeMat = mat4.create();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2 || size), domeMat);

    var mvp = mat4.create();
    mat4.multiply(renderer.camera.getMvpMatrix(), domeMat, mvp);
    mat4.multiply(mvp, normMat, mvp);

    gpu.useProgram(shader, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture || renderer.redTexture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uMVP', mvp);

    renderer.skydomeMesh.draw(shader, 'aPosition', 'aTexCoord');

    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();

    if (nocull) {
        //gl.enable(gl.CULL_FACE);
    }
};


RendererDraw.prototype.drawBall = function(position, size, size2, shader, params, params2, params3, color, color2, normals) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    var normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    var pos = [position[0], position[1], position[2] ];

    var domeMat = mat4.create();
    size = size || 1.5;
    size2 = size2 || 1.5;
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrix(size, size, size2), domeMat);

    var mv = mat4.create();
    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);
    mat4.multiply(mv, normMat, mv);
    var proj = renderer.camera.getProjectionMatrix();

    var norm = [0,0,0, 0,0,0, 0,0,0];
    mat4.toInverseMat3(mv, norm);
    mat3.transpose(norm);
    
    gpu.useProgram(shader, ['aPosition']);
    //gpu.bindTexture(renderer.redTexture);

    //shader.setSampler('uSampler', 0);
    shader.setMat4('uProj', proj);
    shader.setMat4('uMV', mv);
    
    if (normals) {
        shader.setMat3('uNorm', norm);
        gl.cullFace(gl.FRONT);
        //gl.disable(gl.DEPTH_TEST);
    }
    
    if (params) {
        shader.setVec4('uParams', params);
    }

    if (params2) {
        shader.setVec4('uParams2', params2);
    }

    if (params2) {
        shader.setVec4('uParams3', params3);
    }

    if (color) {
        shader.setVec4('uFogColor', color);
    }

    if (color2) {
        shader.setVec4('uFogColor2', color2);
    }

    renderer.atmoMesh.draw(shader, 'aPosition', null /*"aTexCoord"*/);

    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();

    if (normals) {
        gl.cullFace(gl.BACK);
    }
};


RendererDraw.prototype.drawBall2 = function(position, size, shader, nfactor, dir, radius2) {
    var gpu = this.gpu;
    var renderer = this.renderer;

    var normMat = mat4.create();
    mat4.multiply(math.scaleMatrix(2, 2, 2), math.translationMatrix(-0.5, -0.5, -0.5), normMat);

    var pos = [position[0], position[1], position[2] ];

    var domeMat = mat4.create();
    mat4.multiply(math.translationMatrix(pos[0], pos[1], pos[2]), math.scaleMatrixf(size != null ? size : 1.5), domeMat);

    var mv = mat4.create();
    mat4.multiply(renderer.camera.getModelviewMatrix(), domeMat, mv);
    mat4.multiply(mv, normMat, mv);
    var proj = renderer.camera.getProjectionMatrix();

    var norm = [0,0,0, 0,0,0, 0,0,0];
    mat4.toInverseMat3(mv, norm);
    mat3.transpose(norm);
    
    gpu.useProgram(shader, ['aPosition']);
    gpu.bindTexture(renderer.redTexture);

    shader.setSampler('uSampler', 0);
    shader.setMat4('uProj', proj);
    shader.setMat4('uMV', mv);
    shader.setMat3('uNorm', norm);
    shader.setFloat('uNFactor', nfactor);
    shader.setVec3('uCenter', position);
    shader.setVec2('uRadius', [size, radius2]);

    renderer.atmoMesh.draw(shader, 'aPosition', null /*"aTexCoord"*/);
    renderer.renderedPolygons += renderer.skydomeMesh.getPolygons();
};


RendererDraw.prototype.drawLineString = function(points, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;
    var index = 0, p, i;

    var totalPoints = points.length; 
   
    if (totalPoints > 32) {
        for (i = 0; i < totalPoints; i += 31) {
            p = points.slice(i, i + 32); 
            this.drawLineString(p, screenSpace, size, color, depthOffset, depthTest, transparent, writeDepth, useState);
        }
        return;
    }

    var plineBuffer = renderer.plineBuffer;


    if (screenSpace) { 

        //fill points
        for (i = 0; i < totalPoints; i++) {
            p = points[i];
            plineBuffer[index] = p[0];
            plineBuffer[index+1] = p[1];
            plineBuffer[index+2] = p[2] || 0;
            index += 3;
        }

    } else { //covert points from physical space

        var mvp = renderer.camera.getMvpMatrix();
        var curSize = renderer.curSize;
        var cameraPos = renderer.cameraPosition;

        for (i = 0; i < totalPoints; i++) {
            p = points[i];

            plineBuffer[index] = p[0] - cameraPos[0];
            plineBuffer[index+1] = p[1] - cameraPos[1];
            plineBuffer[index+2] = p[2] - cameraPos[2];

            index += 3;
        }
    }

    if (useState !== true) {
        var tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    var prog = (!screenSpace) ? renderer.progLine5 : renderer.progLine4;

    gpu.useProgram(prog, ['aPosition']);

    if (screenSpace) { 
        prog.setMat4('uMVP', renderer.imageProjectionMatrix, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);
    } else {
        prog.setMat4('uMV', renderer.camera.getModelviewFMatrix(), null); //depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);
        prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), null);
    }

    prog.setVec3('uScale', [(2 / renderer.curSize[0]), (2 / renderer.curSize[1]), size*0.5]);
    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setVec3('uPoints', plineBuffer);

    renderer.plines.draw(prog, 'aPosition', totalPoints);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


//draw 2d circle - used for debuging
RendererDraw.prototype.drawCircle = function(point, radius, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    var points = [];
    var circleSides = 16;
    var angle = 0, step = (2.0*Math.PI) / circleSides;

    for (var i = 0; i < circleSides; i++) {
        points[i] = [-Math.sin(angle)*radius+point[0], Math.cos(angle)*radius+point[1], point[2]];
        angle += step;
    }

    points[circleSides] = [point[0], radius+point[1], point[2]];;

    this.drawLineString(points, true, lineWidth, color, depthOffset, depthTest, transparent, writeDepth, useState);
};


//draw 2d image - used for debuging
RendererDraw.prototype.drawImage = function(x, y, lx, ly, texture, color, depth, depthOffset, depthTest, transparent, writeDepth, useState) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    if (texture == null || renderer.imageProjectionMatrix == null) {
        return;
    }

    if (useState !== true) {
        var tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    var prog = renderer.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(texture);

    var vertices = renderer.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    var indices = renderer.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    if (depthOffset) {
        depth = depth * (1 + renderer.getZoffsetFactor(depthOffset) * 2);
    }

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', depth);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


RendererDraw.prototype.drawBillboard = function(mvp, texture, color, depthOffset, depthTest, transparent, writeDepth, useState) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    if (useState !== true) {
        var tmpState = gpu.currentState;

        gpu.setState({
            ztest: !(depthTest !== true),
            blend: (transparent === true),
            zwrite: !(writeDepth === false),
            stencil: false,
            culling: false,
            zequal: false
        });
    }

    var prog = renderer.progImage;

    gpu.useProgram(prog, ['aPosition', 'aTexCoord']);
    gpu.bindTexture(texture);
    prog.setSampler('uSampler', 0);

    var vertices = renderer.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    var indices = renderer.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', mvp, depthOffset ? renderer.getZoffsetFactor(depthOffset) : null);

    var x = 0, y = 0, lx = 1, ly = 1;

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', 0);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


//draw flat 2d image - used for debuging
RendererDraw.prototype.drawFlatImage = function(x, y, lx, ly, texture, color, depth, depthOffset) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    if (texture == null || renderer.imageProjectionMatrix == null) {
        return;
    }

    var prog = renderer.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(texture);

    var vertices = renderer.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    var indices = renderer.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

    prog.setMat4('uData', [
        x, y,  0, 0,
        x + lx, y,  1, 0,
        x + lx, y + ly, 1, 1,
        x,  y + ly,  0, 1  ]);

    prog.setVec4('uColor', (color != null ? color : [1,1,1,1]));
    prog.setFloat('uDepth', depth != null ? depth : 0);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);
};


//draw 2d text - used for debuging
RendererDraw.prototype.drawText = function(x, y, size, text, color, depth, useState) {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;

    if (renderer.imageProjectionMatrix == null) {
        return;
    }

    if (useState !== true) {
        var tmpState = gpu.currentState;

        gpu.setState({
          ztest: !(depth == null),
          blend: false,
          zwrite: !(depth == null),
          stencil: false,
          culling: false,
          zequal: !(depth == null)
        });
    }

    var prog = renderer.progImage;

    gpu.useProgram(prog, ['aPosition']);
    gpu.bindTexture(renderer.textTexture2);

    var vertices = renderer.rectVerticesBuffer;
    gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
    gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

    var indices = renderer.rectIndicesBuffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

    prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
    prog.setVec4('uColor', color);
    prog.setFloat('uDepth', depth != null ? depth : 0);

    var sizeX = size - 1;
    var sizeY = size;

    var sizeX2 = Math.round(size*0.5);

    var texelX = 1 / 256;
    var texelY = 1 / 128;

    var lx = this.getTextSize(size, text) + 2;

    //draw black line before text
    var char = 0;
    var charPosX = (char & 15) << 4;
    var charPosY = (char >> 4) << 4;

    prog.setMat4('uData', [
        x-2, y-2,  (charPosX * texelX), (charPosY * texelY),
        x-2 + lx, y-2,  ((charPosX+15) * texelX), (charPosY * texelY),
        x-2 + lx, y + sizeY+1, ((charPosX + 15) * texelX), ((charPosY+15) * texelY),
        x-2,  y + sizeY+1,  (charPosX * texelX), ((charPosY+15) * texelY) ]);

    gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);
    

    for (var i = 0, li = text.length; i < li; i++) {
        char = text.charCodeAt(i) - 32;
        charPosX = (char & 15) << 4;
        charPosY = (char >> 4) << 4;

        switch(char) {
        case 12:
        case 14:
        case 27: //:
        case 28: //;
        case 64: //'
        case 73: //i
        case 76: //l
        case 84: //t

            prog.setMat4('uData', [
                x, y,  (charPosX * texelX), (charPosY * texelY),
                x + sizeX2, y,  ((charPosX+8) * texelX), (charPosY * texelY),
                x + sizeX2, y + sizeY, ((charPosX + 8) * texelX), ((charPosY+16) * texelY),
                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);

            x += sizeX2;
            break;

        default:

            prog.setMat4('uData', [
                x, y,  (charPosX * texelX), (charPosY * texelY),
                x + sizeX, y,  ((charPosX+15) * texelX), (charPosY * texelY),
                x + sizeX, y + sizeY, ((charPosX + 15) * texelX), ((charPosY+16) * texelY),
                x,  y + sizeY,  (charPosX * texelX), ((charPosY+16) * texelY) ]);

            x += sizeX;
                
            break;
        }

        gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

    }

    if (useState !== true) {
        gpu.setState(tmpState);
    }
};


RendererDraw.prototype.getTextSize = function(size, text) {
    var sizeX = size - 1;
    var sizeX2 = Math.round(size*0.5);
    var x = 0;

    for (var i = 0, li = text.length; i < li; i++) {
        var char = text.charCodeAt(i) - 32;

        switch(char) {
        case 12:
        case 14:
        case 27: //:
        case 28: //;7
        case 64: //'
        case 73: //i
        case 76: //l
        case 84: //t
            x += sizeX2;
            break;

        default:
            x += sizeX;
            break;
        }
    }
    
    return x;
};


RendererDraw.prototype.drawGpuJobs = function() {
    var gpu = this.gpu;
    var gl = this.gl;
    var renderer = this.renderer;
    var sortHysteresis = renderer.config.mapSortHysteresis;
    var timerWait = renderer.config.mapHysteresisWait;

    renderer.geoRenderCounter++;
    renderer.totalJobs = 0;
    renderer.drawnJobs = 0;
    renderer.jobsTimer4 = 0;
    renderer.jobsTimer3 = 0;
    renderer.jobsTimer2 = 0;
    renderer.jobsTimer1 = performance.now();

    //setup stencil
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(gl.EQUAL, 0, 0xFF);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);

    var screenPixelSize = [1.0/renderer.curSize[0], 1.0/renderer.curSize[1]];
    var rmap = this.rmap;
    var clearPass = 513;
    var clearPassIndex = 0;
    var clearStencilPasses = renderer.clearStencilPasses;
    var jobZBuffer = renderer.jobZBuffer;
    var jobZBufferSize = renderer.jobZBufferSize;
    var jobZBuffer2 = renderer.jobZBuffer2;
    var jobZBuffer2Size = renderer.jobZBuffer2Size;
    var onlyHitLayers = renderer.onlyHitLayers;
    var onlyAdvancedHitLayers = renderer.onlyAdvancedHitLayers;
    var geoRenderCounter = renderer.geoRenderCounter;
    var job, key, hitmapRender = renderer.onlyHitLayers;
    //var logDebugInfo = false;

    var hsortBuff = renderer.jobHSortBuffer;
    var hsortBuffSize = 0;

    if (clearStencilPasses.length > 0) {
        clearPass = clearStencilPasses[0];
        clearPassIndex++;
    }

    if (this.rmap.counter != this.renderer.geoRenderCounter) {
        this.rmap.clear();
    }

    renderer.gmapIndex = 0;
    renderer.gmapUseVersion = 1;

    var forceUpdate = false;

    var ret, frameTime = renderer.frameTime, sortHbuffer = false;

    //console.log("" + frameTime);

    //draw job buffer and also clean buffer
    for (var i = 0, li = jobZBuffer.length; i < li; i++) {
        var j, lj = jobZBufferSize[i], lj2 = jobZBuffer2Size[i];
        var buffer = jobZBuffer[i];
        var buffer2 = jobZBuffer2[i];
        renderer.jobHBuffer = {};

        renderer.totalJobs += lj;

        if (lj > 0 && i >= clearPass) {
            gl.clear(gl.STENCIL_BUFFER_BIT);

            if (clearStencilPasses.length > clearPassIndex) {
                clearPass = clearStencilPasses[clearPassIndex];
                clearPassIndex++;
            } else {
                clearPass = 513;
            }
        }

        if (onlyHitLayers) {
            if (onlyAdvancedHitLayers) {
                for (j = 0; j < lj; j++) {
                    if (buffer[j].advancedHit) {
                        this.drawGpuJob(gpu, gl, renderer, buffer[j], screenPixelSize, true);
                    }
                }
            } else {
                for (j = 0; j < lj; j++) {
                    var job = buffer[j];
                    if (job.hitable) {
                        this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);
                        if (job.advancedHit) {
                            renderer.advancedPassNeeded = true;
                        }
                    }
                }
            }
        } else {

            for (j = 0; j < lj; j++) {
 
                job = buffer[j];
                this.drawGpuJob(gpu, gl, renderer, job, screenPixelSize);
            }

            /*if (logDebugInfo) {
                for (j = 0; j < lj; j++) {
                    job = buffer[j];
                    console.log('' + j + ' ' + job.id);
                }
            }*/
        }
    
        renderer.jobsTimer3 = performance.now();

        if (renderer.gmapIndex > 0) {
            switch(renderer.gmapUseVersion) {
                case 1: //scr-count4
                    processGMap(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 2:  //scr-count5
                    processGMap4(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 3: //scr-count6
                    processGMap5(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 4: //scr-count7
                    processGMap6(gpu, gl, renderer, screenPixelSize, this);
                    break;
                case 5: //scr-count8
                    processGMap7(gpu, gl, renderer, screenPixelSize, this);
                    break;
            }
            renderer.gmapIndex = 0;
        }

        if (rmap.rectanglesCount > 0 || rmap.rectangles2Count > 0) {
            rmap.processRectangles(gpu, gl, renderer, screenPixelSize);
        }

        renderer.jobsTimer4 += performance.now() - renderer.jobsTimer3;

        //lj2 = jobZBuffer2Size[i]; //probably no op

        lj2 = false;
        var hbuffer = renderer.jobHBuffer;

        for (key in hbuffer) {
            lj2 = true;
            break;
        }

        if (lj2) {

            if (!hitmapRender) {

                for (key in hbuffer) {
                    job = hbuffer[key];

                     if (job.hysteresis && job.id) {
                        var job2 = buffer2[job.id];

                        if (!job2) {
                            job.timerShow = 0;
                            job.timerHide = 0;
                            job.draw = false;
                            job.hysteresisCounter = renderer.geoRenderCounter;
                            buffer2[job.id] = job;
                            jobZBuffer2Size[i]++;
                            forceUpdate = true;
                        } else {

                            if (job == job2) {
                                job2.hysteresisCounter = renderer.geoRenderCounter;
                            } else {
                                job2.hysteresisBackup = job;
                            }

                        }

                        //if (job.hysteresis[3] === true) {
                            sortHbuffer = true;
                        //}
                    }
                }
            }

            for (key in buffer2) {
                job = buffer2[key];
                job2 = hbuffer[key];

                renderer.drawnJobs++;

                if (!hitmapRender) {
                    if (job2) {
                        if (isNaN(job.timerShow)) {
                            job.timerShow = 0;
                            job.timerHide = 0;
                            job.draw = false;
                        }

                        if (!job.draw) {
                            job.timerShow += frameTime;

                            if ((job.timerShow - timerWait) > (job.hysteresis[0])) {
                                job.draw = true;
                                job.timerShow = 0;
                            } else {
                                forceUpdate = true;
                            }
                        } else if (job.timerHide) {
                            job.draw = false;
                            job.timerShow = timerWait + (job.hysteresis[0]) * (1.0-(job.timerHide / (job.hysteresis[1])));
                        }

                        job.timerHide = 0;

                    } else {
                        //job = buffer2[key];

                        if (job.draw) {
                            job.timerHide += frameTime;

                            if (job.timerHide > (job.hysteresis[1])) {
                                delete buffer2[key];
                                jobZBuffer2Size[i]--;
                                job.draw = false;
                                job.timerHide = 0;
                            } else {
                                forceUpdate = true;
                            }
                        } else if (job.timerShow) {
                            job.draw = true;
                            job.timerHide = (job.hysteresis[1]) * (1.0-((job.timerShow-timerWait) / (job.hysteresis[0])));
                        }

                        job.timerShow = 0;
                    }
                }

                var draw = job.draw, fade = null;

                if (!hitmapRender && job.hysteresis[3] === true) {
 
                    if (draw) {
                        if (job.timerHide != 0) {
                            fade = job.timerHide / (job.hysteresis[1]+1);
                            fade = 1.0 - Math.min(1.0, fade);
                        }
                    } else {
                        if (job.timerShow != 0 && (job.timerShow-timerWait) > 0) {
                            fade = (job.timerShow -timerWait) / (job.hysteresis[0]+1);
                            fade = Math.min(1.0, fade);
                            draw = true;
                        }
                    }
                }


                if (draw) {

                    if (job.hysteresisCounter != renderer.geoRenderCounter && job.hysteresisBackup) {
                        var job3 = job.hysteresisBackup;
                        buffer2[key] = job3;

                        job3.timerShow = job.timerShow;
                        job3.timerHide = job.timerHide;
                        job3.draw = job.draw;

                        job = job3;
                    }

                    // update job matricies
                    if (job.renderCounter[0][0] !== geoRenderCounter && job.renderCounter[0][0] !== null) { 
                        job.updatePos = true;

                        var renderCounter = job.renderCounter[0];

                        var mvp = mat4.create();
                        var mv = mat4.create();
                        var group = renderCounter[3];
                        var bbox = group.bbox;
                        var geoPos = renderer.cameraPosition;
                    
                        var m = math.translationMatrix(bbox.min[0] - geoPos[0], bbox.min[1] - geoPos[1], bbox.min[2] - geoPos[2]);
                        mat4.multiply(renderer.camera.getModelviewMatrix(), m, mv);

                        var proj = renderer.camera.getProjectionMatrix();
                        mat4.multiply(proj, mv, mvp);

                        job.mv = mv;
                        job.mvp = mvp;
                    }                    

                    if (sortHysteresis) {

                        job.fade = fade;

                        hsortBuff[hsortBuffSize] = job;
                        hsortBuffSize++;

                    } else {

                        if (job.type == 10) {
                            var viewExtent = renderer.viewExtent;
                            var slayers = job.vswitch[job.vswitchIndex];

                            if (slayers) {
                                slayers = slayers[1];

                                for (var k = 0, lk = slayers.length; k < lk; k++) {
                                    var sjob = slayers[k];
                                    sjob.updatePos = job.updatePos;
                                    sjob.mvp = job.mvp;
                                    sjob.mv = job.mv;
                                    this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, fade);
                                }
                            }

                        } else {
                            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, fade);
                        }

                        job.updatePos = false;
                    }
                }

                job.hysteresisBackup = null;
            }
        }
    }

    if (sortHysteresis && hsortBuffSize) {

        radixDepthSortFeatures(renderer, hsortBuff, hsortBuffSize, renderer.gmap2);

        for (i = 0; i < hsortBuffSize; i++) {
            job = hsortBuff[i];

            if (job.type == 10) {
                var viewExtent = renderer.viewExtent;
                var slayers = job.vswitch[job.vswitchIndex];

                if (slayers) {
                    slayers = slayers[1];

                    for (var k = 0, lk = slayers.length; k < lk; k++) {
                        var sjob = slayers[k];
                        sjob.updatePos = job.updatePos;
                        sjob.mvp = job.mvp;
                        sjob.mv = job.mv;
                        this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, sjob.lastSubJob, job.fade);
                    }
                }

            } else {
                this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, job.lastSubJob, job.fade);
            }

            job.updatePos = false;
        }

    }

    if (forceUpdate) {
        this.core.markDirty();
    }

    renderer.jobsTimer2 = performance.now();
};


RendererDraw.prototype.clearJobBuffer = function() {
    var renderer = this.renderer;
    var jobZBuffer = renderer.jobZBuffer;
    var jobZBufferSize = renderer.jobZBufferSize;

    //clean job buffer
    for (var i = 0, li = jobZBuffer.length; i < li; i++) {
        var lj = jobZBufferSize[i];
        var buffer = jobZBuffer[i];

        for (var j = 0; j < lj; j++) {
            buffer[j] = null;
        }

        jobZBufferSize[i] = 0;
    }
};


RendererDraw.prototype.clearJobHBuffer = function() {
    var renderer = this.renderer;
    var jobZBuffer2 = renderer.jobZBuffer2;
    var jobZBuffer2Size = renderer.jobZBuffer2Size;

    //clean job hbuffer
    for (var i = 0, li = jobZBuffer2.length; i < li; i++) {
        jobZBuffer2[i] = {};
        jobZBuffer2Size[i] = 0;
    }
};


RendererDraw.prototype.paintGL = function() {   //remove this??
    var renderer = this.renderer;

    this.gpu.clear(true, false);

    if (!renderer.onlyLayers) {
        if (!renderer.onlyDepth && !renderer.onlyHitLayers) {
            this.drawSkydome();
        }
    }
};


RendererDraw.prototype.processNoOverlap = function(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color, pointsIndex) {
    var res = { 
        exit: true
    };

    var reduce78 = (job.reduce && (job.reduce[0] >= 7 && job.reduce[0] <= 11));

    if (!renderer.drawAllLabels && job.noOverlap) { 
        if (!pp) {
            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
        }

        res.pp = pp;
        var o = job.noOverlap, depth = pp[2];

        if (depth < 0 || depth > 1.0) {
            return res;
        }

        if (job.type == 6) {
            if (!renderer.rmap.checkRectangle(pp[0], pp[1], pp[0], pp[1], 0)) {
                return res;
            }
        } else {
            if (!renderer.rmap.checkRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], stickShift)) {
                return res;
            }
        }

        if (o[4] !== null) {
            if (o[4] === 0) {
                depth = o[5];
            } else {
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (!job.reduce || (job.reduce && !(job.reduce[0] >= 8 && job.reduce[0] <= 11))) {  //not overlap code not used for reduce==8
                    depth = o[5] / l;
                }
            } 
        }

        job.lastSubJob = [job, stickShift, texture, files, color, pp, true, depth, o, pointsIndex];

        if (reduce78) {
            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;
            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;
            renderer.gmapIndex++;

            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (l > renderer.fmaxDist) renderer.fmaxDist = l;
                if (l < renderer.fminDist) renderer.fminDist = l;

                job.reduce[1] = job.reduce[2];
                job.reduce[4] = l;
            }
            return res;
        }

        if (job.type == 6) {
            if (!renderer.rmap.addLineLabel(job.lastSubJob)) {
                //renderer.rmap.storeRemovedLineLabel(job.lastSubJob);
                return res;
            }
        } else {
            if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob)) {
                renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], depth, job.lastSubJob);
                return res;
            }
        }

        return res; //draw all labe from same z-index together
    } else {
        if (reduce78) {
            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
            }

            job.lastSubJob = [job, stickShift, texture, files, color, pp, false];

            renderer.gmapUseVersion = (job.reduce[0] >= 8 && job.reduce[0] <= 11) ? (job.reduce[0] - 6) : 1;
            renderer.gmap[renderer.gmapIndex] = job.lastSubJob;
            renderer.gmapIndex++;

            if (renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                if (l === null) {
                    p2 = job.center2;
                    p1 = renderer.cameraPosition;
                    camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                    l = vec3.length(camVec) + 0.0001;
                }

                if (l > renderer.fmaxDist) renderer.fmaxDist = l;
                if (l < renderer.fminDist) renderer.fminDist = l;

                job.reduce[1] = job.reduce[2];
                job.reduce[4] = l;
            }

            res.pp = pp;
            return res;
        }
    }

    if (job.hysteresis && job.id) {
        if (!pp) {
            pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
        }

        job.lastSubJob = [job, stickShift, texture, files, color, pp];
        renderer.jobHBuffer[job.id] = job;
        res.pp = pp;
        return res;
     } else {
        res.pp = pp;
     }

    res.exit = false;

    return res;
}

RendererDraw.prototype.drawGpuJob = function(gpu, gl, renderer, job, screenPixelSize, advancedHitPass, ignoreFilters) {
    if (!job.ready) {
        return;
    }

    //if (!(job.tile.id[0] == 14 && job.tile.id[1] == 4383 && job.tile.id[2] == 2863)) {
      //  return;
    //}

    if (!job.eventInfo) {
        return;
    }

    var state = job.state & 0xff;
    var id = job.eventInfo['#id'];

    if (id != null) {

        if (job.state & (2 << 8)) { //has selection layers?

            if (renderer.geodataSelection.indexOf(id) != -1) {  // is selected

                if (job.state & (3 << 8)) { //has hover layers?

                    if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                        if (state != 3) {
                            return;
                        }
                    } else {
                        if (state != 2) {
                            return;
                        }
                    }
                }
            } else if (job.state & (1 << 8)) { //has hover layers?

                if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                    if (state != 1) {
                        return;
                    }
                } else {
                    if (state != 0) {
                        return;
                    }
                }

            } else {
                if (state != 0) {
                    return;
                }        
            }
        
        } else if (job.state & (1 << 8)) { //has hover layers?

            if (renderer.hoverFeature && renderer.hoverFeature[0]['#id'] == id) {
                if (state != 1) {
                    return;
                }
            } else {
                if (state != 0) {
                    return;
                }
            }

        } else {
            if (state != 0) {
                return;;
            }        
        }

    } else {
        if (state != 0) {
            return;
        }        
    }

    var mvp = job.mvp, prog, texture, res;
    var vertexPositionAttribute, vertexTexcoordAttribute,
        vertexNormalAttribute, vertexOriginAttribute, vertexElementAttribute;

    var hitmapRender = job.hitable && renderer.onlyHitLayers;
    var screenPixelSize2, color = job.color;
    var useSuperElevation = renderer.useSuperElevation;

    if (hitmapRender) {
        var c = renderer.hoverFeatureCounter;
        //color = [(c&255)/255, ((c>>8)&255)/255, ((c>>16)&255)/255, 1];
        color = [(c&255)/255, ((c>>8)&255)/255, 0, 0];
        renderer.hoverFeatureList[c] = [job.eventInfo, job.center, job.clickEvent, job.hoverEvent, job.enterEvent, job.leaveEvent, advancedHitPass];
        renderer.hoverFeatureCounter++;
    }

    switch(job.type) {
    case 1:
    case 11:

        if (job.type == 11) {
            if (hitmapRender) {
                if (job.stencil) {
                    gpu.setState(job.culling ? renderer.polygonB0S1C1tate : renderer.polygonB0S1C0tate);
                } else {
                    gpu.setState(job.culling ? renderer.polygonB0S0C1tate : renderer.polygonB0S0C0tate);
                }
            } else {
                if (job.stencil) {
                    gpu.setState(job.culling ? renderer.polygonB1S1C1tate : renderer.polygonB1S1C0tate);
                } else {
                    gpu.setState(job.culling ? renderer.polygonB1S0C1tate : renderer.polygonB1S0C0tate);
                }
            }
        } else {
            gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);
        }

        var debugWires = (gpu === 0); //just generate false value to avoid compiler warnings;

        if (useSuperElevation) {
            prog = advancedHitPass ? job.program2 : renderer.progLineSE;
        } else {            
            prog = advancedHitPass ? job.program2 : debugWires ? renderer.progLineWireframe : job.program;
        }

        var flatShade = (!advancedHitPass && job.type == 11 && job.style == 1);

        if (flatShade) { 
            prog = useSuperElevation ? renderer.progCFlatShadeTileSE : renderer.progCFlatShadeTile;
        }

        gpu.useProgram(prog, advancedHitPass ? ['aPosition', 'aElement'] : debugWires ? ['aPosition', 'aBarycentric'] : ['aPosition']);

        if (useSuperElevation) {
            var m = this.mBuffer;
            var se = renderer.superElevation;

            m[0] = job.bbox.min[0];
            m[1] = job.bbox.min[1];
            m[2] = job.bbox.min[2];

            m[3] = 1;
            m[4] = 1;
            m[5] = 1;

            m[9] = se[0]; // h1
            m[10] = se[1]; // f1
            m[11] = se[2]; // h2
            m[12] = se[6]; // inv dh
            m[13] = se[5]; // df

            m[14] = renderer.earthRadius;
            m[15] = renderer.earthERatio;

            prog.setMat4('uParamsSE', m);
        }

        if (flatShade) { 
            prog.setMat4('uMV', job.mv);
            prog.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));
            prog.setVec4('uColor', color);
        } else {
            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
            prog.setVec4('uColor', color);
        }

        vertexPositionAttribute = prog.getAttribute('aPosition');

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if (advancedHitPass) {
            vertexElementAttribute = prog.getAttribute('aElement');
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        if (debugWires) {
            var barycentericAttribute = prog.getAttribute('aBarycentric');
            gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);
            gl.vertexAttribPointer(barycentericAttribute, gpu.barycentricBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }
        
        //draw polygons
        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);

        var drawDebugLines = renderer.debug.drawPolyWires;// false;//true;

        if (drawDebugLines) {

            var program = useSuperElevation ? renderer.progWireFrameBasicSE : renderer.progWireFrameBasic;
            renderer.gpu.useProgram(program, ['aPosition']);

            if (useSuperElevation) {
                program.setMat4('uParamsSE', m);
            }

            program.setMat4('uMV', job.mv);
            program.setVec4('uColor', [0,0,0,1]);

            program.setMat4('uProj', renderer.camera.getProjectionFMatrix(), renderer.getZoffsetFactor(job.zbufferOffset));

            for (var i = 0, li = job.vertexPositionBuffer.numItems*2; i < li; i+=3) {
                gl.drawArrays(gl.LINE_LOOP, i, 3);
            }


        }

        break;

    case 2:
    case 3:
    case 4:
    case 5:
        gpu.setState(hitmapRender ? renderer.stencilLineHitState : renderer.stencilLineState);

        prog = advancedHitPass ? job.program2 : job.program;
        texture = null;
        var textureParams = [0,0,0,0];
        screenPixelSize2 = screenPixelSize;

        if (hitmapRender) {
            if (job.type == 5) {
                if (job.widthByRatio) {
                    screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];
                }
                prog = advancedHitPass ? this.renderer.progELine3 : this.renderer.progLine3;
                if (!prog.isReady()) {
                    return;
                }
            }
        }

        if (job.type != 4) {

            if (job.type == 2) {
                textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];
            } else {
                if (hitmapRender) {
                    texture = renderer.whiteTexture;

                    if (job.type == 3 || job.type == 2) {
                        textureParams = [0, 0, 0, job.widthByRatio ? renderer.cameraViewExtent : 1];
                    }

                } else {
                    var t = job.texture;
                    if (t == null || t[0] == null) {
                        return;
                    }

                    texture = t[0];
                    textureParams = [0, t[1]/t[0].height, (t[1]+t[2])/t[0].height, job.widthByRatio ? renderer.cameraViewExtent : 1];

                    if (job.type == 3 || job.type == 2) {
                        if (job.widthByRatio) {
                            textureParams[0] = 1/(renderer.cameraViewExtent2*job.lineWidth)/(texture.width/t[2]);
                        } else {
                            textureParams[0] = 1/job.lineWidth/(texture.width/t[2]);    
                        }
                    } else {
                        if (job.widthByRatio) {
                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);
                            textureParams[0] /= (renderer.curSize[1]*job.lineWidth*0.5);
                            //textureParams[3] = renderer.curSize[1]*(1.0/job.lineWidth)*0.5;
                            textureParams[3] = renderer.curSize[1];
                        } else {
                            textureParams[0] = 1/(renderer.cameraViewExtent2/renderer.curSize[1])/(texture.width/t[2]);
                            textureParams[0] /= (job.lineWidth*0.5);
                            textureParams[3] = 1;
                        }    
                    }
                }

                if (!texture.loaded) {
                    return;
                }

                gpu.bindTexture(texture);
            }

        } else if (job.widthByRatio) {
            screenPixelSize2 = [ screenPixelSize[0] * renderer.curSize[1], screenPixelSize[1] * renderer.curSize[1]];
        }

        if (useSuperElevation) {
            prog = advancedHitPass ? job.program2 : renderer.progLine3SE;

            var m = this.mBuffer;
            var se = renderer.superElevation;

            m[0] = job.bbox.min[0];
            m[1] = job.bbox.min[1];
            m[2] = job.bbox.min[2];

            m[3] = 1;
            m[4] = 1;
            m[5] = 1;

            m[9] = se[0]; // h1
            m[10] = se[1]; // f1
            m[11] = se[2]; // h2
            m[12] = se[6]; // inv dh
            m[13] = se[5]; // df

            m[14] = renderer.earthRadius;
            m[15] = renderer.earthERatio;

            gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);
            prog.setMat4('uParamsSE', m);

        } else {
            gpu.useProgram(prog, advancedHitPass ? ['aPosition','aNormal','aElement'] : ['aPosition','aNormal']);
        }           

        prog.setVec4('uColor', color);
        prog.setVec2('uScale', screenPixelSize2);
        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));

        if (job.type != 4) {
            if (job.background != null) {
                prog.setVec4('uColor2', hitmapRender ? [0,0,0,0] : job.background);
            }
            prog.setVec4('uParams', textureParams);
            prog.setSampler('uSampler', 0);
        }

        vertexPositionAttribute = prog.getAttribute('aPosition');
        vertexNormalAttribute = prog.getAttribute('aNormal');

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind vetex normals
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);
        gl.vertexAttribPointer(vertexNormalAttribute, job.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

        if (advancedHitPass) {
            vertexElementAttribute = prog.getAttribute('aElement');
            gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
            gl.vertexAttribPointer(vertexElementAttribute, job.vertexElementBuffer.itemSize, gl.FLOAT, false, 0, 0);
        }

        //draw polygons
        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);

        break;

    case 6:
        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);

        var files = job.files;

        if (files.length > 0) {
            for (var i = 0, li = files.length; i < li; i++) {
                if (files[i].length > 0) {
                    var font = job.fonts[i];
                    if (font && !font.areTexturesReady(files[i])) {
                        return;
                    }
                }
            }

        } else {
            if (!hitmapRender) {
                return;
            }

            texture = renderer.whiteTexture;
        }

        if (renderer.useSuperElevation) {
            if (job.seCounter != renderer.seCounter) {
                job.seCounter = renderer.seCounter;
                job.center2 = renderer.transformPointBySE(job.center);
            }
        } else {
            job.center2 = job.center;
        }

        var gamma = job.outline[2] * 1.4142 / 20;
        var gamma2 = job.outline[3] * 1.4142 / 20;

        if (job.singleBuffer) {

            var b = (vec3.dot(job.textVector, renderer.labelVector) >= 0) ? job.singleBuffer2 : job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;
            var pointsIndex = b == job.singleBuffer ? 0 : 1;

            res = this.processNoOverlap(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color, pointsIndex);

            if (res.exit) {
                return;
            } else {
                //pp = res.pp;
                //p1 = res.p1;
                //p2 = res.p2;
                //camVec = res.camVec;
                //l = res.l;
            }
           

            if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLineLabel128; } else
            if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLineLabel96; } else
            if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLineLabel64; } else
            if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLineLabel48; } else
            if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLineLabel32; }
            else { vbuff = renderer.textQuads16; prog = renderer.progLineLabel16; }

            gpu.useProgram(prog, ['aPosition']);
            prog.setSampler('uSampler', 0);
            prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));

            prog.setVec4('uColor', hitmapRender ? color : job.color2);
            prog.setVec2('uParams', [job.outline[0], gamma2]);
            lj = hitmapRender ? 1 : 2;

            var vertexPositionAttribute = prog.getAttribute('aPosition');

            prog.setVec4('uData', b);

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

            //draw polygons
            for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {
                if (j == 1) {
                    prog.setVec4('uColor', color);
                    prog.setVec2('uParams', [job.outline[1], gamma]);
                }

                for (var i = 0, li = files.length; i < li; i++) {
                    var fontFiles = files[i];

                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                        var file = fontFiles[k];
                        prog.setFloat('uFile', Math.round(file+i*1000));
                        gpu.bindTexture(job.fonts[i].getTexture(file));
                        gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems
                    }
                }
            }

            if (renderer.drawLabelBoxes) {
                if (job.labelPoints.length > 0) {
                    var points = job.labelPoints[pointsIndex];

                    for(j = 0; j < points.length; j++) {
                        pp = renderer.project2(points[j], mvp, [0,0,0], true);
                        this.drawCircle(pp, points[j][3] *renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1], 1, [255, 0, 255, 255], null, null, null, null, null);
                    }
                }
            }

            return;
        }

        prog = renderer.useSuperElevation ? renderer.progText2SE : job.program;
        gpu.useProgram(prog, ['aPosition', 'aTexCoord']);

        if (useSuperElevation) {
            var m = this.mBuffer;
            var se = renderer.superElevation;

            m[0] = job.bbox.min[0];
            m[1] = job.bbox.min[1];
            m[2] = job.bbox.min[2];

            m[3] = 1;
            m[4] = 1;
            m[5] = 1;

            m[9] = se[0]; // h1
            m[10] = se[1]; // f1
            m[11] = se[2]; // h2
            m[12] = se[6]; // inv dh
            m[13] = se[5]; // df

            m[14] = renderer.earthRadius;
            m[15] = renderer.earthERatio;

            prog.setMat4('uParamsSE', m);
        }  

        prog.setSampler('uSampler', 0);
        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
        prog.setVec4('uVec', renderer.labelVector);

        prog.setVec4('uColor', (hitmapRender ? color : job.color2));
        prog.setVec2('uParams', [job.outline[0], gamma2]);

        vertexPositionAttribute = prog.getAttribute('aPosition');
        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind vetex texcoords
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //draw polygons
        for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {
            if (j == 1) {
                prog.setVec4('uColor', color);
                prog.setVec2('uParams', [job.outline[1], gamma]);
            }

            if (files.length > 0) {
                for (var i = 0, li = files.length; i < li; i++) {
                    var fontFiles = files[i];

                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                        var file = fontFiles[k];
                        prog.setFloat('uFile', Math.round(file+i*1000));
                        gpu.bindTexture(job.fonts[i].getTexture(file));
                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                    }
                }

            } else {
                gpu.bindTexture(texture);
                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
            }
        }

        break;

    case 7:
    case 8:
    case 9:
    case 10:


        if (job.reduce && !(job.reduce[0] >= 7 && job.reduce[0] <= 11)) {
            var a, r = job.reduce;

            if (r[0] > 4) {
                
                if (r[0] == 4) {
                    a = Math.max(r[1], Math.floor(r[2] / Math.max(1, renderer.drawnGeodataTiles)));

                    if (job.index >= a) {
                        return;
                    } 
                    r[5] = a; //for debug
                } else {
                    a = Math.pow(job.texelSize * job.tiltAngle, 0.5); 
                    a = Math.max(r[1], Math.round(r[2] * (a / Math.max(0.00001, this.renderer.drawnGeodataTilesFactor))));

                    if (job.index >= a) {
                        return;
                    } 
                    r[5] = a; //for debug
                }

            } else {
                a = job.tiltAngle;

                if (r[0] == 1) {
                    a = 1.0 - (Math.acos(a) * (1.0/(Math.PI*0.5)));
                } else if (r[0] == 3) {
                    a = (Math.cos(Math.acos(a) * 2) + 1.0) * 0.5;
                }

                var indexLimit = (Math.round(r[1] + (a*r[2]))-1);

                if (job.index > indexLimit) {
                    return;
                } 
                r[5] = indexLimit; //for debug
            }
        }

        var files = job.files;

        if (job.type != 10) {
            if (job.type == 9) {

                var notready = false;
                
                for (var j = 0, lj = job.subjobs.length; j < lj; j++) {
                    var subjob = job.subjobs[j];

                    files = subjob.files;

                    if (files.length > 0) {
                        for (var i = 0, li = files.length; i < li; i++) {
                            if (files[i].length > 0) {
                                var font = subjob.fonts[i];
                                if (font && !font.areTexturesReady(files[i])) {
                                    notready = true;
                                }
                            }
                        }

                    } else {
                        texture = hitmapRender ? renderer.whiteTexture : subjob.texture;
                        if (!texture.loaded) {
                            notready = true;
                        }
                    }
                }

                if (notready) {
                    return;
                }

            } else {
                files = job.files;

                if (files.length > 0) {
                    for (var i = 0, li = files.length; i < li; i++) {
                        if (files[i].length > 0) {
                            var font = job.fonts[i];
                            if (font && !font.areTexturesReady(files[i])) {
                                return;
                            }
                        }
                    }

                } else {
                    texture = hitmapRender ? renderer.whiteTexture : job.texture;
                    if (!texture.loaded) {
                        return;
                    }
                }
            }
        }

        var p1, p2, camVec, ll, l = null, localTilt;

        if (renderer.useSuperElevation) {
            if (job.seCounter != renderer.seCounter) {
                job.seCounter = renderer.seCounter;
                job.center2 = renderer.transformPointBySE(job.center);
            }
        } else {
            job.center2 = job.center;
        }


        if (job.culling != 180) {
            p2 = job.center2;
            p1 = renderer.cameraPosition;
            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];

            if (job.visibility) {
                l = vec3.length(camVec);

                switch(job.visibility.length) {
                    case 1:
                        if (l > job.visibility[0]) {
                            return;
                        }
                        break;

                    case 2:
                        ll = l * renderer.localViewExtentFactor;
                        if (ll < job.visibility[0] || ll > job.visibility[1]) {
                            return;
                        }

                        break;

                    case 4:
                        ll = l * renderer.localViewExtentFactor;

                        var diameter = job.visibility[0] * job.visibility[1];

                        //dinfo = [l, ll, diameter, (job.visibility[2] * ll), (job.visibility[3] * ll)];

                        if (diameter < (job.visibility[2] * ll) || diameter > (job.visibility[3] * ll)) {
                            return;
                        }

                        break;
                }

                l = 1/l;
                camVec[0] *= l;                       
                camVec[1] *= l;                       
                camVec[2] *= l;                       
            } else {
                vec3.normalize(camVec);
            }
                
            job.normal = [0,0,0];
            vec3.normalize(job.center2, job.normal);
                
            localTilt = -vec3.dot(camVec, job.normal);

            if (localTilt < Math.cos(math.radians(job.culling))) {
                return;
            }
            
            /*
            localTilt = math.degrees(Math.acos(localTilt));

            if (localTilt > job.culling) {
                return;
            }*/

        } else if (job.visibility) {

            p2 = job.center2;
            p1 = renderer.cameraPosition;
            camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            l = vec3.length(camVec);

            switch(job.visibility.length) {
                case 1:
                    if (l > job.visibility[0]) {
                        return;
                    }
                    break;

                case 2:
                    l *= renderer.localViewExtentFactor;
                    if (l < job.visibility[0] || l > job.visibility[1]) {
                        return;
                    }

                    break;

                case 4:
                    l *= renderer.localViewExtentFactor;

                    var diameter = job.visibility[0] * job.visibility[1];
                    if (diameter < (job.visibility[2] * l) || diameter > (job.visibility[3] * l)) {
                        return;
                    }

                    break;
            }
        }

        if (job.type == 10) {
            //TODO: solve switch an call render
            var viewExtent = renderer.viewExtent;
            var lastViewExtent = 0, vswitch = job.vswitch;
            job.vswitchIndex = 0;

            for (i = 0, li = vswitch.length; i < li; i++) {
                if (viewExtent <= vswitch[i][0] || i == (li-1)) {
                    job.vswitchIndex = i;
                    var slayers = job.vswitch[i];

                    if (slayers) {
                        slayers = slayers[1];

                        for (j = 0, lj = slayers.length; j < lj; j++) {
                            var sjob = slayers[j];
                            sjob.mv = job.mv;
                            sjob.mvp = job.mvp;
                            sjob.updatePos = job.updatePos;
                            sjob.hysteresis = job.hysteresis;
                            sjob.vswitchIndex = i;
                            sjob.renderCounter = job.renderCounter;
                            sjob.localTilt = localTilt;
                            sjob.id = job.id;
                            this.drawGpuJob(gpu, gl, renderer, sjob, screenPixelSize, advancedHitPass, ignoreFilters);
                        }
                    }

                    return;
                }
            }

            return;
        }

        var s = job.stick;
        var stickShift = 0, pp, o, depth, stickMode, stickHeight;

        if (s[0] != 0) {
            stickMode = renderer.config.mapFeatureStickMode;
            stickHeight = s[0];

            if (stickMode[0]) {
                if (!localTilt) {
                    localTilt = job.localTilt;

                    if (!localTilt) {
                        p2 = job.center2;
                        p1 = renderer.cameraPosition;
                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                        vec3.normalize(camVec);
                        job.normal = [0,0,0];
                        vec3.normalize(job.center2, job.normal);
                            
                        localTilt = -vec3.dot(camVec, job.normal);
                    }
                }

                if (stickMode[0] == 2) {

                    var hdelta = renderer.gridHmax - renderer.gridHmin;

                    if (hdelta < 0) {
                        hdelta = 0;
                    }

                    if (hdelta < stickHeight) {
                        stickHeight = hdelta;
                    }
                }

                if (localTilt < 0) {
                    localTilt = 0;
                }
               
                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;

            } else {
                stickShift = renderer.cameraTiltFator * s[0];
            }
                
            if (stickShift < s[1]) {
                stickShift = 0;
            }

            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
                stickShift += s[7];
            }

            //else if (s[2] != 0) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[0] = Math.round(pp[0]);
                pp[1] -= stickShift;
            //}
        }

        res = this.processNoOverlap(renderer, job, pp, p1, p2, camVec, l, stickShift, texture, files, color);

        if (res.exit) {
            return;
        } else {
            pp = res.pp;
            p1 = res.p1;
            p2 = res.p2;
            camVec = res.camVec;
            l = res.l;
        }
        
        if (job.type == 9) {
            return;
        }

        if (renderer.drawLabelBoxes) {
            o = job.noOverlap;

            if (o) {
                if (!pp) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                }

                gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);
                this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                                     [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

                if (job.reduce) {
                    if (job.reduce[0] >= 10) {
                        this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                    } else {
                        this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
                    }
                }
            }
        }

        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);

        if (s[0] != 0 && s[2] != 0) {
            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
            }

            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], s[6]], null, null, null, null, true);
        }

        /*if (dinfo) { //debug only
            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
            }

            var stmp = "" + dinfo[0].toFixed(0) + " " + dinfo[1].toFixed(0) + " " + dinfo[2].toFixed(0) + " " + dinfo[3].toFixed(0) + " " + dinfo[4].toFixed(0);
            this.drawText(Math.round(pp[0]-this.getTextSize(10,stmp)*0.5), Math.round(pp[1]), 10, stmp, [1,1,1,1], 0);
        }*/

        prog = job.program; //renderer.progIcon;

        if (job.singleBuffer) {
            if (!pp) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
            }

            if (prog == renderer.progIcon) {
                var b = job.singleBuffer;
                prog = renderer.progImage;

                if (!job.singleBuffer2) {
                    job.singleBuffer2 = new Float32Array(b);

                    var tx = 1 / texture.width, ty = 1 / texture.height;
                    b[2] *= tx; b[3] *= ty;
                    b[6] *= tx; b[7] *= ty;
                    b[10] *= tx; b[11] *= ty;
                    b[14] *= tx; b[15] *= ty;
                }

                if (job.updatePos) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                    pp[1] -= stickShift;
                }

                var b2 = job.singleBuffer2;

                b[0] = pp[0] + b2[0];
                b[1] = pp[1] + b2[1];

                b[4] = pp[0] + b2[4];
                b[5] = pp[1] + b2[5];

                b[8] = pp[0] + b2[8];
                b[9] = pp[1] + b2[9];

                b[12] = pp[0] + b2[12];
                b[13] = pp[1] + b2[13];

                gpu.useProgram(prog, ['aPosition']);
                gpu.bindTexture(texture);

                var vertices = renderer.rectVerticesBuffer;
                gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
                gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

                var indices = renderer.rectIndicesBuffer;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

                prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
                prog.setMat4('uData', job.singleBuffer );
                prog.setVec4('uColor', color);
                prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));

                gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

            } else {

                var b = job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6, color2 = job.color2, j = 0;

                if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLabel128; } else
                if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLabel96; } else
                if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLabel64; } else
                if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLabel48; } else
                if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLabel32; }
                else { vbuff = renderer.textQuads16; prog = renderer.progLabel16; }

                if (job.updatePos) {
                    pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                    pp[1] -= stickShift;
                }

                gpu.useProgram(prog, ['aPosition']);
                prog.setSampler('uSampler', 0);
                prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

                prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);
                prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);
                prog.setVec4('uColor', hitmapRender ? color : color2);
                prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
                lj = hitmapRender ? 1 : 2;

                var vertexPositionAttribute = prog.getAttribute('aPosition');

                prog.setVec4('uData', b);

                //bind vetex positions
                gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
                gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

                //draw polygons
                for(;j<lj;j++) {
                    if (j == 1) {
                        prog.setVec4('uColor', color);
                        prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
                    }

                    for (var i = 0, li = files.length; i < li; i++) {
                        var fontFiles = files[i];

                        for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                            var file = fontFiles[k];
                            prog.setFloat('uFile', Math.round(file+i*1000));
                            gpu.bindTexture(job.fonts[i].getTexture(file));
                            gl.drawArrays(gl.TRIANGLES, 0, vitems);
                        }
                    }
                }

            }
            
            return;   
        }

        gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);
        prog.setSampler('uSampler', 0);
        prog.setMat4('uMVP', mvp, renderer.getZoffsetFactor(job.zbufferOffset));
        prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == 8 ? 1.0 : 1.0 / texture.width), stickShift*2]);

        var j = 0, lj = 1;

        if (prog != renderer.progIcon) {
            prog.setVec4('uColor', hitmapRender ? color : job.color2);
            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
            lj = hitmapRender ? 1 : 2;
        } else {
            prog.setVec4('uColor', color);
        }

        vertexPositionAttribute = prog.getAttribute('aPosition');
        vertexTexcoordAttribute = prog.getAttribute('aTexCoord');
        vertexOriginAttribute = prog.getAttribute('aOrigin');

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind vetex texcoordds
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //bind vetex origin
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
        gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);

        //draw polygons
        for(;j<lj;j++) {
            if (j == 1) {
                prog.setVec4('uColor', color);
                prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
            }

            if (files.length > 0) {
                for (var i = 0, li = files.length; i < li; i++) {
                    var fontFiles = files[i];

                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                        var file = fontFiles[k];
                        prog.setFloat('uFile', Math.round(file+i*1000));
                        gpu.bindTexture(job.fonts[i].getTexture(file));
                        gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                    }
                }

            } else {
                gpu.bindTexture(texture);
                gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
            }
        }

        break;
    }

    return;
};

RendererDraw.prototype.drawGpuSubJob = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {
    if (!subjob) {
        return;
    }

    var job = subjob[0], stickShift = subjob[1], texture = subjob[2],
        files = subjob[3], color = subjob[4], pp = subjob[5], s = job.stick,
        o = job.noOverlap, localTilt, p2, p1, camVec;

    if (renderer.useSuperElevation) {
        if (job.seCounter != renderer.seCounter) {
            job.seCounter = renderer.seCounter;
            job.center2 = renderer.transformPointBySE(job.center);
        }
    } else {
        job.center2 = job.center;
    }

    if (job.hysteresis && job.id) {

        /*
        if (job.culling != 180) {
            p2 = job.center2;
            p1 = renderer.cameraPosition;
            var camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
            vec3.normalize(camVec);
                
            job.normal = [0,0,0];
            vec3.normalize(job.center2, job.normal);
                
            localTilt = -vec3.dot(camVec, job.normal);
            if (localTilt < Math.cos(math.radians(job.culling))) {
                return;
            }
        }

        //if (o) {
            //var x1 = pp[0]+o[0], y1 = pp[1]+o[1], 
              //  x2 = pp[0]+o[2], y2 = pp[1]+o[3]+stickShift;

            /*
            if (s[0] != 0) {
                stickShift = renderer.cameraTiltFator * s[0];
                    
                if (stickShift < s[1]) {
                    stickShift = 0;
                }
            }*/

            /* 
            var rmap = renderer.rmap;

            //screen including credits
            if (x1 < 0 || x2 > rmap.slx || y1 < 0 || y2 > rmap.sly) {
                return false;
            }

            //compass
            if (x1 < rmap.clx && x2 > 0 && y1 <= rmap.sly && y2 > (rmap.sly - rmap.cly)) {
                return false;
            }

            //serach bar
            if (x1 < rmap.blx && x2 > 0 && y1 <= rmap.bly && y2 > 0) {
                return false;
            }*/
        //}

        if (s[0] != 0) {
            var stickMode = renderer.config.mapFeatureStickMode;
            var stickHeight = s[0];

            if (stickMode[0]) {
                if (!localTilt) {
                    localTilt = job.localTilt;

                    if (!localTilt) {
                        p2 = job.center2;
                        p1 = renderer.cameraPosition;
                        camVec = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
                        vec3.normalize(camVec);
                        job.normal = [0,0,0];
                        vec3.normalize(job.center2, job.normal);
                            
                        localTilt = -vec3.dot(camVec, job.normal);
                    }
                }

                if (stickMode[0] == 2) {

                    var hdelta = renderer.gridHmax - renderer.gridHmin;

                    if (hdelta < 0) {
                        hdelta = 0;
                    }

                    if (hdelta < stickHeight) {
                        stickHeight = hdelta;
                    }
                }

                if (localTilt < 0) {
                    localTilt = 0;
                }
               
                stickShift = Math.pow(1-localTilt,stickMode[1]) * stickHeight * renderer.cameraTiltFator;

            } else {
                stickShift = renderer.cameraTiltFator * s[0];
            }
              
            if (stickShift < s[1]) {
                stickShift = 0;
            }

            if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
                stickShift += s[7];
            }


             //else if (s[2] != 0) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[0] = Math.round(pp[0]);
                pp[1] -= stickShift;
            //}

        }

    }

    var hitmapRender = job.hitable && renderer.onlyHitLayers;

    if (job.type == 9) {
        if (renderer.drawLabelBoxes && o) {
            gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);
            this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                                 [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

            if (job.reduce) {
                if (job.reduce[0] >= 10) {
                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                } else {
                    this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
                }
            }
        }

        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);

        if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
            this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);
            //stickShift += s[7];
        }

        for (var i = 0, li = job.subjobs.length; i < li; i++) {
            var subjob2 = job.subjobs[i], job2;
            subjob2.mvp = job.mvp;
            subjob2.updatePos = job.updatePos;

            var depth = subjob[7];

            o = null;
            files = subjob2.files;

            if (hitmapRender) {
                color = subjob[4];
                texture = renderer.whiteTexture;
            } else {
                color = subjob2.color;
                texture = subjob2.texture;
            }

            this.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, [subjob2, stickShift, texture, files, color, pp, true, depth, o], fade);
        }

        return;
    }


    if (renderer.drawLabelBoxes && o) {
        gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.lineLabelState);
        this.drawLineString([[pp[0]+o[0], pp[1]+o[1], 0.5], [pp[0]+o[2], pp[1]+o[1], 0.5],
                             [pp[0]+o[2], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[3], 0.5], [pp[0]+o[0], pp[1]+o[1], 0.5]], true, 1, [255, 0, 0, 255], null, true, null, null, null);

        if (job.reduce) {
            if (job.reduce[0] >= 10) {
                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.reduce[7].toFixed(0), [1,0,0,1], 0.5);
                //this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[6].toFixed(3)+' '+job.reduce[1].toFixed(2)+' '+job.reduce[3].toFixed(2)+' '+job.fade, [1,0,0,1], 0.5);
            } else {
                this.drawText(pp[0]+o[0], pp[1]+o[3]-4*renderer.debug.debugTextSize, 4*renderer.debug.debugTextSize, ''+job.reduce[1].toFixed(0)+' '+job.reduce[5].toFixed(0), [1,0,0,1], 0.5);
            }
        }
    }

    gpu.setState(hitmapRender ? renderer.lineLabelHitState : renderer.labelState);

    var j = 0, lj = 1, color2 = job.color2;

    if (fade !== null) {
        color = [color[0], color[1], color[2], color[3] * fade];

        if (color2) {
            color2 = [color2[0], color2[1], color2[2], color2[3] * fade];
        }
    }

    if (s[0] != 0 && s[2] != 0 && stickShift >= 4) {
        this.drawLineString([[pp[0], pp[1]+stickShift+s[7], pp[2]], [pp[0], pp[1]+s[7], pp[2]]], true, s[2], [s[3], s[4], s[5], ((fade !== null) ? s[6] * fade : s[6]) ], null, null, null, null, true);
    }

    var prog = job.program; //renderer.progIcon;

    if (job.singleBuffer) {

        if (prog == renderer.progIcon) {
            var b = job.singleBuffer;
            prog = renderer.progImage;

            if (!job.singleBuffer2) {
                job.singleBuffer2 = new Float32Array(b);

                var tx = 1 / texture.width, ty = 1 / texture.height;
                b[2] *= tx; b[3] *= ty;
                b[6] *= tx; b[7] *= ty;
                b[10] *= tx; b[11] *= ty;
                b[14] *= tx; b[15] *= ty;
            }

            if (job.updatePos) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[1] -= stickShift;
            }

            var b2 = job.singleBuffer2;

            b[0] = pp[0] + b2[0];
            b[1] = pp[1] + b2[1];

            b[4] = pp[0] + b2[4];
            b[5] = pp[1] + b2[5];

            b[8] = pp[0] + b2[8];
            b[9] = pp[1] + b2[9];

            b[12] = pp[0] + b2[12];
            b[13] = pp[1] + b2[13];

            gpu.useProgram(prog, ['aPosition']);
            gpu.bindTexture(texture);

            var vertices = renderer.rectVerticesBuffer;
            gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
            gl.vertexAttribPointer(prog.getAttribute('aPosition'), vertices.itemSize, gl.FLOAT, false, 0, 0);

            var indices = renderer.rectIndicesBuffer;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);

            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);
            prog.setMat4('uData', job.singleBuffer );
            prog.setVec4('uColor', color);
            prog.setFloat('uDepth', pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2));

            gl.drawElements(gl.TRIANGLES, indices.numItems, gl.UNSIGNED_SHORT, 0);

        } else {

            var b = job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;

            if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLabel128; } else
            if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLabel96; } else
            if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLabel64; } else
            if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLabel48; } else
            if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLabel32; }
            else { vbuff = renderer.textQuads16; prog = renderer.progLabel16; }

            if (job.updatePos) {
                pp = renderer.project2(job.center2, renderer.camera.mvp, renderer.cameraPosition);
                pp[1] -= stickShift;
            }

            gpu.useProgram(prog, ['aPosition']);
            prog.setSampler('uSampler', 0);
            prog.setMat4('uProjectionMatrix', renderer.imageProjectionMatrix);

            prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], 1, stickShift*2]);
            prog.setVec3('uOrigin', [pp[0],pp[1],pp[2] * (1 + renderer.getZoffsetFactor(job.zbufferOffset) * 2)]);
            prog.setVec4('uColor', hitmapRender ? color : color2);
            prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
            lj = hitmapRender ? 1 : 2;

            var vertexPositionAttribute = prog.getAttribute('aPosition');

            prog.setVec4('uData', b);

            //bind vetex positions
            gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
            gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

            //draw polygons
            for(;j<lj;j++) {
                if (j == 1) {
                    prog.setVec4('uColor', color);
                    prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
                }

                for (var i = 0, li = files.length; i < li; i++) {
                    var fontFiles = files[i];

                    for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                        var file = fontFiles[k];
                        prog.setFloat('uFile', Math.round(file+i*1000));
                        gpu.bindTexture(job.fonts[i].getTexture(file));
                        gl.drawArrays(gl.TRIANGLES, 0, vitems);
                    }
                }
            }

        }
        
        return;   
    }

    gpu.useProgram(prog, ['aPosition', 'aTexCoord', 'aOrigin']);
    prog.setSampler('uSampler', 0);
    prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));
    prog.setVec4('uScale', [screenPixelSize[0], screenPixelSize[1], (job.type == 8 ? 1.0 : 1.0 / texture.width), stickShift*2]);

    if (prog != renderer.progIcon) {
        prog.setVec4('uColor', hitmapRender ? color : color2);
        prog.setVec2('uParams', [job.outline[0], job.gamma[1]]);
        lj = hitmapRender ? 1 : 2;
    } else {
        prog.setVec4('uColor', color);
    }

    var vertexPositionAttribute = prog.getAttribute('aPosition');
    var vertexTexcoordAttribute = prog.getAttribute('aTexCoord');
    var vertexOriginAttribute = prog.getAttribute('aOrigin');

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, job.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //bind vetex texcoordds
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
    gl.vertexAttribPointer(vertexTexcoordAttribute, job.vertexTexcoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //bind vetex origin
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
    gl.vertexAttribPointer(vertexOriginAttribute, job.vertexOriginBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //draw polygons
    for(;j<lj;j++) {
        if (j == 1) {
            prog.setVec4('uColor', color);
            prog.setVec2('uParams', [job.outline[1], job.gamma[0]]);
        }

        if (files.length > 0) {
            for (var i = 0, li = files.length; i < li; i++) {
                var fontFiles = files[i];

                for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                    var file = fontFiles[k];
                    prog.setFloat('uFile', Math.round(file+i*1000));
                    gpu.bindTexture(job.fonts[i].getTexture(file));
                    gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
                }
            }

        } else {
            gpu.bindTexture(texture);
            gl.drawArrays(gl.TRIANGLES, 0, job.vertexPositionBuffer.numItems);
        }
    }
};

RendererDraw.prototype.drawGpuSubJobLineLabel = function(gpu, gl, renderer, screenPixelSize, subjob, fade) {
    if (!subjob) {
        return;
    }

    var job = subjob[0], stickShift = subjob[1], texture = subjob[2],
        files = subjob[3], color = subjob[4], pp = subjob[5], s = job.stick,
        o = job.noOverlap, localTilt, p2, p1, camVec, prog;

    if (renderer.useSuperElevation) {
        if (job.seCounter != renderer.seCounter) {
            job.seCounter = renderer.seCounter;
            job.center2 = renderer.transformPointBySE(job.center);
        }
    } else {
        job.center2 = job.center;
    }

    var hitmapRender = job.hitable && renderer.onlyHitLayers;

    var gamma = job.outline[2] * 1.4142 / 20;
    var gamma2 = job.outline[3] * 1.4142 / 20;

    if (job.singleBuffer) {

        var b = (vec3.dot(job.textVector, renderer.labelVector) >= 0) ? job.singleBuffer2 : job.singleBuffer, bl = b.length, vbuff, vitems = (b.length / 4) * 6;
        var pointsIndex = b == job.singleBuffer ? 0 : 1;

        if (bl > 384) { vbuff = renderer.textQuads128; prog = renderer.progLineLabel128; } else
        if (bl > 256) { vbuff = renderer.textQuads96; prog = renderer.progLineLabel96; } else
        if (bl > 192) { vbuff = renderer.textQuads64; prog = renderer.progLineLabel64; } else
        if (bl > 128) { vbuff = renderer.textQuads48; prog = renderer.progLineLabel48; } else
        if (bl > 64) { vbuff = renderer.textQuads32; prog = renderer.progLineLabel32; }
        else { vbuff = renderer.textQuads16; prog = renderer.progLineLabel16; }

        gpu.useProgram(prog, ['aPosition']);
        prog.setSampler('uSampler', 0);
        prog.setMat4('uMVP', job.mvp, renderer.getZoffsetFactor(job.zbufferOffset));

        prog.setVec4('uColor', hitmapRender ? color : job.color2);
        prog.setVec2('uParams', [job.outline[0], gamma2]);
        var lj = hitmapRender ? 1 : 2;

        var vertexPositionAttribute = prog.getAttribute('aPosition');

        prog.setVec4('uData', b);

        //bind vetex positions
        gl.bindBuffer(gl.ARRAY_BUFFER, vbuff);
        gl.vertexAttribPointer(vertexPositionAttribute, vbuff.itemSize, gl.FLOAT, false, 0, 0);

        //draw polygons
        for(var j = 0; j < (hitmapRender ? 1 : 2); j++) {
            if (j == 1) {
                prog.setVec4('uColor', color);
                prog.setVec2('uParams', [job.outline[1], gamma]);
            }

            for (var i = 0, li = files.length; i < li; i++) {
                var fontFiles = files[i];

                for (var k = 0, lk = fontFiles.length; k < lk; k++) {
                    var file = fontFiles[k];
                    prog.setFloat('uFile', Math.round(file+i*1000));
                    gpu.bindTexture(job.fonts[i].getTexture(file));
                    gl.drawArrays(gl.TRIANGLES, 0, vitems / 3); //TODO: demystify vitems
                }
            }
        }

        if (renderer.drawLabelBoxes) {
            if (job.labelPoints.length > 0) {
                var points = job.labelPoints[pointsIndex];

                for(j = 0; j < points.length; j++) {
                    pp = renderer.project2(points[j], job.mvp, [0,0,0], true);
                    this.drawCircle(pp, points[j][3] *renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1], 1, [255, 0, 255, 255], null, null, null, null, null);
                }
            }
        }

        return;
    }

};

/* harmony default export */ __webpack_exports__["a"] = (RendererDraw);


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bbox__ = __webpack_require__(5);



//get rid of compiler mess
var BBox = __WEBPACK_IMPORTED_MODULE_0__bbox__["a" /* default */];


var RendererGeometry = {};


RendererGeometry.setFaceVertices = function(vertices, a, b, c, index) {
    vertices[index] = a[0];
    vertices[index+1] = a[1];
    vertices[index+2] = a[2];

    vertices[index+3] = b[0];
    vertices[index+4] = b[1];
    vertices[index+5] = b[2];

    vertices[index+6] = c[0];
    vertices[index+7] = c[1];
    vertices[index+8] = c[2];
};


RendererGeometry.setFaceUVs = function(uvs, a, b, c, index) {
    uvs[index] = a[0];
    uvs[index+1] = a[1];

    uvs[index+2] = b[0];
    uvs[index+3] = b[1];

    uvs[index+4] = c[0];
    uvs[index+5] = c[1];
};


// Procedural mesh representing a heightmap block
// Creates a grid of size x size vertices, all coords are [0..1].
RendererGeometry.buildHeightmap = function(size, use16bit) {
    size--;

    var g = RendererGeometry;
    var numFaces = (size* size) * 2;
    var vertices = new Float32Array(numFaces * 3 * 3);//[];
    var uvs = new Float32Array(numFaces * 3 * 2);//[];

    var factor = 1.0 * size;
    var index = 0;
    var index2 = 0;

    for (var i = 0; i < size; i++) {
        for (var j = 0; j < size; j++) {
            var x1 = (j) * factor;
            var x2 = (j+1) * factor;

            var y1 = (i) * factor;
            var y2 = (i+1) * factor;

            g.setFaceVertices(vertices, [x1, y1, 0], [x2, y1, 0], [x2, y2, 0], index);
            g.setFaceUVs(uvs, [x1, y1], [x2, y1], [x2, y2], index2);
            index += 9;
            index2 += 6;

            g.setFaceVertices(vertices, [x2, y2, 0], [x1, y2, 0], [x1, y1, 0], index);
            g.setFaceUVs(uvs, [x2, y2], [x1, y2], [x1, y1], index2);
            index += 9;
            index2 += 6;
        }
    }

    var bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs)};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs};
    }
};


RendererGeometry.buildPlane = function(size, use16bit) {
    size--;

    var g = RendererGeometry;
    var numFaces = (size* size) * 2;
    var vertices = (use16bit) ? (new Uint16Array(numFaces * 3 * 3)) : (new Float32Array(numFaces * 3 * 3));
    var uvs = new Float32Array(numFaces * 3 * 2);//[];

    var factor = 1.0 / (size);
    var index = 0, index2 = 0;
    var x1, y1, x2, y2, xx1, xx2, yy1, yy2;

    for (var i = 0; i < size; i++) {
        for (var j = 0; j < size; j++) {
            x1 = j;
            x2 = j+1;
            y1 = i;
            y2 = i+1;

            xx1 = j * factor;
            xx2 = (j+1) * factor;
            yy1 = (i) * factor;
            yy2 = (i+1) * factor;

            g.setFaceVertices(vertices, [x1, y1, 0], [x1, y2, 0], [x2, y2, 0], index);
            g.setFaceUVs(uvs, [xx1, yy1], [xx1, yy2], [xx2, yy2], index2);
            index += 9;
            index2 += 6;

            g.setFaceVertices(vertices, [x2, y2, 0], [x2, y1, 0], [x1, y1, 0], index);
            g.setFaceUVs(uvs, [xx2, yy2], [xx2, yy1], [xx1, yy1], index2);
            index += 9;
            index2 += 6;
        }
    }

    var bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:vertices, uvs: this.covnetTo16Bit(uvs)};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs};
    }
};

RendererGeometry.spherePos = function(lon, lat) {
    lat *= Math.PI;
    lon *= 2*Math.PI;

    return [Math.cos(lon)*Math.sin(lat)*0.5 + 0.5,
        Math.sin(lon)*Math.sin(lat)*0.5 + 0.5,
        Math.cos(lat) * 0.5 + 0.5];
};


// Creates an approximation of a unit sphere, note that all coords are
// in the range [0..1] and the center is in (0.5, 0.5). Triangle "normals"
// are oriented inwards.
RendererGeometry.buildSkydome = function(latitudeBands, longitudeBands, use16bit, useIndices) {
    var g = RendererGeometry;
    var numFaces = (latitudeBands * longitudeBands) * 2;
    var numVertices = (latitudeBands * longitudeBands) * (useIndices ? 1 : 3);
    var vertices = new Float32Array(numVertices * 3);
    var uvs = new Float32Array(numVertices * 2);
    var indices = useIndices ? (new Uint16Array(numFaces * 3)) : null;
    var index = 0, index2 = 0;
    var g = RendererGeometry, lat, lon, lon2, lat2, v, flon, flat;

    if (useIndices) {

        for (lat = 0; lat < latitudeBands; lat++) {
            for (lon = 0; lon < longitudeBands; lon++) {

                flon = lon / longitudeBands;
                flat = lat / latitudeBands;
                v = g.spherePos(flon, flat);

                vertices[index] = v[0];
                vertices[index+1] = v[1];
                vertices[index+2] = v[2];

                uvs[index2] = flon;
                uvs[index2+1] = flat;

                index += 3;
                index2 += 2;
            }
        }

        index = 0;

        for (lat = 0; lat < (latitudeBands - 1); lat++) {
            for (lon = 0; lon < longitudeBands; lon++) {

                lat2 = lat + 1;
                lon2 = lon + 1;

                if (lon2 >= longitudeBands) {
                    lon2 = 0;
                }

                indices[index] = (lat2 * longitudeBands) + lon;
                indices[index+1] = (lat * longitudeBands) + lon;
                indices[index+2] = (lat * longitudeBands) + lon2;

                indices[index+3] = (lat * longitudeBands) + lon2;
                indices[index+4] = (lat2 * longitudeBands) + lon2;
                indices[index+5] = (lat2 * longitudeBands) + lon;

                index += 6;
            }
        }

    } else {

        for (var lat = 0; lat < latitudeBands; lat++) {
            for (var lon = 0; lon < longitudeBands; lon++) {

                var lon1 = ((lon) / longitudeBands);
                var lon2 = ((lon+1) / longitudeBands);

                var lat1 = ((lat) / latitudeBands);
                var lat2 = ((lat+1) / latitudeBands);

                g.makeQuad(lon1, lat1, lon2, lat2, vertices, index, uvs, index2);
                index += 9*2;
                index2 += 6*2;
            }
        }

    }

    var bbox = new BBox(0,0,0,1,1,1);

    if (use16bit) {
        return { bbox:bbox, vertices:this.covnetTo16Bit(vertices), uvs: this.covnetTo16Bit(uvs), indices:indices};
    } else {
        return { bbox:bbox, vertices:vertices, uvs: uvs, indices:indices};
    }
};

RendererGeometry.covnetTo16Bit = function(array) {
    var t, array2 = new Uint16Array(array.length);

    for (var i = 0, li = array.length; i < li; i++) {
        t = array[i] * 65535;
        if (t < 0) t = 0; if (t > 65535) t = 65535;
        array2[i] = t;
    }

    return array2;
}


RendererGeometry.makeQuad = function(lon1, lat1, lon2, lat2, vertices, index, uvs, index2) {
    var g = RendererGeometry;
    var a = g.spherePos(lon1, lat1), ta = [lon1, lat1];
    var b = g.spherePos(lon1, lat2), tb = [lon1, lat2];
    var c = g.spherePos(lon2, lat1), tc = [lon2, lat1];
    var d = g.spherePos(lon2, lat2), td = [lon2, lat2];
    g.setFaceVertices(vertices, b, a, c, index);
    g.setFaceUVs(uvs, tb, ta, tc, index2);
    g.setFaceVertices(vertices, c, d, b, index+9);
    g.setFaceUVs(uvs, tc, td, tb, index2+6);
};


/* harmony default export */ __webpack_exports__["a"] = (RendererGeometry);




/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return processGMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return processGMap4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return processGMap5; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return processGMap6; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return processGMap7; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return radixDepthSortFeatures; });


function processGMap(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    var tileCount = renderer.config.mapFeaturesReduceParams[1]; //31; //labelGridCells
    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[0]; //0.6614; //labelsPerSquareInch
    var ppi = 96 * (window.devicePixelRatio || 1);
    var screenLX = renderer.curSize[0];
    var screenLY = renderer.curSize[1];
    var featureCount = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); 
    var i, li, top = renderer.config.mapFeaturesSortByTop;

    if (tileCount <= 0) {
        tileCount = featureCount * 2; //31; //labelGridCells
    } else {
        tileCount = tileCount;
    }

    //renderer.debugStr = '<br>featuresPerScr: ' + featureCount + '<br>gridCells: ' + tileCount + '';

    //get top features
    var featureCache = renderer.gmap;
    var featureCacheSize = renderer.gmapIndex;
    var topFeatures = renderer.gmapTop;
    var featureCount2 = featureCount;

    if (featureCount > featureCacheSize) {
        featureCount2 = featureCacheSize;
    }

    //distribute top features
    var tileSize = Math.floor(Math.sqrt((screenLX*screenLY) / tileCount));
    var hitMap = renderer.gmapHit, usedFeatures = 0;
    var tileFeatures, count, feature;
    var drawAllLabels = renderer.drawAllLabels;

    var colors = [
        [0, 0, 255, 255],
        [128, 0, 255, 255],
        [255, 0, 0, 255],
        [255, 128, 0, 255],
        [0, 255, 0, 255],
        [0, 255, 128, 255],
        [128, 255, 128, 255]
    ];

    var colorIndex = 0;

    do {
        var a,b,c,d,ix,iy,is,pp,tx,ty,mx,my,v,index,o,j;

        ix = screenLX / tileSize;
        iy = screenLY / tileSize;
        is = ix * iy;
        mx = Math.floor(ix);
        my = Math.floor(iy);
        ix = ix - mx;
        iy = iy - my;

        a = 1 / is;
        b = ix / is;
        c = iy / is;
        d = (ix*iy) / is;

        a = Math.floor(a * featureCount);
        b = Math.floor(b * featureCount);
        c = Math.floor(c * featureCount);
        d = Math.floor(d * featureCount);

        var hitMap = renderer.gmapStore;
        var hitMapCount = renderer.gmapHit;

        if (renderer.drawGridCells) {
            gpu.setState(renderer.lineLabelState);

            var x = 0, y = 0, j, lj;

            for (j = 0, lj = (my + 1); j < lj; j++) {
                for (i = 0, li = (mx + 1); i < li; i++) {
                    x = tileSize * i;
                    y = tileSize * j;

                    v = a;

                    if (i >= mx) {
                        if (j >= my) {
                            v =d;
                        } else {
                            v = b;
                        }

                    } else {
                        if (j >= my) {
                            v = b;
                        }
                    }

                    draw.drawLineString([[x, y, 0.5], [x+tileSize, y, 0.5],
                                         [x+tileSize, y+tileSize, 0.5], [x, y+tileSize, 0.5]], true, 1, colors[colorIndex], null, true, null, null, null);

                    draw.drawText(Math.round(x+5), Math.round(y + 5 + colorIndex * 15), 10, '' + v, colors[colorIndex], 0.5);
                }
            }

        }


        //clear hit-map
        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {
            hitMap[i] = null;
        }

        for (i = 0, li = featureCacheSize; i < li; i++) {
            feature = featureCache[i];
            if (!feature) {
                continue;
            }

            pp = feature[5];

            if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {
                featureCache[i] = null;
                continue;
            }

            tx = pp[0] / tileSize;
            ty = pp[1] / tileSize;

            if (tx > mx) {
                if (ty > my) {
                    v = d;
                } else {
                    v = b;
                }
            } else if (ty > my) {
                v = c;
            } else {
                v = a;
            }

            if (v > 0) {
                index = Math.floor(tx) + Math.floor(ty) * (mx + 1);

                tileFeatures = hitMap[index];

                if (tileFeatures) {
                    hitMap[index].push(i);
                } else {
                    hitMap[index] = [i];
                    hitMapCount[index] = v;
                }
            }
        }

        for (i = 0, li = (mx+1) * (my+1); i < li; i++) {
            tileFeatures = hitMap[i];

            if (tileFeatures && tileFeatures.length) {
                count = hitMapCount[i];

                if (count > tileFeatures.length) {
                    count = tileFeatures.length;
                }

                sortFeatures(tileFeatures, top, count, renderer);

                for (j = 0; j < count; j++){
                    index = topFeatures[j]
                    feature = featureCache[index];
                    topFeatures[j] = null;
                    featureCache[index] = null;

                    //render job
                    if (!drawAllLabels && feature[6]) { //no-overlap 
                        pp = feature[5];
                        o = feature[8];
                        if (!renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob)) {
                            renderer.rmap.storeRemovedRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob);
                        }
                    } else {
                        if (feature[0].hysteresis) {
                            renderer.jobHBuffer[feature[0].id] = feature[0];
                        } else {
                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);
                        }
                    }
                }

            }
        }

        a *= mx * my;
        b *= mx;
        c *= my;

        usedFeatures += a + b + c + d;
        featureCount -= a + b + c + d;
        tileSize *= 2;

        colorIndex++;

    } while(usedFeatures < featureCount2);

}


function sortFeatures(features, top, count, renderer) {
    var value, feature;
    var currentIndex = 0;
    var currentValue2 = top ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    var topFeatures = renderer.gmapTop;
    var topFeaturesIndex = 0;
    var topFeaturesIndex2 = 0;

    //remove feature from cache
    var featureCache = renderer.gmap, index;


    do {
        var currentValue = top ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
        topFeaturesIndex2 = topFeaturesIndex;

        for (var i = 0, li = features.length; i < li; i++) {
            index = features[i];
            feature = featureCache[index];
            value = feature[0].reduce[1];

            if (((top && value >= currentValue && value < currentValue2) || (value <= currentValue && value > currentValue2)) ) {
                if (currentValue != value) {
                    topFeaturesIndex = topFeaturesIndex2;
                }

                topFeatures[topFeaturesIndex] = index;
                topFeaturesIndex++;
                currentValue = value;
            }
        }

        currentValue2 = currentValue;
        currentIndex++;

    } while(currentIndex < count);

}

function storeFeatureToHitmap(id, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize) {
    var x1 = ix - 1, y1 = iy - 1, x,
        x2 = ix + 1, y2 = iy + 1, index, blockFeatures;

    if (x1 < 0) x1 = 0;
    if (y1 < 0) y1 = 0;
    if (x2 > mx) x2 = mx;
    if (y2 > my) y2 = my;

    for (; y1 <= y2; y1++) {
        for (x = x1; x <= x2; x++) {
            index = (y1 * mx + x) * 2;
            blockFeatures = hitMap[index];

            if (!hitMap[index]) {
                hitMap[index] = hcacheSize;
                hitMap[index+1] = hcacheSize+1;
                hcache[hcacheSize] = feature;
                hcache[hcacheSize+1] = 0;
                hcacheSize +=2;
            } else {
                hcache[hitMap[index+1]] = hcacheSize;
                hitMap[index+1] = hcacheSize+1;
                hcache[hcacheSize] = feature;
                hcache[hcacheSize+1] = 0;
                hcacheSize +=2;
            }
        }
    }

    return hcacheSize;
}


function processGMap4(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    var ppi = 96 * (window.devicePixelRatio || 1);

    var maxRadius = renderer.config.mapFeaturesReduceParams[0] * ppi; //mapFeatureRadius
    var maxHitcount = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //mapFeatureMaxOverlays

    var screenLX = renderer.curSize[0];
    var screenLY = renderer.curSize[1];
    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;
    var feature, feature2, pp, pp2, o;
    var drawAllLabels = renderer.drawAllLabels;

    //get top features
    var featureCache = renderer.gmap;
    var featureCacheSize = renderer.gmapIndex;

    var hcache = renderer.gmap2;
    var hcacheSize = 1;
    var hmap = renderer.gmap3;
    var hmapSize = renderer.gmap3Size;
    var hmap = renderer.gmap3;


    var hmin = 10000;
    var hmax = 0, h, r;

    var divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);

    if (divByDist) { // imp / dists
        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {
            return;
        }

        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);
        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); 
    }

    //filter features and sort them by importance
    for (i = 0, li = featureCacheSize; i < li; i++) {
        feature = featureCache[i];
        if (!feature) {
            continue;
        }

        pp = feature[5];

        if (divByDist) {
            r = feature[0].reduce;
            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;
            r[5] = h; //for debug
        } else {
            h = Math.round(feature[0].reduce[1]);            
        }

        if (h < 0) h = 0;
        if (h >= 10000) h = 9999;
        if (h < hmin) hmin = h;
        if (h > hmax) hmax = h;

        hmap[h][hmapSize[h]++] = feature;
    }

    var invMaxRadius = 1 / maxRadius, index, ix, iy, features;
    var mx = Math.floor(screenLX * invMaxRadius);
    var my = Math.floor(screenLY * invMaxRadius);

    var hitMap = renderer.gmapStore;
    var hitMapCount = renderer.gmapHit;

    //clear hit-map
    for (i = 0, li = (mx+1) * (my+1) * 2; i < li; i+=2) {
        hitMap[i] = 0;
    }

    //var hitCache = renderer.gmapHit2;
    var hitCacheSize = 0, j, lj, k, lk, hitCount, dx, dy, blockFeatures;

    maxRadius *= maxRadius;

    for (i = hmax, li = hmin; i >= 0; i--) {

        if (hmapSize[i] > 0) {
            var features = hmap[i];

            for (j = 0, lj = hmapSize[i]; j < lj; j++) {
                feature = features[j];

                hitCount = 0;
                pp = feature[5];

                //check area
                ix = Math.floor(pp[0] * invMaxRadius);
                iy = Math.floor(pp[1] * invMaxRadius);
                index = ((iy * mx) + ix) * 2;
                //blockFeatures = hitMap[index];

                //check
                if (hitMap[index]) {
                    index = hitMap[index];
                    do {
                        feature2 = hcache[index];
                        pp2 = feature2[5];

                        dx = pp[0] - pp2[0];
                        dy = pp[1] - pp2[1];

                        if ((dx*dx+dy*dy) < maxRadius) {
                            hitCount++;
                            if (hitCount > maxHitcount) {
                                break;
                            }
                        }

                        index = hcache[index+1];
                    } while (index);
                }

                // check                
                if (hitCount <= maxHitcount) {
                    index = hitCacheSize;

                    //render job
                    if (!drawAllLabels && feature[6]) { //no-overlap 
                        pp = feature[5];
                        o = feature[8];
                        if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {
                            //hitCache[hitCacheSize] = feature;
                            hitCacheSize++;
                        }
                    } else {
                        if (feature[0].hysteresis) {
                            renderer.jobHBuffer[feature[0].id] = feature[0];
                        } else {
                            renderer.drawnJobs++;
                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
                        }

                        //hitCache[hitCacheSize] = feature;
                        hitCacheSize++;
                    }

                    //store to hitmap
                    if (index != hitCacheSize) {
                        hcacheSize = storeFeatureToHitmap(index, feature, ix, iy, mx, my, hitMap, hcache, hcacheSize);
                    }
                }

            }

            hmapSize[i] = 0;  //zero size
        }
    }
}

function processGMap5(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    var ppi = 96 * (window.devicePixelRatio || 1);

    var screenLX = renderer.curSize[0];
    var screenLY = renderer.curSize[1];
    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;
    var feature, feature2, pp, pp2, o;
    var drawAllLabels = renderer.drawAllLabels;

    //get top features
    var featureCache = renderer.gmap;
    var featureCacheSize = renderer.gmapIndex;

    var hcache = renderer.gmap2;
    var hcacheSize = 1;
    var hmap = renderer.gmap3;
    var hmapSize = renderer.gmap3Size;
    var hmap = renderer.gmap3;


    var hmin = 10000;
    var hmax = 0, h, r;

    var divByDist = (renderer.config.mapFeaturesReduceFactor >= 1);

    if (divByDist) { // imp / dists
        if (renderer.fmaxDist == Number.NEGATIVE_INFINITY || renderer.fminDist == Number.POSITIVE_INFINITY) {
            return;
        }

        var ub = 1 - Math.log(renderer.fminDist) / Math.log(101);
        var lb = -Math.log(renderer.fmaxDist) / Math.log(101); 
    }

    //filter features and sort them by importance
    for (i = 0, li = featureCacheSize; i < li; i++) {
        feature = featureCache[i];
        if (!feature) {
            continue;
        }

        pp = feature[5];

        if (divByDist) {
            r = feature[0].reduce;
            h = Math.round(-5000 + ( ( Math.log(r[1]+1) - Math.log(r[4]) ) / Math.log(101) - lb ) / ( ub-lb ) * 10000) + 5000;
            r[5] = h; //for debug
        } else {
            h = Math.round(feature[0].reduce[1]);            
        }

        if (h < 0) h = 0;
        if (h >= 10000) h = 9999;
        if (h < hmin) hmin = h;
        if (h > hmax) hmax = h;

        hmap[h][hmapSize[h]++] = feature;
    }

    var j, lj;

    for (i = hmax, li = hmin; i >= 0; i--) {

        if (hmapSize[i] > 0) {
            var features = hmap[i];

            for (j = 0, lj = hmapSize[i]; j < lj; j++) {
                feature = features[j];

                pp = feature[5];

                // check                

                //render job
                if (!drawAllLabels && feature[6]) { //no-overlap is always enabled
                    pp = feature[5];
                    o = feature[8];
                    if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {
                        //hitCache[hitCacheSize] = feature;
                    }
                } else {
                    if (feature[0].hysteresis) {
                        renderer.jobHBuffer[feature[0].id] = feature[0];
                    } else {
                        renderer.drawnJobs++;
                        draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
                    }
                }
            }

            hmapSize[i] = 0;  //zero size
        }
    }
}


function radixSortFeatures(renderer, input, inputSize, tmp, depthOnly) {
    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; 
    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;
    var distanceFactor = renderer.config.mapFeaturesReduceFactor;
    //var screenDistanceFactor = renderer.config.mapFeaturesReduceFactor2 * 0.5, e100 = 1.0/Math.exp(100);
    //var centerOffset = renderer.config.mapFeaturesReduceFactor3;

    var depthTest = true;

    var sx = renderer.curSize[0], sy = renderer.curSize[1];
    var cx = sx * 0.5, cy = sy * 0.5;
    var invcx = 1.0 / (cx+0.0001), invcy = 1.0 / (cy+0.0001), dx, dy, yy;
    var invsy = 1.0 / (sy+0.0001);

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        r = item[0].reduce;

        // optical center
        //pp = item[5]; 
        //yy = Math.pow(pp[1] * invsy, centerOffset) * sy;
        //dx = (cx - pp[0]) * invcx;
        //dy = (cy - yy) * invcx;

        val = r[3] - distanceFactor * Math.log(r[4]); // - screenDistanceFactor * Math.log(dx*dx + dy*dy + e100);
        r[6] = val;
        val += 10000;
        if (val < 0) val = 0;
        bfloat32[0] = val;
        val = bunit32[0];
        r[5] = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (var j = 0; j < 4; j++) {
        var t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].reduce[5];
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].reduce[5];
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].reduce[5];
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].reduce[5];
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            val = input[i][0].reduce[5];
            console.log('' + val +  ' ' + input[i][0].id);
        }
    }

    return input;
}


function processGMap6(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1]; //0.6614; //labelsPerSquareInch
    var ppi = 96 * (window.devicePixelRatio || 1);
    var screenLX = renderer.curSize[0];
    var screenLY = renderer.curSize[1];
    var maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); 
    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp;
    var feature, feature2, pp, pp2, o, featureCount = 0;
    var drawAllLabels = renderer.drawAllLabels;

    var depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);
    var depthOffset = -renderer.config.mapFeaturesReduceFactor3;

    //var depthTest = true;


    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures;

    //get top features
    var featureCache = renderer.gmap;
    var featureCacheSize = renderer.gmapIndex;
    var featureCache2 = renderer.gmap2;

    if (drawAllLabels) {
        maxFeatures = featureCacheSize;
    }

    //filter features and sort them by importance
    radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);

    for (i = featureCacheSize - 1; i >= 0; i--) {
        feature = featureCache[i];

        // check                

        //render job
        if (!drawAllLabels && feature[6]) { //no-overlap is always enabled
            pp = feature[5];
            o = feature[8];
            
            if (depthTest) {
                if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true, [pp[0],pp[1]+feature[1],feature[0].reduce,depthOffset])) {
                    featureCount++;
                }
            } else {
                if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {
                    featureCount++;
                }
            }

            if (featureCount >= maxFeatures) {
                return;
            }

        } else {
            if (feature[0].hysteresis) {
                renderer.jobHBuffer[feature[0].id] = feature[0];
            } else {
                renderer.drawnJobs++;
                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
            }
        }
    }

}


function radixDepthSortFeatures(renderer, input, inputSize, tmp) {
    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; 
    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;
    var distanceFactor = renderer.config.mapFeaturesReduceFactor;
    //var screenDistanceFactor = renderer.config.mapFeaturesReduceFactor2 * 0.5, e100 = 1.0/Math.exp(100);
    //var centerOffset = renderer.config.mapFeaturesReduceFactor3;

    var depthTest = true;

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = 1 - item.lastSubJob[5][2];
        bfloat32[0] = val;
        val = bunit32[0];
        item.depth = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (var j = 0; j < 4; j++) {
        var t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item.depth;
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item.depth;
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item.depth;
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item.depth;
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    /*if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            item = input[i];
            val = item.depth;
            console.log('' + val +  ' ' + item.lastSubJob[0].id);
        }
    }*/

    return input;
}


function fillVMapHoles(vmap, mx, my) {
    var holesCount = 0, v;
    var x0, y0, x1, y1, x2, y2;
    var maxX = mx - 1;
    var maxY = my - 1;

    for (var j = 0, lj = my; j < lj; j++) {
        for (var i = 0, li = mx; i < li; i++) {

            v = vmap[j*mx+i];

            if (v === null) {

                //find 
                x0 = i - 1;
                y0 = j - 1;

                x1 = i;
                y1 = j;

                x2 = i + 1;
                y2 = j + 1;

                if (x0 < 0) x0 = 0;
                if (y0 < 0) y0 = 0;

                if (x2 > maxX) x2 = maxX;
                if (y2 > maxY) y2 = maxY;

                var vv = [vmap[y0*mx+x0],
                          vmap[y0*mx+x1],
                          vmap[y0*mx+x2],
                          vmap[y1*mx+x0],
                          vmap[y1*mx+x2],
                          vmap[y2*mx+x0],
                          vmap[y2*mx+x1],
                          vmap[y2*mx+x2]];

                var vcount = 0;
                var vsum = 0;

                for (var k= 0; k < 8; k++) {
                    if (vv[k] !== null) {
                        vcount++;
                        vsum += vv[k];
                    }
                }

                if (vcount != 0) {
                    vmap[j*mx+i] = vsum / vcount;
                } else {
                    holesCount++;
                }
            }
        }
    }

    if (holesCount != 0) {
        fillVMapHoles(vmap, mx, my);
    }
}


function getVMapValue(vmap, x, y, mx, my) {
    x -= 0.5;
    y -= 0.5;

    var maxX = mx - 1;
    var maxY = my - 1;

    if (x < 0) { x = 0; }
    if (y < 0) { y = 0; }
    if (x > maxX) { x = maxX; }
    if (y > maxY) { y = maxY; }

    var ix = Math.floor(x);
    var iy = Math.floor(y);
    var fx = x - ix;
    var fy = y - iy;

    var index = iy * mx;
    var index2 = (iy == maxY) ? index : index + mx;
    var ix2 = (ix == maxX) ? ix : ix + 1; 
    var v00 = vmap[index + ix];
    var v01 = vmap[index + ix2];
    var v10 = vmap[index2 + ix];
    var v11 = vmap[index2 + ix2];
    var w0 = (v00 + (v01 - v00)*fx);
    var w1 = (v10 + (v11 - v10)*fx);
   
    return (w0 + (w1 - w0)*fy);
}


function radixDeltaSortFeatures(renderer, input, inputSize, tmp) {
    var count = inputSize < (1 << 16) ? renderer.radixCountBuffer16 : renderer.radixCountBuffer32; 
    var item, val, bunit32 = renderer.buffUint32, bfloat32 = renderer.buffFloat32, i, r, pp;

    if (count.fill) {
        count.fill(0);
    } else { //IE fallback
        for (i = 0; i < (256*4); i++) {
            count[i] = 0;
        }
    }

    // count all bytes in one pass
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        //val = 1 - item.lastSubJob[5][2];
        bfloat32[0] = item[0].delta;
        val = bunit32[0];
        item[0].delta = val;
        count[val & 0xFF]++;
        count[((val >> 8) & 0xFF) + 256]++;
        count[((val >> 16) & 0xFF) + 512]++;
        count[((val >> 24) & 0xFF) + 768]++;
    }

    // create summed array
    for (var j = 0; j < 4; j++) {
        var t = 0, sum = 0, offset = j * 256;

        for (i = 0; i < 256; i++) {
            t = count[i + offset];
            count[i + offset] = sum;
            sum += t;
        }
    }

    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].delta;
        tmp[count[val & 0xFF]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].delta;
        input[count[((val >> 8) & 0xFF) + 256]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = input[i];
        val = item[0].delta;
        tmp[count[((val >> 16) & 0xFF) + 512]++] = item;
    }
    for (i = 0; i < inputSize; i++) {
        item = tmp[i];
        val = item[0].delta;
        input[count[((val >> 24) & 0xFF) + 768]++] = item;
    }

    /*if (i == -123) { //debug
        for (i = 0; i < inputSize; i++) {
            item = input[i];
            val = item.depth;
            console.log('' + val +  ' ' + item.lastSubJob[0].id);
        }
    }*/

    return input;
}

function processGMap7(gpu, gl, renderer, screenPixelSize, draw) {
    if (!renderer.config.mapFeaturesReduceParams) {
        return;
    }

    var tileCount = renderer.config.mapFeaturesReduceParams[5];
    var featuresPerSquareInch = renderer.config.mapFeaturesReduceParams[1];
    var ppi = 96 * (window.devicePixelRatio || 1);
    var screenLX = renderer.curSize[0];
    var screenLY = renderer.curSize[1];
    var maxFeatures = Math.ceil((screenLX/ppi)*(screenLY/ppi)*featuresPerSquareInch); 
    var featuresPerTile = maxFeatures / (tileCount * tileCount); 
    var featuresPerTileInt = Math.floor(featuresPerTile); 
    var featuresPerTileFract = featuresPerTile - featuresPerTileInt; 
    var tileSizeX = screenLX / tileCount;
    var tileSizeY = screenLY / tileCount;

    renderer.debugStr = '<br>featuresPerScr: ' + maxFeatures + '<br>featuresPerTile: ' + featuresPerTile.toFixed(2);

    var i, li, top = renderer.config.mapFeaturesSortByTop, tmp, featureCount = 0;
    //var feature, feature2, pp, pp2, o, featureCount = 0;
    //var drawAllLabels = renderer.drawAllLabels;

    var depthTest = (renderer.config.mapFeaturesReduceFactor2 != 0);
    var depthOffset = -renderer.config.mapFeaturesReduceFactor3;

    //get top features
    var featureCache = renderer.gmap;
    var featureCacheSize = renderer.gmapIndex;
    var featureCache2 = renderer.gmap2;
    var featureCacheSize2 = 0;
    var vmap = renderer.gmap4;
    var drawAllLabels = renderer.drawAllLabels;

    if (drawAllLabels) {
        maxFeatures = featureCacheSize;
    }

    if (featureCacheSize > 0) {

        //filter features and sort them by importance
        radixSortFeatures(renderer, featureCache, featureCacheSize, featureCache2);

        if (drawAllLabels) {

            for (i = featureCacheSize - 1; i >= 0; i--) {
                feature = featureCache[i];

                if (feature[0].hysteresis) {
                    renderer.jobHBuffer[feature[0].id] = feature[0];
                } else {
                    renderer.drawnJobs++;
                    draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
                }
            }

        } else {

            //distribute top features
            var hitMap = renderer.gmapHit, usedFeatures = 0;
            var tileFeatures, count, feature;

            var ix,iy,is,pp,tx,ty,mx,my,v,v2,index,o,j;

            ix = screenLX / tileSizeX;
            iy = screenLY / tileSizeY;
            mx = Math.round(ix);
            my = Math.round(iy);
            //ix = ix - mx;
            //iy = iy - my;

            var hitMap = renderer.gmapStore;
            var hitMapCount = renderer.gmapHit;

            //clear hit-map
            for (i = 0, li = mx * my; i < li; i++) {
                hitMap[i] = null;
                vmap[i] = null;
            }

            for (i = featureCacheSize - 1; i >= 0; i--) {

                feature = featureCache[i];
                if (!feature) {
                    continue;
                }

                pp = feature[5];

                if (pp[0] < 30 || pp[0] >= (screenLX-30) || pp[1] < 30 || pp[1] >= (screenLY-30)) {
                    featureCache[i] = null;
                    continue;
                }

                tx = pp[0] / tileSizeX;
                ty = pp[1] / tileSizeY;

                index = Math.floor(tx) + Math.floor(ty) * (mx);

                tileFeatures = hitMap[index];

                if (tileFeatures) {
                    hitMap[index].push(i);
                } else {
                    hitMap[index] = [i];
                    //hitMapCount[index] = v;
                }
            }


            for (i = 0, li = (mx) * (my); i < li; i++) {
                tileFeatures = hitMap[i];

                if (tileFeatures && tileFeatures.length) {
                    count = tileFeatures.length;

                    if (count > featuresPerTileInt) {
                        count = featuresPerTileInt;
                    }

                    if (count == 0) {
                        vmap[i] = null;
                    } else {
                        index = tileFeatures[count - 1];
                        feature = featureCache[index];

                        v = feature[0].reduce[6];

                        if (tileFeatures.length > count) {
                            index = tileFeatures[count];
                            feature = featureCache[index];
                            v2 = feature[0].reduce[6];
                            
                            v = v + (v2 - v) * featuresPerTileFract;
                        }

                        vmap[i] = v;
                    }
                }
            }

            fillVMapHoles(vmap, mx, my);


            for (i = featureCacheSize - 1; i >= 0; i--) {
                feature = featureCache[i];
                if (!feature) {
                    continue;
                }

                v = feature[0].reduce[6];
                pp = feature[5];

                var vmax = getVMapValue(vmap, pp[0] / tileSizeX, pp[1] / tileSizeY, mx, my);

                if (v >= vmax) {

                    //render job
                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled
                        pp = feature[5];
                        o = feature[8];
                        
                        if (depthTest) {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true, [pp[0],pp[1]+feature[1],feature[0].reduce,depthOffset])) {
                                featureCount++;
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {
                                featureCount++;
                            }
                        }

                    } else {
                        if (feature[0].hysteresis) {
                            renderer.jobHBuffer[feature[0].id] = feature[0];
                        } else {
                            renderer.drawnJobs++;
                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
                        }
                    }
                } else {
                    //store v delta
                    feature[0].delta = Math.abs(vmax - v);
                    featureCache2[featureCacheSize2] = feature; 
                    featureCacheSize2++;
                }
            }

            if (featureCount < maxFeatures && featureCacheSize2 > 0) {
                //sort deltas
                radixDeltaSortFeatures(renderer, featureCache2, featureCacheSize2, featureCache);

                for (i = featureCacheSize2 - 1; i >= 0; i--) {
                    feature = featureCache2[i];

                    //render job
                    if (/*!drawAllLabels &&*/ feature[6]) { //no-overlap is always enabled
                        pp = feature[5];
                        o = feature[8];
                        
                        if (depthTest) {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true, [pp[0],pp[1]+feature[1],feature[0].reduce,depthOffset])) {
                                featureCount++;
                            }
                        } else {
                            if (renderer.rmap.addRectangle(pp[0]+o[0], pp[1]+o[1], pp[0]+o[2], pp[1]+o[3], feature[7], feature[0].lastSubJob, true)) {
                                featureCount++;
                            }
                        }

                    } else {
                        if (feature[0].hysteresis) {
                            renderer.jobHBuffer[feature[0].id] = feature[0];
                        } else {
                            renderer.drawnJobs++;
                            draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, feature[0].lastSubJob, null);
                        }
                    }

                    if (featureCount >= maxFeatures) {
                        break;
                    }
                }
            }
        }
    }


    if (renderer.drawGridCells) {
        gpu.setState(renderer.lineLabelState);

        var x = 0, y = 0, j, lj;

        for (j = 0, lj = my; j < lj; j++) {
            for (i = 0, li = mx; i < li; i++) {
                x = tileSizeX * i;
                y = tileSizeY * j;

                var v = vmap[j*mx+i];

                draw.drawLineString([[x, y, 0.5], [x+tileSizeX, y, 0.5],
                                     [x+tileSizeX, y+tileSizeY, 0.5], [x, y+tileSizeY, 0.5]], true, 1, [0,0,255,255], null, true, null, null, null);

                draw.drawText(Math.round(x+5), Math.round(y + 5), 11, '' + v.toFixed(2), [255,255,255,255], 0.5);
            }
        }
    }

}






/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var GpuBBox = function(gpu, free) {
    this.gl = gpu.gl;

    var gl = this.gl;

    if (gl == null)
        return;

    this.free = free;
    this.vertexPositionBuffer = null;

    //create vertex buffer
    this.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);

    var vertices;

    if (free) {
        vertices = [0,0,0, 0,0,1,
            0,0,1, 0,0,2,
            0,0,2, 0,0,3,
            0,0,3, 0,0,0,

            0,0,4, 0,0,5,
            0,0,5, 0,0,6,
            0,0,6, 0,0,7,
            0,0,7, 0,0,4,

            0,0,0, 0,0,4,
            0,0,1, 0,0,5,
            0,0,2, 0,0,6,
            0,0,3, 0,0,7 ];
    } else {
        vertices = [0,0,0, 1,0,0,
            1,0,0, 1,1,0,
            1,1,0, 0,1,0,
            0,1,0, 0,0,0,

            0,0,1, 1,0,1,
            1,0,1, 1,1,1,
            1,1,1, 0,1,1,
            0,1,1, 0,0,1,

            0,0,0, 0,0,1,
            1,0,0, 1,0,1,
            1,1,0, 1,1,1,
            0,1,0, 0,1,1 ];
    }

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    this.vertexPositionBuffer.itemSize = 3;
    this.vertexPositionBuffer.numItems = vertices.length / 3;

    this.size = 4 + 4 * 8;
    this.lines = this.vertexPositionBuffer.numItems / 3;
};

//destructor
GpuBBox.prototype.kill = function() {
    this.gl.deleteBuffer(this.vertexPositionBuffer);
};

// Draws the mesh, given the two vertex shader attributes locations.
GpuBBox.prototype.draw = function(program, attrPosition) {
    var gl = this.gl;
    if (gl == null)
        return;

    var vertexPositionAttribute = program.getAttribute(attrPosition);

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    //draw lines
    gl.drawArrays(gl.LINES, 0, this.vertexPositionBuffer.numItems);

};


/* harmony default export */ __webpack_exports__["a"] = (GpuBBox);



/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var GpuDevice = function(renderer, div, size, keepFrameBuffer, antialias, aniso) {
    this.renderer = renderer;
    this.div = div;
    this.canvas =  null;
    this.curSize = size;
    this.currentProgram = null;
    this.maxAttributesCount = 8;
    this.newAttributes = new Uint8Array(this.maxAttributesCount);
    this.enabledAttributes = new Uint8Array(this.maxAttributesCount);
    this.noTextures = false;
    this.barycentricBuffer = null;
   
    //state of device when first initialized
    this.defaultState = this.createState({blend:false, stencil:false, zequal: false, ztest:false, zwrite: false, culling:false}); 
    this.currentState = this.defaultState;
    this.currentOffset = 0; //used fot direct offset

    this.keepFrameBuffer = (keepFrameBuffer == null) ? false : keepFrameBuffer;
    this.antialias = antialias ? true : false;
    this.anisoLevel = aniso;
};


GpuDevice.prototype.init = function() {
    var canvas = document.createElement('canvas');

    if (canvas == null) {
        //canvas not supported
        return;
    }

    this.canvas = canvas;

    canvas.width = this.curSize[0];
    canvas.height = this.curSize[1];
    canvas.style.display = 'block';

    if (canvas.getContext == null) {
        //canvas not supported
        return;
    }

    canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), false);
    canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), false);

    var gl;

    try {
        gl = canvas.getContext('webgl', {preserveDrawingBuffer: this.keepFrameBuffer, antialias: this.antialias, stencil: true}) || canvas.getContext('experimental-webgl', {preserveDrawingBuffer: this.keepFrameBuffer});
    } catch(e) {
        //webgl not supported
    }

    if (!gl) {
        //webgl not supported
        return;
    }

    this.gl = gl;

    if (!gl.getExtension('OES_standard_derivatives')) {
    }

    this.anisoExt = (
      gl.getExtension('EXT_texture_filter_anisotropic') ||
      gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
    );

    if (this.anisoExt) {
        this.maxAniso = gl.getParameter(this.anisoExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

        if (this.anisoLevel) {
            if (this.anisoLevel == -1) {
                this.anisoLevel = this.maxAniso;
            } else {
                this.anisoLevel = Math.min(this.anisoLevel, this.maxAniso);
            }
        }
    } else {
        this.maxAniso = 0;
        this.anisoLevel = 0;
    }

    this.div.appendChild(canvas);

    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    //gl.enable(gl.DEPTH_TEST);

    //initial state
    gl.disable(gl.BLEND);

    gl.disable(gl.STENCIL_TEST);
    gl.depthMask(false);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    gl.disable(gl.CULL_FACE);

    //clear screen
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
};


GpuDevice.prototype.kill = function() {
    this.div.removeChild(this.canvas);
    delete this.canvas;
    this.canvas = null;
};


GpuDevice.prototype.contextLost = function(event) {
    event.preventDefault();
    this.renderer.core.contextLost = true;
    this.renderer.core.callListener('gpu-context-lost', {});
};


GpuDevice.prototype.contextRestored = function() {
    this.renderer.core.callListener('gpu-context-restored', {});
};


GpuDevice.prototype.resize = function(size, skipCanvas) {
    this.curSize = size;
    var canvas = this.canvas, gl = this.gl;

    if (canvas != null && skipCanvas !== true) {
        canvas.width = this.curSize[0];
        canvas.height = this.curSize[1];
    }

    if (gl != null) {
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    }
};


GpuDevice.prototype.setAniso = function(aniso) {
    if (this.anisoExt) {
        if (this.anisoLevel) {
            if (aniso == -1) {
                this.anisoLevel = this.maxAniso;
            } else {
                this.anisoLevel = Math.min(aniso, this.maxAniso);
            }
        }
    }
};


GpuDevice.prototype.getCanvas = function() {
    return this.canvas;
};


GpuDevice.prototype.setViewport = function() {
    this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
};


GpuDevice.prototype.clear = function(clearDepth, clearColor, color) {
    if (color != null) {
        this.gl.clearColor(color[0]/255, color[1]/255, color[2]/255, color[3]/255);
    }
    
    this.gl.clear((clearColor ? this.gl.COLOR_BUFFER_BIT : 0) |
                  (clearDepth ? this.gl.DEPTH_BUFFER_BIT : 0) );
};


GpuDevice.prototype.useProgram = function(program, attributes, nextSampler) {
    if (this.currentProgram != program) {
        this.gl.useProgram(program.program);
        this.currentProgram = program;

        program.setSampler('uSampler', 0);
        
        if (nextSampler) {
            program.setSampler('uSampler2', 1);
        }

        var newAttributes = this.newAttributes;
        var enabledAttributes = this.enabledAttributes; 
       
        //reset new attributes list
        for (var i = 0, li = newAttributes.length; i < li; i++){
            newAttributes[i] = 0;
        }
        
        for (i = 0, li = attributes.length; i < li; i++){
            var index = program.getAttribute(attributes[i]);
            
            if (index != -1){
                newAttributes[index] = 1;
            }
        }

        //enable or disable current attributes according to new attributes list
        for (i = 0, li = newAttributes.length; i < li; i++){
            if (enabledAttributes[i] != newAttributes[i]) {
                if (newAttributes[i]) {
                    this.gl.enableVertexAttribArray(i);
                    enabledAttributes[i] = 1;
                } else {
                    this.gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }
    }
};


GpuDevice.prototype.bindTexture = function(texture, id) {
    if (!texture.loaded) {
        return;
    }

    this.gl.activeTexture(id ? this.gl.TEXTURE1 : this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture.texture);
};


GpuDevice.prototype.setFramebuffer = function(texture) {
    if (texture != null) {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, texture.framebuffer);
    } else {
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    }
};


GpuDevice.prototype.createState = function(state) {
    if (state.blend == null) { state.blend = false; }
    if (state.stencil == null) { state.stencil = false; }
    if (state.zwrite == null) { state.zwrite = true; }
    if (state.ztest == null) { state.ztest = true; }
    if (state.zequal == null) { state.zequal = false; }
    if (state.culling == null) { state.culling = true; }

    return state;
};


GpuDevice.prototype.setState = function(state) {
    if (!state) {
        return;
    }

    var gl = this.gl;
    var currentState = this.currentState;

    if (currentState.blend != state.blend) {
        if (state.blend) {
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
        } else {
            gl.disable(gl.BLEND);
        }
    }

    if (currentState.stencil != state.stencil) {
        if (state.stencil) {
            gl.enable(gl.STENCIL_TEST);
        } else {
            gl.disable(gl.STENCIL_TEST);
        }
    }

    if (currentState.zwrite != state.zwrite) {
        if (state.zwrite) {
            gl.depthMask(true);
        } else {
            gl.depthMask(false);
        }
    }

    if (currentState.ztest != state.ztest) {
        if (state.ztest != 0) {
            gl.enable(gl.DEPTH_TEST);
        } else {
            gl.disable(gl.DEPTH_TEST);
        }
    }

    if (currentState.zequal != state.zequal) {
        if (state.zequal != 0) {
            gl.depthFunc(gl.LEQUAL);
        } else {
            gl.depthFunc(gl.LESS);
        }
    }

    if (currentState.culling != state.culling) {
        if (state.culling) {
            gl.enable(gl.CULL_FACE);
        } else {
            gl.disable(gl.CULL_FACE);
        }
    }

    this.currentState = state;
};


/* harmony default export */ __webpack_exports__["a"] = (GpuDevice);






/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bbox__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_utils__ = __webpack_require__(2);






//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var BBox = __WEBPACK_IMPORTED_MODULE_1__bbox__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_2__utils_math__["a" /* math */];
var utils = __WEBPACK_IMPORTED_MODULE_3__utils_utils__["a" /* utils */];


var GpuGroup = function(id, bbox, origin, gpu, renderer) {
    this.id = id;
    this.bbox = null;
    this.origin = origin || [0,0,0];
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.renderer = renderer;
    this.jobs = [];
    this.reduced = 0;
    this.geometries = {};
    this.subjob = null;
    this.mv = new Float32Array(16);
    this.mvp = new Float32Array(16);

    if (bbox != null && bbox[0] != null && bbox[1] != null) {
        this.bbox = new BBox(bbox[0][0], bbox[0][1], bbox[0][2], bbox[1][0], bbox[1][1], bbox[1][2]);
    }

    this.size = 0;
    this.polygons = 0;
};

//destructor
GpuGroup.prototype.kill = function() {
    for (var i = 0, li = this.jobs.length; i < li; i++) {
        var job = this.jobs[i]; 

        switch(job.type) {
        case 1:
        case 11:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 3:
        case 2:
        case 4:
        case 5:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexNormalBuffer) this.gl.deleteBuffer(job.vertexNormalBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 6:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;

        case 7:
        case 8:
            if (job.vertexPositionBuffer) this.gl.deleteBuffer(job.vertexPositionBuffer);
            if (job.vertexTexcoordBuffer) this.gl.deleteBuffer(job.vertexTexcoordBuffer);
            if (job.vertexOriginBuffer) this.gl.deleteBuffer(job.vertexOriginBuffer);
            if (job.vertexElementBuffer) this.gl.deleteBuffer(job.vertexElementBuffer);
            break;
        }
    }

    //remove geometries
    for (var key in this.geometries) {
        var geometries = this.geometries[key];
        var globalGeometry = this.renderer.geometries[key];
        this.geometries[key] = null;

        //remove geometry from glbal stack
        for (i = 0, li = geometries.length; i < li; i++) {
            if (geometries[i] == globalGeometry) {
                this.renderer.geometries[key] = null;
            }
        }
    }
};


GpuGroup.prototype.getSize = function() {
    return this.size;
};


GpuGroup.prototype.getZbufferOffset = function() {
    return this.size;
};

GpuGroup.prototype.addGeometry = function(data) {
    var id = data['id'];

    if (!this.geometries[id]) {
        this.geometries[id] = [data];
    } else {
        this.geometries[id].push(data);
    }

    this.renderer.geometries[id] = data;
};

GpuGroup.prototype.convertColor = function(c) {
    var f = 1.0/255;
    return [c[0]*f, c[1]*f, c[2]*f, c[3]*f];
};

GpuGroup.prototype.addLineJob = function(data) {
    var gl = this.gl;

    var vertices = data.vertexBuffer;

    var job = {};

    if (data.type == 13) {
        job.type = 11;
    } else {
        job.type = 1;
    }

    job.program = this.renderer.progLine;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.style = data['style'] || 0;
    job.stencil = (data['stencil'] === false) ? false : true;
    job.culling = data['culling'] || 0;
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        job.program2 = this.renderer.progELine;

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 3;
    job.vertexPositionBuffer.numItems = vertices.length / 3;

    if (job.advancedHit) {
        job.program = this.renderer.progLine;

        var elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4;
    this.polygons += vertices.length / (3 * 3);
};


GpuGroup.prototype.addExtentedLineJob = function(data) {
    var gl = this.gl;

    var vertices = data.vertexBuffer;
    var normals = data.normalBuffer;

    var job = {};
    job.type = data['type'];

    
    switch(job.type) {
    case 6:  job.type = 3;  break;
    case 7:  job.type = 2;  break;
    case 9:  job.type = 4;  break;
    case 10: job.type = 5; break;
    }

    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.advancedHit = data['advancedHit'];
    job.widthByRatio = data['width-units'] == 'ratio',
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.lineWidth = data['line-width'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    if (data['texture'] != null) {
        var texture = data['texture'];
        var bitmap = texture[0];
        job.texture = [this.renderer.getBitmap(bitmap['url'], bitmap['filter'] || 'linear', bitmap['tiled'] || false),
            texture[1], texture[2], texture[3], texture[4]];
        var background = this.convertColor(data['background']);

        if (background[3] != 0) {
            job.background = background;
        }
    }

    switch(job.type) {
    case 3:   job.program = (background[3] != 0) ? this.renderer.progTBLine : this.renderer.progTLine;  break;
    case 2:   job.program = this.renderer.progRLine;  break;
    case 4:   job.program = this.renderer.progLine3;  break;
    case 5:  job.program = (background[3] != 0) ? this.renderer.progTPBLine : this.renderer.progTPLine; break;
    }

    if (!job.program.isReady()) {
        return;
    }

    if (job.advancedHit) {
        switch(job.type) {
        case 3:   job.program2 = this.renderer.progETLine;  break;
        case 2:   job.program2 = this.renderer.progERLine;  break;
        case 4:   job.program2 = this.renderer.progELine3;  break;
        case 5:  job.program2 = this.renderer.progETPLine; break;
        }

        if (!job.program2.isReady()) {
            return;
        }
    }

    //create vertex buffer
    job.vertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    job.vertexPositionBuffer.itemSize = 4;
    job.vertexPositionBuffer.numItems = vertices.length / 4;

    //create normal buffer
    job.vertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
    job.vertexNormalBuffer.itemSize = 4;
    job.vertexNormalBuffer.numItems = normals.length / 4;

    if (job.advancedHit) {
        var elements = data.elementBuffer;

        job.vertexElementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexElementBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, elements, gl.STATIC_DRAW);
        job.vertexElementBuffer.itemSize = 1;
        job.vertexElementBuffer.numItems = elements.length;
    }

    this.jobs.push(job);

    this.size += vertices.length * 4 + normals.length * 4;
    this.polygons += vertices.length / (4 * 3);
};


GpuGroup.prototype.addLineLabelJob = function(data) {
    var gl = this.gl;

    if (data.singleBuffer) {
        var singleBuffer = data.singleBuffer;
        var singleBuffer2 = data.singleBuffer2;
    } else {
        var vertices = data.vertexBuffer;
        var texcoords = data.texcoordsBuffer;
    }

    var job = {};
    job.type = 6;
    job.program = this.renderer.progText;
    job.color = this.convertColor(data['color']);
    job.color2 = this.convertColor(data['color2']);
    job.outline = data['outline'];
    job.zIndex = data['z-index'] + 256;
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.labelPoints = data['labelPoints'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.bbox = this.bbox;

    job.files = data['files'] || [];
    var fonts = data['fonts'] || ['#default'];
    job.fonts = fonts;

    for (var i = 0, li = fonts.length; i < li; i++) {
        fonts[i] = this.renderer.fonts[fonts[i]];
    }

    job.program = this.renderer.progText2;

    if (!job.program.isReady()) {
        return;
    }

    if (singleBuffer) {

        job.singleBuffer = singleBuffer;
        job.singleBuffer2 = singleBuffer2;
        job.textVector = data['textVector'];

        //this.size += vertices.length * 4 + texcoords.length * 4;
        this.polygons += (singleBuffer.length / 12) * 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        this.size += vertices.length * 4 + texcoords.length * 4;
        this.polygons += vertices.length / (4 * 3);
    }

    this.jobs.push(job);
};


GpuGroup.prototype.addIconJob = function(data, label, tile) {
    var gl = this.gl;

    var vertices = data.vertexBuffer;
    var texcoords = data.texcoordsBuffer;
    var origins = data.originBuffer;
    var singleBuffer = data.singleBuffer;
    var s = data['stick'];
    var f = 1.0/255;

    var job = { tile: tile };
    job.type = label ? 8 : 7;
    job.program = this.renderer.progIcon;
    job.color = this.convertColor(data['color']);
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.clickEvent = data['click-event'];
    job.hoverEvent = data['hover-event'];
    job.enterEvent = data['enter-event'];
    job.leaveEvent = data['leave-event'];
    job.hitable = data['hitable'];
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.stick = [s[0], s[1], s[2], s[3]*f, s[4]*f, s[5]*f, s[6]*f, s[7]];
    job.lod = data['lod'];
    job.zbufferOffset = data['zbuffer-offset'];
    job.hysteresis = data['hysteresis'];
    job.noOverlap = data['noOverlap'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];

    //if (job.id && job.id.indexOf('Longs Peak') != -1) {
      //  console.log('tile: ' + JSON.stringify(tile.id));        
    //}

    //console.log('id: ' + job.eventInfo['#id']);

    if (job.reduce) {
        switch(job.reduce[0]) {
            case 'tilt':       job.reduce[0] = 1; break;
            case 'tilt-cos':   job.reduce[0] = 2; break;
            case 'tilt-cos2':  job.reduce[0] = 3; break;
            case 'scr-count':  job.reduce[0] = 4; break;
            case 'scr-count2': job.reduce[0] = 5; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count3': job.reduce[0] = 6; this.renderer.drawnGeodataTilesUsed = true; break;
            case 'scr-count4': job.reduce[0] = 7; break;
            case 'scr-count5': job.reduce[0] = 8; break;
            case 'scr-count6': job.reduce[0] = 9; break;
            case 'scr-count7': job.reduce[0] = 10; break;
            case 'scr-count8': job.reduce[0] = 11; break;
        }

        job.reduce[5] = 0; //zero debug value
        job.reduce[6] = 0;
        job.reduce[7] = 0;

        if (job.reduce[0] >= 7 && job.reduce[0] <= 11) {

            if (job.reduce[0] == 10 || job.reduce[0] == 11) {
                job.reduce[1] = Math.abs(job.reduce[1]);
                job.reduce[3] = job.reduce[1] * job.reduce[2];
                job.reduce[2] = job.reduce[1];
                job.reduce[4] = 0;
            } else {
                job.reduce[2] = Math.abs(job.reduce[1]); //copy prominence for prom / dist support

                if (this.renderer.config.mapFeaturesReduceFactor >= 1) { // prom / dists
                    job.reduce[1] = job.reduce[2];
                } else {
                    if (job.reduce[0] == 9) {
                        job.reduce[1] = job.reduce[2];
                    } else {
                        job.reduce[1] = Math.floor((Math.log(job.reduce[2] * 500) / Math.log(1.0017)) + 5000);
                    }
                }
            }
        }
    }

    if (!job.program.isReady()) {
        return;
    }

    if (label !== true) {
        var icon = data['icon'];
        job.texture = this.renderer.getBitmap(null, icon['filter'] || 'linear', icon['tiled'] || false, icon['hash'], true);
        job.files = [];
    } else {
        job.color2 = this.convertColor(data['color2']);
        job.outline = data['outline'];
        job.size = data['size'];
        job.origin = data['origin'];
        job.files = data['files'] || [];
        job.index = data['index'] || 0;
        var fonts = data['fonts'] || ['#default'];
        job.fonts = fonts;
        job.gamma = [job.outline[2] * 1.4142 / job.size, job.outline[3] * 1.4142 / job.size];

        if (job.origin) {
            job.origin = new Float32Array(job.origin);
        }

        for (var i = 0, li = fonts.length; i < li; i++) {
            fonts[i] = this.renderer.fonts[fonts[i]];
        }

        job.program = this.renderer.progIcon2;
    }

    if (job.visibility != null && !Array.isArray(job.visibility)) {
        job.visibility = [job.visibility];
    }

    if (singleBuffer) {
        job.singleBuffer = singleBuffer;
        this.polygons += 2;

    } else {
        //create vertex buffer
        job.vertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        job.vertexPositionBuffer.itemSize = 4;
        job.vertexPositionBuffer.numItems = vertices.length / 4;

        //create normal buffer
        job.vertexTexcoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexTexcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
        job.vertexTexcoordBuffer.itemSize = 4;
        job.vertexTexcoordBuffer.numItems = texcoords.length / 4;

        //create origin buffer
        job.vertexOriginBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, job.vertexOriginBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, origins, gl.STATIC_DRAW);
        job.vertexOriginBuffer.itemSize = 3;
        job.vertexOriginBuffer.numItems = origins.length / 3;

        this.size += job.vertexPositionBuffer.numItems * 4 +
                      job.vertexOriginBuffer.numItems * 4 +
                      job.vertexTexcoordBuffer.numItems * 4;
        this.polygons += job.vertexPositionBuffer.numItems / (4 * 3);
    }


    if (this.subjobs) {
        this.subjobs.push(job);
    } else {
        if (this.vsjobs) {
            this.vsjobs.push(job);
        } else {
            this.jobs.push(job);
        }
    }

};


GpuGroup.prototype.addPack = function(data) {
    if (!this.subjobs.length) {
        this.subjobs = null;
        return;
    }

    var job = {
        type : 9,
        subjobs: this.subjobs,
        culling : 180,
        zIndex : 0,
        ready : true
    };

    //extract no overlap, remove it form subjobs
    for (var i = 0, li = job.subjobs.length; i < li; i++) {
        var subjob = job.subjobs[i];

        if (subjob.noOverlap) {
            
            if (!job.noOverlap) {
                job.noOverlap = subjob.noOverlap;
            } else {
                var o = job.noOverlap;
                var o2 = subjob.noOverlap;

                if (o2[0] < o[0]) o[0] = o2[0];
                if (o2[1] < o[1]) o[1] = o2[1];
                if (o2[2] > o[2]) o[2] = o2[2];
                if (o2[3] > o[3]) o[3] = o2[3];
            }

            subjob.noOverlap = null;
        }

        if (subjob.culling <= job.culling) {
            job.culling = subjob.culling;
            subjob.culling = 180;
        }

        if (subjob.visibility) {
            job.visibility = subjob.visibility;
            subjob.visibility = null;
        }

        if (subjob.stick) {
            job.stick = subjob.stick;
            subjob.stick = [0,0,0,255,255,255,255,0];
        }

        if (subjob.zIndex > job.zIndex) {
            job.zIndex = subjob.zIndex;
        }

        if (subjob.center) {
            job.center = subjob.center;
        }

        job.eventInfo = subjob.eventInfo;
        job.reduce = subjob.reduce;

        job.hysteresis = subjob.hysteresis;
        job.id = subjob.id;
    }

    if (this.vsjobs) {
        this.vsjobs.push(job);
    } else {
        this.jobs.push(job);
    }
    
    this.subjobs = null;
};


GpuGroup.prototype.addVSPoint = function(data, tile){
    var job = { tile: tile };
    job.type = 10;
    job.zIndex = data['z-index'] + 256;
    job.visibility = data['visibility'];
    job.culling = data['culling'];
    job.hitable = false;
    job.eventInfo = data['eventInfo'];
    job.state = data['state'];
    job.center = data['center'];
    job.lod = data['lod'];
    job.hysteresis = data['hysteresis'];
    job.id = job.hysteresis ? job.hysteresis[2] : null;
    job.reduced = false;
    job.ready = true;
    job.reduce = data['reduce'];
    job.vswitch = [];

    this.vsjob = job;
};


GpuGroup.prototype.storeVSJobs = function(data){
    this.vsjob.vswitch.push([data.viewExtent, this.vsjobs]);
    this.vsjobs = [];
};


GpuGroup.prototype.addVSwitch = function(){
    if (this.vsjob) {
        this.jobs.push(this.vsjob);
    }

    this.vsjobs = null;
};


GpuGroup.prototype.copyBuffer = function(buffer, source, index) {
    var tmp = new Uint8Array(buffer.buffer);
    tmp.set(new Uint8Array(source.buffer, index, buffer.byteLength));
    return buffer;
};


GpuGroup.prototype.addRenderJob2 = function(buffer, index, tile) {
    var data, str, length, tmp;
    var view = new DataView(buffer.buffer);
    var type = buffer[index]; index += 1;

    if (type != 15 && type != 16 && 
        type != 17 && type != 19 && type != 18) {

        length = view.getUint32(index); index += 4;
        str = utils.unint8ArrayToString(new Uint8Array(buffer.buffer, index, length)); index+= length;
        data = JSON.parse(str);
    }

    switch(type) {
        case 13:
        case 6:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addLineJob(data);
            break;

        case 8:
        case 7:
        case 9:
        case 10:
            data.type = type;
            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.normalBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.normalBuffer.byteLength;

            if (data['advancedHit']) {
                length = view.getUint32(index); index += 4;
                data.elementBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.elementBuffer.byteLength;
            }

            this.addExtentedLineJob(data);
            break;

        case 11:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addLineLabelJob(data);
            break;

        case 12:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.singleBuffer2 = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer2.byteLength;
            this.addLineLabelJob(data);
            break;

        case 3:
        case 1:

            length = view.getUint32(index); index += 4;
            data.singleBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.singleBuffer.byteLength;
            this.addIconJob(data, (type == 1), tile);
            break;

        case 4:
        case 2:

            length = view.getUint32(index); index += 4;
            data.vertexBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.vertexBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.originBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.texcoordsBuffer = this.copyBuffer(new Float32Array(length), buffer, index); index += data.texcoordsBuffer.byteLength;
            this.addIconJob(data, (type == 2), tile);
            break;

        case 5:
        case 14:

            length = view.getUint32(index); index += 4;
            data.geometryBuffer = this.copyBuffer(new Float64Array(length), buffer, index); index += data.originBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            data.indicesBuffer = this.copyBuffer(new Uint32Array(length), buffer, index); index += data.indicesBuffer.byteLength;
            length = view.getUint32(index); index += 4;
            this.addGeometry(data);
            break;

        case 15:
            this.subjobs = []; index += 4;
            break;

        case 16:
            this.addPack(); index += 4;
            break;

        case 20:
            this.addVSPoint(data, tile);
            break;

        case 17:
            this.vsjobs = []; this.vsjob = null; index += 4;
            break;

        case 19:
            this.addVSwitch(); index += 4;
            break;

        case 18:
            data = { viewExtent: view.getUint32(index) }; index += 4;
            this.storeVSJobs(data);
            break;
    }

    return index;
};


GpuGroup.prototype.addRenderJob = function(data, tile) {
    switch(data['type']) {
    case 'polygon':
    case 'flat-line':     this.addLineJob(data); break;
    case 'flat-tline':
    case 'flat-rline':
    case 'pixel-line':
    case 'pixel-tline':    this.addExtentedLineJob(data); break;
    case 'line-label':     this.addLineLabelJob(data); break;
    case 'icon':           this.addIconJob(data); break;
    case 'label':          this.addIconJob(data, true, tile); break;
    case 'point-geometry': this.addGeometry(data); break;
    case 'line-geometry':  this.addGeometry(data); break;
    case 'pack-begin':     this.subjobs = []; break;
    case 'pack-end':       this.addPack(); break;
    case 'vspoint':        this.addVSPoint(data, tile); break;
    case 'vswitch-begin':  this.vsjobs = []; this.vsjob = null; break;
    case 'vswitch-store':  this.storeVSJobs(data); break;
    case 'vswitch-end':    this.addVSwitch(); break;
    }
};


GpuGroup.prototype.draw = function(mv, mvp, applyOrigin, tiltAngle, texelSize) {
    if (this.id != null) {
        if (this.renderer.layerGroupVisible[this.id] === false) {
            return;
        }
    }

    var renderer = this.renderer;
    var renderCounter = [[renderer.geoRenderCounter, mv, mvp, this]];

    if (applyOrigin) {
        var mvp2 = mat4.create();
        var mv2 = mat4.create();
        var pos = this.renderer.position;

        /*
        var transform = this.renderer.layerGroupTransform[this.id];

        if (transform != null) {
            origin = transform[1];
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(math.translationMatrix(origin[0], origin[1], origin[2]), transform[0], mv2);
            mat4.multiply(mv, mv2, mv2);
        } else {*/
            var origin = this.origin;
            origin = [origin[0] - pos[0], origin[1] - pos[1], origin[2]];
            mat4.multiply(mv, math.translationMatrix(origin[0], origin[1], origin[2]), mv2);
        /*}*/

        mat4.multiply(mvp, mv2, mvp2);
        mv = mv2;
        mvp = mvp2;
    }

    var cameraPos = renderer.cameraPosition;
    var jobZBuffer = renderer.jobZBuffer;
    var jobZBufferSize = renderer.jobZBufferSize;
    var jobZBuffer2 = renderer.jobZBuffer2;
    var jobZBuffer2Size = renderer.jobZBuffer2Size;

    var onlyHitable = renderer.onlyHitLayers;

    for (var i = 0, li = this.jobs.length; i < li; i++) {
        var job = this.jobs[i];

        if ((job.type == 7 || job.type == 8) && job.visibility > 0) {
            var center = job.center;
            if (vec3.length([center[0]-cameraPos[0],
                center[1]-cameraPos[1],
                center[2]-cameraPos[2]]) > job.visibility) {
                continue;
            }
        }

        if (onlyHitable && !job.hitable) {
            continue;
        }

        job.mv = mv;
        job.mvp = mvp;
        job.renderCounter = renderCounter;
        job.tiltAngle = tiltAngle;
        job.texelSize = texelSize;

        var zIndex = job.zIndex;

        jobZBuffer[zIndex][jobZBufferSize[zIndex]] = job;
        jobZBufferSize[zIndex]++;
    }
};


/* harmony default export */ __webpack_exports__["a"] = (GpuGroup);


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var GpuPixelLine3 = function(gpu, core, lines, maxLines, joins, joinSides) {
    this.bbox = null;
    this.gpu = gpu;
    this.gl = gpu.gl;
    this.core = core;

    var gl = this.gl;

    if (gl == null){
        return;
    }

    this.vertices = [];
    this.normals = [];
    this.vertexBuffer = null;
    this.lines = lines;
    this.joins = joins;
    this.joinSides = joinSides;
    this.maxLines = maxLines;

    this.init();
};

//destructor
GpuPixelLine3.prototype.kill = function() {
    this.gl.deleteBuffer(this.vertexBuffer);
};


GpuPixelLine3.prototype.init = function() {
    var i;
    if (this.lines) {
        if (this.joins) {
            this.addCircle(0, this.joinSides);
        }

        for (i = 0; i < this.maxLines; i++) {
            this.addLine(i, i+1);

            if (this.joins) {
                this.addCircle(i+1, this.joinSides);
            }
        }
    } else if (this.joins) {
        for (i = 0; i <= this.maxLines; i++) {
            this.addCircle(i, this.joinSides);
        }
    }

    this.compile();
};

//add line to vertices buffer
GpuPixelLine3.prototype.addLine = function(i1, i2) {
    var index = this.vertices.length;

    //first polygon
    this.vertices[index] = i1;
    this.vertices[index+1] = i2;
    this.vertices[index+2] = 1;

    this.vertices[index+3] = i1;
    this.vertices[index+4] = i2;
    this.vertices[index+5] = -1;

    this.vertices[index+6] = i2;
    this.vertices[index+7] = i1;
    this.vertices[index+8] = 1;

    //next polygon
    this.vertices[index+9] = i1;
    this.vertices[index+10] = i2;
    this.vertices[index+11] = 1;

    this.vertices[index+12] = i2;
    this.vertices[index+13] = i1;
    this.vertices[index+14] = 1;

    this.vertices[index+15] = i2;
    this.vertices[index+16] = i1;
    this.vertices[index+17] = -1;

    this.polygons += 2;
};

//add circle to vertices buffer
GpuPixelLine3.prototype.addCircle = function(i1, sides) {
    var index = this.vertices.length;
    var step = (2.0*Math.PI) / sides;

    for (var i = 0; i < sides; i++) {
        this.vertices[index] = i1;
        this.vertices[index+1] = -1;
        this.vertices[index+2] = 0;

        this.vertices[index+3] = i1;
        this.vertices[index+4] = -2;
        this.vertices[index+5] = step * i;

        this.vertices[index+6] = i1;
        this.vertices[index+7] = -2;
        this.vertices[index+8] = step * (i+1);

        index += 9;
    }

    this.polygons += sides;
};

//compile content of vertices buffer into gpu buffer
GpuPixelLine3.prototype.compile = function() {
    var gl = this.gl;

    //create vertex buffer
    this.vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
    this.vertexBuffer.itemSize = 3;
    this.vertexBuffer.numItems = this.vertices.length / 3;

    this.size = this.vertexBuffer.numItems * 3 * 4 * 2;
    this.polygons = this.vertexBuffer.numItems / 3;
};

// Draws the mesh, given the two vertex shader attributes locations.
GpuPixelLine3.prototype.draw = function(program, attrPosition, points) {
    var gl = this.gl;
    if (gl == null || this.vertexBuffer == null || points > this.maxLines){
        return;
    }

    var vertexPositionAttribute = program.getAttribute(attrPosition);

    //bind vetex positions
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

    var size = 0;

    if (this.lines) {
        size += ((points-1) * 3 * 2);
    }

    if (this.joins) {
        size += points * (this.joinSides * 3);
    }

    //draw polygons
    gl.drawArrays(gl.TRIANGLES, 0, size);
};

// Returns GPU RAM used, in bytes.
GpuPixelLine3.prototype.getSize = function(){ return this.size; };


GpuPixelLine3.prototype.getBbox = function(){ return this.bbox; };


GpuPixelLine3.prototype.getPolygons = function(){ return this.polygons; };


/* harmony default export */ __webpack_exports__["a"] = (GpuPixelLine3);

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geometry__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gpu_bbox__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gpu_font__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gpu_mesh__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gpu_pixel_line3__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gpu_program__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gpu_shaders__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gpu_texture__ = __webpack_require__(6);










//get rid of compiler mess
var RendererGeometry = __WEBPACK_IMPORTED_MODULE_0__geometry__["a" /* default */];
var GpuBBox = __WEBPACK_IMPORTED_MODULE_1__gpu_bbox__["a" /* default */];
var GpuFont = __WEBPACK_IMPORTED_MODULE_2__gpu_font__["a" /* default */];
var GpuMesh = __WEBPACK_IMPORTED_MODULE_3__gpu_mesh__["a" /* default */];
var GpuPixelLine3 = __WEBPACK_IMPORTED_MODULE_4__gpu_pixel_line3__["a" /* default */];
var GpuProgram = __WEBPACK_IMPORTED_MODULE_5__gpu_program__["a" /* default */];
var GpuShaders = __WEBPACK_IMPORTED_MODULE_6__gpu_shaders__["a" /* default */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_7__gpu_texture__["a" /* default */];


var RendererInit = function(renderer) {
    this.renderer = renderer;
    this.core = renderer.core;
    this.gpu = renderer.gpu;

    //renderer.font = new GpuFont(this.gpu, this.core);
    //renderer.fonts['#default'] = renderer.font;
    //renderer.font = new GpuFont(this.gpu, this.core, null, null, './allinone.fnt');

    this.initShaders();
    this.initHeightmap();
    this.initSkydome();
    this.initHitmap();
    this.initTextMap();
    this.initImage();
    this.initTestMap();
    this.initBBox();
    this.initLines();
    this.initBaricentricBuffer();
};


RendererInit.prototype.initShaders = function() {
    var shaders = GpuShaders;
    var renderer = this.renderer;
    var gpu = this.gpu;

    renderer.progTile = new GpuProgram(gpu, shaders.tileVertexShader, shaders.tileFragmentShader);
    renderer.progTile2 = new GpuProgram(gpu, '#define externalTex\n' + shaders.tileVertexShader, '#define externalTex\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));
    renderer.progTile3 = new GpuProgram(gpu, '#define externalTex\n' + shaders.tileVertexShader, '#define externalTex\n#define mask\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));
    renderer.progFogTile = new GpuProgram(gpu, '#define onlyFog\n' + shaders.tileVertexShader, '#define onlyFog\n' + shaders.tileFragmentShader);

    renderer.progTileSE = new GpuProgram(gpu, '#define applySE\n' + shaders.tileVertexShader, shaders.tileFragmentShader);
    renderer.progTile2SE = new GpuProgram(gpu, '#define externalTex\n#define applySE\n' + shaders.tileVertexShader, '#define externalTex\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));
    renderer.progTile3SE = new GpuProgram(gpu, '#define externalTex\n#define applySE\n' + shaders.tileVertexShader, '#define externalTex\n#define mask\n' + shaders.tileFragmentShader.replace('__FILTER__', ''));

    var sdExt = '#extension GL_OES_standard_derivatives : enable\n';

    renderer.progFlatShadeTile = new GpuProgram(gpu, '#define flatShadeVar\n' + shaders.tileVertexShader, sdExt+'#define flatShadeVar\n#define flatShade\n' + shaders.tileFragmentShader);
    renderer.progFlatShadeTileSE = new GpuProgram(gpu, '#define applySE\n#define flatShadeVar\n' + shaders.tileVertexShader, sdExt+'#define flatShadeVar\n#define flatShade\n' + shaders.tileFragmentShader);
    renderer.progCFlatShadeTile = new GpuProgram(gpu, '#define flatShadeVar\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\n#define flatShade\n#define fogAndColor\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));
    renderer.progCFlatShadeTileSE = new GpuProgram(gpu, '#define applySE\n#define flatShadeVar\n' + shaders.tileVertexShader, (sdExt+'#define flatShadeVar\n#define flatShade\n#define fogAndColor\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));

    renderer.progDepthTile = new GpuProgram(gpu, '#define depth\n' + shaders.tileVertexShader, ('#define depth\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));
    renderer.progDepthTileSE = new GpuProgram(gpu, '#define applySE\n#define depth\n' + shaders.tileVertexShader, ('#define depth\n' + shaders.tileFragmentShader).replace('mediump', 'highp'));
    renderer.progDepthHeightmap = new GpuProgram(gpu, shaders.heightmapDepthVertexShader, (shaders.heightmapDepthFragmentShader).replace('mediump', 'highp'));

    renderer.progShadedTile = new GpuProgram(gpu, shaders.shadedMeshVertexShader, shaders.shadedMeshFragmentShader);
    renderer.progTShadedTile = new GpuProgram(gpu, shaders.shadedMeshVertexShader, '#define textured\n' + shaders.shadedMeshFragmentShader);

    renderer.progWireFrameBasic = new GpuProgram(gpu, shaders.tileVertexShader, shaders.tileWireFrameBasicShader);
    renderer.progWireFrameBasicSE = new GpuProgram(gpu, '#define applySE\n' + shaders.tileVertexShader, shaders.tileWireFrameBasicShader);

    renderer.progHeightmap = new GpuProgram(gpu, shaders.heightmapVertexShader, shaders.heightmapFragmentShader);
    renderer.progPlane = new GpuProgram(gpu, '#define flat\n' + shaders.planeVertexShader, shaders.planeFragmentShader); //flat
    renderer.progPlane2 = new GpuProgram(gpu, '#define poles\n' + shaders.planeVertexShader, '#define poles\n' + shaders.planeFragmentShader); //poles
    renderer.progPlane3 = new GpuProgram(gpu, shaders.planeVertexShader, shaders.planeFragmentShader); // grid
    renderer.progPlaneD = new GpuProgram(gpu, '#define depth\n#define flat\n' + shaders.planeVertexShader, '#define depth\n' + shaders.planeFragmentShader); //flat
    renderer.progPlane2D = new GpuProgram(gpu, '#define depth\n#define poles\n' + shaders.planeVertexShader, '#define depth\n#define poles\n' + shaders.planeFragmentShader); //poles
    renderer.progPlane3D = new GpuProgram(gpu, '#define depth\n' + shaders.planeVertexShader, '#define depth\n' + shaders.planeFragmentShader); // grid

    renderer.progSkydome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.skydomeFragmentShader);
    renderer.progStardome = new GpuProgram(gpu, shaders.skydomeVertexShader, shaders.stardomeFragmentShader);
    
    renderer.progAtmo2 = new GpuProgram(gpu, shaders.atmoVertexShader, shaders.atmoFragmentShader);
    renderer.progAtmo = new GpuProgram(gpu, shaders.atmoVertexShader3, shaders.atmoFragmentShader3);

    renderer.progBBox = new GpuProgram(gpu, shaders.bboxVertexShader, shaders.bboxFragmentShader);
    renderer.progBBox2 = new GpuProgram(gpu, shaders.bbox2VertexShader, shaders.bboxFragmentShader);

    renderer.progLine = new GpuProgram(gpu, shaders.lineVertexShader, shaders.lineFragmentShader); //line
    renderer.progLineSE = new GpuProgram(gpu, '#define applySE\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //line SE
    renderer.progELine = new GpuProgram(gpu, '#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //line elements 
    renderer.progELineSE = new GpuProgram(gpu, '#define applySE\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //line SE elements 
    renderer.progLine3 = new GpuProgram(gpu, '#define pixelLine\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line
    renderer.progELine3 = new GpuProgram(gpu, '#define pixelLine\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //pixel line elements
    renderer.progLine3SE = new GpuProgram(gpu, '#define applySE\n#define pixelLine\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //pixel line SE
    renderer.progELine3SE = new GpuProgram(gpu, '#define applySE\n#define pixelLine\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //pixel line SE elements
    renderer.progLine4 = new GpuProgram(gpu, '#define pixelLine\n#define dataPoints\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //direct linestring pixel line
    renderer.progLine5 = new GpuProgram(gpu, '#define pixelLine\n#define dataPoints\n#define dataPoints2\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //clipped direct linestring pixel line, physical coords
    renderer.progRLine = new GpuProgram(gpu, '#define dynamicWidth\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line
    renderer.progRLineSE = new GpuProgram(gpu, '#define applySE\n#define dynamicWidth\n' + shaders.lineVertexShader, shaders.lineFragmentShader); //dynamic width line
    renderer.progERLine = new GpuProgram(gpu, '#define dynamicWidth\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //dynamic width line elements
    renderer.progERLineSE = new GpuProgram(gpu, '#define applySE\n#define dynamicWidth\n#define withElements\n' + shaders.lineVertexShader, '#define withElements\n' + shaders.lineFragmentShader); //dynamic width line elements

    renderer.progTLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tlineFragmentShader); //textured line
    renderer.progTPLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tlineFragmentShader); //textured pixed line
    renderer.progTBLine = new GpuProgram(gpu, shaders.tlineVertexShader, shaders.tblineFragmentShader); //textured line with background color
    renderer.progTPBLine = new GpuProgram(gpu, shaders.tplineVertexShader, shaders.tblineFragmentShader); //textured pixel line with background color
    renderer.progETLine = new GpuProgram(gpu, shaders.etlineVertexShader, shaders.elineFragmentShader); //textured line elements
    renderer.progETPLine = new GpuProgram(gpu, shaders.etplineVertexShader, shaders.elineFragmentShader); //textured pixed line elements
    //renderer.progLineWireframe = new GpuProgram(gpu, shaders.lineWireframeVertexShader, shaders.lineWireframeFragmentShader); //line with wireframe for debugging

    renderer.progText2 = new GpuProgram(gpu, '#define lineLabel\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label 
    renderer.progText2SE = new GpuProgram(gpu, '#define applySE\n#define lineLabel\n' + shaders.lineVertexShader, shaders.text2FragmentShader); //line label 

    renderer.progLineLabel16 = new GpuProgram(gpu, '#define DSIZE 16\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 
    renderer.progLineLabel32 = new GpuProgram(gpu, '#define DSIZE 32\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 
    renderer.progLineLabel48 = new GpuProgram(gpu, '#define DSIZE 48\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 
    renderer.progLineLabel64 = new GpuProgram(gpu, '#define DSIZE 64\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 
    renderer.progLineLabel96 = new GpuProgram(gpu, '#define DSIZE 96\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 
    renderer.progLineLabel128 = new GpuProgram(gpu, '#define DSIZE 128\n#define lineLabel2\n' + shaders.lineVertexShader, shaders.text2FragmentShader); 

    renderer.progPolygon = new GpuProgram(gpu, shaders.polygonVertexShader, shaders.polygonFragmentShader);
    renderer.progImage = new GpuProgram(gpu, shaders.imageVertexShader, shaders.imageFragmentShader);
    renderer.progIcon = new GpuProgram(gpu, shaders.iconVertexShader, shaders.textFragmentShader); //label or icon
    renderer.progIcon2 = new GpuProgram(gpu, shaders.icon2VertexShader, shaders.text2FragmentShader); //label

    renderer.progLabel16 = new GpuProgram(gpu, '#define DSIZE 16\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); //label with singleBuffer
    renderer.progLabel32 = new GpuProgram(gpu, '#define DSIZE 32\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    renderer.progLabel48 = new GpuProgram(gpu, '#define DSIZE 48\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    renderer.progLabel64 = new GpuProgram(gpu, '#define DSIZE 64\n' + shaders.icon3VertexShader, shaders.text2FragmentShader);
    renderer.progLabel96 = new GpuProgram(gpu, '#define DSIZE 96\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); 
    renderer.progLabel128 = new GpuProgram(gpu, '#define DSIZE 128\n' + shaders.icon3VertexShader, shaders.text2FragmentShader); 
};

RendererInit.prototype.initProceduralShaders = function() {
    var shaders = GpuShaders;
    var renderer = this.renderer;
    var gpu = this.gpu;
    renderer.progHmapPlane = new GpuProgram(gpu, shaders.planeVertex4Shader, shaders.planeFragmentShader2);
    renderer.progHmapPlane2 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define grid\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane3 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane4 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define flat\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane5 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define normals\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane6 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\n#define normals\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane7 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define nmix\n' + shaders.planeFragmentShader2);
    renderer.progHmapPlane8 = new GpuProgram(gpu, shaders.planeVertex4Shader, '#define exmap\n#define classmap\n' + shaders.planeFragmentShader2);
}

RendererInit.prototype.initHeightmap = function() {
    var renderer = this.renderer;
    var use16Bit = renderer.core.config.map16bitMeshes;
    var gpu = this.gpu;

    // initialize heightmap geometry
    var meshData = RendererGeometry.buildHeightmap(5, true);
    //renderer.heightmapMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit);

    meshData = RendererGeometry.buildPlane(16, true);
    renderer.planeMesh = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);

    meshData = RendererGeometry.buildPlane(128, true);
    renderer.planeMesh2 = new GpuMesh(gpu, meshData, null, this.core, true, use16Bit, true);

    // create heightmap texture
    var size = 64;
    var halfLineWidth = 1;
    var data = new Uint8Array( size * size * 4 );

    for (var i = 0; i < size; i++) {
        for (var j = 0; j < size; j++) {

            var index = (i*size+j)*4;

            if (i < halfLineWidth || i >= size-halfLineWidth || j < halfLineWidth || j >= size-halfLineWidth) {
                data[index] = 255;
                data[index + 1] = 255;
                data[index + 2] = 255;
            } else {
                data[index] = 32;
                data[index + 1] = 32;
                data[index + 2] = 32;
            }

            data[index + 3] = 255;
        }
    }


    renderer.heightmapTexture = new GpuTexture(gpu);
    renderer.heightmapTexture.createFromData(size, size, data, 'trilinear', true);
};


RendererInit.prototype.initHitmap = function() {
    var renderer = this.renderer;
    var size = renderer.hitmapSize;
    var data = new Uint8Array( size * size * 4 );

    if (renderer.hitmapMode > 2) {
        renderer.hitmapData = data;
    }

    renderer.hitmapTexture = new GpuTexture(this.gpu);
    renderer.hitmapTexture.createFromData(size, size, data);
    renderer.hitmapTexture.createFramebuffer(size, size);

    renderer.geoHitmapTexture = new GpuTexture(this.gpu);
    renderer.geoHitmapTexture.createFromData(size, size, data);
    renderer.geoHitmapTexture.createFramebuffer(size, size);

    renderer.geoHitmapTexture2 = new GpuTexture(this.gpu);
    renderer.geoHitmapTexture2.createFromData(size, size, data);
    renderer.geoHitmapTexture2.createFramebuffer(size, size);
};


RendererInit.prototype.initTestMap = function() {
    var renderer = this.renderer;
    var gpu = this.gpu;

   // create red texture
    var size = 16, i, j, index;
    var data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 255;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 255;
        }
    }

    renderer.redTexture = new GpuTexture(gpu);
    renderer.redTexture.createFromData(size, size, data);

    data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 255;
            data[index + 1] = 255;
            data[index + 2] = 255;
            data[index + 3] = 255;
        }
    }

    renderer.whiteTexture = new GpuTexture(gpu);
    renderer.whiteTexture.createFromData(size, size, data);

    data = new Uint8Array( size * size * 4 );

    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            index = (i*size+j)*4;
            data[index] = 0;
            data[index + 1] = 0;
            data[index + 2] = 0;
            data[index + 3] = 255;
        }
    }

    renderer.blackTexture = new GpuTexture(gpu);
    renderer.blackTexture.createFromData(size, size, data);
};


RendererInit.prototype.initTextMap = function() {
    var renderer = this.renderer;

    //font texture
    var texture = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAACACAMAAADTa0c4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAZQTFRFAAAA////pdmf3QAABIFJREFUeNrsnNuyqzAIhsP7v/Se6Yxra0L4OUVNCzetVqP5DAQItrVOiLg95739NnfOaR99RDj6esBw+CKZXiMK4PiuBkAcANoHAP3J5fzzAV2jePQIt6f4Ndb/MIChlVcCEFpAACZPfN4KUAF0/ufboDW3AuBMFgBwHTCfg2ftYgDUKBuA1ABuHKvA2P+5XdONIEt7BO2o2MdlAJoTQOsV6GEAswt0Zq/bsBhdeQQkqEDMwmIAnJHzA8i3ASkWRFKBbADyLGB3mlYD6DyhA4DfBlgsBDtirUPcBgC5woStYMgVtgKATWcB6DskKUEkGFLYrGw3+l3ydR16wKbbPDlWp4Xfo9vZwR1jtOMA6GkABrdvNmt1Vluy6pyvxu4Xt62fquyTggCTsIkCoIuv8gAA08w+ATBXAdSRY56xPDFPx/VPWFZp5v65kFMPgFjP70YASMfRsDn01xLPcwkRq1HLMoK647hR8v+nId74MQBjvIbUQePra42ZVXVcBCR3mIY89mYAlNGLflqA0V1seosCQNMg80B0bsLGAIDNwvFyiqu66ngVGGMGVBwyWwIwpty2DqEr/qf0Bq+DbjYkkcr4VUoOxiRjrYn3YY5SC4BQB/cF0Lq4kD1RCJ+tN4g6Jps5zfWu+QmSz9sUABkA0BIAXocmBwCJ99MDIASATkmtLQAIft4IgE/ZDStZ59yQbOQQAGZWYMbZ3FFCAGRHnwHQznegGAE+zwxNi8kALCOgS9tzAC4jYG1Qo0myRm0Ae/z8eleqewBoZLwfUswCsbT1KgBZD6QAzAEoXUe3K+xxVf2uLf5U3nBeMPRyACW/LtrwVX989id3PRQOG5Io6vh9XwC6stHIdGdJozun03lxNlwvH4u6UgDM8/LmJyx7ak12feEebaXmUwCOYJWk1JcYKsl74HL74wAaH93NqkE1FSKXc4cv0AjaPEEPgE4ru/ieWdvzVq/4psG3AYDFHlEAioQCuEgMgPjK1VDrqlkbTABAiQBGK38B0BlBSf9xtiAJQDM4NtDqMlaeyduTtkDjHgAtEQBj5ZGK2QE0aCcMAIxLSw0WVYlGDgOQXWE+afouAM0S398O4Nej3wIQf4cIHSfz9pbWugyep4MFIAFARvspbm8BcE2DOdvWnCJQAWFhJ/hKzh4AaB2A7NxedKmLPc+6PN4cL2S8GYC1QMIEQJvmFsJfxdvkEQAoLV4AogBS8/kNvdXlWe5GKhABvQUAZASDALJffY1XfsrToFXFbvYD1gBo6wC8LR7/uvj9CwHcfWuoUJItsVl5nwWAnhxxqsXatUq0OYCcaS/fkbK61u5H8jwAuUIEZXHNL1Jmub5oSKZWiDR9FttM4HEAigqRpn8TeB2AuWNiByAXSHCGbB7/3qYCfgCgPgADEEskbjCCaJDB/+kR6wP4P1Obl8jsBwDUB4yAxqKkthaATjX0KmCtDyCxm+yIMLjCbwBgrg94FYC3h8vLPPmfAVBSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlJSUlLy9fJPgAEAvWMULbGsSjwAAAAASUVORK5CYII=';
    renderer.textTexture2 = new GpuTexture(this.gpu, texture, this.core, null, true);
};


RendererInit.prototype.initImage = function() {
    var renderer = this.renderer;
    var gl = this.gpu.gl;

    //create vertices buffer for rect
    renderer.rectVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, renderer.rectVerticesBuffer);

    var vertices = [ 0, 0, 0, 1,   1, 0, 0, 1,   2, 0, 0, 1,   3, 0, 0, 1 ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    renderer.rectVerticesBuffer.itemSize = 4;
    renderer.rectVerticesBuffer.numItems = 4;

    //create indices buffer for rect
    renderer.rectIndicesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderer.rectIndicesBuffer);

    var indices = [ 0, 2, 1,    0, 3, 2 ];

    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    renderer.rectIndicesBuffer.itemSize = 1;
    renderer.rectIndicesBuffer.numItems = 6;

    renderer.textBuff16 = new Float32Array(16 * 4);
    renderer.textBuff32 = new Float32Array(32 * 4);
    renderer.textBuff48 = new Float32Array(48 * 4);
    renderer.textBuff64 = new Float32Array(64 * 4);

    renderer.textQuads16 = this.generateTextQuads(16);
    renderer.textQuads32 = this.generateTextQuads(32);
    renderer.textQuads48 = this.generateTextQuads(48);
    renderer.textQuads64 = this.generateTextQuads(64);
    renderer.textQuads96 = this.generateTextQuads(96);
    renderer.textQuads128 = this.generateTextQuads(128);
};


RendererInit.prototype.generateTextQuads = function(num) {
    var renderer = this.renderer;
    var gl = this.gpu.gl;

    var buffer = new Float32Array(num * 2 * 6);
    var index, j;

    for (var i = 0; i < num; i++) {
        index = i * 6 * 2;

        j = 0;
        buffer[index] = i;
        buffer[index+1] = j;

        j = 1;
        buffer[index+2] = i;
        buffer[index+3] = j;

        j = 2;
        buffer[index+4] = i;
        buffer[index+5] = j;

        j = 2;
        buffer[index+6] = i;
        buffer[index+7] = j;

        j = 3;
        buffer[index+8] = i;
        buffer[index+9] = j;

        j = 0;
        buffer[index+10] = i;
        buffer[index+11] = j;
    }

    //create vertices buffer for rect
    var vbuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);

    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);
    vbuffer.itemSize = 2;
    vbuffer.numItems = num * 6;

    return vbuffer;
};

RendererInit.prototype.initSkydome = function() {
    var renderer = this.renderer;
    var use16Bit = renderer.core.config.map16bitMeshes;
    var meshData = RendererGeometry.buildSkydome(32, 64, use16Bit);
    renderer.skydomeMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);
    //this.skydomeTexture = new GpuTexture(this.gpu, "./skydome.jpg", this.core);

    meshData = RendererGeometry.buildSkydome(128, 256, use16Bit, true);
//    var meshData = RendererGeometry.buildSkydome(256, 512);
    renderer.atmoMesh = new GpuMesh(this.gpu, meshData, null, this.core, true, use16Bit);
};


RendererInit.prototype.initBBox = function() {
    var renderer = this.renderer;
    var gpu = this.gpu;
    renderer.bboxMesh = new GpuBBox(gpu);
    renderer.bboxMesh2 = new GpuBBox(gpu, true);
};


RendererInit.prototype.initLines = function() {
    var gpu = this.gpu;
    var renderer = this.renderer;
    renderer.plineBuffer = new Float32Array(32*3);
    renderer.plines = new GpuPixelLine3(gpu, this.core, true, 64, true, 8);
    renderer.plineJoints = new GpuPixelLine3(gpu, this.core, false, 64, true, 8);

    renderer.stencilLineState = gpu.createState({blend:true, stencil:true, culling: false});
    renderer.lineLabelState = gpu.createState({blend:true, culling: false, zequal: true, zwrite:false});
    renderer.labelState = gpu.createState({blend:true, culling: false, zequal: true});
    renderer.stencilLineHitState = gpu.createState({blend:false, stencil:true, culling: false});
    renderer.lineLabelHitState = gpu.createState({blend:false, culling: false});

    renderer.polygonB1S1C1tate = gpu.createState({blend:true, stencil:true, culling: true, zequal: true});
    renderer.polygonB1S0C1tate = gpu.createState({blend:true, stencil:false, culling: true, zequal: true});
    renderer.polygonB1S1C0tate = gpu.createState({blend:true, stencil:true, culling: false, zequal: true});
    renderer.polygonB1S0C0tate = gpu.createState({blend:true, stencil:false, culling: false, zequal: true});

    renderer.polygonB0S1C1tate = gpu.createState({blend:false, stencil:true, culling: true, zequal: true});
    renderer.polygonB0S0C1tate = gpu.createState({blend:false, stencil:false, culling: true, zequal: true});
    renderer.polygonB0S1C0tate = gpu.createState({blend:false, stencil:true, culling: false, zequal: true});
    renderer.polygonB0S0C0tate = gpu.createState({blend:false, stencil:false, culling: false, zequal: true});

};


RendererInit.prototype.initBaricentricBuffer = function() {
    var gpu = this.gpu;
    var buffer = new Array(65535*3);

    for (var i = 0; i < 65535*3; i+=9) {
        buffer[i] = 1.0;
        buffer[i+1] = 0;
        buffer[i+2] = 0;

        buffer[i+3] = 0;
        buffer[i+4] = 1.0;
        buffer[i+5] = 0;

        buffer[i+6] = 0;
        buffer[i+7] = 0;
        buffer[i+8] = 1.0;
    }

    var gl = gpu.gl;
    gpu.barycentricBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gpu.barycentricBuffer);

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer), gl.STATIC_DRAW);
    gpu.barycentricBuffer.itemSize = 3;
    gpu.barycentricBuffer.numItems = buffer.length / 3;
};


/* harmony default export */ __webpack_exports__["a"] = (RendererInit);


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gpu_texture__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gpu_mesh__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gpu_program__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__octree_js__ = __webpack_require__(167);






//get rid of compiler mess
var GpuTexture = __WEBPACK_IMPORTED_MODULE_0__gpu_texture__["a" /* default */];
var GpuMesh = __WEBPACK_IMPORTED_MODULE_1__gpu_mesh__["a" /* default */];
var GpuProgram = __WEBPACK_IMPORTED_MODULE_2__gpu_program__["a" /* default */];
var Octree = __WEBPACK_IMPORTED_MODULE_3__octree_js__["a" /* Octree */];
var OctreeRaycaster = __WEBPACK_IMPORTED_MODULE_3__octree_js__["b" /* OctreeRaycaster */];

var RendererInterface = function(renderer) {
    this.renderer = renderer;
    this.gpu = renderer.gpu;
};


RendererInterface.prototype.clear = function(options) {
    if (options != null) {
        this.gpu.clear((options['clearDepth'] || true),
                        (options['clearColor'] || false),
                        (options['color'] || [255,255,255,255]),
                        ((options['depth'] != null) ? options['depth'] : 1.0) );
    }
    return this;    
};


RendererInterface.prototype.createState = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }
    
    var stateOptions = {
        blend : (options['blend'] != null) ? options['blend'] : false,
        stencil : (options['stencil'] != null) ? options['stencil'] : false,
        zoffset : (options['zoffset'] != null) ? options['zoffset'] : 0,
        zwrite : (options['zwrite'] != null) ? options['zwrite'] : true,
        ztest : (options['ztest'] != null) ? options['ztest'] : true,
        zequal : (options['zequal'] != null) ? options['zequal'] : true,
        culling : (options['culling'] != null) ? options['culling'] : true
    };

    return this.gpu.createState(stateOptions);
};


RendererInterface.prototype.setState = function(state) {
    if (state != null) {
        this.gpu.setState(state);
    }
    return this;    
};


RendererInterface.prototype.createTexture = function(options) {
    if (options == null || typeof options !== 'object') {
        return null;
    }

    var source = options['source'];
    if (source == null) {
        return null;
    }

    var filter = options['filter'] || 'linear';
    var repeat = options['repeat'] || false, texture;

    if (source instanceof Uint8Array) {
        var width = options['width'];
        var height = options['height'];

        if (width && height) {
            texture = new GpuTexture(this.gpu);
            texture.createFromData(width, height, source, filter, repeat);
            return texture;
        }
    }

    if (source instanceof Image) {
        texture = new GpuTexture(this.gpu);
        texture.createFromImage(source, filter, repeat);
        return texture;
    }

    return null;
};


RendererInterface.prototype.removeTexture = function(texture) {
    if (texture) {
        texture.kill();
    }
    return this;    
};


RendererInterface.prototype.createMesh = function(options) {
    if (options == null || typeof options !== 'object') {
        return null;
    }

    var data = {
        vertices : options['vertices'],
        uvs : options['uvs'],
        uvs2 : options['normals'],
        vertexSize : options['vertexSize'],
        uvSize : options['uvSize'],
        uv2Size : options['normalSize'] || 3,
        vertexAttr : options['vertexAttr'],
        uvAttr : options['uvAttr'],
        uv2Attr : options['normalAttr'],
        bbox : options['bbox']
    };

    return new GpuMesh(this.gpu, data, 0, this.renderer.core);
};


RendererInterface.prototype.removeMesh = function(mesh) {
    if (mesh) {
        mesh.kill();
    }
    return this;    
};


RendererInterface.prototype.createShader = function(options) {
    if (options == null || typeof options !== 'object') {
        return null;
    }

    var vertexShader = options['vertexShader'];
    var fragmentShader = options['fragmentShader'];

    if (vertexShader != null && fragmentShader) {
        return new GpuProgram(this.gpu, vertexShader, fragmentShader);
    }
};


RendererInterface.prototype.removeResource = function(resource) {
    if (resource != null && resource.kill != null) {
        resource.kill();
    }
    return this;    
};


RendererInterface.prototype.addJob = function(/*options*/) {
    return this;    
};


RendererInterface.prototype.clearJobs = function(/*options*/) {
    return this;    
};


RendererInterface.prototype.drawMesh = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }

    if (!options['mesh'] == null || !options['shaderVariables']) {
        return this;    
    }

    //var shaderAttributes = options['shaderAttributes'];
    var vertexAttr = options['vertex'] || 'aPosition';
    var uvAttr = options['uv'] || 'aTexCoord';
    var uv2Attr = options['normal'] || 'aNormal';
    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;

    var shaderVariables = options['shaderVariables'];
    var shader = options['shader'] || 'textured';

   
    var renderer = this.renderer; 
    var mesh = options['mesh'];
    var texture = options['texture'];
    var mv = renderer.camera.getModelviewMatrix();
    var proj = renderer.camera.getProjectionMatrix();
    var fogDensity = renderer.fogDensity;
    
    if (typeof shader === 'string') {
        switch(shader) {
        case 'hit':

            if (!shaderVariables['uMV']) {
                shaderVariables['uMV'] = ['mat4', mv];
            } 

            if (!shaderVariables['uProj']) {
                shaderVariables['uProj'] = ['mat4', proj];
            } 

            uvAttr = null;
            uv2Attr = null;
            texture = null;
            shader = renderer.progDepthTile;
            break;

        case 'shaded':
            uvAttr = null;

        // eslint-disable-next-line
        case 'textured':
        case 'textured-and-shaded':

            if (!shaderVariables['uMV']) {
                shaderVariables['uMV'] = ['mat4', mv];
            } 

            if (!shaderVariables['uProj']) {
                shaderVariables['uProj'] = ['mat4', proj];
            } 

            if (!shaderVariables['uFogDensity']) {
                shaderVariables['uFogDensity'] = ['float', fogDensity];
            } 
            
            uv2Attr = (shader == 'textured') ? null : 'aNormal';
            shader = (shader == 'textured') ? renderer.progTile : ((shader == 'shaded') ? renderer.progShadedTile : renderer.progTShadedTile);
            break;
        }
    }

    if (!shader || !shader.isReady()) {
        return;
    }

    var attributes = [vertexAttr];
    if (uvAttr){
        attributes.push(uvAttr);        
    } 
    if (uv2Attr){
        attributes.push(uv2Attr);        
    } 

    renderer.gpu.useProgram(shader, attributes);

    for (var key in shaderVariables) {
        var item = shaderVariables[key];
        
        if (item.length == 2) {
            switch(item[0]){
            case 'floatArray':
                shader.setFloatArray(key, item[1]);
                break;
            case 'float':
                shader.setFloat(key, item[1]);
                break;
            case 'mat3':
                shader.setMat3(key, item[1]);
                break;
            case 'mat4':
                if (depthOffset && key == 'uProj') {
                    shader.setMat4(key, item[1], renderer.getZoffsetFactor(depthOffset));
                } else {
                    shader.setMat4(key, item[1]);
                }
                break;
            case 'vec2':
                shader.setVec2(key, item[1]);
                break;
            case 'vec3':
                shader.setVec3(key, item[1]);
                break;
            case 'vec4':
                shader.setVec4(key, item[1]);
                break;
            case 'sampler':
                shader.setSampler(key, item[1]);
                break;
            } 
        }
    }

    if (texture) {
        renderer.gpu.bindTexture(texture);
    }
    
    //mesh.draw(shader, vertexAttr, texture ? uvAttr : null, uv2Attr, null);
    mesh.draw(shader, vertexAttr, uvAttr, uv2Attr, null);
    return this;    
};


RendererInterface.prototype.drawImage = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }

    if (options['texture'] == null || options['rect'] == null) {
        return this;    
    }

    var rect = options['rect'];
    var color = options['color'] || [255,255,255,255];
    var depth = (options['depth'] != null) ? options['depth'] : 0;
    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    var blend = (options['blend'] != null) ? options['blend'] : false;
    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    var useState = (options['useState'] != null) ? options['useState'] : false;
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    this.renderer.draw.drawImage(rect[0], rect[1], rect[2], rect[3], options['texture'], color, depth, depthOffset, depthTest, blend, writeDepth, useState);
    return this;    
};


RendererInterface.prototype.drawBillboard = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }

    if (options['texture'] == null || options['mvp'] == null) {
        return this;    
    }

    var mvp = options['mvp'];
    var color = options['color'] || [255,255,255,255];
    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    var blend = (options['blend'] != null) ? options['blend'] : false;
    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    var useState = (options['useState'] != null) ? options['useState'] : false;
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    this.renderer.draw.drawBillboard(mvp, options['texture'], color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;    
};


RendererInterface.prototype.drawLineString = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }

    if (options['points'] == null) {
        return this;    
    }

    var points = options['points'];
    var color = options['color'] || [255,255,255,255];
    var depthOffset = (options['depthOffset'] != null) ? options['depthOffset'] : null;
    var size = options['size'] || 2;
    var screenSpace = (options['screenSpace'] != null) ? options['screenSpace'] : true;
    var depthTest = (options['depthTest'] != null) ? options['depthTest'] : false;
    var blend = (options['blend'] != null) ? options['blend'] : false;
    var writeDepth = (options['writeDepth'] != null) ? options['writeDepth'] : false;
    var useState = (options['useState'] != null) ? options['useState'] : false;
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    this.renderer.draw.drawLineString(points, screenSpace, size, color, depthOffset, depthTest, blend, writeDepth, useState);
    return this;    
};


RendererInterface.prototype.drawJobs = function(/*options*/) {
    return this;    
};


RendererInterface.prototype.drawBBox = function(/*options*/) {
    return this;    
};


RendererInterface.prototype.drawDebugText = function(options) {
    if (options == null || typeof options !== 'object') {
        return this;    
    }

    var text = options['text'];
    var coords = options['coords'];

    if (!text || !coords) {
        return this;    
    }
    
    var color = options['color'] || [255,255,255,255];
    var size = options['size'] || 16;
    var depth = options['depth'];
    var useState = options['useState'] || false;
    color[0] *= 1.0/255;
    color[1] *= 1.0/255;
    color[2] *= 1.0/255;
    color[3] *= 1.0/255;

    var lx = this.renderer.draw.getTextSize(size, text);

    this.renderer.draw.drawText(coords[0] - (lx * 0.5), coords[1], size, text, color, depth, useState);

    return this;    
};


RendererInterface.prototype.buildOctreeFromGeometry = function(geometry) {
    var octree = new Octree();
    octree.buildFromGeometry(geometry);
    return octree;
};


RendererInterface.prototype.raycastOctreeGeometry = function(octree, rayPos, rayDir) {
    var raycaster = new OctreeRaycaster(), intersects = [];
    raycaster.intersectOctree(rayPos, rayDir, octree, intersects);
    return raycaster.intersectOctants(rayPos, rayDir, intersects);
};

RendererInterface.prototype.saveScreenshot = function(output, filename, filetype) {
    return this.renderer.saveScreenshot(output, filename, filetype);
};


RendererInterface.prototype.getCanvasCoords = function(point, mvp) {
    return this.renderer.project2(point, mvp);
};


RendererInterface.prototype.getCanvasSize = function() {
    return this.renderer.curSize.slice();
};


RendererInterface.prototype.setConfigParams = function(params) {
    this.renderer.setConfigParams(params);
    return this;
};


RendererInterface.prototype.setConfigParam = function(key, value) {
    this.renderer.setConfigParam(key, value);
    return this;
};


RendererInterface.prototype.getConfigParam = function(key) {
    return this.renderer.getConfigParam(key);
};


RendererInterface.prototype.getGLInterface = function() {
    return {
        canvas : this.gpu.canvas,
        gl : this.gpu.gl
    };
};


RendererInterface.prototype.setSuperElevation = function(h1, f1, h2, f2) {
    return this.renderer.setSuperElevation(h1, f1, h2, f2);
};


RendererInterface.prototype.setMarginFlags = function(flags) {
    return this.renderer.marginFlags = flags;
};


RendererInterface.prototype.getMarginFlags = function() {
    return this.renderer.marginFlags;
};


/* harmony default export */ __webpack_exports__["a"] = (RendererInterface);


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Octree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return OctreeRaycaster; });



//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */];


var Octree = function() {
    this.root = null;
    this.maxItemsPerNode = 20;
    this.maxDepth = 20;

    this.depthCount = [];
    for (var i = 0; i < 1000; i++) {
        this.depthCount[i] = 0;
    }

    /**
     * A binary pattern that describes the standard octant layout:
     *
     * ```text
     *    3____7
     *  2/___6/|
     *  | 1__|_5
     *  0/___4/
     * ```
     *
     * This common layout is crucial for positional assumptions.
     *
     */

    this.pattern = [
        new Uint8Array([0, 0, 0]),
        new Uint8Array([0, 0, 1]),
        new Uint8Array([0, 1, 0]),
        new Uint8Array([0, 1, 1]),

        new Uint8Array([1, 0, 0]),
        new Uint8Array([1, 0, 1]),
        new Uint8Array([1, 1, 0]),
        new Uint8Array([1, 1, 1])
    ];
};


Octree.prototype.clear = function() {
};


Octree.prototype.buildFromGeometry = function(data) {
    if (!data) {
        return;
    }

    var i, li, j, lj, k, lk, v, item, submeshes, submesh, bbox, index,
        minX, minY, minZ, maxX, maxY, maxZ, geometry, vertices;

    minX = minY = minZ = Number.POSITIVE_INFINITY;
    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

    //get gemetery bbox
    for (i = 0, li = data.length; i < li; i++) {
        geometry = data[i];
        if (geometry["type"] == "mesh") {
            submeshes = geometry["submeshes"];

            for (j = 0, lj = submeshes.length; j < lj; j++) {
                submesh = submeshes[j];
                bbox = submesh["bbox"];
                
                if (bbox[0][0] < minX) minX = bbox[0][0];
                if (bbox[0][1] < minY) minY = bbox[0][1];
                if (bbox[0][2] < minZ) minZ = bbox[0][2];

                if (bbox[1][0] > maxX) maxX = bbox[1][0];
                if (bbox[1][1] > maxY) maxY = bbox[1][1];
                if (bbox[1][2] > maxZ) maxZ = bbox[1][2];
            }
        }
    }

    this.root = new OctreeNode([minX, minY, minZ], [maxX, maxY, maxZ]);

    //get gemetery bbox
    for (i = 0, li = data.length; i < li; i++) {
        geometry = data[i];
        if (geometry["type"] == "mesh") {
            submeshes = geometry["submeshes"];

            for (j = 0, lj = submeshes.length; j < lj; j++) {
                submesh = submeshes[j];

                vertices = submesh["vertices"];

                for (k = 0, lk = vertices.length; k < lk; k += 9) {

                    minX = minY = minZ = Number.POSITIVE_INFINITY;
                    maxX = maxY = maxZ = Number.NEGATIVE_INFINITY;

                    for (v = 0; v < 3; v ++) {
                        index = k + v * 3;

                        if (vertices[index] < minX) minX = vertices[index];
                        if (vertices[index+1] < minY) minY = vertices[index+1];
                        if (vertices[index+2] < minZ) minZ = vertices[index+2];

                        if (vertices[index] > maxX) maxX = vertices[index];
                        if (vertices[index+1] > maxY) maxY = vertices[index+1];
                        if (vertices[index+2] > maxZ) maxZ = vertices[index+2];
                    }

                    //this.root.add([minX, minY, minZ], [maxX, maxY, maxZ], [vertices, k])
                    this.root.add([minX, minY, minZ, maxX, maxY, maxZ, vertices, k], this)
                }

            }
        }
    }


};


var OctreeNode = function(min, max) {
    this.min = min;
    this.max = max;
    this.children = null;
    this.items = null;
};

OctreeNode.prototype.add = function(item, octree, depth) {
    if (this.children) {
        if (!depth) {
            depth = 0; 
        }

        for (var i = 0; i < 8; i++) {
            var child = this.children[i],
                min = child.min,
                max = child.max;

            if (item[0] < max[0] && item[3] > min[0] &&
                item[1] < max[1] && item[4] > min[1] &&
                item[2] < max[2] && item[5] > min[2]) {

                //collision detected, add item
                child.add(item, octree, depth + 1);
            }
        }

        return;
    }

    if (!this.items) {
        this.items = [];
    }

    this.items.push(item);

    if (depth < octree.maxDepth && this.items.length >= octree.maxItemsPerNode) {
        this.split(octree, depth + 1);
    }
};

OctreeNode.prototype.split = function(octree, depth) {
    var min = this.min,
        max = this.max,
        mid = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5],
        i, li, j;

    this.children = [
        null, null,
        null, null,
        null, null,
        null, null
    ];

    this.depthCount[depth]++;

    for (i = 0; i < 8; i++) {
        var combination = octree.pattern[i];

        this.children[i] = new OctreeNode(
            [
                (combination[0] === 0) ? min[0] : mid[0],
                (combination[1] === 0) ? min[1] : mid[1],
                (combination[2] === 0) ? min[2] : mid[2]
            ],

            [
                (combination[0] === 0) ? mid[0] : max[0],
                (combination[1] === 0) ? mid[1] : max[1],
                (combination[2] === 0) ? mid[2] : max[2]
            ]
        );
    }

    var items = this.items;

    //distribute items
    if (items) {
        for (i = 0, li = items.length; i < li; i++) {
            var item = items[i];

            for (j = 0; j < 8; j++) {
                var child = this.children[j];
                min = child.min;
                max = child.max;

                if (item[0] < max[0] && item[3] > min[0] &&
                    item[1] < max[1] && item[4] > min[1] &&
                    item[2] < max[2] && item[5] > min[2]) {

                    //collision detected, add item
                    child.add(item, octree);
                }
            }
        }
    }

    this.items = null;   
};


var OctreeRaycaster = function() {

    // A lookup-table containing octant ids. Used to determine the exit plane from an octant.
    this.octantTable = [
        new Uint8Array([4, 2, 1]),
        new Uint8Array([5, 3, 8]),
        new Uint8Array([6, 8, 3]),
        new Uint8Array([7, 8, 8]),
        new Uint8Array([8, 6, 5]),
        new Uint8Array([8, 7, 8]),
        new Uint8Array([8, 8, 7]),
        new Uint8Array([8, 8, 8])
    ];

    // A byte that stores raycasting flags.
    this.flags = 0;
};


/**
 * Finds the entry plane of the first octant that a ray travels through.
 *
 * Determining the first octant requires knowing which of the t0s is the
 * largest. The tms of the other axes must also be compared against that
 * largest t0.
 * 
 * tx0, ty0,tz0 - Ray projection parameter.
 * txm, tym, tzm - Ray projection parameter mean.
 * returns - index of the first octant that the ray travels through.
 */

OctreeRaycaster.prototype.findEntryOctant = function(tx0, ty0, tz0, txm, tym, tzm) {
    var entry = 0;

    // Find the entry plane.
    if(tx0 > ty0 && tx0 > tz0) {

        // YZ-plane.
        if (tym < tx0) {
            entry |= 2;
        }

        if (tzm < tx0) {
            entry |= 1;
        }

    } else if (ty0 > tz0) {

        // XZ-plane.
        if (txm < ty0) {
            entry |= 4;
        }

        if (tzm < ty0) {
            entry |= 1;
        }

    } else {

        // XY-plane.
        if (txm < tz0) {
            entry |= 4;
        }

        if (tym < tz0) {
            entry |= 2;
        }
    }

    return entry;
}

/**
 * Finds the next octant that intersects with the ray based on the exit plane of
 * the current one.
 *
 * urrentOctant - The index of the current octant.
 * tx1, ty1, tz1 - Ray projection parameter.
 * returns - index of the next octant that the ray travels through.
 */

OctreeRaycaster.prototype.findNextOctant = function(currentOctant, tx1, ty1, tz1) {
    var min;
    var exit = 0;

    // Find the exit plane.
    if (tx1 < ty1) {
        min = tx1;
        exit = 0; // YZ-plane.
    } else {
        min = ty1;
        exit = 1; // XZ-plane.
    }

    if (tz1 < min) {
        exit = 2; // XY-plane.
    }

    return this.octantTable[currentOctant][exit];
}

/**
 * Finds all octants that intersect with the given ray.
 *
 * octant - The current octant.
 * tx0 - Ray projection parameter. Initial tx0 = (minX - rayOriginX) / rayDirectionX.
 * ty0 - Ray projection parameter. Initial ty0 = (minY - rayOriginY) / rayDirectionY.
 * tz0 - Ray projection parameter. Initial tz0 = (minZ - rayOriginZ) / rayDirectionZ.
 * tx1 - Ray projection parameter. Initial tx1 = (maxX - rayOriginX) / rayDirectionX.
 * ty1 - Ray projection parameter. Initial ty1 = (maxY - rayOriginY) / rayDirectionY.
 * tz1 - Ray projection parameter. Initial tz1 = (maxZ - rayOriginZ) / rayDirectionZ.
 * intersects - An array to be filled with the intersecting octants.
 * returns
 */

OctreeRaycaster.prototype.raycastOctant = function(octant, tx0, ty0, tz0, tx1, ty1, tz1, intersects) {
    var children = octant.children;
    var currentOctant;
    var txm, tym, tzm;

    if (tx1 >= 0.0 && ty1 >= 0.0 && tz1 >= 0.0) {

        if (!children) {

            // Leaf.
            if (octant.items) {
                intersects.push(octant);
            }

        } else {

            // Compute means.
            txm = 0.5 * (tx0 + tx1);
            tym = 0.5 * (ty0 + ty1);
            tzm = 0.5 * (tz0 + tz1);

            currentOctant = this.findEntryOctant(tx0, ty0, tz0, txm, tym, tzm);

            do {

                /* The possibilities for the next node are passed in the same respective
                 * order as the t-values. Hence, if the first value is found to be the
                 * greatest, the fourth one will be returned. If the second value is the
                 * greatest, the fifth one will be returned, etc.
                 */

                switch(currentOctant) {

                    case 0:
                        this.raycastOctant(children[this.flags], tx0, ty0, tz0, txm, tym, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tzm);
                        break;

                    case 1:
                        this.raycastOctant(children[this.flags ^ 1], tx0, ty0, tzm, txm, tym, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, tym, tz1);
                        break;

                    case 2:
                        this.raycastOctant(children[this.flags ^ 2], tx0, tym, tz0, txm, ty1, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tzm);
                        break;

                    case 3:
                        this.raycastOctant(children[this.flags ^ 3], tx0, tym, tzm, txm, ty1, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, txm, ty1, tz1);
                        break;

                    case 4:
                        this.raycastOctant(children[this.flags ^ 4], txm, ty0, tz0, tx1, tym, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tzm);
                        break;

                    case 5:
                        this.raycastOctant(children[this.flags ^ 5], txm, ty0, tzm, tx1, tym, tz1, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, tym, tz1);
                        break;

                    case 6:
                        this.raycastOctant(children[this.flags ^ 6], txm, tym, tz0, tx1, ty1, tzm, intersects);
                        currentOctant = this.findNextOctant(currentOctant, tx1, ty1, tzm);
                        break;

                    case 7:
                        this.raycastOctant(children[this.flags ^ 7], txm, tym, tzm, tx1, ty1, tz1, intersects);
                        // Far top right octant. No other octants can be reached from here.
                        currentOctant = 8;
                        break;

                }

            } while(currentOctant < 8);

        }

    }

}

OctreeRaycaster.prototype.hitFace = function(origin, dir, index, vertices) {
    var EPSILON = 0.0000001,
        v1 = [vertices[index], vertices[index+1], vertices[index+2]],
        v2 = [vertices[index+3], vertices[index+4], vertices[index+5]],
        v3 = [vertices[index+6], vertices[index+7], vertices[index+8]];

    var h = [0,0,0], q = [0,0,0], s, a, f, u, v,
        edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]],
        edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

    vec3.cross(dir, edge2, h);
    a = vec3.dot(edge1, h);

    if (a > -EPSILON && a < EPSILON) {
        return [false];
    }

    f = 1/a;
    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];
    u = f * (vec3.dot(s, h));

    if (u < 0.0 || u > 1.0) {
        return [false];
    }

    q = vec3.cross(s, edge1);
    v = f * vec3.dot(dir, q);
    if (v < 0.0 || u + v > 1.0) {
        return [false];
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    var t = f * vec3.dot(edge2, q);
    //if (t > EPSILON) { // ray intersection
        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];
    //} else { // This means that there is a line intersection but not a ray intersection.
     //   return [false];
    //}
};


/**
 * Finds the octants that intersect with the given ray. The intersecting
 * octants are sorted by distance, closest first.
 *
 * octree - An octree.
 * intersects - A list to be filled with intersecting octants.
 */

// https://github.com/vanruesc/sparse-octree/blob/master/src/core/OctreeRaycaster.js

OctreeRaycaster.prototype.intersectOctree = function(rayPos, rayDir, octree, intersects) {
    // Translate the octree extents to the scene origin.
    var min = [0,0,0];
    var max = [octree.root.max[0] - octree.root.min[0],
               octree.root.max[1] - octree.root.min[1],
               octree.root.max[2] - octree.root.min[2]] 

    var dimensions = [max[0], max[1], max[2]];
    var halfDimensions = [dimensions[0]*0.5, dimensions[1]*0.5, dimensions[2]*0.5];

    var origin = [rayPos[0],rayPos[1],rayPos[2]];
    var direction = [rayDir[0], rayDir[1], rayDir[2]];

    var invDirX, invDirY, invDirZ;
    var tx0, tx1, ty0, ty1, tz0, tz1;

    var center = [(octree.root.max[0] + octree.root.min[0]) * 0.5,
                  (octree.root.max[1] + octree.root.min[1]) * 0.5,
                  (octree.root.max[2] + octree.root.min[2]) * 0.5] 

    // Translate the ray to the center of the octree.
    //origin.sub(octree.getCenter(v[2])).add(halfDimensions);
    origin[0] = (origin[0] - center[0]) + halfDimensions[0]; 
    origin[1] = (origin[1] - center[1]) + halfDimensions[1]; 
    origin[2] = (origin[2] - center[2]) + halfDimensions[2]; 

    // Reset all flags.
    this.flags = 0;

    // Handle rays with negative directions.
    if (direction[0] < 0.0) {
        origin[0] = dimensions[0] - origin[0];
        direction[0] = -direction[0];
        this.flags |= 4;
    }

    if (direction[1] < 0.0) {
        origin[1] = dimensions[1] - origin[1];
        direction[1] = -direction[1];
        this.flags |= 2;
    }

    if (direction[2] < 0.0) {
        origin[2] = dimensions[2] - origin[2];
        direction[2] = -direction[2];
        this.flags |= 1;
    }

    // Improve IEEE double stability.
    invDirX = 1.0 / direction[0];
    invDirY = 1.0 / direction[1];
    invDirZ = 1.0 / direction[2];

    // Project the ray to the root's boundaries.
    tx0 = (min[0] - origin[0]) * invDirX;
    tx1 = (max[0] - origin[0]) * invDirX;
    ty0 = (min[1] - origin[1]) * invDirY;
    ty1 = (max[1] - origin[1]) * invDirY;
    tz0 = (min[2] - origin[2]) * invDirZ;
    tz1 = (max[2] - origin[2]) * invDirZ;

    // Check if the ray hits the octree.
    if (Math.max(Math.max(tx0, ty0), tz0) < Math.min(Math.min(tx1, ty1), tz1)) {
        // Find the intersecting octants.
        this.raycastOctant(octree.root, tx0, ty0, tz0, tx1, ty1, tz1, intersects);
    }
};

OctreeRaycaster.prototype.intersectOctants = function(rayPos, rayDir, octants) {
    var hits = [];
    var t = Number.POSITIVE_INFINITY;

    for (var i = 0, li = octants.length; i < li; i++) {
        var items = octants[i].items;

        for (var j = 0, lj = items.length; j < lj; j++) {
            var item = items[j];
            var res = this.hitFace(rayPos, rayDir, item[7], item[6]);

            if (res[0] && res[1] < t) {
                t = res[1];
            }
        }
    }

    if (t !== Number.POSITIVE_INFINITY) {
        hits = [t];
    }

    return hits;
};




/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gpu_device__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gpu_texture__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gpu_font__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__camera__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__init__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__draw__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__rmap__ = __webpack_require__(169);










//get rid of compiler mess
var vec3 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["b" /* vec3 */], mat4 = __WEBPACK_IMPORTED_MODULE_0__utils_matrix__["e" /* mat4 */];
var GpuDevice = __WEBPACK_IMPORTED_MODULE_1__gpu_device__["a" /* default */];
var GpuTexture = __WEBPACK_IMPORTED_MODULE_2__gpu_texture__["a" /* default */];
var GpuFont = __WEBPACK_IMPORTED_MODULE_3__gpu_font__["a" /* default */];
var Camera = __WEBPACK_IMPORTED_MODULE_4__camera__["a" /* default */];
var RenderInit = __WEBPACK_IMPORTED_MODULE_5__init__["a" /* default */];
var RenderDraw = __WEBPACK_IMPORTED_MODULE_6__draw__["a" /* default */];
var RenderRMap = __WEBPACK_IMPORTED_MODULE_7__rmap__["a" /* default */];

var Renderer = function(core, div, onUpdate, onResize, config) {
    this.config = config || {};
    this.core = core;
    this.marginFlags = 0;
    this.progTile = null;
    this.progHeightmap = null;
    this.progSkydome = null;
    this.progWireframeTile = null;
    this.progWireframeTile2 = null;
    this.progText = null;
    this.div = div;
    this.onUpdate = onUpdate;
    this.killed = false;
    this.onlyDepth = false;
    this.onlyLayers = false;
    this.onlyHitLayers = false;
    this.onlyAdvancedHitLayers = false;
    this.advancedPassNeeded = false;
    this.hitmapCounter = 0;
    this.geoRenderCounter = 0;
    this.geoHitmapCounter = 0;
    this.frameTime = 0;
    this.geometries = {};
    this.clearStencilPasses = [];
    this.onResizeCall = onResize;
    //this.math = Math;
    this.stencilLineState = null;
    this.drawLabelBoxes = false;
    this.drawGridCells = false;
    this.drawAllLabels = false;
    this.debug = {};
    this.mapHack = null;

    this.geodataSelection = [];
    this.hoverFeatureCounter = 0;
    this.hoverFeatureList = [];

    this.touchSurfaceEvent = [];

    var rect = this.div.getBoundingClientRect();

    this.winSize = [rect.width, rect.height]; //QSize
    this.curSize = [rect.width, rect.height]; //QSize
    this.oldSize = [rect.width, rect.height]; //QSize
    this.dirty = true;
    this.cameraVector = [0,1,0];
    this.viewExtent = 1;
    //this.texelSizeLimit = this.core.mapConfig.texelSize * texelSizeFactor;

    this.gpu = new GpuDevice(this, div, this.curSize, this.config.rendererAllowScreenshots, this.config.rendererAntialiasing, this.config.rendererAnisotropic);
    this.camera = new Camera(this, 45, 2, 1200000.0);

    //reduce garbage collection
    this.drawTileMatrix = mat4.create();
    this.drawTileMatrix2 = mat4.create();
    this.drawTileVec = [0,0,0];
    this.drawTileWorldMatrix = mat4.create();
    this.pixelTileSizeMatrix = mat4.create();

    this.heightmapMesh = null;
    this.heightmapTexture = null;

    this.skydomeMesh = null;
    this.skydomeTexture = null;

    this.hitmapTexture = null;
    this.geoHitmapTexture = null;
    this.hitmapSize = this.config.mapDMapSize;
    this.hitmapMode = this.config.mapDMapMode;
    this.updateHitmap = true;
    this.updateGeoHitmap = true;

    this.redTexture = null;

    this.rectVerticesBuffer = null;
    this.rectIndicesBuffer = null;
    this.imageProjectionMatrix = null;

    this.font = null;
    this.fonts = {};
    this.fogDensity = 0;

    this.gmap = new Array(2048);
    this.gmap2 = new Array(2048);
    this.gmap3 = new Array(10000);
    this.gmap3Size = new Array(10000);
    this.gmap4 = new Array(10000);
    this.gmapIndex = 0;
    this.gmapTop = new Array(512);
    this.gmapHit = new Array(512);
    this.gmapStore = new Array(512);
    this.fmaxDist = 0;
    this.fminDist = 0;

    this.jobZBuffer = new Array(512);
    this.jobZBufferSize = new Array(512);

    this.jobZBuffer2 = new Array(512);
    this.jobZBuffer2Size = new Array(512);
    
    this.jobHBuffer = {};
    this.jobHBufferSize = 0;
    this.jobHSortBuffer = new Array(2048);


    for (var i = 0, li = this.jobZBuffer.length; i < li; i++) {
        this.jobZBuffer[i] = [];
        this.jobZBufferSize[i] = 0;
        this.jobZBuffer2[i] = {};
        this.jobZBuffer2Size[i] = 0;
    }

    for (i = 0, li = this.gmap3.length; i < li; i++) {
        this.gmap3[i] = [];
        this.gmap3Size[i] = 0;
    }

    this.radixCountBuffer16 = new Uint16Array(256*4);
    this.radixCountBuffer32 = new Uint32Array(256*4);
    //this.radixOutputBufferUint32 = new Uint32Array(256*256);
    //this.radixOutputBufferFloat32 = new Uint32Array(256*256);

    this.buffFloat32 = new Float32Array(1);
    this.buffUint32 = new Uint32Array(this.buffFloat32.buffer);

    this.layerGroupVisible = [];
    this.bitmaps = {};
    
    this.cameraPosition = [0,0,0];
    this.cameraOrientation = [0,0,0];
    this.cameraTiltFator = 1;
    this.cameraViewExtent = 1;
    this.distanceFactor = 1;
    this.tiltFactor = 1;
    this.localViewExtentFactor = 1;
    this.cameraVector = [0,0,0];
    this.labelVector = [0,0,0];
    this.drawnGeodataTiles = 0;
    this.drawnGeodataTilesFactor = 0;
    this.drawnGeodataTilesUsed = false;
    this.progMap = {};
    this.gridHmax = 0;
    this.gridHmin = 0;
    this.seCounter = 0;

    //hack for vts maps
    //this.vtsHack = true;
    //this.vtsHack = false;

    //reduce garbage collection
    this.updateCameraMatrix = mat4.create();

    this.seTmpVec = [0,0,0];
    this.seTmpVec2 = [0,0,0];
    this.seTmpVec3 = [0,0,0];

    //debug
    this.lastHitPosition = [0,0,100];
    this.logTilePos = null;
    this.setSuperElevation(0,2,4000,1.5);

    window.addEventListener('resize', (this.onResize).bind(this), false);

    this.gpu.init();

    //intit resources
    // eslint-disable-next-line
    this.init = new RenderInit(this);
    this.rmap = new RenderRMap(this, 50);
    this.draw = new RenderDraw(this);

    var factor = 1;
    this.resizeGL(Math.floor(this.curSize[0]*factor), Math.floor(this.curSize[1]*factor));
};

Renderer.prototype.initProceduralShaders = function() {
    this.init.initProceduralShaders();
};


Renderer.prototype.onResize = function() {
    if (this.killed){
        return;
    }

    var rect = this.div.getBoundingClientRect();
    this.resizeGL(Math.floor(rect.width), Math.floor(rect.height));
    
    if (this.onResizeCall) {
        this.onResizeCall();
    }
};


Renderer.prototype.kill = function() {
    if (this.killed){
        return;
    }

    this.killed = true;

    if (this.heightmapMesh) this.heightmapMesh.kill();
    if (this.heightmapTexture) this.heightmapTexture.kill();
    if (this.skydomeMesh) this.skydomeMesh.kill();
    if (this.skydomeTexture) this.skydomeTexture.kill();
    if (this.hitmapTexture) this.hitmapTexture.kill();
    if (this.geoHitmapTexture) this.geoHitmapTexture.kill();
    if (this.redTexture) this.redTexture.kill();
    if (this.whiteTexture) this.whiteTexture.kill();
    if (this.blackTexture) this.blackTexture.kill();
    if (this.lineTexture) this.lineTexture.kill();
    if (this.textTexture2) this.textTexture2.kill();
    if (this.atmoMesh) this.atmoMesh.kill();
    if (this.bboxMesh) this.bboxMesh.kill();
    if (this.font) this.font.kill();
    if (this.plines) this.plines.kill();
    if (this.plineJoints) this.plineJoints.kill();
 
    this.gpu.kill();
    //this.div.removeChild(this.gpu.getCanvas());
};


Renderer.prototype.resizeGL = function(width, height, skipCanvas, skipPaint) {
    this.camera.setAspect(width / height);
    this.curSize = [width, height];
    this.oldSize = [width, height];
    this.gpu.resize(this.curSize, skipCanvas);

    //if (skipPaint !== true) { //remove this??
       // this.draw.paintGL();
    //}

    var m = new Float32Array(16);
    m[0] = 2.0/width; m[1] = 0; m[2] = 0; m[3] = 0;
    m[4] = 0; m[5] = -2.0/height; m[6] = 0; m[7] = 0;
    m[8] = 0; m[9] = 0; m[10] = 1; m[11] = 0;
    m[12] = -width*0.5*m[0]; m[13] = -height*0.5*m[5]; m[14] = 0; m[15] = 1;

    this.imageProjectionMatrix = m;
};


Renderer.prototype.project2 = function(point, mvp, cameraPos, includeDistance) {
    var p = [0, 0, 0, 1];

    if (cameraPos) {
        p = mat4.multiplyVec4(mvp, [point[0] - cameraPos[0], point[1] - cameraPos[1], point[2] - cameraPos[2], 1 ]);
    } else {
        p = mat4.multiplyVec4(mvp, [point[0], point[1], point[2], 1 ]);
    }

    //project point coords to screen
    if (p[3] != 0) {
        var sp = [0,0,0];

        //x and y are in screen pixels
        sp[0] = ((p[0]/p[3])+1.0)*0.5*this.curSize[0];
        sp[1] = (-(p[1]/p[3])+1.0)*0.5*this.curSize[1];

        //depth in meters
        sp[2] = p[2]/p[3];

        if (includeDistance) {
            sp[3] = p[2];
        }

        return sp;
    } else {
        return [0, 0, 0];
    }
};


Renderer.prototype.setSuperElevationState = function(state) {
    if (this.useSuperElevation != state) {
        this.useSuperElevation = state;
        this.seCounter++;
    }
};


Renderer.prototype.getSuperElevationState = function() {
    return this.useSuperElevation;
};


Renderer.prototype.setSuperElevation = function(h1, f1, h2, f2) {
    if (f1 == 1 && f2 == 1) {
        if (this.useSuperElevation != false) {
            this.useSuperElevation = false;
            this.seCounter++;
        }

        if (h1 == h2) { h2 = h1 + 1; }
        this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];
        return;
    }

    if (h1 == h2) { h2 = h1 + 1; }
    this.superElevation = [h1, f1, h2, f2, h2-h1, f2-f1, 1.0 / (h2-h1)];
    this.seCounter++;
};


Renderer.prototype.getSuperElevation = function() {
    return this.superElevation.slice();
};


Renderer.prototype.getSuperElevatedHeight = function(height) {
    var se = this.superElevation, h = height;

    if (h < se[0]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh
        h = se[0];
    }

    if (h > se[2]) {
        h = se[2];
    }

    return height * (se[1] + ((h - se[0]) * se[6]) * se[5]);
};

Renderer.prototype.getUnsuperElevatedHeight = function(height) {
    var se = this.superElevation, s = height;

    if (se[1] == se[3]) {
        return s / se[1];
    }

    if (s <= se[0] * se[1]) {  // 0 - h1, 1 - f1, 2 - h2, 3 - f2, 4 - dh, 5 - df, 6 - invdh
        return s / se[1];
    }

    if (s >= se[2] * se[3]) {
        return s / se[3];
    }


    var h1 = se[0], f1 = se[1], h2 = se[2], f2 = se[3];

    // and f1!=f2 and h1!=h2

    return -(Math.sqrt(-2*f2*(f1*h1*h2 + 2*h1*s - 2*h2*s) + f1*(f1*h2*h2 + 4*h1*s - 4*h2*s) + f2*f2*h1*h1) - f1*h2 + f2*h1)/(2*(f1 - f2));
};


Renderer.prototype.getEllipsoidHeight = function(pos, shift) {
    var p, p2;
    this.seTmpVec3 = [0,0,0];

    if (shift) {
        p = this.seTmpVec;
        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];
    } else {
        p = pos;
        p2 = [p[0], p[1], p[2] * this.earthERatio];
    }

    var l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);

    return l - this.earthRadius;
};


Renderer.prototype.transformPointBySE = function(pos, shift) {
    var p = pos, p2;
    this.seTmpVec3 = [0,0,0];

    if (shift) {
        p2 = [pos[0] + shift[0], pos[1] + shift[1], (pos[2] + shift[2]) * this.earthERatio];
    } else {
        p2 = [p[0], p[1], p[2] * this.earthERatio];
    }

    var l = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1] + p2[2] * p2[2]);
    var v = this.seTmpVec2;

    var m = (1.0/(l+0.0001));
    v[0] = p2[0] * m;
    v[1] = p2[1] * m;
    v[2] = p2[2] * m;

    var h = l - this.earthRadius;
    var h2 = this.getSuperElevatedHeight(h);
    m = (h2 - h);

    p2[0] = p[0] + v[0] * m;
    p2[1] = p[1] + v[1] * m;
    p2[2] = p[2] + v[2] * m;

    return p2;
};


Renderer.prototype.project = function(point) {
    //get mode-view-projection matrix
    var mvp = this.camera.getMvpMatrix();

    //get camera position relative to position
    var cameraPos2 = this.camera.getPosition();

    //get global camera position
    var cameraPos = this.cameraPosition();

    //get point coords relative to camera
    var p = [point[0] - cameraPos[0] + cameraPos2[0], point[1] - cameraPos[1] + cameraPos2[1], point[2] - cameraPos[2] + cameraPos2[2], 1 ];

    //project point coords to screen
    var p2 = [0, 0, 0, 1];
    p2 = mat4.multiplyVec4(mvp, p);

    if (p2[3] != 0) {

        var sp = [0,0,0];

        //x and y are in screen pixels
        sp[0] = ((p2[0]/p2[3])+1.0)*0.5*this.curSize[0];
        sp[1] = (-(p2[1]/p2[3])+1.0)*0.5*this.curSize[1];

        //depth in meters
        sp[2] = p2[2]/p2[3];

        return sp;
    } else {
        return [0, 0, 0];
    }
};


Renderer.prototype.getScreenRay = function(screenX, screenY) {
    if (this.camera == null) {
        return [0,0,1.0];
    }

    this.camera.dirty = true; //???? why is projection matrix distored so I have to refresh

    //conver screen coords
    var x = (2.0 * screenX) / this.curSize[0] - 1.0;
    var y = 1.0 - (2.0 * screenY) / this.curSize[1];
    
    var rayNormalizeDeviceSpace = [x, y, 1.0];

    var rayClipCoords = [rayNormalizeDeviceSpace[0], rayNormalizeDeviceSpace[1], -1.0, 1.0];

    var invProjection = mat4.create();
    invProjection = mat4.inverse(this.camera.getProjectionMatrix());

    //console.log("--" + JSON.stringify(rayClipCoords));
    //console.log("----" + JSON.stringify(invProjection));

    var rayEye = [0,0,0,0];
    mat4.multiplyVec4(invProjection, rayClipCoords, rayEye); //inverse (projectionmatrix) * rayClipCoords;
    rayEye[2] = -1.0;
    rayEye[3] = 0.0;

    var invView = mat4.create();
    invView = mat4.inverse(this.camera.getModelviewMatrix());

    var rayWorld = [0,0,0,0];
    mat4.multiplyVec4(invView, rayEye, rayWorld); //inverse (projectionmatrix) * rayClipCoords;

    // don't forget to normalise the vector at some point
    rayWorld = vec3.normalize([rayWorld[0], rayWorld[1], rayWorld[2]]); //normalise (raywor);

    return rayWorld;
};


Renderer.prototype.hitTestGeoLayers = function(screenX, screenY, secondTexture) {
    var gl = this.gpu.gl;

    //conver screen coords to texture coords
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
        return [false, 0,0,0,0];
    }

    var surfaceHit = false, pixel;

    if (screenX >= 0 && screenX < this.curSize[0] &&
        screenY >= 0 && screenY < this.curSize[1]) {

        var x = 0, y = 0;

        //get screen coords
        x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
        y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));

        //get pixel value from framebuffer

        if (secondTexture) {
            pixel = this.geoHitmapTexture2.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);
        } else {
            pixel = this.geoHitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);
        }

        surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);
    }

    if (surfaceHit) {
        return [true, pixel[0], pixel[1], pixel[2], pixel[3]];
    } 

    return [false, 0,0,0,0];
};


Renderer.prototype.switchToFramebuffer = function(type, texture) {
    var gl = this.gpu.gl, size, width, height;
    
    switch(type) {
    case 'base':
        width = this.oldSize[0];
        height = this.oldSize[1];
    
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
    
        gl.viewport(0, 0, width, height);
        this.gpu.setFramebuffer(null);
    
        this.camera.setAspect(width / height);
        this.curSize = [width, height];
        this.gpu.resize(this.curSize, true);
        this.camera.update();
            //this.updateCamera();
        this.onlyDepth = false;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;

    case 'depth':
        //set texture framebuffer
        this.gpu.setFramebuffer(this.hitmapTexture);

        this.oldSize = [ this.curSize[0], this.curSize[1] ];
   
        gl.clearColor(1.0,1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        size = this.hitmapSize;
    
        //clear screen
        gl.viewport(0, 0, size, size);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
        this.curSize = [size, size];

        //this.gpu.clear();
        this.camera.update();
        this.onlyDepth = true;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;

    case 'geo':
    case 'geo2':

        this.hoverFeatureCounter = 0;
        size = this.hitmapSize;
            
        //set texture framebuffer
        this.gpu.setFramebuffer(type == 'geo' ? this.geoHitmapTexture : this.geoHitmapTexture2);
            
        width = size;
        height = size;
            
        gl.clearColor(1.0,1.0, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
            
        //clear screen
        gl.viewport(0, 0, size, size);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
        this.curSize = [width, height];
            
        //render scene
        this.onlyHitLayers = true;
        this.advancedPassNeeded = false;
        this.onlyAdvancedHitLayers = (type == 'geo2');
            
        //this.gpu.clear();
        this.camera.update();
        break;

    case 'texture':
        //set texture framebuffer
        this.gpu.setFramebuffer(texture);

        this.oldSize = [ this.curSize[0], this.curSize[1] ];
   
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        //clear screen
        gl.viewport(0, 0, this.gpu.canvas.width, this.gpu.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
        this.curSize = [this.gpu.canvas.width, this.gpu.canvas.height];

        //this.gpu.clear();
        this.camera.update();
        this.onlyDepth = false;
        this.onlyHitLayers = false;
        this.onlyAdvancedHitLayers = false;
        this.advancedPassNeeded = false;
        break;        
    }
};


Renderer.prototype.hitTest = function(screenX, screenY) {
    var gl = this.gpu.gl;

    //get screen ray
    var screenRay = this.getScreenRay(screenX, screenY);
    var cameraPos = this.camera.getPosition();

    //conver screen coords to texture coords
    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
        return [0, 0, 0, null, screenRay, Number.MAX_VALUE, cameraPos];
    }

    var x = 0, y = 0;

    //get screen coords
    x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
    y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));

    //get pixel value from framebuffer
    var pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1);

    //convert rgb values into depth
    var depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);

    var surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);

    //compute hit postion
    this.lastHitPosition = [cameraPos[0] + screenRay[0]*depth, cameraPos[1] + screenRay[1]*depth, cameraPos[2] + screenRay[2]*depth];

    return [this.lastHitPosition[0], this.lastHitPosition[1], this.lastHitPosition[2], surfaceHit, screenRay, depth, cameraPos];
};


Renderer.prototype.copyHitmap = function() {
    this.hitmapTexture.readFramebufferPixels(0,0,this.hitmapSize,this.hitmapSize, false, this.hitmapData);
};


Renderer.prototype.getDepth = function(screenX, screenY) {
    var x = Math.floor(screenX * (this.hitmapSize / this.curSize[0]));
    var y = Math.floor(screenY * (this.hitmapSize / this.curSize[1]));

    if (this.hitmapMode <= 2) {
        //get pixel value from framebuffer
        var pixel = this.hitmapTexture.readFramebufferPixels(x, this.hitmapSize - y - 1, 1, 1, (this.hitmapMode == 2));

        //convert rgb values into depth
        var depth = (pixel[0] * (1.0/255)) + (pixel[1]) + (pixel[2]*255.0) + (pixel[3]*65025.0);// + (pixel[3]*16581375.0);
        var surfaceHit = !(pixel[0] == 255 && pixel[1] == 255 && pixel[2] == 255 && pixel[3] == 255);

    } else {
        var pixels = this.hitmapData;
        var index = (x + (this.hitmapSize - y - 1) * this.hitmapSize) * 4;
        var r = pixels[index], g = pixels[index+1], b = pixels[index+2], a = pixels[index+3];

        var depth = (r * (1.0/255)) + (g) + (b*255.0) + (a*65025.0);// + (pixel[3]*16581375.0);
        var surfaceHit = !(r == 255 && g == 255 && b == 255 && a == 255);
    }

    return [surfaceHit, depth];
};


Renderer.prototype.getZoffsetFactor = function(params) {
    return (params[0] + params[1]*this.distanceFactor + params[2]*this.tiltFactor)*0.0001;
};


Renderer.prototype.saveScreenshot = function(output, filename, filetype) {
    var gl = this.gpu.gl;

    //get current screen size
    var width = this.curSize[0];
    var height = this.curSize[1];

    //read rgba data from frame buffer
    //works only when webgl context is initialized with preserveDrawingBuffer: true
    var data2 = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data2);

    //flip image vertically
    var data = new Uint8Array(width * height * 4);
    var index = 0;

    for (var y = 0; y < height; y++) {

        var index2 = ((height-1) - y) * width * 4;

        for (var x = 0; x < width; x++) {
            data[index] = data2[index2];
            data[index+1] = data2[index2+1];
            data[index+2] = data2[index2+2];
            data[index+3] = data2[index2+3];
            index+=4;
            index2+=4;
        }
    }

    // Create a 2D canvas to store the result
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');

    // Copy the pixels to a 2D canvas
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);

    filetype = filetype || 'jpg'; 
   
    if (output == 'file') {
        var a = document.createElement('a');

        var dataURI= canvas.toDataURL('image/' + filetype);

        var byteString = atob(dataURI.split(',')[1]);
        
        // write the bytes of the string to an ArrayBuffer
        var ab = new ArrayBuffer(byteString.length);
        var ia = new Uint8Array(ab);
        for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
      
        var file = new Blob([ab], {type: filetype});

        var url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);  
        }, 0); 
    } if (output == 'tab') {
        //open image in new window
        window.open(canvas.toDataURL('image/' + filetype));
    }
    
    return imageData;
};


Renderer.prototype.getBitmap = function(url, filter, tiled, hash, useHash) {
    var id = (useHash ? hash : url) + '*' + filter + '*' + tiled;

    var texture = this.bitmaps[id];
    if (!texture && url) {
        texture = new GpuTexture(this.gpu, url, this.core, null, null, tiled, filter);
        this.bitmaps[id] = texture;
    }

    return texture;
};


Renderer.prototype.getFont = function(url) {
    var font = this.fonts[url];
    if (!font) {
        font = new GpuFont(this.gpu, this.core, null, null, url);
        this.fonts[url] = font;
    }

    return font;
};


/* harmony default export */ __webpack_exports__["a"] = (Renderer);


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var RendererRMap = function(renderer, blockSize, maxBlockRectangles) {
    this.renderer = renderer;
    this.drawAllLabels = false;
    this.maxBlockRectangles = maxBlockRectangles || 500;
    this.blockSize = blockSize;
    this.blockSizeFactor = 1/blockSize;
    this.blocks = [];
    this.blocks2 = [];
    this.blocksRCount = [];
    this.blocks2RCount = [];
    this.allocatedBlocks = 0;
    this.lx = 1;
    this.ly = 1;
    this.counter = 0;
    this.rectangles = null;
    this.rectanglesCount = 0;
    this.rectangles2 = null;
    this.rectangles2Count = 0;
    this.rectanglesR = null;
    this.rectanglesRCount = 0;
    this.positionsBuffer = new Float64Array(256*4);
};


RendererRMap.prototype.clear = function() {
    this.sx2 = this.renderer.curSize[0];
    this.sy2 = this.renderer.curSize[1];

    //reduce by credits
    this.sy2 = Math.max(1, this.sy2 - 55);
    this.sy1 = 1;
    this.sx1 = 1;

    //compass size
    this.cx2 = 135;
    this.cy1 = this.renderer.curSize[1] - 145;

    //search bar size
    this.bx2 = 245;
    this.by2 = 45;

    this.lx = Math.floor(this.renderer.curSize[0] * this.blockSizeFactor) + 1;
    this.ly = Math.floor(this.renderer.curSize[1] * this.blockSizeFactor) + 1;

    if (this.renderer.marginFlags & 4096) {
        this.sx1 = Math.min(34, this.sx2);
        this.sx2 = Math.max(1, this.renderer.curSize[0] - 34);
        this.sy1 = Math.min(50, this.sy2);
        this.sy2 = Math.max(1, this.renderer.curSize[1] - 68);
    }

    var totalNeeded = this.ly * this.lx;
    
    if (!this.rectangles) {
        this.rectangles = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (!this.rectangles2) {
        this.rectangles2 = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (!this.rectanglesR) {
        this.rectanglesR = new Array(totalNeeded * this.maxBlockRectangles * 6); //preallocate empty rectangles
    }

    if (this.rectanglesCount > 0 || this.allocatedBlocks != totalNeeded) {

        for (var i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner
            if (!this.blocks[i]) {
                this.blocks[i] = [];
            }

            this.blocksRCount[i] = 0;
        }
    }

    if (this.rectangles2Count > 0 || this.allocatedBlocks != totalNeeded) {

        for (var i = 0; i < totalNeeded; i++) { //check if all rectangles are preallocated and reset coutner
            if (!this.blocks2[i]) {
                this.blocks2[i] = [];
            }

            this.blocks2RCount[i] = 0;
        }
    }

    this.allocatedBlocks = totalNeeded;
    this.drawAllLabels = this.renderer.debug.drawAllLabels;

    this.rectanglesCount = 0;
    this.rectangles2Count = 0;
    this.rectanglesRCount = 0;
    this.counter = this.renderer.geoRenderCounter;
};


RendererRMap.prototype.storeRemovedRectangle = function(x1, y1, x2, y2, z, subjob) {
    var rectangles2 = this.rectanglesR;
    var rectangles2Count = this.rectanglesRCount;

    rectangles2[rectangles2Count] = x1;
    rectangles2[rectangles2Count+1] = y1;
    rectangles2[rectangles2Count+2] = x2;
    rectangles2[rectangles2Count+3] = y2;
    rectangles2[rectangles2Count+4] = z;
    rectangles2[rectangles2Count+5] = subjob;
    this.rectanglesRCount += 6;
};


//aabbox circle
//http://www.firenibbler.com/2016/04/27/how-to-js-collision-detection-cheat-sheets-learn-aabb-box-circle-and-point-detection/
RendererRMap.prototype.circleAABBoxCollide = function(x1, y1, x2, y2, cx, cy, cr){
    // Get the distance between the two objects
    var hwidth = (x2 - x1) * 0.5;
    var hheight = (y2 - y1) * 0.5;
    var distX = Math.abs(cx - x1 - hwidth);
    var distY = Math.abs(cy - y2 - hheight);

    // Check to make sure it is definitely not overlapping
    if (distX > (hwidth + cr) || distY > (hheight + cr)) {
        return false;
    }
    // Check to see if it is definitely overlapping
    if (distX <= hwidth || distY <= hheight) {
        return true;
    }

    // Last Resort to see if they are overlapping
    var dx = distX - hwidth;
    var dy = distY - hheight;
    return (dx * dx + dy * dy <= (cr * cr));
};


//aabbox line
//https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms
RendererRMap.prototype.lineAABBoxCollide = function(x1, y1, x2, y2, rx1, ry1, rx2, ry2) {
    var dx = 1 / ( (rx2 != rx1) ? (rx2 - rx1) : 0.00001);
    var tx1 = (x1 - rx1)*dx;
    var tx2 = (x2 - rx1)*dx;

    var tmin = Math.min(tx1, tx2);
    var tmax = Math.max(tx1, tx2);

    var dy = 1 / ( (ry2 != ry1) ? (ry2 - ry1) : 0.00001);
    var ty1 = (y1 - ry1)*dy;
    var ty2 = (y2 - ry1)*dy;

    tmin = Math.max(tmin, Math.min(ty1, ty2));
    tmax = Math.min(tmax, Math.max(ty1, ty2));

    return tmax >= tmin;
};


RendererRMap.prototype.checkRectangle = function(x1, y1, x2, y2, y3) {
    var t;

    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }
    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }

    y3 += y2;
    
    //screen including credits
    if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {
        return false;
    }

    //compass
    if ((this.renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {
        return false;
    }

    //search bar
    if ((this.renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {
        return false;
    }

    return true;
}

RendererRMap.prototype.addRectangle = function(x1, y1, x2, y2, z, subjob, any, checkDepthMap) {
    var x, y, i, index, blockRectangles, blockRectanglesCount,
        rectangleIndex, t, renderer = this.renderer;

    if (this.drawAllLabels) {
        return true;
    }

    if (x1 > x2) { t = x1; x1 = x2; x2 = t; }
    if (y1 > y2) { t = y1; y1 = y2; y2 = t; }

    var y3 = y2 + subjob[1]; //add stick shift
    
    //screen including credits
    if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y3 > this.sy2) {
        return false;
    }

    //compass
    if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y3 > this.cy1) {
        return false;
    }

    //search bar
    if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y3 > 0) {
        return false;
    }

    var xx1 = Math.floor(x1 * this.blockSizeFactor);
    var yy1 = Math.floor(y1 * this.blockSizeFactor);
    var xx2 = Math.floor(x2 * this.blockSizeFactor);
    var yy2 = Math.floor(y2 * this.blockSizeFactor);

    if (xx2 < 0 || yy2 < 0 || xx1 >= this.lx || yy1 >= this.ly) {
        return false;
    }

    if (xx1 < 0) xx1 = 0;
    if (xx2 >= this.lx) xx2 = this.lx - 1;

    if (yy1 < 0) yy1 = 0;
    if (yy2 >= this.ly) yy2 = this.ly - 1;

    var lx = (xx2 - xx1) + 1;
    var ly = (yy2 - yy1) + 1;
    var removeList = {};
    var exit = false;

    var top = renderer.config.mapFeaturesSortByTop,
        rectangles = this.rectangles, rectangles2 = this.rectangles2;

    //test collision
    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);

            blockRectangles = this.blocks[index];
            blockRectanglesCount = this.blocksRCount[index];

            //test rectangles
            for (i = 0; i < blockRectanglesCount; i++) {
                rectangleIndex = blockRectangles[i];

                if (x1 < rectangles[rectangleIndex + 2] && x2 > rectangles[rectangleIndex + 0] &&
                    y1 < rectangles[rectangleIndex + 3] && y2 > rectangles[rectangleIndex + 1]) {

                    if (any) {
                        return false;
                    }

                    if (top) {
                        if (z < rectangles[rectangleIndex + 4]) {
                            return false;
                        }
                    } else {
                        if (z > rectangles[rectangleIndex + 4]) {
                            return false;
                        }
                    }

                    removeList[rectangleIndex] = true;
                }
            }

            if ((blockRectanglesCount + 1) >= this.maxBlockRectangles) {
                return false;
            }

            blockRectangles = this.blocks2[index];
            blockRectanglesCount = this.blocks2RCount[index];

            //test circles
            for (i = 0; i < blockRectanglesCount; i++) {
                rectangleIndex = blockRectangles[i];

//                if (this.circleAABBoxCollide(rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 2], rectangles[rectangleIndex + 3], x, y, r)) {
                if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles2[rectangleIndex + 0], rectangles2[rectangleIndex + 1], rectangles[rectangleIndex + 3])) {

                 //   if (any) {
                        return false;
                  //  }                    
                }
            }


        }
    }

    //remove rectangles
    for (var key in removeList) {
        this.removeRectangle(parseInt(key));
    }

    if (checkDepthMap) {

        var reduce = checkDepthMap[2];
        var depth = renderer.mapHack.getScreenDepth(checkDepthMap[0], checkDepthMap[1], (reduce[4] > 10000000));

        if (depth[0]) {
            var delta = depth[1] - reduce[4];
            reduce[7] = delta;

            if (!renderer.drawHiddenLabels && delta < checkDepthMap[3]) {
                return false;
            }
        }
    }

    //there is no collision so we can store rectangle
    rectangleIndex = this.rectanglesCount;
    rectangles[rectangleIndex] = x1;
    rectangles[rectangleIndex+1] = y1;
    rectangles[rectangleIndex+2] = x2;
    rectangles[rectangleIndex+3] = y2;
    rectangles[rectangleIndex+4] = z;
    rectangles[rectangleIndex+5] = subjob;
    this.rectanglesCount += 6;

    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);
            this.blocks[index][this.blocksRCount[index]] = rectangleIndex;
            this.blocksRCount[index]++;
        }
    }

    return true;
};


RendererRMap.prototype.addLineLabel = function(subjob, checkDepthMap) {
    var job = subjob[0], blockRectangles, blockRectanglesCount, rectangleIndex;
    var x1 = Number.POSITIVE_INFINITY, x2 = Number.NEGATIVE_INFINITY,
        y1 = Number.POSITIVE_INFINITY, y2 = Number.NEGATIVE_INFINITY;
    var x, y, r, rr = 0, pp, xx, yy, renderer = this.renderer;
    var points = job.labelPoints[subjob[9]];
    var pbuff = this.positionsBuffer;
    var index = 0, pindex = 0;

    for (var i = 0, li = points.length; i < li; i++) {

        pp = renderer.project2(points[i], job.mvp, [0,0,0], true);

        if (pp[0] > x2) x2 = pp[0];
        if (pp[1] > y2) y2 = pp[1];
        if (pp[0] < x1) x1 = pp[0];
        if (pp[1] < y1) y1 = pp[1];

        //minX, maxX, minY, maxY;
        pbuff[pindex] = pp[0];
        pbuff[pindex+1] = pp[1];
        pbuff[pindex+2] = pp[2];

        r = points[i][3] * renderer.camera.scaleFactor2(pp[3])*0.5*renderer.curSize[1];
        pbuff[pindex+3] = r;

        if (r > rr) {
            rr = r;
        }

        pindex += 4;
    }

    x1 -= rr, x2 += rr, y1 -= rr, y2 += rr;

    //screen including credits
    if (x1 < this.sx1 || x2 > this.sx2 || y1 < this.sy1 || y2 > this.sy2) {
        return false;
    }

    //compass
    if ((renderer.marginFlags & 1) && x1 < this.cx2 && x2 > 0 && y1 <= this.sx2 && y2 > this.cy1) {
        return false;
    }

    //search bar
    if ((renderer.marginFlags & 2) && x1 < this.bx2 && x2 > 0 && y1 <= this.by2 && y2 > 0) {
        return false;
    }

    var blockSizeFactor = this.blockSizeFactor, xx1, yy1, xx2, yy2, dx, dy;
    var top = renderer.config.mapFeaturesSortByTop, j,
        rectangles = this.rectangles, rectangles2 = this.rectangles2;

    pindex = 0;

    for (i = 0, li = points.length; i < li; i++) {

        xx = pbuff[pindex];
        yy = pbuff[pindex+1];
        r = pbuff[pindex+3];

        xx1 = Math.floor((xx-r) * blockSizeFactor);
        yy1 = Math.floor((yy-r) * blockSizeFactor);
        xx2 = Math.floor((xx+r) * blockSizeFactor);
        yy2 = Math.floor((yy+r) * blockSizeFactor);

        var lx = (xx2 - xx1) + 1;
        var ly = (yy2 - yy1) + 1;

        //test collision
        for (y = 0; y < ly; y++) {
            for (x = 0; x < lx; x++) {
                index = (yy1 + y)*this.lx + (xx1 + x);

                blockRectangles = this.blocks[index];
                blockRectanglesCount = this.blocksRCount[index];

                //test rectangles
                for (j = 0; j < blockRectanglesCount; j++) {
                    rectangleIndex = blockRectangles[j];

                    if (this.circleAABBoxCollide(x1, y1, x2, y2, rectangles[rectangleIndex + 0], rectangles[rectangleIndex + 1], rectangles[rectangleIndex + 2])) {

                        //if (any) {
                            return false;
                        //}                    
                    }
                }

                blockRectangles = this.blocks2[index];
                blockRectanglesCount = this.blocks2RCount[index];

                //test circles
                for (j = 0; j < blockRectanglesCount; j++) {
                    rectangleIndex = blockRectangles[j];

                    dx = xx - rectangles2[rectangleIndex + 0];
                    dy = yy - rectangles2[rectangleIndex + 1];
                    rr = rectangles2[rectangleIndex + 2] + r;

                    if ((dx*dx + dy*dy) < (rr * rr)) {

                        //if (any) {
                            return false;
                        //}                    
                    }
                }
            }
        }

        pindex += 4;
    }

    //there is no collision so we can store line label
    pindex = 0;

    for (i = 0, li = points.length; i < li; i++) {

        xx = pbuff[pindex];
        yy = pbuff[pindex+1];
        r = pbuff[pindex+3];

        xx1 = Math.floor((xx-r) * blockSizeFactor);
        yy1 = Math.floor((yy-r) * blockSizeFactor);
        xx2 = Math.floor((xx+r) * blockSizeFactor);
        yy2 = Math.floor((yy+r) * blockSizeFactor);

        var lx = (xx2 - xx1) + 1;
        var ly = (yy2 - yy1) + 1;

        rectangleIndex = this.rectangles2Count;
        rectangles2[rectangleIndex] = xx;
        rectangles2[rectangleIndex+1] = yy;
        rectangles2[rectangleIndex+2] = r;
        rectangles2[rectangleIndex+3] = subjob;
        this.rectangles2Count += 4;

        //test collision
        for (y = 0; y < ly; y++) {
            for (x = 0; x < lx; x++) {
                index = (yy1 + y)*this.lx + (xx1 + x);

                //console.log('' + index);

                //if (typeof this.blocks2[index][this.blocks2RCount[index]] === 'undefined') {
                  //  debugger
                //}

                this.blocks2[index][this.blocks2RCount[index]] = rectangleIndex;
                this.blocks2RCount[index]++;
            }
        }

        pindex += 4;
    }

    return true;
};


RendererRMap.prototype.removeRectangle = function(rectangleIndex) {
    var rectangles = this.rectangles, x1, y1, x2, y2, x, y, i, index,
        blockRectangles, blockRectanglesCount;

    x1 = rectangles[rectangleIndex];
    y1 = rectangles[rectangleIndex+1];
    x2 = rectangles[rectangleIndex+2];
    y2 = rectangles[rectangleIndex+3];

    //store removed rectangels for second pass
    var rectangles2 = this.rectanglesR;
    var rectangles2Count = this.rectanglesRCount;

    rectangles2[rectangles2Count] = x1;
    rectangles2[rectangles2Count+1] = y1;
    rectangles2[rectangles2Count+2] = x2;
    rectangles2[rectangles2Count+3] = y2;
    rectangles2[rectangles2Count+4] = rectangles[rectangleIndex+4];
    rectangles2[rectangles2Count+5] = rectangles[rectangleIndex+5];
    this.rectanglesRCount += 6;

    //remove subjob
    rectangles[rectangleIndex+5] = null;

    var xx1 = Math.floor(x1 * this.blockSizeFactor);
    var yy1 = Math.floor(y1 * this.blockSizeFactor);
    var xx2 = Math.floor(x2 * this.blockSizeFactor);
    var yy2 = Math.floor(y2 * this.blockSizeFactor);

    if (xx1 < 0) xx1 = 0;
    if (xx2 >= this.lx) xx2 = this.lx - 1;

    if (yy1 < 0) yy1 = 0;
    if (yy2 >= this.ly) yy2 = this.ly - 1;

    var lx = (xx2 - xx1) + 1;
    var ly = (yy2 - yy1) + 1;

    for (y = 0; y < ly; y++) {
        for (x = 0; x < lx; x++) {
            index = (yy1 + y)*this.lx + (xx1 + x);

            blockRectangles = this.blocks[index];
            blockRectanglesCount = this.blocksRCount[index];

            for (i = 0; i < blockRectanglesCount; i++) {
                if (blockRectangles[i] == rectangleIndex) {
                    blockRectangles[i] = blockRectangles[blockRectanglesCount - 1];
                    this.blocksRCount[index]--;
                    break;
                }
            }

        }
    }
};

RendererRMap.prototype.processRectangles = function(gpu, gl, renderer, screenPixelSize) {
    var rectangles = this.rectangles;
    var rectangles2 = this.rectangles2;
    var rectanglesR = this.rectanglesR;
    var draw = renderer.draw;

    // second pass
    // add removed rectangles
    for (var i = 0, li = this.rectanglesRCount; i < li; i+=6) {
        var x1 = rectanglesR[i],
            y1 = rectanglesR[i+1],
            x2 = rectanglesR[i+2],
            y2 = rectanglesR[i+3],
            z = rectanglesR[i+4],
            subjob = rectanglesR[i+5];

        this.addRectangle(x1, y1, x2, y2, z, subjob);
    }

    this.rectanglesRCount = 0;

    //labels
    for (i = 0, li = this.rectanglesCount; i < li; i+=6) {
        var subjob = rectangles[i+5];

        if (subjob) {
            if (subjob[0].hysteresis) {
                renderer.jobHBuffer[subjob[0].id] = subjob[0];
            } else {
                renderer.drawnJobs++;
                draw.drawGpuSubJob(gpu, gl, renderer, screenPixelSize, subjob, null);
            }
        }
    }

    //line labels
    for (i = 0, li = this.rectangles2Count; i < li; i+=4) {
        var subjob = rectangles2[i+3];

        if (subjob) {
            var job = subjob[0];

            if (job.hysteresis) {
                renderer.jobHBuffer[job.id] = job;
            } else {
                renderer.drawnJobs++;
                draw.drawGpuSubJobLineLabel(gpu, gl, renderer, screenPixelSize, subjob, null);
            }

            var l = job.labelPoints[0].length;

            if (l > 0) {
                i += (4 * (l - 1));
            }
        }
    }

    this.clear();
};

/* harmony default export */ __webpack_exports__["a"] = (RendererRMap);



/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_utils_math__ = __webpack_require__(4);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ControlModeMapObserver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return constrainMapPosition; });




//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_1__core_utils_math__["a" /* math */];


var ControlModeMapObserver = function(browser) {
    this.browser = browser;
    this.config = browser.config;
    
    this.coordsDeltas = [];
    this.orientationDeltas = [];
    this.viewExtentDeltas = [];
    this.northResetAnimation = false;

    this['drag'] = this.drag;
    this['wheel'] = this.wheel;
    this['tick'] = this.tick;
    this['reset'] = this.reset;
    this['keyup'] = this.keyup;
    this['keydown'] = this.keydown;
    this['keypress'] = this.keypress;
    this['doubleclick'] = this.doubleclick;
    
    this.retinaFactor = 1.0 / Math.max(1.0,(window.devicePixelRatio || 1) - 1);
};


ControlModeMapObserver.prototype.drag = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var pos = map.getPosition();
    var coords = pos.getCoords();
    var delta = event.getDragDelta();
    //var zoom = event.getDragZoom(); 
    var touches = event.getDragTouches(); 
    var azimuthDistance = this.getAzimuthAndDistance(delta[0], delta[1]);
    var sensitivity, config = this.config;
    
    var modifierKey = (this.browser.controlMode.altKey
               || this.browser.controlMode.shiftKey
               || this.browser.controlMode.ctrlKey);

    //event.getTouchParameter("touchMode");


    if (touches == 2) {//} && /*event.getDragButton("middle")*/ zoom != 0 && this.config.zoomAllowed) {
        if (pos.getViewMode() != 'obj') {
            return;
        }
        
        if (event.getTouchParameter('touchMode') == 'pan' && config.rotationAllowed) {

            sensitivity = config.sensitivity[1] * this.retinaFactor;
            this.orientationDeltas.push([delta[0] * sensitivity,  -delta[1] * sensitivity, 0]);
            this.browser.callListener('map-position-rotated', {});

        } else if (event.getTouchParameter('touchMode') == 'zoom' && config.zoomAllowed) {

            var delta = event.getTouchParameter('touchDistanceDelta');

            if (Math.abs(delta) >= 1) {

                var factor = 1.0 + (delta > 0 ? -1 : 1)*0.01;
                this.viewExtentDeltas.push(factor);
                this.reduceFloatingHeight(0.8);
                
                if (config.legacyInertia) {
                    this.updateDeltas(false, false, true);
                }

                this.browser.callListener('map-position-zoomed', {});
            }
        }
        
    } else if ((event.getDragButton('left') && !modifierKey) && config.panAllowed) { //pan
            
        if (pos.getHeightMode() == 'fix') {
            var pos2 = map.convertPositionHeightMode(pos, 'float', true);
            if (pos2 != null) {
                pos = pos2;
                this.setPosition(pos);
            }
        } else {
            sensitivity = config.sensitivity[0] * this.retinaFactor;
            var fov = pos.getFov();
            var fovCorrection = (fov > 0.01 && fov < 179) ? (1.0 / Math.tan(math.radians(fov*0.5))) : 1.0;
            var azimuth = math.radians(azimuthDistance[0]);
            var forward = [Math.sin(azimuth), //direction vector x
                Math.cos(azimuth), //direction vector y
                azimuthDistance[1] * fovCorrection * sensitivity, azimuthDistance[0], //distance and azimut
                coords[0], coords[1]]; //coords
            
            this.coordsDeltas.push(forward);
            this.reduceFloatingHeight(0.9);

            if (config.legacyInertia) {
                this.updateDeltas(true);
            }

            this.browser.callListener('map-position-panned', {});
        }
    } else if (((touches <= 1 && event.getDragButton('right')) || event.getDragButton('middle') || modifierKey)  && config.rotationAllowed) { //rotate
                   
        sensitivity = config.sensitivity[1] * this.retinaFactor * (pos.getViewMode() != 'obj' ? 0.5 : 1);
        this.orientationDeltas.push([delta[0] * sensitivity, -delta[1] * sensitivity, 0]);

        if (config.legacyInertia) {
            this.updateDeltas(false, true);
        }

        this.browser.callListener('map-position-rotated', {});
    }
};


ControlModeMapObserver.prototype.wheel = function(event) {
    dom.preventDefault(event);    

    var map = this.browser.getMap();
    if (!map || !this.config.zoomAllowed) { 
        return;
    }

    if (map.getStats(true)['maxZoom']) {
        this.browser.config.minViewExtent = 0.5;
    }

    var pos = map.getPosition();
    var delta = event.getWheelDelta();
    var sensitivity = this.config.sensitivity[2];
    var factor = 1.0 + (delta > 0 ? -1 : 1)*sensitivity;

    if (this.browser.controlMode.altKey &&
        this.browser.controlMode.shiftKey &&
        this.browser.controlMode.ctrlKey) {
        var fov = math.clamp(pos.getFov() * factor, 1, 179);
        pos.setFov(fov);
        map.setPosition(pos);
    } else {
        if (pos.getViewMode() != 'obj') {
            var coords = pos.getCoords();

            var cameraInfo = map.getCameraInfo();
            var vector = cameraInfo.vector;
            var height = cameraInfo.height;
            var speed = Math.max(100, height) * (this.browser.controlMode.shiftKey ? 0.00025 : 0.0025) * (delta > 0 ? 1 : -1);

            coords = map.convertCoordsFromNavToPhys(coords, 'float');

            coords[0] += vector[0] * speed;
            coords[1] += vector[1] * speed;
            coords[2] += vector[2] * speed;

            coords = map.convertCoordsFromPhysToNav(coords, 'float');

            pos.setCoords(coords);
            map.setPosition(pos);
            return;
        }
       
        this.viewExtentDeltas.push(factor);
        this.reduceFloatingHeight(0.8);
        this.browser.callListener('map-position-zoomed', {});
    }
};


ControlModeMapObserver.prototype.doubleclick = function(event) {
    dom.preventDefault(event);    

    var map = this.browser.getMap();
    if (!map || !this.config.jumpAllowed) {
        return;
    }

    if (this.browser.controlMode.altKey &&
        this.browser.controlMode.shiftKey &&
        this.browser.controlMode.ctrlKey) {
        this.browser.config.minViewExtent = 0.5;        
        return;            
    }

    var coords = event.getMouseCoords();
    var canvasSize = this.browser.getRenderer().getCanvasSize();

    if (coords[0] < 0 || coords[1] < 0 || coords[0] >= canvasSize[0] || coords[1] >= canvasSize[1]) {
        return;
    }

    //get hit coords with fixed height
    var mapCoords = map.getHitCoords(coords[0], coords[1], 'fix');
    
    if (mapCoords) {
        var pos = map.getPosition();
        pos.setCoords(mapCoords);
        pos = map.convertPositionHeightMode(pos, 'fix');
        pos.setHeight(mapCoords[2]);
        //pos = map.convertPositionHeightMode(pos, "fix");
        //pos.setPositionHeight(0);
        
        this.browser.autopilot.flyTo(pos, {'mode' : 'direct', 'maxDuration' : 2000 });
    }
};


ControlModeMapObserver.prototype.keyup = function() {
};


ControlModeMapObserver.prototype.keydown = function() {
};


ControlModeMapObserver.prototype.keypress = function() {
};


ControlModeMapObserver.prototype.setPosition = function(pos) {
    pos = constrainMapPosition(this.browser, pos);
    var map = this.browser.getMap();
    map.setPosition(pos);
    //console.log(JSON.stringify(pos));
};


ControlModeMapObserver.prototype.reduceFloatingHeight = function(factor) {
    var map = this.browser.getMap();
    var pos = map.getPosition();
    var coords = pos.getCoords();
    
    if (pos.getHeightMode() == 'float' &&
        pos.getViewMode() == 'obj') {
        if (coords[2] != 0) {
            coords[2] *= factor;

            if (Math.abs(coords[2]) < 0.1) {
                coords[2] = 0;
            }

            pos.setCoords(coords);
            this.setPosition(pos);
        }
    }
};


ControlModeMapObserver.prototype.isNavigationSRSProjected = function() {
    var map = this.browser.getMap();
    var rf = map.getReferenceFrame();
    var srs = map.getSrsInfo(rf['navigationSrs']);
    return (srs) ? (srs['type'] == 'projected') : false; 
};


ControlModeMapObserver.prototype.getAzimuthAndDistance = function(dx, dy) {
    var map = this.browser.getMap();
    var pos = map.getPosition();
    var viewExtent = pos.getViewExtent();
    var fov = pos.getFov()*0.5;

    //var sensitivity = 0.5;
    var zoomFactor = (((viewExtent*0.5) * Math.tan(math.radians(fov))) / 800);
    dx *= zoomFactor;
    dy *= zoomFactor;

    var distance = Math.sqrt(dx*dx + dy*dy);    
    var azimuth = -math.degrees(Math.atan2(dx, dy)) + pos.getOrientation()[0]; 
    
    return [azimuth, distance];
};


ControlModeMapObserver.prototype.updateDeltas = function(onlyLastPan, onlyLastRotate, onlyLastZoom) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var pos = map.getPosition(), delta, deltas;
    var update = false, azimuth, correction, i;
    var inertia = this.config.inertia, stats = map.getStats();
    var timeFactor = 1;
    var invTimeFactor = 1;

    if (this.config.timeNormalizedInertia) {
        var fps = (1000/(map.getStats()['frameTime'] + 0.000001));

        if (fps < 1) {
            fps = 60;
        }

        timeFactor = (fps/60);  //normalized to 60 fps
        invTimeFactor = 1.0/timeFactor;
    }

    //console.log(''+timeFactor);

    //process coords deltas
    if (!onlyLastRotate && !onlyLastZoom && this.coordsDeltas.length > 0) {
        deltas = this.coordsDeltas;
        var forward = [0,0];
        var coords = pos.getCoords();
        
        //get foward vector form coord deltas    
        for (i = (onlyLastPan ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            delta = deltas[i];

            azimuth = delta[3];
            azimuth = math.radians(azimuth);

            forward[0] += Math.sin(azimuth) * (delta[2] * invTimeFactor);  
            forward[1] += Math.cos(azimuth) * (delta[2] * invTimeFactor);

            delta[2] *= inertia[0] * timeFactor;

            //remove zero deltas
            if (delta[2] < 0.01) {
                deltas.splice(i, 1);
                i--;
            }
        }

        var distance = Math.sqrt(forward[0]*forward[0] + forward[1]*forward[1]);
        azimuth = math.degrees(Math.atan2(forward[0], forward[1]));
    
        if (!this.isNavigationSRSProjected()) {
            if (!this.northResetAnimation && this.config.navigationMode == 'azimuthal' && (Math.abs(coords[1]) > 75 || Math.abs(pos.getOrientation()[0]) > 1))  {
                this.config.navigationMode = 'azimuthal2';
            }
        }

        //apply final azimuth and distance
        correction = pos.getOrientation()[0];
        pos = map.movePositionCoordsTo(pos, (this.isNavigationSRSProjected() ? -1 : 1) * azimuth, distance,
                                            (!(this.config.navigationMode == 'free' || this.config.navigationMode == 'azimuthal2')) ? 0 : 1);
        correction = pos.getOrientation()[0] - correction;
        

        for (i = 0; i < deltas.length; i++) {
            delta = deltas[i];
            delta[3] += correction; 
        }

        update = true;
    }

    //process coords deltas
    if (!onlyLastPan && !onlyLastZoom && this.orientationDeltas.length > 0) {
        deltas = this.orientationDeltas;
        var orientation = pos.getOrientation();
        
        //apply detals to current orientation    
        for (i = (onlyLastRotate ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            delta = deltas[i];
            orientation[0] += delta[0] * invTimeFactor;  
            orientation[1] += delta[1] * invTimeFactor;
            orientation[2] += delta[2] * invTimeFactor;

            delta[0] *= inertia[1] * timeFactor;
            delta[1] *= inertia[1] * timeFactor;
            delta[2] *= inertia[1] * timeFactor;
            
            //remove zero deltas
            if (delta[0]*delta[0] + delta[1]*delta[1] + delta[2]*delta[2] < 0.1) {
                deltas.splice(i, 1);
                i--;
            }
        }

        //apply final orintation
        // HACK
        pos.setOrientation(orientation);
        update = true;
    }

    //process view extents deltas
    if (!onlyLastRotate && !onlyLastPan && this.viewExtentDeltas.length > 0) {
        deltas = this.viewExtentDeltas;
        var viewExtent = pos.getViewExtent();
        
        //apply detals to current view extent    
        for (i = (onlyLastZoom ? (deltas.length - 1) : 0); i < deltas.length; i++) {
            //viewExtent *= deltas[i];
            viewExtent *= Math.pow(deltas[i], invTimeFactor);
            deltas[i] += (1 - deltas[i]) * (1.0 - (inertia[2] * timeFactor));
            
            //deltas[i] *= Math.pow(deltas[i], Math.pow(inertia[2], timeFactor));

            //remove zero deltas
            if (Math.abs(1 - deltas[i]) < 0.001) {
                deltas.splice(i, 1);
                i--;
            }
        }
        
        viewExtent = Math.max(1, viewExtent);

        //apply final view extrent
        pos.setViewExtent(viewExtent);
        update = true;
    }

    //set new position
    if (update) {
        this.setPosition(pos);    
    }
};

ControlModeMapObserver.prototype.tick = function() {
    this.updateDeltas();
};


ControlModeMapObserver.prototype.reset = function() {
    this.coordsDeltas = [];
    this.orientationDeltas = [];
    this.viewExtentDeltas = [];
};


function constrainMapPosition(browser, pos) {
    if (!browser.config.constrainCamera) {
        return pos;
    }

    var minVE = browser.config.minViewExtent;
    var maxVE = browser.config.maxViewExtent;

    var map = browser.getMap(), o;

    //clamp view extets
    var viewExtent = math.clamp(pos.getViewExtent(), minVE, maxVE); 
    pos.setViewExtent(viewExtent);

    var distance = (viewExtent*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
    //var hmaxOffset = 0;

    //reduce tilt when you are far off the planet
    if (pos.getViewMode() == 'obj') {
        var rf = map.getReferenceFrame();
        var srs = map.getSrsInfo(rf['navigationSrs']);
        
        if (srs['a']) {

            var a1 = Math.asin(srs['a'] / (distance + srs['a'])); //get angle to horion
            //console.log('a1: ' + math.degrees(a1));

            var factor = Math.tan(math.radians(pos.getFov()*0.5)) / Math.tan(a1);
            //var viewFactor = factor;

            //console.log('factor: ' + factor);

            var threshold = browser.config.tiltConstrainThreshold;
            var thresholdMin = threshold[0];// * 0.5;
            var thresholdMax = threshold[1];// * 0.5;
            var maxTilt, minTilt = -90; 

            if (!(thresholdMin > thresholdMax || thresholdMin == thresholdMax)) {
                factor = math.clamp(factor, thresholdMin, thresholdMax);
                factor = ((factor - thresholdMin) / (thresholdMax - thresholdMin));
                maxTilt = 20 + ((-90) - 20) * (factor); 
            } else {
                maxTilt = 20; 
            }

            //console.log('maxTilt: ' + maxTilt);

            o = pos.getOrientation();
            o[1] = math.clamp(o[1], minTilt, maxTilt);
    
            pos.setOrientation(o);
        }

        //do not allow camera under terrain
        var camPos = map.getPositionCameraCoords(pos, 'float');
        //var cameraConstrainDistance = 1;
        var cameraConstrainDistance = (minVE*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
        cameraConstrainDistance *= 0.5; //divice by 2 to alow 45deg tilt in maximum zoom
        
        //var hmax = Math.max(Math.min(4000,cameraConstrainDistance), (distance * Math.tan(math.radians(3.0))));
        //var hmax = Math.max(Math.min(4000,cameraConstrainDistance), (distance * Math.tan(math.radians(3.0))));
        var hmax = Math.max(cameraConstrainDistance, (distance * Math.tan(math.radians(3.0))));

        var cameraHeight = camPos[2]; //this.cameraHeight() - this.cameraHeightOffset - this.cameraHeightOffset2;

        if (cameraHeight < hmax) {
            o = pos.getOrientation();

            var getFinalOrientation = (function(start, end, level) {
                var value = (start + end) * 0.5;

                if (level > 20) {
                    return value;
                } else {
                    o[1] = value;
                    pos.setOrientation(o);

                    if (map.getPositionCameraCoords(pos, 'float')[2] < hmax) {
                        return getFinalOrientation(start, value, level+1);
                    } else {
                        return getFinalOrientation(value, end, level+1);
                    }
                }

            });//.bind(this);

            o[1] = getFinalOrientation(-90, Math.min(20, o[1]), 0);
            pos.setOrientation(o);
        }
    }

    return pos;
}





/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_utils_matrix__ = __webpack_require__(1);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UIControlMeasure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return UIControlMeasureIcon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return UIControlMeasureIcon2; });





//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */],
    utils = __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__["a" /* utils */],
    vec3 = __WEBPACK_IMPORTED_MODULE_2__core_utils_matrix__["b" /* vec3 */],
    UIControlMeasureIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2lpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkNjI1MjFjMi1mYzE5LTcyNDUtOTI5My1kNTU3MmE5N2E1MjgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODJGRUI2NzE2NzkwMTFFN0EzRUZFNzQ1NEFCMkVFQUQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODJGRUI2NzA2NzkwMTFFN0EzRUZFNzQ1NEFCMkVFQUQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRBMjkwN0JENjc4QzExRTc5QTQwRjk4NjQzOEI4RDczIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRBMjkwN0JFNjc4QzExRTc5QTQwRjk4NjQzOEI4RDczIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+k3ySjQAAAdJJREFUeNrclk0oBGEYgHemjZOLm8tSyt9BqT2I1O7JSdSSkpsDxZGLi5MTjn5K4SDh4OfiaPfkIDebOPiPUqKUiLKet96pzzT7MztxMPX0le+b95n3Z2ZZmUwm9NuXHfqLK1smsVhsED5hKkhswc4mYJmHVxgNIvIslyE4hnLYDSqycwiaoCGVSnUFFdk5BH2wKHtBRbYKqlVwbQhGoNU5GETkZHKpggjMqaBFhaGgIltv/mKphRuQss1oZkPuG4oRWTLHlmU5fSlhOYNKSEK7xIUugj+6hmSHpROm2RvL9Q7arqf80IykdDEdgll4IWi/Bm+ECT8Z2R7l+DBKV6N/PoRnEbBuwIKf0nm+8S7RGuzDLaxLMuw/5OuR+bn60ROPt9/pUUQnUEa6A56SyeSWeTYejzs9GkC8ZIpySjxEy1APbdCM6MAlGmeZdIahYIlLVAU9kIA7KZFxrJrA5+bU8RBjBf+eGD26gk0oI4AItiU4dMOqHh+GTylbQT3JU7oj2IMLmNBJrIATKIUoD5L2LfEQJbRPvXAP0iPZj5J92vNl9Fk6mSCZsBV4dwuyflb8XJrRqX6C3iDsFhSdiXOzZlSnwxD2yuBHJv/iX6JvAQYAPSICqA82OnoAAAAASUVORK5CYII=',
    UIControlMeasureIcon2 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2Nzg3NzczMzY3OEMxMUU3QjU2QUUxNTNCNzc4MzVBQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2Nzg3NzczNDY3OEMxMUU3QjU2QUUxNTNCNzc4MzVBQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY3ODc3NzMxNjc4QzExRTdCNTZBRTE1M0I3NzgzNUFCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjY3ODc3NzMyNjc4QzExRTdCNTZBRTE1M0I3NzgzNUFCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+owD8TQAAAepJREFUeNrcls8rBGEYx993lIMfxR4kF/+AKMqBg7K1ajelLEWK025tKOTnjVykuAklNgcHuzmQg4MiTtz4Aza3TeGActDr+45nZt41s7tmBwdbn2l35933M9/3eead5UII9tsvjf3FK2uSiGgBKdDtZW6JllXA2DG4A3teRM7LZQl2QRuY9irScghGQRXb5KteRVoOQSMY0895FGkk8JHgSBH0gllzpAeRkeSRBAEwQIIZUJMxukARly3GOZdpivA5DnpAM2iQ5zFx3KE55DIugT6cT+a7PTTlKt9xHAT74AzU6vWJiEVQ4iWR9uXHhkgu3QhYB/JK3zBZE6WoBkE3Ivt9YolOQBd9uwJedQFjC+A8XyJ1J3G+4zNFV+CCmmMejINnY8sQG0wVzZnFlnW2Fd55ezGaIUAtPgzqwAsmv8mYMCLW8DaqdyY1g73w+RMFQRh0glse1RtDHRvDcdJp6XInsScKU3u3gnukSfCoOcoH0YPa3jif/P7zxEqUoPqUkWBZ398YqwdTNHqLdu+YuyTONToEl+AaTIAhUE61qwTtuJC0e4klkssQAn7QTy3+BA5AhRQgfdoovHvJp6iYli5EdTqlBKZA7a7CJFaiHdABUqBUFfyMxBJt06PBrwpskn/xl+hDgAEAH0j0b9rsgVUAAAAASUVORK5CYII=';


var UIControlMeasure = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('measure',
      '<div id="vts-measure" class="vts-measure">'

        + '<img id="vts-measure-button"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon + '">'

        + '<img id="vts-measure-button2"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon2 + '">'

        + '<div id="vts-measure-text-holder" class="vts-measure-text-holder">'
            + '<div class="vts-measure-text-holder2">'
                + '<div class="vts-measure-text">'
                  + '<textarea id="vts-measure-text-input" rows="10" cols="67" wrap="hard"></textarea>'
                + '</div>'
                + '<div class="vts-measure-tools">'
                    + '<div id="vts-measure-position" class="vts-measure-tools-button">Position</div>'
                    + '<div id="vts-measure-length" class="vts-measure-tools-button">Length</div>'
                    + '<div id="vts-measure-track" class="vts-measure-tools-button">Track Length</div>'
                    + '<div id="vts-measure-area" class="vts-measure-tools-button">Area</div>'
                    + '<div id="vts-measure-volume" class="vts-measure-tools-button">Volume</div>'
                    + '<div id="vts-measure-clear" class="vts-measure-tools-button">Clear Log</div>'
                    + '<div id="vts-measure-metric" class="vts-measure-tools-button">Units: Meters</div>'
                + '</div>'
            + '</div>'
        + '</div>'

        + '<div id="vts-measure-info" class="vts-measure-info">'
        + '</div>'

        + '<div id="vts-measure-buttons" class="vts-measure-compute">'
            + '<div id="vts-measure-undo" class="vts-measure-tools-button">Undo</div>'
            + '<div id="vts-measure-compute" class="vts-measure-tools-button">Compute</div>'
        + '</div>'
        
     + ' </div>', visible, visibleLock);
     
    this.div = this.control.getElement('vts-measure');

    this.buttonOff = this.control.getElement('vts-measure-button');
    this.buttonOff.on('click', this.onSwitch.bind(this));
    this.buttonOff.on('dblclick', this.onDoNothing.bind(this));

    this.buttonOn = this.control.getElement('vts-measure-button2');
    this.buttonOn.on('click', this.onSwitch.bind(this));
    this.buttonOn.on('dblclick', this.onDoNothing.bind(this));

    this.info = this.control.getElement('vts-measure-info');
    this.compute = this.control.getElement('vts-measure-buttons');

    var computeButton = this.control.getElement('vts-measure-undo');
    computeButton.on('click', this.onCompute.bind(this, 0));
    computeButton.on('dblclick', this.onDoNothing.bind(this));
    computeButton = this.control.getElement('vts-measure-compute');
    computeButton.on('click', this.onCompute.bind(this, 1));
    computeButton.on('dblclick', this.onDoNothing.bind(this));

    var clearButton = this.control.getElement('vts-measure-clear');
    clearButton.on('click', this.onClear.bind(this));
    clearButton.on('dblclick', this.onDoNothing.bind(this));

    this.toolButtons = [];
    var toolButton = this.control.getElement('vts-measure-position');
    toolButton.on('click', this.onTool.bind(this, 0));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-length');
    toolButton.on('click', this.onTool.bind(this, 1));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-track');
    toolButton.on('click', this.onTool.bind(this, 2));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-area');
    toolButton.on('click', this.onTool.bind(this, 3));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-volume');
    toolButton.on('click', this.onTool.bind(this, 4));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    toolButton = this.control.getElement('vts-measure-metric');
    toolButton.on('click', this.onTool.bind(this, 5));
    toolButton.on('dblclick', this.onDoNothing.bind(this));
    this.toolButtons.push(toolButton);
    this.metricButton = toolButton;


    this.measuring = false;
    this.counter = 1;
    this.renderCounter = 1;
    this.lastCoords = null;
    this.navCoords = null;
    this.tool = 0;
    this.metric = true;
    this.mapUpdateDestructor = null;

    this.listPanel = this.control.getElement('vts-measure-text-holder');
    this.list = this.control.getElement('vts-measure-text-input');

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');
    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');
    }    

    this.onMouseMoveCall = this.onMouseMove.bind(this);
    this.onMouseLeaveCall = this.onMouseLeave.bind(this);
    this.onMouseClickCall = this.onMouseClick.bind(this);
    this.onMapUpdateCall = this.onMapUpdate.bind(this);

    this.update();
};


UIControlMeasure.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);    
};


UIControlMeasure.prototype.onMouseLeave = function(event) {
    this.info.setStyle('display', 'none');
};


UIControlMeasure.prototype.onMouseClick = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var mapElement = this.ui.getMapElement();
    var state = mapElement.getDraggingState();

    //if (state['dragging']) { //TODO: why does not work this parameter? Fix it once you have time
      //  return;
    //}
    var delta = state['absMoved'];

    if ((delta[0]+delta[1]) > 0) {
        return;
    }

    var coords = event.getMouseCoords();
    var clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    map.redraw();

    if (!clickCoords) {
        return;
    }

    var i, li, res, str;
    var space = '  ';

    for (i = 0, li = ('' + this.counter).length; i < li; i++) {
        space += ' ';
    }

    if (this.tool == 0) {
        this.navCoords = clickCoords;
        clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

        str = '------------------------------------------------------\n';
        str += '#' + this.counter + ' Position: ';
        str += '\n' + space + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        this.counter++;

    } else if (this.tool == 1) { 
        if (!this.navCoords || this.navCoords.length == 2) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ' Length: ';
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');
            
            str = space + 'p2: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
            str += '\n' + space + '------------------------';

            res = map.getDistance(this.lastCoords, clickCoords, false, true);
            str += '\n' +  space + 'great-circle distance: ' + this.getTextNumber(res[0]);
            str += '\n' + space + 'euclidean distance: ' + this.getTextNumber(res[2]);
            str += '\n' + space + 'elevation difference: ' + this.getTextNumber(clickCoords[2] - this.lastCoords[2]);
            str += '\n' + space + 'azimuth: ' + res[1].toFixed(2) + ' deg';

            this.counter++;
        }
    } else if (this.tool == 2) { 
        if (this.renderCounter != this.counter) {
            this.renderCounter = this.counter;
            this.onTool(2);
        }

        if (!this.navCoords) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');
            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ' Track Length: ';
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = space + 'p' + this.navCoords.length + ': ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        }
    } else if (this.tool == 3 || this.tool == 4) { 
        if (this.renderCounter != this.counter) {
            this.renderCounter = this.counter;
            this.onTool(this.tool);
        }

        if (!this.navCoords) {
            this.navCoords = [clickCoords];
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');
            str = '------------------------------------------------------\n';
            str += '#' + this.counter + ((this.tool == 3) ? ' Area: ' : ' Volume: ');
            str += '\n' + space + 'p1: ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        } else {
            this.navCoords.push(clickCoords);
            clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

            str = space + 'p' + this.navCoords.length + ': ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);
        }
    }

    this.lastCoords = clickCoords;

    if (str) {
        var listElement = this.list.getElement();
        listElement.value += str + '\n';
        listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
    }
};


UIControlMeasure.prototype.onMouseMove = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var coords = event.getMouseCoords();
    var clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        this.info.setStyle('display', 'none');
        return;    
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    var str = clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + this.getTextNumber(clickCoords[2]);

    coords[0] -= this.divRect.left;
    coords[1] -= this.divRect.top;

    this.info.setStyle('display', 'block');
    this.info.setStyle('left', (coords[0]+20)+'px');
    this.info.setStyle('top', (coords[1]+10)+'px');
    this.info.setHtml(str);
};


UIControlMeasure.prototype.onSwitch = function() {
    this.measuring = !this.measuring;

    var mapElement = this.ui.getMapElement();

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');

        this.divRect = this.div.getRect();

        mapElement.on('mousemove', this.onMouseMoveCall);
        mapElement.on('mouseleave', this.onMouseLeaveCall);
        mapElement.on('click', this.onMouseClickCall);
        this.mapUpdateDestructor = this.browser.on('map-update', this.onMapUpdateCall);

    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');

        mapElement.off('mousemove', this.onMouseMoveCall);
        mapElement.off('mouseleave', this.onMouseLeaveCall);
        mapElement.off('click', this.onMouseClickCall);
        
        if (this.mapUpdateDestructor) {
            this.mapUpdateDestructor();
        }
    }

    this.onTool(this.tool);

    this.compute.setStyle('display', 'none');

    var map = this.browser.getMap();
    if (map) {
        map.redraw();
    }

    this.update();
};


UIControlMeasure.prototype.onTool = function(tool) {
    if (tool == 5) {
        this.metric = !this.metric;
        this.metricButton.setHtml(this.metric ? 'Units: Meters' : 'Units: Feets');
        return;
    }

    this.tool = tool;
    this.navCoords = null;

    this.compute.setStyle('display', 'none');

    for (var i = 0; i < 5; i++) {
        this.toolButtons[i].setClass('vts-measure-tools-button');
    }

    this.toolButtons[tool].setClass('vts-measure-tools-button-selected');

    var map = this.browser.getMap();
    if (map) {
        map.redraw();
    }
};


UIControlMeasure.prototype.onCompute = function(button) {
    if (!this.navCoords) {
        return;
    }

    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var str, i, li, space;
    var listElement = this.list.getElement();

    if (button == 0) { //undo button
        this.navCoords.pop();
    } else { //compute button
        if (this.tool == 2) {

            var distance = 0;
            var distance2 = 0, coords, coords2, res;
            var emin = Number.POSITIVE_INFINITY;
            var emax = Number.NEGATIVE_INFINITY;

            space = '  ';

            for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                space += ' ';
            }

            str = space + '------------------------';

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPublic(this.navCoords[i], 'fix');

                if (coords[2] > emax) {
                    emax = coords[2];
                }

                if (coords[2] < emin) {
                    emin = coords[2];
                }
            }

            for (i = 0, li = this.navCoords.length - 1; i < li; i++) {
                coords = map.convertCoordsFromNavToPublic(this.navCoords[i], 'fix');
                coords2 = map.convertCoordsFromNavToPublic(this.navCoords[i+1], 'fix');
                res = map.getDistance(coords, coords2, false, true);
                distance += res[0];
                distance2 += res[2];
            }

            str += '\n' +  space + 'great-circle distance: ' + this.getTextNumber(distance);
            str += '\n' + space + 'euclidean distance: ' + this.getTextNumber(distance2);
            str += '\n' + space + 'max elevation: ' + this.getTextNumber(emax);
            str += '\n' + space + 'min elevation: ' + this.getTextNumber(emin);
            str += '\n' + space + 'elevation difference: ' + this.getTextNumber(emax - emin);

            this.counter++;
        }

        if (this.tool == 3) {
            console.log(JSON.stringify(this.navCoords));

            var geodata = map.createGeodata();
            geodata.addPolygon3(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            geodata.processHeights('node-by-lod', 62, (function(){

                space = '  ';

                for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                    space += ' ';
                }

                str = space + '------------------------';

                var poly = geodata.extractGeometry('tmp-polygon');

                var area = poly.getSurfaceArea()

                if (this.metric) {
                    str += '\n' +  space + 'area: ' + area.toFixed(2) + ' m\u00B2';

                    if (area > 100) {
                        str += '\n' +  space + '      ' + (area/100).toFixed(2) + ' ares';
                    }

                    if (area > 10000) {
                        str += '\n' +  space + '      ' + (area/10000).toFixed(2) + ' hectares';
                    }

                    if (area > 1000000) {
                        str += '\n' +  space + '      ' + (area/1000000).toFixed(2) + ' km\u00B2';
                    }
                } else {
                    //str += '\n' +  space + 'area: ' + (area / 0.09290304).toFixed(2) + ' ft';
                    str += '\n' +  space + 'area: ' + (area / 0.83612736).toFixed(2) + ' yd\u00B2';

                    if ((area / 4046.8564224) >= 1) {
                        str += '\n' +  space + '      ' + (area / 4046.8564224).toFixed(2) + ' acres';
                    }
                    
                    if ((area / 2589988.110346) >= 1) {
                        str += '\n' +  space + '      ' + (area / 2589988.110346).toFixed(2) + ' mi\u00B2';
                    }
                }

                this.counter++;

            }).bind(this));
        }

        if (this.tool == 4) {

            var center = [0,0,0];

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPhys(this.navCoords[i], 'fix');
                center[0] += coords[0];
                center[1] += coords[1];
                center[2] += coords[2];
            }

            center[0] /= li;
            center[1] /= li;
            center[2] /= li;

            var radius = 0, dx, dy, dz, distance;

            for (i = 0, li = this.navCoords.length; i < li; i++) {
                coords = map.convertCoordsFromNavToPhys(this.navCoords[i], 'fix');
                dx = (center[0] - coords[0]);
                dy = (center[1] - coords[1]);
                dz = (center[2] - coords[2]);
                distance = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (distance > radius) {
                    radius = distance;
                }
            }

            var geodata = map.createGeodata();

            if (radius > 30000) {
                geodata.addPolygon3(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            } else {
                geodata.addPolygon(this.navCoords, [], null, 'fix', {}, 'tmp-polygon');
            }

            geodata.processHeights('node-by-lod', 62, (function(){

            if (this.navCoords.length) {

                space = '  ';

                for (i = 0, li = ('' + this.counter).length; i < li; i++) {
                    space += ' ';
                }

                str = space + '------------------------';

                var poly = geodata.extractGeometry('tmp-polygon');

                var faces = new Array(poly.getElements());

                for (i = 0, li = faces.length; i < li; i++) {
                    faces[i] = poly.getElement(i);
                }

                var renderer = this.browser.getRenderer();
                var x, y, north, east;

                coords = map.convertCoordsFromPhysToNav(center, 'fix');

                var texelSize = radius * 0.0030; //0.15 texel size for 100m diameter 
                var core = this.browser.getCore();

                var traceVolumeCall = (function(terrain){

                    str = listElement.value;
                    str = str.substr(0, str.lastIndexOf('loading data ...'));
                    str += 'computation progress: 0%';

                    if (!terrain) {
                        str += '\n some error ocurred. Try it again.';
                        return;
                    }

                    var octree = renderer.buildOctreeFromGeometry(terrain);

                    var ned = map.getNED(coords, false);
                    north = ned.direction;
                    east = ned.east;

                    var steps = 25, l, sx, sy, res2, dir = [0,0,0], delta;
                    var sampleArea = (1.0 / steps) * radius;
                    var volumeAbove = 0;
                    var volumeBelow = 0;

                    sampleArea *= sampleArea;

                    var y = -steps;

                    var traceVolumeLine = (function(){

                        for (x = -steps; x <= steps; x++) {

                            sx = (1.0 / steps) * x * radius;
                            sy = (1.0 / steps) * y * radius;
                            coords[0] = center[0] * 1.0001 + north[0] * sy + east[0] * sx;
                            coords[1] = center[1] * 1.0001 + north[1] * sy + east[1] * sx;
                            coords[2] = center[2] * 1.0001 + north[2] * sy + east[2] * sx;

                            vec3.normalize(coords, dir); // TODO: add support for projected systems
                            dir[0] = -dir[0];
                            dir[1] = -dir[1];
                            dir[2] = -dir[2];

                            res = this.hitFaces(coords, dir, faces);

                            if (res[0]) {
                                res2 = renderer.raycastOctreeGeometry(octree, coords, dir);

                                if (res2.length > 0) {
                                    delta = (res[1] - res2[0]) * sampleArea;

                                    if (delta >= 0) {
                                        volumeAbove += delta;
                                    } else {
                                        volumeBelow += -delta;
                                    }

                                    ///console.log("T" + JSON.stringify(res2));
                                }
                            }
                        }

                        if (y < steps) {
                            str = str.substr(0, str.lastIndexOf('computation progress:'));
                            str += 'computation progress: ' + (((y + steps) / (steps*2))*100).toFixed(1) + ' %';
                        } else {
                            str = str.substr(0, str.lastIndexOf('computation progress:'));
                            
                            if (this.metric) {
                                str += 'volume above: ' + volumeAbove.toFixed(2) + ' m\u00B3';
                                str += '\n' +  space + 'volume below: ' + volumeBelow.toFixed(2) + ' m\u00B3';
                                str += '\n' +  space + 'volume combined: ' + (volumeAbove + volumeBelow).toFixed(2) + ' m\u00B3' + '\n';
                            } else {
                                var yd2m = 0.764554857984;
                                str += 'volume above: ' + (volumeAbove/yd2m).toFixed(2) + ' yd\u00B3';
                                str += '\n' +  space + 'volume below: ' + (volumeBelow/yd2m).toFixed(2) + ' yd\u00B3';
                                str += '\n' +  space + 'volume combined: ' + ((volumeAbove + volumeBelow)/yd2m).toFixed(2) + ' yd\u00B3' + '\n';
                            }
                        }

                        if (str) {
                            listElement.value = str;
                            listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
                        }

                        if (y < steps) {
                            core.once('tick', traceVolumeLine, 1);
                        }

                        y++;

                       //console.log("*");
                    }).bind(this);

                    core.once('tick', traceVolumeLine, 1);

                }).bind(this);

                str += '\n' +  space + 'loading data ...';
                listElement.value += str;
                listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
                str = null;

                var destructor = map.getSurfaceAreaGeometry(coords, radius, 'texelSize', texelSize, traceVolumeCall, false);

            }

            }).bind(this));

            this.counter++;
        }
    }

    if (str) {
        listElement.value += str + '\n';
        listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
    }

    map.redraw();
};

UIControlMeasure.prototype.hitFace = function(origin, dir, face) {
    var EPSILON = 0.0000001; 
    var v1 = face[0];
    var v2 = face[1];  
    var v3 = face[2];

    var h = [0,0,0], q = [0,0,0], s;
    var a,f,u,v;
    var edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
    var edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];

    vec3.cross(dir, edge2, h);
    a = vec3.dot(edge1, h);

    if (a > -EPSILON && a < EPSILON) {
        return [false];
    }

    f = 1/a;
    s = [origin[0] - v1[0], origin[1] - v1[1], origin[2] - v1[2]];
    u = f * (vec3.dot(s, h));

    if (u < 0.0 || u > 1.0) {
        return [false];
    }

    q = vec3.cross(s, edge1);
    v = f * vec3.dot(dir, q);
    if (v < 0.0 || u + v > 1.0) {
        return [false];
    }

    // At this stage we can compute t to find out where the intersection point is on the line.
    var t = f * vec3.dot(edge2, q);
    //if (t > EPSILON) { // ray intersection
        return [true, t]; //[origin[0] + dir[0] * t, origin[1] + dir[1] * t, origin[2] + dir[2] * t ]];
    //} else { // This means that there is a line intersection but not a ray intersection.
     //   return [false];
    //}
};


UIControlMeasure.prototype.hitFaces = function(coords, dir, faces) {
    var hit = false, t = Number.POSITIVE_INFINITY;

    for (var i = 0, li = faces.length; i < li; i++) {
        var res = this.hitFace(coords, dir, faces[i]);

        if (res[0]) {
            hit = true;
            
            if (res[1] < t) {
                t = res[1];
            }
        }
    }

    //console.log(hit ? ("" + t.toFixed(2)) : ("N"));
    return [hit, t];
};


UIControlMeasure.prototype.onClear = function() {
    this.counter = 1;
    this.lastCoords = null;
    this.navCoords = null;

    var listElement = this.list.getElement();
    listElement.value = '';
    listElement.scrollTop = 0;

    this.compute.setStyle('display', 'none');

    var map = this.browser.getMap();
    if (map) {
        map.redraw();
    }
};


UIControlMeasure.prototype.update = function() {
    //var button = this.control.getElement('vts-measure-button');
    
    var left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                (this.ui.config.controlSpace ? 35 : 0);
    
    this.div.setStyle('left', left + 'px');
    this.listPanel.setStyle('display', this.measuring ? 'block' : 'none');
};


UIControlMeasure.prototype.onMapUpdate = function() {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var renderer = this.browser.getRenderer();

    if (!this.circleImage) {
        this.circleImage = utils.loadImage(
                'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QAAAAAAAD5Q7t/AAAACW9GRnMAAAAgAAAA4ACD+EAUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/UlEQVRYw+2VPwqDMBTG3dz1Am56EnH2XLroETxGuwc3Z7cOdhY8QJpfSUBspUvStJAPPggvD973/uQligICAgL+DKViqygUV02hbaXLwJlio7gpyhNu2idzEXwwgfI8H+u6vnZdN/V9P3EuimLcCRlsiyArGcfxjWDLsmzyAGzc4aNFNDZ7/iw7AeQH4LNrh5WZYLgkJTaZCyHuVVVdkiSZ0zSdOWMzlaBFWkRrQ4A4Zk/A4wBie1MFYUMAz0wybCYAmR8FUAlzj6+2r18TgM2VAO8tOB1Cyk7mrofQ+zP0voheVjHtIBjDxjrmvCu7k1Xs/TP6ie84ICDAGR5uCYdPo0MWiAAAAABJRU5ErkJggg==',
                //"http://maps.google.com/mapfiles/kml/shapes/placemarkcircle.png",
                (function(){
                    this.circleTexture = renderer.createTexture({ 'source': this.circleImage });
                }).bind(this)
            );
    }

    if (!this.circleTexture) {
        return;
    }

    var i, li, coords, points, wpoints;

    switch(this.tool) {
        case 0: //point

            if (this.navCoords) {
                coords = map.convertCoordsFromNavToCanvas(this.navCoords, "fix");

                if (coords[2] <= 1) {
                    renderer.drawImage({
                        rect : [coords[0]-12, coords[1]-12, 24, 24],
                        texture : this.circleTexture,
                        color : [255,0,0,255],  //white point is multiplied by red color so resulting point will be red
                        depth : coords[2],
                        depthTest : false,
                        blend : true   //point texture has alpha channel so blend is needed
                        });
                }
            }

            break;

        case 1: //line
        case 2: //track
        case 3: //area
        case 4: //volume

            if (this.navCoords) {
                points = [];

                for (i = 0, li = this.navCoords.length; i < li; i++) {
                    points.push(map.convertCoordsFromNavToCanvas(this.navCoords[i], "fix"));
                }

                if (li > 1) {

                    var points2 = [], points3 = [], tmp;

                    for (i = 0, li = this.navCoords.length - 1; i < li; i++) {
                        tmp = map.getGeodesicLinePoints(this.navCoords[i], this.navCoords[i+1]);
                        points2 = points2.concat(tmp);
                    }

                    if (this.tool == 3 || this.tool == 4) {
                        tmp = map.getGeodesicLinePoints(this.navCoords[li], this.navCoords[0]);
                        points2 = points2.concat(tmp);
                    }

                    for (i = 0, li = points2.length; i < li; i++) {
                        points3.push(map.convertCoordsFromNavToPhys(points2[i], "fix", null, true));
                    }

                    renderer.drawLineString({
                        points : points3,
                        size : 5.0,
                        color : [0,0,0,255],
                        depthTest : false,
                        //depthTest : true,
                        //depthOffset : [-0.01,0,0],
                        screenSpace : false,
                        blend : false
                        });

                    renderer.drawLineString({
                        points : points3,
                        size : 2.0,
                        color : [255,0,0,255],
                        depthTest : false,
                        //depthTest : true,
                        //depthOffset : [-0.01,0,0],
                        screenSpace : false,
                        blend : false
                        });
                }

                for (i = 0, li = points.length; i < li; i++) {
                    coords = points[i];

                    if (coords[2] <= 1) {
                        renderer.drawImage({
                            rect : [coords[0]-12, coords[1]-12, 24, 24],
                            texture : this.circleTexture,
                            color : [255,0,0,255],  //white point is multiplied by red color so resulting point will be red
                            depth : coords[2],
                            depthTest : false,
                            blend : true   //point texture has alpha channel so blend is needed
                            });
                    }
                }
            }


    }


    if ((this.tool == 2 || this.tool == 3 || this.tool == 4) && points) {
        if (points.length < 2 || this.renderCounter != this.counter) {
            this.compute.setStyle('display', 'none');
            return;    
        }

        coords = points[points.length - 1];
        coords[0] -= this.divRect.left;
        coords[1] -= this.divRect.top;

        this.compute.setStyle('display', 'block');
        this.compute.setStyle('left', (coords[0]+20)+'px');
        this.compute.setStyle('top', (coords[1]+10)+'px');
    }

};

UIControlMeasure.prototype.getTextNumber = function(value) {
    var m2ft = 3.28084, km2mi = 0.621371;

    if (value >= 100000) {
        return (this.metric) ? (value*0.001).toFixed(2) + 'km' : (value*0.001*km2mi).toFixed(2) + 'mi';
    } else {
        return (this.metric) ? (value).toFixed(2) + 'm' : (value*m2ft).toFixed(2) + 'ft';
    }
};





/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIEvent = function(type, element, event) {
    this.type = type;
    this.event = event;
    this.element = element;
};


UIEvent.prototype.getMouseButton = function() {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':

        var touches = this.event['touches'];
            
        if (touches) {
            switch(touches.length) {
            case 1: return 'left';
            case 2: return 'right';
            case 3: return 'middle';
            }
        }

        return '';   

    default:
    
        if (this.event.which) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
                //right = e.which == 3;
        
            switch(this.event.which) {
            case 1: return 'left';
            case 2: return 'middle';
            case 3: return 'right';
            }
        
        } else if (this.event.button) { // IE, Opera
                //right = e.button == 2;
        
            switch(this.event.button) {
            case 1: return 'left';
            case 2: return 'right';
            case 3: return 'middle';
            }
        }
    
    }

    return '';
};


UIEvent.prototype.getMouseCoords = function(absolute) {
    var pos = [0,0];

    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':

        var touches = this.event['touches'];
        if (!touches || touches.length == 0) {
            break;
        }
            
        for (var i = 0, li = touches.length; i < li; i++) {
            var pos2 = this.getEventCoords(this.event['touches'][i], absolute);
            pos[0] += pos2[0];   
            pos[1] += pos2[1];   
        }
            
        pos[0] /= li;
        pos[1] /= li;
        break;

    case 'mousedown':
    case 'mouseup':
    case 'mousemove':
    case 'mouseenter':
    case 'mouseover':
    case 'mouseleave':
    case 'click':
    case 'dblclick':
    case 'dragstart':
    case 'dragend':
    case 'drag':

        pos = this.getEventCoords(this.event, absolute);
        break;
    }

    return pos;
};


UIEvent.prototype.getEventCoords = function(event, absolute) {
//    if (this.element.getBoundingClientRect == null || absolute) {
    if (this.element.getPageRect == null || absolute) {
        return [ event['clientX'],
                 event['clientY'] ];
    } else {
        var rect = this.element.getPageRect();

        return [ event['pageX'] - rect.left,
                 event['pageY'] - rect.top ];
    }
};


UIEvent.prototype.getDragDelta = function() {
    switch (this.type) {
    case 'drag':

        return [ this.event['deltaX'],
                 this.event['deltaY'] ];
    }

    return [0,0];
};


UIEvent.prototype.getDragZoom = function() {
    switch (this.type) {
    case 'drag':
        return this.event['zoom'];
    }
    
    return 1.0;
};


UIEvent.prototype.getDragTouches = function() {
    switch (this.type) {
    case 'drag':
        return this.event['touches'];
    }
    
    return 0;
};


UIEvent.prototype.getModifierKey = function(key) {
    switch (this.type) {
    case 'mouseup':
    case 'mousedown':
    case 'dblclick':
    case 'keyup':
    case 'keydown':
    case 'keypress':

        switch(key) {
        case 'alt':   return this.event.altKey;
        case 'ctrl':  return this.event.ctrlKey;
        case 'shift': return this.event.shiftKey;
        }
    }

    return false;
};


UIEvent.prototype.getKeyCode = function() {
    switch (this.type) {
    case 'keyup':
    case 'keydown':
    case 'keypress':
        
        if (this.event.keyCode) {         // eg. IE
            return this.event.keyCode;
        } else if (this.event.which) {   // eg. Firefox
            return this.event.which;
        } else {
            return this.event.charCode;
        }
    }
    
    return null;
};


UIEvent.prototype.getDragButton = function(button) {
    switch(button) {
    case 'left': 
    case 'right':
    case 'middle':
            
        switch(this.getTouchesCount()) {
        case -1: return this.event[button];
        case 0: return false;
        case 1: return button == 'left';
        case 2: return button == 'right';
        case 3: return button == 'middle';
        }
        
    }

    return false;
};


UIEvent.prototype.getWheelDelta = function() {
    switch (this.type) {
    case 'mousewheel':

        var delta = 0;

        if (this.event.wheelDelta) {
            delta = this.event.wheelDelta / 120;
        }
        if (this.event.detail) {
            delta = -this.event.detail / 3;
        }

        return delta;
    }

    return 0;
};


UIEvent.prototype.getTouchesCount = function() {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':

        var touches = this.event['touches'];
        if (!touches) {
            break;
        }
            
        return this.event['touches'].length;    
    }
    
    return -1;
};


UIEvent.prototype.getTouchParameter = function(name) {
    switch (this.type) {
    case 'drag':
        return this.event[name];
    }
    
    return null;
};


UIEvent.prototype.getTouchCoords = function(index, absolute) {
    switch (this.type) {
    case 'touchstart':
    case 'touchend':
    case 'touchmove':

        var touches = this.event['touches'];
        if (!touches) {
            break;
        }
            
        var event = this.event['touches'][index];    
        if (!event) {
            break;
        }

        if (this.element.getPageRect == null || absolute) {
            return [ event['clientX'],
                     event['clientY'] ];
        } else {
            var rect = this.element.getPageRect();

            return [ event['pageX'] - rect.left,
                     event['pageY'] - rect.top ];
        }
    }

    return [0,0];
};


UIEvent.prototype.getType = function() {
    return this.type;
};


/* harmony default export */ __webpack_exports__["a"] = (UIEvent);




/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_browser_browser_css__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_browser_browser_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_browser_browser_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_browser_presenter_css_main_css__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_browser_presenter_css_main_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_browser_presenter_css_main_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_browser_presenter_css_panel_css__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_browser_presenter_css_panel_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_browser_presenter_css_panel_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_browser_presenter_css_subtitles_css__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_browser_presenter_css_subtitles_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_browser_presenter_css_subtitles_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__browser__ = __webpack_require__(179);

//css stuff








//get rid of compiler mess
var Browser = __WEBPACK_IMPORTED_MODULE_4__browser__["a" /* default */];


var BrowserInterface = function(element, config) {
    this.browser = new Browser(element, config);
    this.core = this.browser.getCore();
    this.killed = false;


    Object.defineProperty(this, 'map', {
        get: function() {
            if (this.killed) return;
            return this.core.map;
        }
    });

    Object.defineProperty(this, 'renderer', {
        get: function() {
            if (this.killed) return;
            return this.core.renderer;
        }
    });

    Object.defineProperty(this, 'autopilot', {
        get: function() {
            if (this.killed) return;
            return this.browser.autopilot;
        }
    });

    Object.defineProperty(this, 'presenter', {
        get: function() {
            if (this.killed) return;
            return this.browser.presenter;
        }
    });

    Object.defineProperty(this, 'ui', {
        get: function() {
            if (this.killed) return;
            return this.browser.ui;
        }
    });
};



BrowserInterface.prototype.destroy = function() {
    if (this.killed) return;
    this.core.destroy();
    this.browser.kill();
    this.killed = true;
    return null;    
};


BrowserInterface.prototype.setControlMode = function(mode) {
    if (this.killed) return;
    this.browser.setControlMode(mode);
    return this;    
};


BrowserInterface.prototype.getControlMode = function() {
    if (this.killed) return;
    return this.browser.getControlMode();
};


BrowserInterface.prototype.loadMap = function(path) {
    if (this.killed) return;
    this.core.loadMap(path);
    return this;    
};


BrowserInterface.prototype.destroyMap = function() {
    if (this.killed) return;
    this.core.destroyMap();
    this.map = null;
    return this;    
};


BrowserInterface.prototype.on = function(eventName, call) {
    if (this.killed) return;
    return this.core.on(eventName, call);
    //return this;    
};


BrowserInterface.prototype.setParams = function(params) {
    if (this.killed) return;
    this.setConfigParams(params,true);
    return this;
};


BrowserInterface.prototype.setParam = function(key, value) {
    if (this.killed) return;
    this.browser.setConfigParam(key, value, true);
    return this;
};


BrowserInterface.prototype.getParam = function(key) {
    if (this.killed) return;
    return this.browser.getConfigParam(key);
};


/* harmony default export */ __webpack_exports__["a"] = (BrowserInterface);


/***/ }),
/* 174 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 175 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 176 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 177 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var Autopilot = function(browser) {
    this.browser = browser;
    this.trajectory = [];
    this.flightDuration = 1;
    this.flightTime = 0;
    this.trajectoryIndex = 0;
    this.finished = true;
    this.autoMovement = false;
    this.autoRotate = 0;
    this.autoPan = 0;
    this.autoPanAzimuth = 0;

    this.center = [0,0,0];
    this.orientation = [0,0,0];
    this.viewHeight = 0;
    this.fov = 90;
    this.lastTime = 0;
};


Autopilot.prototype.setAutorotate = function(speed) {
    if (this.autoRotate != speed) {
        this.browser.callListener('autorotate-changed', { 'autorotate' : speed});
    }

    this.autoRotate = speed;
};


Autopilot.prototype.getAutorotate = function() {
    return this.autoRotate;
};


Autopilot.prototype.setAutopan = function(speed, azimuth) {
    this.autoPan = speed;
    this.autoPanAzimuth = azimuth;
};


Autopilot.prototype.getAutopan = function() {
    return [this.autoPan, this.autoPanAzimuth];
};

Autopilot.prototype.flyToDAH = function(distance, azimuth, height, options) {
    var map = this.browser.core.map;
    if (!map) {
        return;
    }
    
    options = options || {};
    
    var trajectory = map.generatePIHTrajectory(map.getPosition(), distance, azimuth, height, options);
    this.setTrajectory(trajectory, options['samplePeriod'] || 10, options); 
};


Autopilot.prototype.flyTo = function(position, options) {
    var map = this.browser.core.map;
    if (!map) {
        return;
    }
    
    options = options || {};
    var trajectory = map.generateTrajectory(map.getPosition(), position, options);
    this.setTrajectory(trajectory, options['samplePeriod'] || 10, options); 
};


Autopilot.prototype.flyTrajectory = function(trajectory, sampleDuration) {
    this.setTrajectory(trajectory, sampleDuration || 10, {});
};


Autopilot.prototype.cancelFlight = function() {
    this.browser.getControlMode().setCurrentControlMode(this.lastControlMode);
    this.finished = true;
};


Autopilot.prototype.setTrajectory = function(trajectory, sampleDuration, options) {
    if (trajectory == null || trajectory.length == 0) {
        return;
    }

    this.setAutorotate(0);
    this.setAutopan(0,0);

    this.speed = options['speed'] || 1.0;
    if (this.finished) {
        this.lastControlMode = this.browser.getControlMode().getCurrentControlMode(); 
    }
    this.browser.getControlMode().setCurrentControlMode('disabled');

    this.trajectory = trajectory;
    this.sampleDuration = sampleDuration;
    //this.
    
    this.browser.callListener('fly-start', { 'startPosition' : this.trajectory[0],
        'endPosition' : this.trajectory[this.trajectory.length - 1],
        'options' : options
    });
    
    this.timeStart = performance.now();
    this.finished = false;
};


Autopilot.prototype.tick = function() {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var time = performance.now(), pos;
    var timeFactor =  (time - this.lastTime) / 1000; 
    this.lastTime = time;

    if (this.browser.ui && this.browser.ui.loading &&
        this.browser.ui.loading.control.getVisible()) {
        return;
    }


    if (this.autoRotate != 0) {
        pos = map.getPosition();
        var o = pos.getOrientation();
        o[0] = (o[0] + this.autoRotate*timeFactor) % 360;
        pos.setOrientation(o);
        map.setPosition(pos);
    }
    
    if (this.autoPan != 0) {
        pos = map.getPosition();
        pos = map.movePositionCoordsTo(pos, this.autoPanAzimuth, pos.getViewExtent()*(this.autoPan*0.01)*timeFactor, 0);
        map.setPosition(pos);
    }

    if (this.finished || !this.trajectory) {
        return;
    }
    
    time = time - this.timeStart;
    var sampleIndex =  Math.floor((time / this.sampleDuration)*this.speed);
    var totalSamples = this.trajectory.length - 1; 

    if (sampleIndex < totalSamples) {
        //interpolate
        map.setPosition(this.trajectory[sampleIndex]);        
        //console.log(JSON.stringify(this.trajectory[sampleIndex]));

        this.browser.callListener('fly-progress', { 'position' : this.trajectory[sampleIndex],
            'progress' : 100 * (sampleIndex / totalSamples)
        });

    } else {
        map.setPosition(this.trajectory[totalSamples]);
        //console.log(JSON.stringify(this.trajectory[totalSamples]));
    } 
    
    if (sampleIndex >= this.trajectory.length) {
        this.browser.callListener('fly-end', { 'position' : this.trajectory[totalSamples] });

        this.browser.getControlMode().setCurrentControlMode(this.lastControlMode);
        this.finished = true;
    } 
};


Autopilot.prototype.generateTrajectory = function(p1, p2, options) {
    var map = this.browser.core.map;
    if (!map) {
        return;
    }
    
    options = options || {};
    return map.generateTrajectory(p1, p2, options);
};


Autopilot.prototype.generatePIHTrajectory = function(position, azimuth, distance, options) {
    var map = this.browser.core.map;
    if (!map) {
        return;
    }
    
    options = options || {};
    return map.generatePIHTrajectory(position, azimuth, distance, options);
};


/* harmony default export */ __webpack_exports__["a"] = (Autopilot);



/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_core__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_interface__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ui_ui__ = __webpack_require__(203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__autopilot_autopilot__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__control_mode_control_mode__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__presenter_presenter__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__rois_rois__ = __webpack_require__(185);










//get rid of compiler mess
var CoreInterface = __WEBPACK_IMPORTED_MODULE_1__core_interface__["a" /* CoreInterface */];
var utils = __WEBPACK_IMPORTED_MODULE_2__core_utils_utils__["a" /* utils */];
var UI = __WEBPACK_IMPORTED_MODULE_3__ui_ui__["a" /* default */];
var Autopilot = __WEBPACK_IMPORTED_MODULE_4__autopilot_autopilot__["a" /* default */];
var ControlMode = __WEBPACK_IMPORTED_MODULE_5__control_mode_control_mode__["a" /* default */];
var Presenter = __WEBPACK_IMPORTED_MODULE_6__presenter_presenter__["a" /* default */];
var Rois = __WEBPACK_IMPORTED_MODULE_7__rois_rois__["a" /* default */];
var checkSupport = __WEBPACK_IMPORTED_MODULE_0__core_core__["b" /* checkSupport */];


var Browser = function(element, config) {
    this.killed = false;
    this.configStorage = {};
    this.initConfig();
    this.setConfigParams(config, true);
    this.originalConfig = JSON.parse(JSON.stringify(config));
    
    this.element = (typeof element === 'string') ? document.getElementById(element) : element; 
    this.ui = new UI(this, this.element);

    element = (typeof element !== 'string') ? element : document.getElementById(element);

    if (!checkSupport()) {
        this.ui.setControlVisible('fallback', true);
        return;
    }

    this.core = new CoreInterface(this.ui.getMapControl().getMapElement().getElement(), config);

    if (this.core == null) {
        this.ui.setControlVisible('fallback', true);
        return;
    }
    
    this.updatePosInUrl = false;
    this.lastUrlUpdateTime = false;
    this.mapLoaded = false;
    this.mapInteracted = false;

    this.autopilot = new Autopilot(this);
    this.rois = new Rois(this);
    this.controlMode = new ControlMode(this, this.ui);
    this.presenter = new Presenter(this, config);

    this.on('map-loaded', this.onMapLoaded.bind(this));
    this.on('map-unloaded', this.onMapUnloaded.bind(this));
    this.on('map-update', this.onMapUpdate.bind(this));
    this.on('map-position-changed', this.onMapPositionChanged.bind(this));
    this.on('map-position-fixed-height-changed', this.onMapPositionFixedHeightChanged.bind(this));
    this.on('map-position-panned', this.onMapPositionPanned.bind(this));
    this.on('map-position-rotated', this.onMapPositionRotated.bind(this));
    this.on('map-position-zoomed', this.onMapPositionZoomed.bind(this));
        
    this.on('tick', this.onTick.bind(this));
};


Browser.prototype.kill = function() {
    this.ui.kill();
    this.killed = true;
};


Browser.prototype.getCore = function() {
    return this.core;
};


Browser.prototype.getMap = function() {
    return this.core ? this.core.map : null;
};


Browser.prototype.getRenderer = function() {
    return this.core ? this.core.renderer : null;
};


Browser.prototype.getProj4 = function() {
    return this.core ? this.core.proj4 : null;
};


Browser.prototype.getUI = function() {
    return this.ui;
};


Browser.prototype.setControlMode = function(mode) {
    this.controlMode = mode;
};


Browser.prototype.getControlMode = function() {
    return this.controlMode;
};


Browser.prototype.on = function(name, listener) {
    return this.core.on(name, listener);
};


Browser.prototype.callListener = function(name, event) {
    this.core.callListener(name, event);
};


Browser.prototype.onMapLoaded = function(event) {
    this.mapLoaded = true;

    //overwrite browser options
    var options = event['browserOptions'] || {};
    var originalOptions = this.originalConfig;
    for (var key in originalOptions) {
        if (typeof options[key] !== 'undefined') {
            options[key] = originalOptions[key]; 
        } 
    }    
    
    this.setConfigParams(options);

    if (this.config.geojson || this.config.geodata) {
        var data = this.config.geojson || this.config.geodata;

        if (typeof data === 'string') {
            data = data.trim();
           
            if (data.charAt(0) == '{') {
                try {
                    data = JSON.parse(data);
                    this.onGeoJsonLoaded(data);
                } catch(e){ }
            } else {
                utils.loadJSON(data, this.onGeoJsonLoaded.bind(this));
            }
        }
    }

    if (this.autopilot) {
        this.autopilot.setAutorotate(this.config.autoRotate);
        this.autopilot.setAutopan(this.config.autoPan[0], this.config.autoPan[1]);
    }
};


Browser.prototype.getLinkWithCurrentPos = function() {
    var map = this.getMap();
    if (!map) {
        return '';
    }

    //get url params
    var params = utils.getParamsFromUrl(window.location.href);
    
    //get position string
    var p = map.getPosition();
    p = map.convertPositionHeightMode(p, 'fix', true);
    
    var s = '';
    s += p.getViewMode() + ',';
    var c = p.getCoords();
    s += c[0].toFixed(6) + ',' + c[1].toFixed(6) + ',' + p.getHeightMode() + ',' + c[2].toFixed(2) + ',';
    var o = p.getOrientation();
    s += o[0].toFixed(2) + ',' + o[1].toFixed(2) + ',' + o[2].toFixed(2) + ',';
    s += p.getViewExtent().toFixed(2) + ',' + p.getFov().toFixed(2);

    //replace old value with new one    
    params['pos'] = s;

    if (this.mapInteracted) {
        if (params['rotate'] || this.getConfigParam('rotate')) {
            params['rotate'] = '0';
        }
        
        var pan = this.getConfigParam('pan');
        if (params['pan'] || (pan && (pan[0] || pan[1]))) {
            params['pan'] = '0,0';
        }
    }
    
    //convert prameters to url parameters string
    s = '';
    for (var key in params) {
        s += ((s.length > 0) ? '&' : '') + key + '=' + params[key];
    }

    //separete base url and url params
    var urlParts = window.location.href.split('?');
    
    if (urlParts.length > 1) {
        var extraParts = urlParts[1].split('#'); //is there anchor?
        return urlParts[0] + '?' + s + (extraParts[1] || ''); 
    } else {
        return urlParts[0] + '?' + s; 
    }
};


Browser.prototype.onMapPositionChanged = function() {
    if (this.config.positionInUrl) {
        this.updatePosInUrl = true;
    }
};


Browser.prototype.onMapPositionPanned = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionRotated = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionZoomed = function() {
    this.mapInteracted = true;
};


Browser.prototype.onMapPositionFixedHeightChanged = function() {
    if (this.config.positionInUrl) {
        this.updatePosInUrl = true;
    }
};


Browser.prototype.onMapUnloaded = function() {
};


Browser.prototype.onMapUpdate = function() {
    this.dirty = true;
};


Browser.prototype.onGeoJsonLoaded = function(data) {
    var map = this.getMap();
    var geodata = map.createGeodata();

    var addFreeLayer = (function(){
        var freeLayer = geodata.makeFreeLayer(this.config.geojsonStyle);
        map.addFreeLayer('geojson', freeLayer);
        var view = map.getView();
        view.freeLayers.geojson = {};
        map.setView(view);
    }).bind(this)

    if (this.config.geodata) {
        geodata.importVTSGeodata(data);
        addFreeLayer();
    } else {
        geodata.importGeoJson(data);
        geodata.processHeights('node-by-precision', 62, addFreeLayer);
    }
};


Browser.prototype.onTick = function() {
    if (this.killed) {
        return;
    }

    this.autopilot.tick();
    this.ui.tick(this.dirty);
    this.dirty = false;
    
    if (this.updatePosInUrl) {
        var timer = performance.now(); 
        if ((timer - this.lastUrlUpdateTime) > 1000) {
            if (window.history.replaceState) {
                window.history.replaceState({}, null, this.getLinkWithCurrentPos());
            }        
            this.updatePosInUrl = false;
            this.lastUrlUpdateTime = timer;
        }
    }
};


Browser.prototype.initConfig = function() {
    this.config = {
        panAllowed : true,
        rotationAllowed : true,
        zoomAllowed : true,
        jumpAllowed : false,
        sensitivity : [1, 0.06, 0.05],
        inertia : [0.81, 0.9, 0.7],
        timeNormalizedInertia : false, // legacy inertia [0.8,0.8,0.8] sensitivity [0.5,0.4]
        legacyInertia : false, // legacy inertia [0.8,0.8,0.8] sensitivity [0.5,0.4]
        positionInUrl : false,
        positionUrlHistory : false,
        constrainCamera : true,
        navigationMode : 'azimuthal',
        controlCompass : true,
        controlZoom : true,
        controlSpace : true,
        controlSearch : true,
        controlSearchSrs : null,
        controlSearchUrl : null,
        controlSearchFilter : true,
        controlMeasure : false,
        controlMeasureLite : false,
        controlLink : false,
        controlGithub : false,
        controlScale : true,
        controlLayers : false,
        controlCredits : true,
        controlFullscreen : false,
        controlLoading : true,
        searchElement : null,
        searchValue : null,
        geojson : null,
        tiltConstrainThreshold : [0.5,1],
        bigScreenMargins : false, //75,
        minViewExtent : 20, //75,
        maxViewExtent : Number.MAXINTEGER,
        autoRotate : 0,
        autoPan : [0,0]
    };
};


Browser.prototype.setConfigParams = function(params, ignoreCore) {
    if (typeof params === 'object' && params !== null) {
        for (var key in params) {
            this.setConfigParam(key, params[key], ignoreCore);

            /*if (!(key == "pos" || key == "position" || key == "view" ||
                key.indexOf("map") == 0 || key.indexOf("renderer") == 0)) {
                this.configStorage[key] = params[key];
            }*/
        }
    }
};


Browser.prototype.updateUI = function(key) {
    if (this.ui == null) {
        return;
    }

    this.ui.setParam(key);
};


Browser.prototype.setConfigParam = function(key, value, ignoreCore) {
    var map = this.getMap();

    switch (key) {
    case 'pos':                
    case 'position':
        this.config.position = value;
        if (map) {
            map.setPosition(this.config.position);
        }
        break;
            
    case 'view':
        this.config.view = value;
        if (map) {
            map.setView(this.config.view);
        }
        break;

    case 'panAllowed':             this.config.panAllowed = utils.validateBool(value, true);           break;
    case 'rotationAllowed':        this.config.rotationAllowed = utils.validateBool(value, true);      break;
    case 'zoomAllowed':            this.config.zoomAllowed = utils.validateBool(value, true);          break;
    case 'jumpAllowed':            this.config.jumpAllowed = utils.validateBool(value, false);         break;
    case 'constrainCamera':        this.config.constrainCamera = utils.validateBool(value, true);      break;
    case 'navigationMode':         this.config.navigationMode = value;                                 break;
    case 'positionInUrl':          this.config.positionInUrl = utils.validateBool(value, false);       break;
    case 'positionUrlHistory':     this.config.positionUrlHistory = utils.validateBool(value, false);  break;
    case 'controlCompass':         this.config.controlCompass = utils.validateBool(value, true); this.updateUI(key);    break;
    case 'controlZoom':            this.config.controlZoom = utils.validateBool(value, true); this.updateUI(key);       break;
    case 'controlMeasure':         this.config.controlMeasure = utils.validateBool(value, false); this.updateUI(key);   break;
    case 'controlScale':           this.config.controlScale = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'controlLayers':          this.config.controlLayers = utils.validateBool(value, false); this.updateUI(key);    break;
    case 'controlSpace':           this.config.controlSpace = utils.validateBool(value, false); this.updateUI(key);     break;
    case 'controlSearch':          this.config.controlSearch = utils.validateBool(value, false); this.updateUI(key);    break;
    case 'controlSearchUrl':       this.config.controlSearchUrl = value;    break;
    case 'controlSearchSrs':       this.config.controlSearchSrs = value;    break;
    case 'controlSearchFilter':    this.config.controlSearchFilter = utils.validateBool(value, true);  break;
    case 'controlSearchElement':   this.config.controlSearchElement = value; this.updateUI(key);  break;
    case 'controlSearchValue':     this.config.controlSearchValue = /*utils.validateString(*/value/*, null)*/; this.updateUI(key); break;
    case 'controlLink':            this.config.controlLink = utils.validateBool(value, false); this.updateUI(key);        break;
    case 'controlGithub':          this.config.controlGithub = utils.validateBool(value, false); this.updateUI(key);      break;
    case 'controlMeasure':         this.config.controlMeasure = utils.validateBool(value, false); this.updateUI(key);     break;
    case 'controlMeasureLite':     this.config.controlMeasureLite = utils.validateBool(value, false); this.updateUI(key); break;
    case 'controlLogo':            this.config.controlLogo = utils.validateBool(value, false); this.updateUI(key);        break;
    case 'controlFullscreen':      this.config.controlFullscreen = utils.validateBool(value, true); this.updateUI(key);   break;
    case 'controlCredits':         this.config.controlCredits = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'controlLoading':         this.config.controlLoading = utils.validateBool(value, true); this.updateUI(key);      break;
    case 'minViewExtent':          this.config.minViewExtent = utils.validateNumber(value, 0.01, Number.MAXINTEGER, 100); break;
    case 'maxViewExtent':          this.config.maxViewExtent = utils.validateNumber(value, 0.01, Number.MAXINTEGER, Number.MAXINTEGER); break;
    case 'sensitivity':            this.config.sensitivity = utils.validateNumberArray(value, 3, [0,0,0], [10, 10, 10], [1, 0.12, 0.05]); break;
    case 'inertia':                this.config.inertia = utils.validateNumberArray(value, 3, [0,0,0], [0.99, 0.99, 0.99], [0.85, 0.9, 0.7]); break;
    case 'legacyInertia':          this.config.legacyInertia = utils.validateBool(value, false); break;
    case 'timeNormalizedInertia':  this.config.timeNormalizedInertia = utils.validateBool(value, false); break;
    case 'bigScreenMargins':       this.config.bigScreenMargins = utils.validateBool(value, false); break;
    case 'tiltConstrainThreshold': this.config.tiltConstrainThreshold = utils.validateNumberArray(value, 2, [0.5,1], [-Number.MAXINTEGER, -Number.MAXINTEGER], [Number.MAXINTEGER, Number.MAXINTEGER]); break;
    case 'geodata':                this.config.geodata = value; break;
    case 'geojson':                this.config.geojson = value; break;
    case 'geojsonStyle':           this.config.geojsonStyle =  JSON.parse(value); break;
    case 'rotate':             
        this.config.autoRotate = utils.validateNumber(value, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, 0);
        if (map && this.autopilot) {
            this.autopilot.setAutorotate(this.config.autoRotate);
        }
        break;
    case 'pan':
        if (Array.isArray(value) && value.length == 2){
            this.config.autoPan = [
                utils.validateNumber(value[0], Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, 0),
                utils.validateNumber(value[1], -360, 360, 0)
            ];
        }

        if (map && this.autopilot) {
            this.autopilot.setAutorotate(this.config.autoRotate);
        }
        break;
    }

    if (ignoreCore) {
        if ((key.indexOf('map') == 0 || key.indexOf('mario') == 0 || key.indexOf('authorization') == 0) && map) {
            map.setConfigParam(key, value);
        }

        if (key.indexOf('renderer') == 0 && this.getRenderer()) {
            this.getRenderer().setConfigParam(key, value);
        }

        if (key.indexOf('debug') == 0 && this.core) {
            this.core.setConfigParam(key, value);
        }

    }
};


Browser.prototype.getConfigParam = function(key) {
    var map = this.getMap();

    switch (key) {
    case 'pos':
    case 'position':
        
        if (map) {
            map.getPosition();
        } else {
            return this.config.position;
        }
            
        break;
        
    case 'view':               

        if (map) {
            return map.getView();
        } else {
            return this.config.view;
        }
            
    case 'panAllowed':             return this.config.panAllowed;
    case 'rotationAllowed':        return this.config.rotationAllowed;
    case 'zoomAllowed':            return this.config.zoomAllowed;
    case 'jumpAllowed':            return this.config.jumpAllowed;
    case 'sensitivity':            return this.config.sensitivity;
    case 'inertia':                return this.config.inertia;
    case 'legacyInertia':          return this.config.legacyInertia;
    case 'timeNormalizedInertia':  return this.config.timeNormalizedInertia;
    case 'bigScreenMargins':       return this.config.bigScreenMargins;
    case 'navigationMode':         return this.config.navigationMode;
    case 'constrainCamera':        return this.config.constrainCamera;
    case 'positionInUrl':          return this.config.positionInUrl;
    case 'positionUrlHistory':     return this.config.positionUrlHistory;
    case 'controlCompass':         return this.config.controlCompass;
    case 'controlZoom':            return this.config.controlZoom;
    case 'controlMeasure':         return this.config.controlMeasure;
    case 'controlScale':           return this.config.controlScale;
    case 'controlLayers':          return this.config.controlLayers;
    case 'controlSpace':           return this.config.controlSpace;
    case 'controlSearch':          return this.config.controlSearch;
    case 'controlLink':            return this.config.controlLink;
    case 'controlGithub':          return this.config.controlGithub;
    case 'controlMeasure':         return this.config.controlMeasure;
    case 'controlMeasureLite':     return this.config.controlMeasureLite;
    case 'controlLogo':            return this.config.controlLogo;
    case 'controlFullscreen':      return this.config.controlFullscreen;
    case 'controlCredits':         return this.config.controlCredits;
    case 'controlLoading':         return this.config.controlLoading;
    case 'controlSearchElement':   return this.config.controlSearchElement;
    case 'controlSearchValue':     return this.config.controlSearchValue;
    case 'controlSearchUrl':       return this.config.controlSearchUrl;
    case 'controlSearchSrs':       return this.config.controlSearchSrs;
    case 'controlSearchFilter':    return this.config.controlSearchFilter;
    case 'minViewExtent':          return this.config.minViewExtent;
    case 'maxViewExtent':          return this.config.maxViewExtent;
    case 'rotate':                 return this.config.autoRotate;
    case 'pan':                    return this.config.autoPan;
    }

    //if (ignoreCore) {
    if (key.indexOf('map') == 0 && map) {
        return map.getConfigParam(key);
    }

    if (key.indexOf('renderer') == 0) {
        return map.getConfigParam(key);
    }
    //}
};


/* harmony default export */ __webpack_exports__["a"] = (Browser);


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__disabled__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__map_observer__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pano__ = __webpack_require__(182);





//get rid of compiler mess
var ControlModeDisabled = __WEBPACK_IMPORTED_MODULE_0__disabled__["a" /* default */];
var ControlModeMapObserver = __WEBPACK_IMPORTED_MODULE_1__map_observer__["a" /* ControlModeMapObserver */];
var ControlModePano = __WEBPACK_IMPORTED_MODULE_2__pano__["a" /* default */];


var ControlMode = function(browser) {
    this.browser = browser;
    this.ui = browser.ui;
    this.mapControl = this.ui.getMapControl();
    this.mapElement = this.mapControl.getMapElement();
    this.altKey = false;
    this.shiftKey = false;
    this.ctrlKey = false;

    this.mapElement.on('drag', this.onDrag.bind(this));
    //this.mapElement.on('dragstart', this.onDragStart.bind(this));
    //this.mapElement.on('dragend', this.onDragEnd.bind(this));
    this.mapElement.on('mousedown', this.onDown.bind(this));
    this.mapElement.on('mouseup', this.onUp.bind(this));
    this.mapElement.on('mousewheel', this.onWheel.bind(this));
    this.mapElement.on('keyup', this.onKeyUp.bind(this), window);
    this.mapElement.on('keydown', this.onKeyDown.bind(this), window);
    this.mapElement.on('keypress', this.onKeyPress.bind(this), window);
    this.mapElement.on('dblclick', this.onDoubleClick.bind(this), window);
    this.browser.on('tick', this.onTick.bind(this));

    this.controlModes = {};
    this.currentCotnrolModeId = 'map-observer';
    this.currentControlMode = this.controlModes['map-observer'];

    // default control modes
    this.addControlMode('map-observer', new ControlModeMapObserver(browser));
    this.addControlMode('disabled', new ControlModeDisabled());
    this.addControlMode('pano', new ControlModePano(browser));

    // use map observer mode as default
    this.setDefaultControlMode();
};


ControlMode.prototype.addControlMode = function(id, controller) {
    this.controlModes[id] = controller;
};


ControlMode.prototype.removeControlMode = function(id) {
    if (id === this.currentCotnrolModeId) {
        return;
    }

    delete this.controlModes[id];
};


ControlMode.prototype.setCurrentControlMode = function(id, options) {
    var newMode = this.controlModes[id];
    if (!newMode) {
        return;
    }

    // set new mode
    this.currentControlModeId = id;
    this.currentControlMode = newMode;

    // call reset
    if (newMode['reset']) {
        newMode['reset'](options);
    }
};


ControlMode.prototype.setDefaultControlMode = function() {
    this.setCurrentControlMode('map-observer');
};


ControlMode.prototype.getCurrentControlMode = function() {
    return this.currentControlModeId;
};

ControlMode.prototype.getCurrentController = function() {
    return this.currentControlMode;
};

// Event callbacks

ControlMode.prototype.onDrag = function(event) {
    this.checkAutopilot();
    if (this.currentControlMode['drag']) {
        this.currentControlMode['drag'](event);
    }
};


ControlMode.prototype.onDown = function(event) {
    this.checkAutopilot();
    this.updateModifierKeys(event);
    if (this.currentControlMode['down']) {
        this.currentControlMode['down'](event);
    }
};


ControlMode.prototype.onUp = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['up']) {
        this.currentControlMode['up'](event);
    }
};


ControlMode.prototype.onWheel = function(event) {
    this.checkAutopilot();
    if (this.currentControlMode['wheel']) {
        this.currentControlMode['wheel'](event);
    }
};


ControlMode.prototype.onKeyUp = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keyup']) {
        this.currentControlMode['keyup'](event);
    }
};


ControlMode.prototype.onKeyDown = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keydown']) {
        this.currentControlMode['keydown'](event);
    }
};


ControlMode.prototype.onKeyPress = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['keypress']) {
        this.currentControlMode['keypress'](event);
    }
};


ControlMode.prototype.onDoubleClick = function(event) {
    this.updateModifierKeys(event);
    if (this.currentControlMode['doubleclick']) {
        this.currentControlMode['doubleclick'](event);
    }
};


ControlMode.prototype.onTick = function(event) {
    if (this.currentControlMode['tick']) {
        event.draggingState = this.mapElement.getDraggingState();    
        this.currentControlMode['tick'](event);
    }
};


// Private metod
ControlMode.prototype.updateModifierKeys = function(event) {
    this.altKey = event.getModifierKey('alt');
    this.shiftKey = event.getModifierKey('shift');
    this.ctrlKey = event.getModifierKey('ctrl');
    //console.log("alt:" + this.altKey + "  ctrl:" + this.ctrlKey + "  shift:" + this.shiftKey);
};


ControlMode.prototype.checkAutopilot = function() {
    if (this.browser.autopilot) {
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }
};


/* harmony default export */ __webpack_exports__["a"] = (ControlMode);


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var ControlModeDisabled = function() {

};


/* harmony default export */ __webpack_exports__["a"] = (ControlModeDisabled);


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_utils_math__ = __webpack_require__(4);




//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_0__core_utils_math__["a" /* math */];


var ControlModePano = function(browser) {
    this.browser = browser;
    this.config = null;

    this.center = [0, 0];
    this.dragging = false;
    this.velocity = [0, 0];

    this.impulse = [0, 0];

    this['drag'] = this.drag;
    this['down'] = this.drag;
    this['up'] = this.drag;
    this['wheel'] = this.wheel;
    this['tick'] = this.tick;
    this['reset'] = this.reset;
    this['keyup'] = this.keyup;
    this['keydown'] = this.keydown;
    this['keypress'] = this.keypress;
};


ControlModePano.prototype.drag = function(event) {
    if (!this.dragging) {
        return;
    }

    var mouse = event.getMouseCoords();
    var delta = [mouse[0] - this.center[0], mouse[1] - this.center[1]];
    var sensitivity = 0.008;
    this.velocity[0] = delta[0] * sensitivity;
    this.velocity[1] = delta[1] * sensitivity;

    this.impulse[0] = delta[0] * sensitivity;
    this.impulse[1] = delta[1] * sensitivity;
};


ControlModePano.prototype.down = function(event) {
    if (event.getMouseButton() === 'left') {
        this.center = event.getMouseCoords();
        this.dragging = true;
    }
};


ControlModePano.prototype.up = function(event) {
    if (event.getMouseButton() === 'left') {
        this.dragging = false;
    }
};


ControlModePano.prototype.wheel = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var pos = map.getPosition();
    var delta = event.getWheelDelta();

    var factor = (delta > 0 ? -1 : 1) * 1;
    pos.setViewExtent(math.clamp(pos.getViewExtent() + factor, 1, 179));

    map.setPosition(pos);
};


ControlModePano.prototype.keyup = function() {
};


ControlModePano.prototype.keydown = function() {
};


ControlModePano.prototype.keypress = function() {
};


ControlModePano.prototype.tick = function() {
    if (this.velocity[0] == 0.0 && this.velocity[1] == 0.0) {
        return;
    }

    var map = this.browser.getMap();
    if (!map) {
        return;
    }
    
    var pos = map.getPosition();
    var coords = pos.getCoords();
    coords[0] -= this.velocity[0];
    coords[1] -= this.velocity[1];
    pos.setCoords(coords);
    map.setPosition(pos);

    // friction
    if (this.dragging) {
        return;
    }
    var step = 0.9;
    var treshold = 0.0005;

    if (Math.abs(this.velocity[0]) < treshold) {
        this.velocity[0] = 0.0;
    } else {
        this.velocity[0] *= step;
    }

    if (Math.abs(this.velocity[1]) < treshold) {
        this.velocity[1] = 0.0;
    } else {
        this.velocity[1] *= step;
    }
};


ControlModePano.prototype.reset = function(config) {
    this.config = config;
};


/* harmony default export */ __webpack_exports__["a"] = (ControlModePano);



/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_proj4__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_earcut___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_earcut__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_core__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__core_utils_math__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__core_utils_platform__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__interface__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utility_dom__ = __webpack_require__(9);
/* harmony reexport (default from non-hamory) */ __webpack_require__.d(__webpack_exports__, "earcut", function() { return __WEBPACK_IMPORTED_MODULE_1_earcut___default.a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return vec2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return vec3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return vec4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return mat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "math", function() { return math; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return utils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCoreVersion", function() { return getCoreVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkSupport", function() { return checkSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "browser", function() { return browser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBrowserVersion", function() { return getBrowserVersion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proj4", function() { return proj4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "platform", function() { return platform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dom", function() { return dom; });











//get rid of compiler mess
var getCoreVersion = __WEBPACK_IMPORTED_MODULE_2__core_core__["a" /* getCoreVersion */], checkSupport = __WEBPACK_IMPORTED_MODULE_2__core_core__["b" /* checkSupport */];
var vec2 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["a" /* vec2 */], vec3 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["b" /* vec3 */], vec4 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["c" /* vec4 */], mat3 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["d" /* mat3 */], mat4 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["e" /* mat4 */];
var utils = __WEBPACK_IMPORTED_MODULE_4__core_utils_utils__["a" /* utils */];
var dom = __WEBPACK_IMPORTED_MODULE_8__utility_dom__["a" /* default */];
var math = __WEBPACK_IMPORTED_MODULE_5__core_utils_math__["a" /* math */];
var BrowserInterface = __WEBPACK_IMPORTED_MODULE_7__interface__["a" /* default */];
var proj4 = __WEBPACK_IMPORTED_MODULE_0_proj4__["a" /* default */];
var platform = __WEBPACK_IMPORTED_MODULE_6__core_utils_platform__["a" /* platform */];

function browser (element, config) {
    var browserInterface = new BrowserInterface(element, config);
    return browserInterface.core ? browserInterface : null;
}

function getBrowserVersion() {
//    return "Browser: 2.0.0, Core: " + getCoreVersion();
    return '' + getCoreVersion();
}




/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var Presenter = function(browser, config) {
    this.container = null;
    this.aTags = null;
    this.sectionTags = null;
    this.defaultHeight = 0; // Changes based on presentation"s height
    this.maxHeight = 0; // Height of inner container to be set
    this.subtitlesHeights = []; // Set of heights after init() for subtitles

    this.firstTitleMargin = 20; // First slide of presentation has some css margin-top, so here we use it
    this.swipeOffset = 60; // Height of swipeControl

    this.actualNode = 0;
    this.maxNodes = 1;
    this.animTime = 600; // Default css transition time
    this.currentToolbox = 'right'; // Default toolbox (right | wide)

    this.browser = browser;
    this.id = [];
    this.current = null;

    this.presenter = (typeof config['presenter'] !== 'undefined') ? JSON.parse(JSON.stringify(config['presenter'])) : {};
    this.presenterAutoplay = config['presenterAutoplay'];

    if (typeof this.presenter !== 'undefined') {
        this.playPresentation();
    }
};


Presenter.prototype.addPresentation = function(id, source) {
    if (Object.keys(this.presenter).length !== 0) {
        this.presenter[id] = source;
    } else if (typeof id !== 'undefined') {
        this.presenter = {};
        this.presenter[id] = source;
    }
};


Presenter.prototype.removePresentation = function(id) {
    if (typeof id !== 'undefined') {
        if (this.getCurrentPresentation() == id) {
            this.stopPresentation();
            this.current = null;
        }
        delete this.presenter[id];
        return('Removed presentation id: '+id);            
    } else {
        if (this.getCurrentPresentation() !== null) {
            this.stopPresentation();
        }
        this.presenter = {}; // Remove all presentations
        this.presenterAutoplay = '';
        this.current = null;
        return('All presentations removed.');
    }
};


Presenter.prototype.getCurrentPresentation = function() {
    return this.current;
};


Presenter.prototype.getCurrentPresentationType = function() {
    return this.currentToolbox;
};


Presenter.prototype.playPresentation = function(id) {
    this.stopPresentation();
    if (this.presenterAutoplay !== undefined && typeof id === 'undefined') {
        id = this.presenterAutoplay;
    } else if (typeof id === 'undefined' && this.presenter !== undefined && Object.keys(this.presenter).length > 0) {
        for (var key in this.presenter) {
            id = key;
            break;
        }
    }
    
    if (typeof id !== 'undefined' && Object.keys(this.presenter).indexOf(id) != -1) {
        this.current = id;
        this.readTextInput(id);
        return true;
    } else {
        return false;
    }
};


Presenter.prototype.stopPresentation = function() {
    var current = this.getCurrentPresentation();
    this.currentToolbox = 'right';
    if (current !== null) {
        this.current = null;
        this.browser.ui.removeControl(current);
        this.container.getElementsByTagName('article')[0].parentNode.parentNode.parentNode.remove();
        return true;
    }
    return false;    
};


Presenter.prototype.listPresentations = function(id) {
    if (Object.keys(this.presenter).length === 0) {
        return [];
    }
    if (typeof id !== 'undefined') {
        if (this.presenter[id] !== 'undefined') {
            return this.presenter[id];
        } else {
            return null;
        }
    } else {
        var tmp = [];
        for (var key in this.presenter) {
            tmp.push(key);
        }
        return tmp;
    }
};


Presenter.prototype.initPresentation = function(id, HTMLtemplate) {
    var obj = this;    
    var templatePanelPrefix = '<div class="vts-presenter panelContainer"><div class="vts-presenter swipeControl top"></div><div class="vts-presenter toolboxContainer">';
    var templatePanelSuffix = '</div><div class="vts-presenter swipeControl"></div></div>';
    var templatePanel = templatePanelPrefix + HTMLtemplate + templatePanelSuffix;
    var templateSubtitlesPrefix = '<div class="vts-presenter subtitlesContainer"><button type="button"></button><button type="button"></button>'
                                    + '<div class="vts-presenter swipeSubtitles"><div><div></div></div></div><div class="vts-presenter swipeSubtitles"><div><div></div></div></div><div class="vts-presenter innerContainer">';
    var templateSubtitlesSuffix = '</div></div>';
    var templateSubtitles = templateSubtitlesPrefix + HTMLtemplate + templateSubtitlesSuffix;
    var template = templatePanel + templateSubtitles;
    var ctrlDelve = this.browser.ui.addControl(id, template);
    this.id.push(id);
    this.setContainer(ctrlDelve);

    // Set all <a> tags to have onclick
    this.aTags = this.container.getElementsByTagName('a');
    for (var i = 0; i < this.aTags.length; i++) {
        this.aTags[i].onclick = function() {
            obj.linksDecode(this);
        };
    }
    
    setTimeout((function(){
        this.renderControl();
    }).bind(this), 200);
};


Presenter.prototype.readTextInput = function(id) {
    var presentation = {
        htmlDataStorage : this.presenter[id],
        id : id,
        checkID : function() {
            var url = /^(ftp|http|https):\/\/[^ "]+$/;
            var relative = /.*\/+.*/;
            var level = /(\.\.\/|\.\/)/g;
            var hash = /^#.*$/;
            var str = /(<article)/g;
            if (str.test(this.htmlDataStorage)) {
                return 'string';
            } else if (url.test(this.htmlDataStorage)) {
                return 'url';
            } else if (relative.test(this.htmlDataStorage)) {
                var getLevel;
                var l = 0;
                var split = '';
                var loc = window.location.href.split('/');
                var path = '';
                while ((getLevel = level.exec(this.htmlDataStorage)) !== null) {
                    split = split + getLevel[0];
                    if (getLevel[0] === './') {
                        break;     
                    }
                    l++;
                }
                l++;
                for (var i = 0; i < (loc.length-l); i++) {
                    path = path + loc[i] + '/';
                }
                path = path + this.htmlDataStorage.split(split)[1];
                //console.log('Final path:');
                //console.log(path);
                this.htmlDataStorage = path;
                return 'url';
            } else if (hash.test(this.htmlDataStorage)) {
                return 'hash';
            } else {
                return 'string';
            }
        }
    };
    
    var mode = presentation.checkID();
    
    if (mode == 'url') {
        var rawFile = new XMLHttpRequest();
        //var obj = this;
        rawFile.open('GET', presentation.htmlDataStorage, false);
        rawFile.onreadystatechange = (function() {
            if (rawFile.readyState === 4) {
                if (rawFile.status === 200 || rawFile.status == 0) {
                    var allText = rawFile.responseText;
                    this.html = allText;
                    this.initPresentation(presentation.id, this.html);
                } else {
                    this.file = 'undefined';
                }
            }
        }).bind(this);
        rawFile.send(null); 
    } else if (mode == 'hash') {
        var obj = document.getElementById(presentation.htmlDataStorage).innerHTML;
        this.initPresentation(presentation.id, obj);
    } else if (mode == 'string') {
        this.initPresentation(presentation.id, presentation.htmlDataStorage);
    }
};


Presenter.prototype.linksDecode = function(obj) {
    var position = null;
    var autorotate = null;
    var transition = null;
    var navigate = null;
    
    if (obj.getAttribute('data-mln-navigate') !== null) {
        navigate = obj.getAttribute('data-mln-navigate');
        if (navigate !== null) {
            if (navigate == 'prev') {
                this.nextArticle('-1');
            } else if (navigate == 'next') {
                this.nextArticle('+1');
            } else if (navigate == 'first') {
                this.nextArticle(0);
            } else if (navigate == 'last') {
                this.nextArticle(this.maxNodes-1);
            } else {
                this.nextArticle(navigate);
            }        
            return 'navigation:true';
        }
    }
    
    if (obj.getAttribute('data-mln-position') === null){
        return 'position:false';
    }

    position = this.getNumbers(obj.getAttribute('data-mln-position').split(','));
    
    if (obj.getAttribute('data-mln-autorotate') !== null) {
        autorotate = this.getNumbers(obj.getAttribute('data-mln-autorotate'));
    }
    if (obj.getAttribute('data-mln-transition') !== null) {
        transition = obj.getAttribute('data-mln-transition');
    }
    
    if (transition === null) {
        this.browser.autopilot.flyTo(position);
    } else if (transition == 'teleport') {
        this.browser.core.getMap().setPosition(position);
    } else {
        this.browser.autopilot.flyTo(position);
        // Feature to be considered
        // browser.flyTo(position, {mode : transition});
    }
    if (autorotate !== null) {
        this.browser.autopilot.setAutorotate(autorotate);
    }
        
    return 'Moving to position: ' + position;
};


// parseFloat here
Presenter.prototype.getNumbers = function(obj) {
    //var obj = obj;
    for (var i = 0; i < obj.length; i++){
        if (typeof obj == 'string' && parseFloat(obj)) {
            obj = parseFloat(obj);
            break;
        }
        if (parseFloat(obj[i])) {
            obj[i] = parseFloat(obj[i]); // toFixed might be added here
        }
    }
    return obj;
};


Presenter.prototype.nextArticle = function(node, init, lastNode) {
    // fly to whatever node we wish
    if (node === '+1') {
        node = 1;
    } else if (node === '-1') {
        node = -1;
    } else {
        this.actualNode = node;
        node = 0;
    }
    this.actualNode = this.actualNode + node;
    
    if (this.actualNode >= 0 && this.actualNode < this.maxNodes) {
        if (!init) {
            if (this.currentToolbox == 'right') {
                this.handleArticle(this.actualNode);
            } else if (this.currentToolbox == 'wide') {
                this.handleSubtitlesPosition(this.actualNode);
            }
        }
        if (typeof lastNode !== 'undefined') {
            this.maxNodes = lastNode;
        }
        this.linksDecode(this.container.getElementsByTagName('section')[this.actualNode]);
        return true;
    
    } else {
        this.actualNode = this.actualNode - node;
    }
    return false;
};


Presenter.prototype.useToolbox = function() {
    var type = this.container.getElementsByTagName('article')[0].getAttribute('data-mln-style');
    
    if (type === null) {
        type = 'right';
    }
    
    var rightPanel = this.container.getElementsByClassName('vts-presenter panelContainer')[0];
    //var toolboxContainer = this.container.getElementsByClassName('vts-presenter toolboxContainer')[0];
    var subtitles = this.container.getElementsByClassName('vts-presenter subtitlesContainer')[0];
    var swipeControl = this.container.getElementsByClassName('vts-presenter swipeControl');
    var i;
    this.currentToolbox = type;
    
    subtitles.setAttribute('style', 'opacity: 0;');
    subtitles.setAttribute('class', 'vts-presenter subtitlesContainer');
    if (type == 'right') {
        rightPanel.style.display = 'block';
        setTimeout(function() {
            rightPanel.style.opacity = 1;
        }, 20);
        swipeControl[0].style.display = 'block';
        swipeControl[1].style.display = 'block';
        for (i = 0; i < this.sectionTags.length; i++) { // Set maxHeight back as there is no dynamic rescaling of rightPanel
            this.sectionTags[i].style.height = this.maxHeight + 'px';
        }
        this.nextArticle(0);
    } else if (type == 'wide') {
        subtitles.style.display = 'block';
        setTimeout(function() {
            subtitles.style.opacity = 1;
        }, 20);
        rightPanel.style.display = 'none';
        rightPanel.style.opacity = 0;
        swipeControl[0].style.display = 'none';
        swipeControl[1].style.display = 'none';
        for (i = 0; i < this.sectionTags.length; i++) { // Set height to auto so we can dynamicaly adjust subtitles height
            this.sectionTags[i].style.height = 'auto';
        }
        this.handleSubtitlesPosition(0, true);
    }
};


Presenter.prototype.setContainer = function(c) {
    this.container = c.element;
};


// Rendering of DOM elements for Presenter

Presenter.prototype.renderControl = function() {
    // Set every <section> tag excluding the first one to not to be displayed
    this.sectionTags = this.container.getElementsByClassName('vts-presenter toolboxContainer')[0].querySelectorAll('section');
    
    var swipeControlUp = this.container.getElementsByClassName('vts-presenter swipeControl')[0];
    var swipeControlDw = this.container.getElementsByClassName('vts-presenter swipeControl')[1];

    var nextButton = document.createElement('button');
    nextButton.innerHTML = '<div><div></div></div>';
    nextButton.setAttribute('type','button');
    nextButton.setAttribute('class','vts-presenter-btnDw');
    nextButton.onclick = (function(){
        this.nextArticle('+1');
    }).bind(this);
        
    var prevButton = document.createElement('button');
    prevButton.innerHTML = '<div><div></div></div>';
    prevButton.setAttribute('type','button');
    prevButton.setAttribute('class','vts-presenter-btnUp');
    prevButton.onclick = (function(){
        this.nextArticle('-1');
    }).bind(this);

    // End of all buttons and other controllers
    
    swipeControlUp.appendChild(prevButton);
    swipeControlDw.appendChild(nextButton);

    this.getElementsTrueHeight(this.sectionTags);

    var offsetTop = this.maxHeight + this.swipeOffset;

    this.container.getElementsByClassName('vts-presenter panelContainer')[0].style.height = (offsetTop + this.swipeOffset) + 'px';
    swipeControlDw.style.top = offsetTop +'px';
    swipeControlUp.style.opacity = '1';
    swipeControlDw.style.opacity = '1';
    
    // init now
    setTimeout((function() {
        this.useToolbox();
    }).bind(this), this.animTime);
    this.nextArticle(0, false, this.sectionTags.length);
};


Presenter.prototype.getElementsTrueHeight = function(elems) {
    for (var i = 0; i < elems.length; i++) {
        if (elems[i].offsetHeight > this.maxHeight) {
            this.maxHeight = elems[i].offsetHeight;
        }
    }
    
    for (i = 0; i < elems.length; i++) {
        elems[i].style.height = this.maxHeight + 'px';
    }
};


Presenter.prototype.handleArticle = function(node) {
    var rightPanel = this.container.getElementsByClassName('vts-presenter toolboxContainer')[0];
    var btnUp = this.container.getElementsByClassName('vts-presenter-btnUp')[0];
    var btnDw = this.container.getElementsByClassName('vts-presenter-btnDw')[0];

    var articleClass = (function(a) {
        this.container.getElementsByClassName('vts-presenter toolboxContainer')[0].querySelectorAll('article')[0].setAttribute('class',a);
    }).bind(this);
    
    var actualHeight = this.maxHeight * this.actualNode * -1;
    
    btnUp.setAttribute('class','vts-presenter-btnUp');
    btnDw.setAttribute('class','vts-presenter-btnDw');

    if (node === 0) {
        btnUp.setAttribute('class','vts-presenter-btnUp vts-presenter hidden');
    } else if (node === this.maxNodes-1) {
        btnDw.setAttribute('class','vts-presenter-btnDw vts-presenter hidden');
    }
        
    this.container.getElementsByTagName('article')[0].setAttribute('style','top: '+actualHeight+'px');
    
    if (this.actualNode === 0) {
        /* handle right panel stuff */
        rightPanel.style.height = (this.maxHeight + this.swipeOffset) + 'px';
        rightPanel.style.top = 0;
        articleClass('vts-presenter');
        /* done - now add some cosmetic attributes */
        this.container.getElementsByClassName('vts-presenter swipeControl')[0].style.height = 0;
        this.container.getElementsByTagName('article')[0].style.top = 0;
        this.container.getElementsByTagName('section')[0].style.height = (this.maxHeight + (this.swipeOffset - this.firstTitleMargin)) + 'px';
    } else {
        /* handle right panel stuff */
        rightPanel.style.height = this.maxHeight + 'px';
        rightPanel.style.top = this.swipeOffset + 'px';
        articleClass('vts-presenter nonFirst');
        /* done - now add some cosmetic attributes */
        this.container.getElementsByClassName('vts-presenter swipeControl')[0].style.height = this.swipeOffset + 'px';
        this.container.getElementsByTagName('section')[0].style.height = (this.maxHeight + this.swipeOffset) + 'px';
    }
    return true;
};


Presenter.prototype.handleSubtitlesPosition = function(node, init) {
    if (typeof node === 'undefined') {
        node = 0;
    }
    
    var subtitlesContainer = this.container.getElementsByClassName('vts-presenter subtitlesContainer')[0];
    var leftButton = subtitlesContainer.childNodes[0];
    var rightButton = subtitlesContainer.childNodes[1];
    var sections = subtitlesContainer.childNodes[4].querySelectorAll('article')[0].querySelectorAll('section');
    var swipeSubtitles = this.container.getElementsByClassName('vts-presenter swipeSubtitles');
    
    this.linksDecode(sections[node]);
    
    // clean all previous states
    sections[node].removeAttribute('style');
    subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer');
    subtitlesContainer.removeAttribute('onclick');
    swipeSubtitles[0].removeAttribute('onclick');
    swipeSubtitles[1].removeAttribute('onclick');
    swipeSubtitles[0].removeAttribute('style');
    swipeSubtitles[1].removeAttribute('style');
    leftButton.removeAttribute('onclick');
    rightButton.removeAttribute('onclick');
    leftButton.setAttribute('class', 'vts-presenter hidden');
    rightButton.setAttribute('class', 'vts-presenter hidden');
    
    for (var i = 0; i < sections.length; i++) {
        sections[i].style.opacity = 0;
        if (this.subtitlesHeights[i] === undefined) {
            sections[i].style.display = 'block';
            this.subtitlesHeights[i] = sections[i].offsetHeight;
            sections[i].style.display = 'none';
        }
        if (i !== node) {
            this.hideSections(sections[i]);
        }
    }
    this.showSections(sections[node]);
    
    var sectionType = sections[node].getAttribute('data-mln-style');
    if (sectionType == undefined) {
        sectionType = 'full';
    }
    
    if (sectionType == 'full') {
        swipeSubtitles[0].style.opacity = 0;
        swipeSubtitles[1].style.opacity = 0;
        swipeSubtitles[0].style.cursor = 'default';
        swipeSubtitles[1].style.cursor = 'default';
        
        if (node === 0) {
            leftButton.setAttribute('class', 'vts-presenter hidden');
            rightButton.setAttribute('class', 'vts-presenter');
            rightButton.onclick = (function() {
                this.nextArticle(1);
            }).bind(this);
            rightButton.innerHTML = 'Continue';
        } else if (node === sections.length - 2) { // One more before end
            leftButton.setAttribute('class', 'vts-presenter');
            leftButton.onclick = (function() {  
                this.nextArticle('-1');
            }).bind(this);
            leftButton.innerHTML = 'Back';
            rightButton.setAttribute('class', 'vts-presenter');
            rightButton.onclick = (function() {  
                this.nextArticle('+1');
            }).bind(this);
            rightButton.innerHTML = 'Explore';
        }
        if (typeof init === 'undefined') {
            subtitlesContainer.setAttribute('style', 'display: block;');
        }
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer full');
    } else if (sectionType == 'title') {
        swipeSubtitles[0].style.opacity = 1;
        swipeSubtitles[1].style.opacity = 1;
        swipeSubtitles[0].onclick = (function() {
            this.nextArticle('-1');
        }).bind(this);
        swipeSubtitles[1].onclick = (function() {
            this.nextArticle('+1');
        }).bind(this);
        leftButton.setAttribute('class', 'vts-presenter hidden');
        rightButton.setAttribute('class', 'vts-presenter hidden');
        subtitlesContainer.style.height = this.subtitlesHeights[node] + 'px';
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer title');
       
    } else if (sectionType == 'mini') {
        subtitlesContainer.setAttribute('style', 'display: block;');
        subtitlesContainer.setAttribute('class','vts-presenter subtitlesContainer mini');
        leftButton.setAttribute('class', 'vts-presenter hidden');
        rightButton.setAttribute('class', 'vts-presenter hidden');
    }
};



Presenter.prototype.hideSections = function(elem) {
    setTimeout(function() {
        elem.style.display = 'none';
    }, this.animTime);
};


Presenter.prototype.showSections = function(elem) {
    setTimeout(function() {
        elem.style.display = 'block';
        setTimeout(function() {
            elem.style.opacity = 1;
        }, 50);    
    }, this.animTime);
};


/* harmony default export */ __webpack_exports__["a"] = (Presenter);



/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Basic class for requesting ROI servers. It hasn't any UI. Eg. Explore Bar
// class has this class as ancestor.

/**
 * @constructor
 */

var Rois = function(roiServers) {
    this.roiServers = roiServers;
};


/**
 * roisAtPosition
 * Request rois intended for specific position
 * @param position position array 
 * @param count number of requested rois
 * @param clb callback
 * @return Response promise object (if ES6 is supported otherwise null)
 */
Rois.prototype.roisAtPosition = function(/*position, count, clb*/) {
    // TODO request ROI server
    // ROI gravity must be defined before implementation
};


/* harmony default export */ __webpack_exports__["a"] = (Rois);



/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);



//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];

var UIControlCompass = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('compass',
      '<div id="vts-compass">'

        + '<div id="vts-compass-frame">'
            + '<img id="vts-compass-compass" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODRDNjZFNDJCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODRDNjZFNDNCQjNCMTFFM0IyN0ZCQTZFQTAwNzEzNDUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4NEM2NkU0MEJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4NEM2NkU0MUJCM0IxMUUzQjI3RkJBNkVBMDA3MTM0NSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pgg3VBcAAAzUSURBVHja7F1bbBTXGf7tNdiAbTAXYxscMJe04GDLwVwKNDgNhaogRB+4qKgtzUMrISEhIXjiLsT9gQd4oQ8lPFRtEdACoWCCuASRBCelJBASEnM1xsbgGwYbg03PN/4PHI93vTO7s7tnxv6kX7Pe9Y7H/zf/5fxnzn/iXr16Rd3QA3HdZHST0Q2XktFTSLKQNCGpQlKEJLL4WFqFvGRp5uMTIfVCaoQ08PvdZNgEFJ8uZIiQQQ6fu0rIfSEPmaBuMvygv5CRQrJN78cLyeLPQc4AIX2ZsB5Cegn5qZBqIff47oc8F1In5DErH5+XswWpwHdK+fMuTQYUOUrIaJPy3xLyEyYnV0iGQ3+vQsg1Vv73Qu6ayPlByI9CGrsSGf34bs5SCMgRksfKL4jSdVxmcr4WckshBhb0nZBaL5ORysrO5J+ThExmmRBjD3FJyBdCPhfSxO89YLLqvUQGsp18IcP5Z2RD04X8jC1EJ8AiPhNyjrMx4LaQK0Ja3E7GGBaZon4gZCbHBZ2BeHJKyCdKSnydxXVk+Nj1ZHFMeEfIbCGFLhuHfSnkYyFXOaYgnpREykoiQQbSz2lMCFLS+WwNbkaxkAOcAoOIC5w2a03GOCVVRXa0UMO4EE48+QdnXzIV/kZXMibwoA0WMU/Ib8mb+JuQf7GF3GO3pQ0Z8ZwZDeZMaYmQIvI2zgrZxxlXJWdgrbEmA0T8nOMEyPijBmOGaAEW8VcmA/Hj03AJCYeMOA7UKOYNFfJ7IeOpa+ErIfuFlFFbERKB/VU4d3aomMhEoID3oVUijhw5QqWlpV4hYzz/77LCPDFcNxMK3uULQJ3pdzzCtoSmpiaqqanxknXksw7SWCfvRpOMd7i0gTL2n63EiKqqKrp+vW3w2qtXL3r27JnX3BV08CfWyXDWUcTJgCW8zenrEqtmWVlZSSUlbRlg7969qbGxkTyIiawTH+soLZJk4Hen8OtfC3nfikuSBMjXHrUMifdZN8Tpvq2bPcEm8yh7j7E6oNu8eTNt3LjRIEMS0LdvXzp27BhdvnyZfD6f8RkIeu+99ygvL88LhEA3mKS6zjr73GkyQICc/kStqaedq+vTp89ry8jNzTVIAl68eEFPnz41iEpOTvaKdfRkHe1WdHfdKTJ8fMJ4/iP5wVJX3OX9+vVrRwaC+KFDhwwrgMAiBg4cSCNGjGj3ux7KsKCrv7DubpCFSm+8xRMDKAIGrb6WlZXRkydt8zJwQy9fvqT4+HhasmQJZWVlUWJiIjU0NNCdO3fo1q1brtEuLLi52dbTPjMV3eU7YRmpnKolKoGpUyQlJb2OD7AAKD09Pd1wTyDFjbh48SJduHCBVq1aZfervxLyLesQcaQ+HDJy+TiDLE4Mwf3gLgLGjh1LR48epefPnxvpbGtrK8XFxdH69euNoxusYefOnXTu3Dk6cOBAKKcoZN19zLr8LFQy4Mjx8EAKn9AS1NR1zpw5rnX6sIZNmzbRw4cPacOGDTRgwIBQTwXdnVd0WhsKGXJSqIhszFmDjOPHj9OlS5deB2vI9OnTKSMjwzXWAIsGpk2bRrNnzw7nlG+xDo+yTgOmuoGqtkkcI3DcSG0PlFkGLEOmrPL1yJEjKS0tzTXWYATM1FTDPYVhFRKojK6ltseA/kMBHpQLZBly6nSyXSJk3IC4KVNSrUFixYoVThBBrEPo8iy1PUX5jZ3UdjR/Nok8DgTn+fPndyDCAfdkxiTW6Wg7MaM/H3MozPq8zsBYaNu2bXTixImO+bxwT2vWrHH6T05knZayjqutWIZ0S3letwZ/RADLly93yj2ZkWfScVDLyGaScruSNUhMnjyZ5s6dG6lLgE7/zTouCUaGrNZhxFjgNWvYsmULPXr0KODvoFi5du3aSF5GAev2Juu6oTMy0k3ZVJewBtU9oXQTYbzNZKQHI2NIZz7Ni9aguqd58+ZF47JGKLq+2RkZeMLB5/Z4YccaouSezHHDR37WK6pkyAkj1KMyuoI1RNk9SWSwjstY583+yEg2jTNchbq6OsMaiouLbX0viu7JPJYrY51X+xtnpJnihmtw+vRpY9xgl4gouycVQ00672AZqXwc4CZr2Lp1K506dSqk70fZPfmrcqQGIiOFj33dYg1wS9XVoS3hjpF7IpOOUwKRkWSKHdoCAfrgwYMhfz+G7skcn5PUN+P9ZFM9dLcISUSoU7cxdE8SiSaddyDDx8deumdMAOZLMAeBCqsdTJo0KZbuyWwZvmBkaLsGD8Faxohly5YZU7l79uyxTAgIXL16tQ7/yshgZMhVN9U6EgH3JLOmCRMmGKksMGbMGMuEgMDMzExtXbBKxks+3tPdPZmDrxVCVAI1gFwt1BKMDO2aZG3fvr2de/J3d3dGiD8CY4yGYGRIEl7odNWoNZ08edLS3R2IEA3d03N/N75KhiRBm5UsqL5iTGHn7gYhixYt0tU9mS2jKdCgD8+BDtIpgCNOyOqrlbvbXB7R0D1JyFYXdYHIkKseH+ninuR8hJW721weARF4wkPT7OmRSecdyJD9lcrd5J78FQtBHr6jcRpbbtJ5BzKkH6t1i3vyZw34fQ1jhBm1Jp13IEMGcLRfQHPFjFi7p8LCQr+Kdak1SFSwjjtkruY58CoO4tdiQYbqnvDkur/ShYutQeIajy+qzB+YybjPZGCE+EEs3dPSpUtp6NChnVoD5iQQpAcPHkwuwk1F152S8ZCPP8TSPRUUFLQbK5itAfMRKINrUH0NBTdMug5Ihgwot6mt72tBLNzTunXrjLkKKB8kgAzVGhAbYjwfESous247BG9/ZAAoFGazbyuIlXtCCWTHjh1UW1vrBWuQwGLLVgpQjPVHRimT8XU0ru78+fPt3NOsWbNo5cqVdObMGa9Yg4orio4tkSHLIVikjU7IEVujgRVDCMrSPU2dOpUWLFjgNWuQuMQ6pUAlp0DLyBDA8fDzF5EkA9Omcv0csHv3bi9ag0QJu6iAyVEgMn5kMrAyEwstHX8QGosZ1aVbsu2RbtaARmXoHIeWG3KtonxtA3BLFxXd2iKjkesnaN7yqdNkwD1hVakZOloDGgqADNwsUpBsFBUV0cyZlnsnQ4dNrNNGu2QA3zEZZ4X8ghzsX252T5gMgjVEcMVQyMDa9YULF7Z7D60rHj+23PD5LusQ+L6zX0wIUsx6wK/RoP3DSLgnrCrFKDpCa+hCAtbGo6UGjuh3guQCDWhGjRpldH2Ai0LDGouA7p6wLmtCJUPWUTL5hFgcWOiUe4I1YJ21w8t7HQEGnGhRAaDfCa4bloyH50AGYobFbnJfsu6kLikcMup5xDhcyIlwyZDuSUdrkGUXjPplPywZrMeNG2e8J5MMtc1fEEBnmO++QxY2RbHSc+iKciwOxz2h/oQ7bteuXdoRAeTk5NCwYcOMjA6Bu7y8nPbt22dYR0JCArW0tD3MkZKS0q6IGQDFiu7+Z+XvW+nEhitAWzd0FEOfH5RI8+26JwQ9h/pwOIr6+nqjGRnu9uzsbKMznIobN24Y1w8CJNA5LkiycYV11cq6a3GKDOITysfYDzAxlvsU9ujRI5TGWVHB7du3jZIMXBDiAO5+dI9bvHix0bAMzczMZARBM73Za6OcbOxGY6cXOlwaOovhMXbcFn8gj+Lw4cPGHMmUKVNo7969NGPGDMNiECdAThB8JOQIjytOkI1m9Xb61OGkspMYOoud8SoZaiNktc2fBSLOsG6IQtjGwW7TQOTJshPlPnJwIw+doHaTw9y6xZnEEtZJC+vIdsP3hBCu9SrHi+FskiB0vNcso6KiwniNJxQt4CvWRQMPBa6G8ncTQrze/9KbRTX7+Tz5XiEDHeMsuCQ1c9rPI+xK1k1og80wNjOBRWAzk4HUvZkJaiOYqrxAYewu4+Q2P5mcYXWlbX4+YouI+TY/KiFdbQOsc0xEHWm0AZYKuTUc4sdvhCzyKBF/x1CE2hYXabc1nIruTRM1IoOo43aiC4T80uVE4DHGf5LLthOVMG+0C4vBXLobN9o9zhbgyo12VahbUKMrwAwWN2xB/QmLXH/n2i2ozVZi3py9iFNi3drvlXKKepY8uDm7CixBzeXxCIAhLjbUmqjB2ASuBw+Z4XEaOYWH8QOmSuujdRHRJON1tYEzrExlnJLD1jOWotfCFQ8hf8t3/S1lnPCAM6eo7+wYCzIkUNsaRe3btsZzPAFZI9iSnFq0U8F3+k1W9l3TQA2pKh4wi9nS61iSoaI/x49sP6N7uQvaEE6bMeOYzAlBmpIM3OW7GQG3gUfHSD/v05tZN/Mo+R6T81gHJehChopkLq2AhEEOn7uKSakkP+sjuskIjp5MUBonASkc/HtypibbBLWwNHMQfsLBt4YV36z7P+oGMroMusnQCP8XYACgtQtbAKLiKwAAAABJRU5ErkJggg==">'
        + '</div>'

        + '<div id="vts-compass-frame2">'
            + '<img id="vts-compass-compass2" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'
        + '</div>'

        + '<div id="vts-compass-frame3">'
            + '<img id="vts-compass-compass3" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGMAAABjCAYAAACPO76VAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABG9JREFUeNrtnM9LFGEcxkeEPCQVmbkh7EXoEgW6noIQzQwKoQ5Lkgh7SA8iddlCQfAQFApdghAxooJCsEMe9JAEek8i81YQCIEYQvgHZM9L37Fpmpl9Z3d+rs8DDw7unuaz3+ddX+d9DIOiKIqiKIqiKIqiKIqiKIqiKIqiKMpTQ0NDyqNwTq7/MRUNAKsfwL2EER+MLHxBru/BA4QR3zR0wY/lWmmEMKKHcVh+tsEv5PoGPE4Y0cP4LD9b4AW57oC/whvwB3gZfgN3886FG1EmjAZ41WEa6uAm+DTcyLsXPAz11fWkDUYtvAVPwHfgAnwdbmVMhQtjDj4jN3gNPiTXF+E8fAsuwvfhQScIuVwuMusK762H69IGYwY+LwDew+3wcZkOQ2fhThoMvK8TnkrjZEzCV+RGF2XhXoE/wuvwJ7jGK5aSAkOm4Qm8DTemEcYYfNNtCnTWiCTAkGn4Bu/B+bSuGcPwF3gJfg1Pww/l661uLMQGwzINe+L5tH+1PSpbIOdkG0TtRWWSDsM2Dco/UhlPQSpqGA7TsJfqeEorDLjHNg3pj6cUwjgCzzpAYDxFDENNw6YLCOU+Uggfhtc0mH5LAuHDKDUNyjtwhgTCg6EzDab7effDg6EzDYynkGH4mQbGU4gw/EwD4ykkGMfgZz4hMJ5CgHEV/l4GCMZTgDDUNDwvAwLjKeD1odxp2I8nP/92JQx3P6oAwn48EUYw64N5U3+VG09+H0ggDOc1woymn/Bl2WH1A2KhnKdDCON/WxfrgvzurA8gCmAzYVQOwxpPi7bXdIEUyn1uijDc46nZ4T2lgCxW8hAbYfz1U69PtwYQN4AE4BNGT6lPtwaQQqWPdxLGn93XzVKfbgff1QVI6cOY1Ywnt+2RkgApPRh+48m+PaJA9Ab1FPpBhuEnnpw2Cxd1I40qDUM3npymoRDG+YyDCsMaT0thTANh6MGwxtMunA1jGghDD4Y1ngY1pkH9T+JUFMfIDhoMazy9g2s8pmHHug1OGMHCcIunBvilwzRkoj5geZBgOMXTNXgrjGkgDHcYl2zxdAJ+FeY0EIYziHrLQRUVT7ejmAbCcIZhPbq1G9U06MIo97RuGkF0ejy50Z9LwDlwuekZOSB6QQ6MZuUAaVXGU+TT4BNGixydnpaj1EtytHq4GuPJPEPXF/HBSkcYOmUCUjowVo3xNK8OM8YBwgNGjdRqrEvNxorUbhTldVXHMVlN8aSmIR8XBDsMjymolSKadimmMaSoZqZa4mnePNqbMBiDUr1UlCqmvFQzGVLVtCbXqsJpLu3xtG1vHYgThMMUtEopWUFKyiaktKzWVmamys1G0xxPU04H3RMAo1Fq+Zqkps8OaFVq/aww0vt3hleDWQJgdEth5bIUWG5IoWWHvL5gNgJZYVABy2PRHpfKV0MqYNts1bC8eRHCGJEyZEPKkbvYwRsfjAGpCTdkGyRLAPHB6JUCfU5DAmDkpJ+XN4miKIqiKIqiKIqiKIqiKIqiKIpKpn4DKrVAiBFUfdUAAAAASUVORK5CYII=">'
        + '</div>'

      + ' </div>', visible, visibleLock);

    var compass = this.control.getElement('vts-compass');
    compass.setDraggableState(true);
    compass.on('drag', this.onDrag.bind(this));
    compass.on('dblclick', this.onDoubleClick.bind(this));

    this.image = this.control.getElement('vts-compass-compass');
    this.image2 = this.control.getElement('vts-compass-compass2');
    this.image3 = this.control.getElement('vts-compass-compass3');
    
    this.lastStyle = '';
};


UIControlCompass.prototype.update = function() {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var pos = map.getPosition();
    var orientation = pos.getOrientation();
    var value = 'rotateX('+(Math.round(orientation[1]+90)*0.7)+'deg) ' + 'rotateZ('+Math.round(-orientation[0]-45)+'deg)';

    if (value != this.lastStyle) {
        this.lastStyle = value;
        this.image.setStyle(dom.TRANSFORM, value);
        this.image2.setStyle(dom.TRANSFORM, value);
        this.image3.setStyle(dom.TRANSFORM, value);
    }
};


UIControlCompass.prototype.onDrag = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    var delta = event.getDragDelta();
    var sensitivity = 0.4;
    
    var controller = this.browser.controlMode.getCurrentController();
    
    if (controller.orientationDeltas) {
        controller.orientationDeltas.push([delta[0] * sensitivity,
            -delta[1] * sensitivity, 0]);
    }
};


UIControlCompass.prototype.onDoubleClick = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    var pos = map.getPosition();
    var orientation = pos.getOrientation();
    orientation[0] = 0;
    orientation[1] = -90;
    pos.setOrientation(orientation);

    map.setPosition(pos);

    if (this.browser.config.navigationMode == 'azimuthal2')  {
        this.browser.config.navigationMode = 'azimuthal';
    }
    
    dom.stopPropagation(event);    
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlCompass);


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlCredits = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('credits',
      '<div id="vts-credits"'
      + ' class="vts-credits">'
      + ' </div>', visible, visibleLock);

    this.lastHTML = '';
    this.lastHTML2 = '';
    this.lastHTML3 = '';
    this.credits = this.control.getElement('vts-credits');
};


UIControlCredits.prototype.getCreditsString = function(array, separator, full) {
    var map = this.browser.getMap();
    var html = '';
    //var copyright = '&copy;' + (new Date().getFullYear());
    
    var li = array.length;
    var plain = ''; 
    var more = false;
    var creditInfo;

    for (var i = 0; i < li; i++) {
        creditInfo = map.getCreditInfo(array[i]);
        if (creditInfo['plain']) {
            plain += creditInfo['plain'];
        }
    }        
    
    if (plain && plain.length > 30 && li > 1 && !full) {
        for (i = 0; i < li; i++) {
            creditInfo = map.getCreditInfo(array[i]);
            if (creditInfo['html'].trim() != '') {
                li = i + 1;
                break;
            }
        }

        if (li < array.length) {
            more = true; 
        } else {
            li = array.length;
        }
    }

    for (i = 0; i < li; i++) {
        creditInfo = map.getCreditInfo(array[i]);
       
        if (creditInfo['html'] && creditInfo['html'].trim() != '') {
            html += creditInfo['html'];

            if (i + 1 < li) {
                html += separator;        
            }
        }
    }
    
    return [html, more];
};


UIControlCredits.prototype.update = function() {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var html = '', html2 = '', html3 = '', res;
    var credits = map.getCurrentCredits();
    
    if (credits['imagery'].length > 0) {
        res = this.getCreditsString(credits['imagery'], ', ');
        if (res[0] != '') {
            html += '<div class="vts-credits-supercell">';
            html += '<div class="vts-credits-cell">Imagery: ' + res[0] + '</div>';
            html += res[1] ? '<div class="vts-credits-cell-button" id="vts-credits-imagery-more">and others</div>' : '';
            html += '<div class="vts-credits-separator"></div>';
            html += '</div>';
            html2 = '<div class="vts-credits-list">';
            html2 += this.getCreditsString(credits['imagery'], '<br/>', true)[0] + '</div>';
        }
    }
    
    if (credits['mapdata'].length > 0) {
        res = this.getCreditsString(credits['mapdata'], ', ');
        if (res[0] != '') {
            html += '<div class="vts-credits-supercell">';
            html += '<div class="vts-credits-cell">Map Data: ' + res[0] + '</div>';
            html += res[1] ? '<div class="vts-credits-cell-button" id="vts-credits-mapdata-more">and others</div>' : '';
            html += '<div class="vts-credits-separator"></div>';
            html += '</div>';
            html3 = '<div class="vts-credits-list">';
            html3 += this.getCreditsString(credits['mapdata'], '<br/>', true)[0] + '</div>';
        }
    }

    html += '<div class="vts-credits-supercell">';
    html += '<div class="vts-credits-cell">Powered by <a class="vts-logo" href="https://www.melown.com/products/vts/" target="blank">VTS 3D Geospatial Software Stack</a></div>';
    html += '<div class="vts-credits-separator"></div>';
    html += '</div>';

    if (this.lastHTML != html) {
        this.lastHTML = html;
        this.credits.setHtml(html);

        var butt = this.control.getElement('vts-credits-imagery-more');
        if (butt) {
            butt.on('click', this.onMoreButton.bind(this, butt, '2'));
        }
        
        butt = this.control.getElement('vts-credits-mapdata-more');
        if (butt) {
            butt.on('click', this.onMoreButton.bind(this, butt, '3'));
        }
    }

    this.lastHTML2 = html2;
    this.lastHTML3 = html3;

    /*
    if (this.lastHTML2 != html2) {
        var butt = this.control.getElement("vts-credits-imagery-more");
        if (butt) {
            butt.on("click", this.onMoreButton.bind(this, butt, "2"));
        }
    }
        
    if (this.lastHTML3 != html3) {
        var butt = this.control.getElement("vts-credits-mapdata-more");
        if (butt) {
            butt.on("click", this.onMoreButton.bind(this, butt, "3"));
        }
    }*/
};


UIControlCredits.prototype.onMoreButton = function(butt, html) {
    var rect = butt.getRect();
    
    if (html == '2') {
        html = this.lastHTML2;
    } else {
        html = this.lastHTML3;
    }
    
    this.ui.popup.show({'right' : Math.max(0,(rect['fromRight']-rect['width'])) + 'px',
        'bottom' : (rect['fromBottom']+7) + 'px'}, html);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlCredits);



/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


var UIControlFallback = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('fallback',
      '<div class="vts-fallback">'

        + '<div class="vts-fallback-text">'
            + '<p>VTS Browser needs <a href="http://get.webgl.org/">WebGL</a> capable web browser.</p>'
        + '</div>'

      + ' </div>', visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlFallback);


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);



//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];


var UIControlFullscreen = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('fullscreen',
      '<img id="vts-fullscreen" class="vts-fullscreen" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAwUlEQVRo3u2YwRWDIBBEIc+SLMKmckpTFkFPePKQQ57DsitR/z/D6KgMDikBAMCTycKYxai9Bul8MYkic+NFS7BOs4FUa/1IrzTn9xk6O6+rrwEMjGayTlS/UXWeujbcDKgpEZRObgYOc1oYt7CIMXCFFLKmTrS+aqAEP8iSAGBYI1s776FLv7eReaWHWd/cyLz3Bas+vxIYGNXIhBTxOhcKNdCaHvPfGPjVYb3OhVjEGLhrI/Pewc9uZDQvAABwZQMKFi+DmFdLbgAAAABJRU5ErkJggg==">'
      , visible, visibleLock);
      
    var img = this.control.getElement('vts-fullscreen');
    img.on('click', this.onClick.bind(this));
    img.on('dblclick', this.onDoNothing.bind(this));
    
    this.enabled = false;
};


UIControlFullscreen.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);    
    dom.stopPropagation(event);    
};


UIControlFullscreen.prototype.requestFullscreen = function(element) {
    if(element.requestFullscreen) {
        element.requestFullscreen();
    } else if(element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if(element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
    } else if(element.msRequestFullscreen) {
        element.msRequestFullscreen();
    }
};


UIControlFullscreen.prototype.exitFullscreen = function() {
    if(document.exitFullscreen) {
        document.exitFullscreen();
    } else if(document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if(document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    }
};


UIControlFullscreen.prototype.fullscreenEnabled = function() {
    return (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled);
};


UIControlFullscreen.prototype.onClick = function() {
    var element = this.ui.element;
    
    if (!this.enabled) {
    //if (!this.fullscreenEnabled()) {
        this.enabled = true;
        this.requestFullscreen(element);
    } else {
        this.enabled = false;
        this.exitFullscreen();  
    } 
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlFullscreen);


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlGithub = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl("github",
      '<a target="_blank" href="https://github.com/Melown/vts-browser-js">'
      + '<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png">'
      + '</a>'
      , visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlGithub);



/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__element_element__ = __webpack_require__(202);



//get rid of compiler mess
var UIElement = __WEBPACK_IMPORTED_MODULE_0__element_element__["a" /* default */];


var UIControlHolder = function(ui, html, visible, visibleLock, parentElement) {
    this.ui = ui;
    this.html = html;
    this.elementsById = [];
    this.visible = (visible != null) ? visible : true;

    //create holder element
    this.element = document.createElement('div');
    this.setVisible(this.visible);

    this.visibleLock = visibleLock ? true : false;
    this.setVisibleLock(this.visibleLock);

    //set element content
    this.setHtml(html);

    //append elemenet to UI
    if (parentElement) {
        parentElement.appendChild(this.element);
    } else {
        this.ui.element.appendChild(this.element);
    }
};


UIControlHolder.prototype.setHtml = function(html) {
    this.element.innerHTML = html;

    var allElements = this.element.getElementsByTagName('*');

    //store all elements with id attribute to the table
    for (var i = 0, li = allElements.length; i < li; i++) {
        var id = allElements[i].getAttribute('id');

        if (id !== null) {
            //store element to the table
            this.elementsById[id] = new UIElement(this, allElements[i]);
        }
    }
};


UIControlHolder.prototype.getElement = function(id) {
    return this.elementsById[id];
};


UIControlHolder.prototype.setVisible = function(state) {
    if (this.visibleLock) {
        return;
    }

    this.element.style.display = state ? 'block' : 'none';
    this.visible = state;
};


UIControlHolder.prototype.getVisible = function() {
    return this.visible;
};

UIControlHolder.prototype.setVisibleLock = function(state) {
    this.visibleLock = state;
};


UIControlHolder.prototype.getVisibleLock = function() {
    return this.visibleLock;
};

/* harmony default export */ __webpack_exports__["a"] = (UIControlHolder);

/*
//prevent minification
UIControlHolder.prototype["setHtml"] = UIControlHolder.prototype.setHtml; 
UIControlHolder.prototype["getElement"] = UIControlHolder.prototype.getElement; 
UIControlHolder.prototype["setVisible"] = UIControlHolder.prototype.setVisible; 
UIControlHolder.prototype["getVisible"] = UIControlHolder.prototype.getVisible; 
*/





/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlLayers = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.control = this.ui.addControl('layers',
      '<div class="vts-layers"'
      + '</div>', visible, visibleLock);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlLayers);


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);



//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];


var UIControlLink = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('link',
      '<div id="vts-link" class="vts-link">'

        + '<div id="vts-link-button" class="vts-link-button">'
          + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABrUlEQVRIx+2VMWtUQRSFz5nZjVrpD9gNVhpLQbZZ5vWaIoUECayNRSpbo9UiJI1pBRs7DVjYGBC1ntm3yHaiwgYsZP+EmMe7x8K3YJEH+xYLwT3NcGe483HvnJkBVvovxWWSsiy7BeAxgGuSpmY2zPP8/V+DhBAekDysQgPgAMDMbo5Gow9n5bgmgF6vd47kAYBC0t0Y45qkPQAguV+X1wgymUx+ShqUZZmllI4AlEVRPJckkht1ea1FNu/3+1ve+31JV0h+dc49mq+12+0dkpQ0XfpMQgh7JJ9U4SmANf3WZUnXvfevAbQBbMYY3zVu1x+Awsx2YoznzewOgKcke3OApId1AADwCwIGJG90u12f5/nx+vr6Jefc0RyQUjpsfE9CCJsk3wIoyrLcljRttVrznv8AcAEAFgHUtovksNrkXp7nx+Px+ETSbQBfKrN8NrOtRQC17pK0QbJMKb2az5nZd+fc/ZRSBKAm1q+r5ASADyHsVuPAe/+R5JtlnqEzIWY2rGDPsiw7JfmysulB0ypq3TWbzb51Op0JyaskLwL4BGA3xvhi9aes9G/pF4AdwlhUZ8RfAAAAAElFTkSuQmCC">'
        + '</div>'

        + '<div id="vts-link-text-holder" class="vts-link-text-holder">'
            + '<div class="vts-link-text">'
              + '<textarea id="vts-link-text-input" rows="4" cols="50" wrap="hard"></textarea>'
            + '</div>'
        + '</div>'
        
     + ' </div>', visible, visibleLock);
     
    this.div = this.control.getElement('vts-link');

    var button = this.control.getElement('vts-link-button');
    button.on('click', this.onSwitch.bind(this));
    button.on('dblclick', this.onDoNothing.bind(this));

    this.linkPanel = this.control.getElement('vts-link-text-holder');
    this.link = this.control.getElement('vts-link-text-input');

    this.linkVisible = false;
    this.update();
};


UIControlLink.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);    
};


UIControlLink.prototype.onSwitch = function() {
    this.linkVisible = !this.linkVisible;
    this.updateLink();
    this.update();
};


UIControlLink.prototype.update = function() {
    //var button = this.control.getElement('vts-link-button');
    
    var left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                (this.ui.config.controlSpace ? 35 : 0);
    
    this.div.setStyle('left', left + 'px');
    this.linkPanel.setStyle('display', this.linkVisible ? 'block' : 'none');
};


UIControlLink.prototype.updateLink = function() {
    var linkValue =  this.browser.getLinkWithCurrentPos();
    if (this.link.getElement().value != linkValue) {
        this.link.getElement().value = linkValue;
    }
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlLink);



/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlLoading = function(ui, visible) {
    this.ui = ui;
    this.control = this.ui.addControl('loading',
      '<div id="vts-loading" class="vts-loading">'

        + '<div class="vts-loading-progress">'
            + '<div id="vts-loading-dot1" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot2" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot3" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot4" class="vts-loading-dot"></div>'
            + '<div id="vts-loading-dot5" class="vts-loading-dot"></div>'
        + '</div>'

      + ' </div>', visible);

    this.loading = this.control.getElement('vts-loading');
    this.dots = [
        this.control.getElement('vts-loading-dot1'),
        this.control.getElement('vts-loading-dot2'),
        this.control.getElement('vts-loading-dot3'),
        this.control.getElement('vts-loading-dot4'),
        this.control.getElement('vts-loading-dot5')
    ];
    
    this.time = Date.now();
    this.hiding = null;
    
    //setTimeout(this.hide.bind(this), 5000);
};


UIControlLoading.prototype.show = function() {
    this.hiding = null;
    this.ui.setControlVisible('compass', false);
    this.ui.setControlVisible('zoom', false);
    this.ui.setControlVisible('space', false);
    this.ui.setControlVisible('search', false);
    this.ui.setControlVisible('link', false);
    this.ui.setControlVisible('github', false);
    this.ui.setControlVisible('measure', false);
    this.ui.setControlVisible('measure2', false);
    this.ui.setControlVisible('fullscreen', false);
    this.ui.setControlVisible('credits', false);
    this.ui.setControlVisible('loading', true);
    this.time = Date.now();
};


UIControlLoading.prototype.hide = function() {
    this.hiding = Date.now();
    
    var search = this.ui.config.controlSearch;
    if (search && !this.ui.browser.config.controlSearchUrl) { //enable search for melown2015 reference frame only
        var map = this.ui.browser.getMap();
        if (map) {
            //search = (map.getReferenceFrame()["id"] == "melown2015");
            
            var radius = map.getSrsInfo(map.getReferenceFrame()['physicalSrs'])['a'];
            
            if (radius < (6378137 + 50000) && radius > (6378137 - 50000)) { //is it earth
                search = true;  
            } else {
                search = false;  
            }
            //search = (map.getSrsInfo(map.getReferenceFrame()["physical"]) == "melown2015");
        }
    } 
   
    this.ui.setControlVisible('compass', this.ui.config.controlCompass, false);
    this.ui.setControlVisible('zoom', this.ui.config.controlZoom, false);
    this.ui.setControlVisible('space', this.ui.config.controlSpace, false);
    this.ui.setControlVisible('search', search, false);
    this.ui.setControlVisible('link', this.ui.config.controlLink, false);
    this.ui.setControlVisible('github', this.ui.config.controlGithub, false);
    this.ui.setControlVisible('measure', this.ui.config.controlMeasure, false);
    this.ui.setControlVisible('measure2', this.ui.config.controlMeasureLite, false);
    this.ui.setControlVisible('fullscreen', this.ui.config.controlFullscreen, false);
    this.ui.setControlVisible('credits', this.ui.config.controlCredits, false);
    this.ui.setControlVisible('loading', false);
};


UIControlLoading.prototype.update = function() {
    var timer = Date.now();
    var timeDelta;

    if (this.hiding) { 
        timeDelta = (timer - this.hiding) * 0.001;
        this.loading.setStyle('opacity', (1-Math.min(1.0, timeDelta*2)) + '' );
        
        if (timeDelta > 0.5) {
            this.control.setVisible(false);
        }
    }


    timeDelta = (timer - this.time) * 0.001;

    //sine wave
    /*
    for (var i = 0; i < 5; i++) {
        this.dots[i].setStyle("top", (Math.sin(((Math.PI*1.5)/5)*i+timeDelta*Math.PI*2)*10)+"%");
    }*/

    //opacity    
    for (var i = 0; i < 5; i++) {
        //this.dots[i].setStyle("opacity", (Math.sin(((Math.PI*1.5)/5)*i+timeDelta*Math.PI*2)*60+20)+"%");
        this.dots[i].setStyle('opacity', (Math.sin(((Math.PI*1.5)/5)*i-timeDelta*Math.PI*2)*0.6+0.2));
    }

    var map = this.ui.browser.getMap();
    if (!map) {
        return;
    }

    var stats = map.getStats();

    if ((stats['surfaces'] == 0 && stats['freeLayers'] == 0) ||  //nothing to load 
        ((timer - this.time) > 7000) || //loading takes too long
        (stats['downloading'] == 0 && stats['lastDownload'] > 0 && (timer - stats['lastDownload']) > 1000) || //or everything loaded
        (stats['bestMeshTexelSize'] != 0 && stats['bestMeshTexelSize'] <= (stats['texelSizeFit'] * 3) || //or resolution is good enough
        (stats['loadMode'] == 'fit' || stats['loadMode'] == 'fitonly') && (stats['drawnTiles'] - stats['drawnGeodataTiles']) > 1) ) { //or at leas some tiles are loaded
        this.hide();
        this.ui.browser.callListener('loading-screen-hidden', {});
    }
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlLoading);


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlMap = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('map',
      '<div id="vts-map"'
      + ' class="vts-map">'
      + ' </div>', visible, visibleLock);

    var map = this.getMapElement();
    map.setDraggableState(true);
};


UIControlMap.prototype.getMapElement = function() {
    return this.control.getElement('vts-map');
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlMap);


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__measure__ = __webpack_require__(171);




//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */],
    UIControlMeasureIcon = __WEBPACK_IMPORTED_MODULE_1__measure__["b" /* UIControlMeasureIcon */],
    UIControlMeasureIcon2 = __WEBPACK_IMPORTED_MODULE_1__measure__["c" /* UIControlMeasureIcon2 */];


var UIControlMeasureLite = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('measure2',
      '<div id="vts-measure" class="vts-measure">'

        + '<img id="vts-measure-button"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon + '">'

        + '<img id="vts-measure-button2"'
          + ' class="vts-measure-button"'
          + ' src="' + UIControlMeasureIcon2 + '">'

        + '<div id="vts-measure-text-holder" class="vts-measure-text-holder">'
            + '<div class="vts-measure-text-holder2">'
                + '<div class="vts-measure-text">'
                  + '<textarea id="vts-measure-text-input" rows="6" cols="50" wrap="hard"></textarea>'
                + '</div>'
                + '<div class="vts-measure-tools">'
                    + '<div id="vts-measure-clear" class="vts-measure-tools-button">Clear</div>'
                + '</div>'
            + '</div>'
        + '</div>'

        + '<div id="vts-measure-info" class="vts-measure-info">'
        + '</div>'
        
     + ' </div>', visible, visibleLock);
     
    this.div = this.control.getElement('vts-measure');

    this.buttonOff = this.control.getElement('vts-measure-button');
    this.buttonOff.on('click', this.onSwitch.bind(this));
    this.buttonOff.on('dblclick', this.onDoNothing.bind(this));

    this.buttonOn = this.control.getElement('vts-measure-button2');
    this.buttonOn.on('click', this.onSwitch.bind(this));
    this.buttonOn.on('dblclick', this.onDoNothing.bind(this));

    this.info = this.control.getElement('vts-measure-info');

    var clearButton = this.control.getElement('vts-measure-clear');
    clearButton.on('click', this.onClear.bind(this));
    clearButton.on('dblclick', this.onDoNothing.bind(this));

    this.measuring = false;
    this.counter = 1;
    this.lastCoords = null;

    this.listPanel = this.control.getElement('vts-measure-text-holder');
    this.list = this.control.getElement('vts-measure-text-input');

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');
    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');
    }    

    this.onMouseMoveCall = this.onMouseMove.bind(this);
    this.onMouseLeaveCall = this.onMouseLeave.bind(this);
    this.onMouseClickCall = this.onMouseClick.bind(this);

    this.update();
};


UIControlMeasureLite.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);    
};

UIControlMeasureLite.prototype.onMouseLeave = function(event) {
    this.info.setStyle('display', 'none');
};


UIControlMeasureLite.prototype.onMouseClick = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var mapElement = this.ui.getMapElement();
    var state = mapElement.getDraggingState();

    //if (state['dragging']) { //TODO: why does not work this parameter? Fix it once you have time
      //  return;
    //}
    var delta = state['absMoved'];

    if ((delta[0]+delta[1]) > 0) {
        return;
    }

    var coords = event.getMouseCoords();
    var clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        return;
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    var str = '#' + this.counter + '  ' + clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + clickCoords[2].toFixed(2) + 'm';

    if (this.lastCoords) {
        var res = map.getDistance(this.lastCoords, clickCoords, false, true);
        var space = '\n   ';

        for (var i = 0, li = ('' + this.counter).length; i < li; i++) {
            space += ' ';
        }

        str += space + 'great-circle distance: ';

        if (res[0] > 100000) {
            str += '' + (res[0]*0.001).toFixed(2) + 'km';
        } else {
            str += '' + res[0].toFixed(2) + 'm';
        }

        str += space + 'elevation difference: ' + (clickCoords[2] - this.lastCoords[2]).toFixed(2) + 'm';
        str += space + 'euclidean distance: ';

        if (res[2] > 100000) {
            str += '' + (res[2]*0.001).toFixed(2) + 'km';
        } else {
            str += '' + res[2].toFixed(2) + 'm';
        }
    }

    this.counter++;
    this.lastCoords = clickCoords;

    var listElement = this.list.getElement();
    listElement.value += str + '\n';
    listElement.scrollTop = listElement.scrollHeight;    //scroll list to the last line
};

UIControlMeasureLite.prototype.onMouseMove = function(event) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var coords = event.getMouseCoords();
    var clickCoords = map.getHitCoords(coords[0], coords[1], 'fix');

    if (!clickCoords) {
        this.info.setStyle('display', 'none');
        return;    
    }

    clickCoords = map.convertCoordsFromNavToPublic(clickCoords, 'fix');

    var str = clickCoords[0].toFixed(7) + ', ' + clickCoords[1].toFixed(7) + ', ' + clickCoords[2].toFixed(2) + 'm';

    coords[0] -= this.divRect.left;
    coords[1] -= this.divRect.top;

    this.info.setStyle('display', 'block');
    this.info.setStyle('left', (coords[0]+20)+'px');
    this.info.setStyle('top', (coords[1]+10)+'px');
    this.info.setHtml(str);
};

UIControlMeasureLite.prototype.onSwitch = function() {
    this.measuring = !this.measuring;

    var mapElement = this.ui.getMapElement();

    if (this.measuring) {
        this.buttonOn.setStyle('display', 'block');
        this.buttonOff.setStyle('display', 'none');

        this.divRect = this.div.getRect();

        mapElement.on('mousemove', this.onMouseMoveCall);
        mapElement.on('mouseleave', this.onMouseLeaveCall);
        mapElement.on('click', this.onMouseClickCall);

    } else {
        this.buttonOn.setStyle('display', 'none');
        this.buttonOff.setStyle('display', 'block');

        mapElement.off('mousemove', this.onMouseMoveCall);
        mapElement.off('mouseleave', this.onMouseLeaveCall);
        mapElement.off('click', this.onMouseClickCall);
    }

    this.updateLink();
    this.update();
};

UIControlMeasureLite.prototype.onClear = function() {
    this.counter = 1;
    this.lastCoords = null;

    var listElement = this.list.getElement();
    listElement.value = '';
    listElement.scrollTop = 0;
};

UIControlMeasureLite.prototype.update = function() {
    //var button = this.control.getElement('vts-measure-button');
    
    var left = 10 + (this.ui.config.controlZoom ? 70 : 0) +
                (this.ui.config.controlSpace ? 35 : 0);
    
    this.div.setStyle('left', left + 'px');
    this.listPanel.setStyle('display', this.measuring ? 'block' : 'none');
};


UIControlMeasureLite.prototype.updateLink = function() {
    /*
    var linkValue =  this.browser.getLinkWithCurrentPos();
    if (this.list.getElement().value != linkValue) {
        this.list.getElement().value = linkValue;
    }*/
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlMeasureLite);


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

var UIControlPopup = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('popup',
        '<div class="vts-popup-background" id="vts-popup-background">'
      +    '<div id="vts-popup"</div>'
      + '</div>', visible, visibleLock);

    this.lastHTML = '';
    this.popup = this.control.getElement('vts-popup');
    this.background = this.control.getElement('vts-popup-background');
    this.background.on('click', this.hide.bind(this));
};


UIControlPopup.prototype.show = function(style, html) {
    this.control.setVisible(true);
    
    for (var key in style) {
        this.popup.setStyle(key, style[key]);
    }

    this.popup.setHtml(html);
};


UIControlPopup.prototype.hide = function() {
    this.control.setVisible(false);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlPopup);


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_utils_math__ = __webpack_require__(4);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filterSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nofilterSearch; });



//get rid of compiler mess
var math = __WEBPACK_IMPORTED_MODULE_0__core_utils_math__["a" /* math */];

// Deduplication of hits, that have the same display_name
// and are subsequent in a result set. 
function dedupe(hits) {
    var hit, result = [], dupes = [];

    // Helper function, that takes set of duplicities
    // and returns just one hit.
    //
    // we return first populated place  - if exist
    // or if not exist we return just first one 
    var filterHits = (function(dupes){
        for (var j = 0; j < dupes.length; j++) {
            switch (dupes[j].type) {
                case 'hamlet':
                case 'village':
                case 'town':
                case 'city':
                    return dupes[j];
            }
        }

        return dupes[0];
    });

    // We go through all hits and separate results 
    // and duplicities
    for (var i = 0; i < hits.length - 1; i++) {
        hit = hits[i];

        if (hit.display_name === hits[ i + 1 ].display_name) {
            dupes.push(hit);
        } else {
            if (dupes.length > 0) {
                dupes.push(hit);
                result.push(filterHits(dupes));
                dupes.length = 0;
            } else {
                result.push(hit);
            }
        }
    }

    // Make sure filterHits is called
    if (dupes.length) {
        result.push(filterHits(dupes));
    }

    return result;
}

function getDistance(lon1, lat1, lon2, lat2) {
    var r = 6371e3; // metres
    var l1 = math.radians(lat1);
    var l2 = math.radians(lat2);
    var dlat = math.radians(lat2-lat1);
    var dlon = math.radians(lon2-lon1);

    var a = Math.sin(dlat/2) * Math.sin(dlat/2) +
            Math.cos(l1) * Math.cos(l2) *
            Math.sin(dlon/2) * Math.sin(dlon/2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return r * c;
}

// Stupid unprecise comparsion of two points, if 
// they lay close to each other (less than 10km)
function layClose(A, B) {
    //return ruler.distance([ A.lon, A.lat ], [ B.lon, B.lat ] ) < 10
    var diff = 0.1;

    return ( +B.lat > +A.lat - diff ) && ( +B.lat < +A.lat + diff )
        && ( +B.lon > +A.lon - diff ) && ( +B.lon < +A.lon + diff );
}

// Hits with low importance can be reshaked by its distance
function reshakeHits(hits) {
    var maxDiff = 0.06;
    var maxRank = 0.4;
    var temp, done;

    do {
        done = true;

        for (var i = 0; i < hits.length - 1; i++ ) {
            var h1 = hits[i];
            var h2 = hits[i + 1];

            if (( h1.rank < maxRank && h2.rank < maxRank ) // both hits have lowRank
                && ( Math.abs( h1.rank - h2.rank ) < maxDiff ) // ...and diff in their rank is small
                && ( h1.distance > h2.distance ) // ...and h1 has bigger distance
                ) {

                // Switch both hits
                h1.note = 'reshaked-down'
                h2.note = 'reshaked-up'

                temp = h1;
                hits[i] = h2;
                hits[i + 1] = temp;
                done = false;
            }
        }
    } while (!done);
}

function nofilterSearch(data, lon, lat) {
    var rtrn = [];
    var hits = data;
    var hasLocation = lat && lon;
    var rtrnHit, hit;

    //Cycle each hit and reduce uts size
    for (var i = 0; i < hits.length; i++) {
        hit = hits[i];

        rtrnHit = { 
            lat: +hit.lat, 
            lon: +hit.lon,  
            title: hit.display_name,
            rank: hit.importance || 1,
            country: '', 
            region: '',
            state: '',
            cc: '',
            type: '', 
            bounds: hit.boundingbox,
            polygon : [],
            bbox : hit.boundingbox
        }

        // Calculate distance
        if (hasLocation) {
            rtrnHit.distance = getDistance(lon, lat, rtrnHit.lon, rtrnHit.lat);
        }

        rtrn.push(rtrnHit);
    }

    return rtrn;
}

// Return Promise, that resolves nice deduplicated results from 
// Nominatim (on particular keyword)
function filterSearch(data, lon, lat) {
    var rtrn = [];
    var hasLocation = lat && lon;
    var hits = data;

    /*
    // Should we search ZIP code? 
    var querySubString = ( /^\d{3,5}$/.test( query ) ) ? 
                            `postalcode=${  query }` : `q=${ encodeURIComponent( query ) }`

    var url = `${ searchServer }search.php?format=json&limit=20&addressdetails=1&${ querySubString }&accept-language=${lang}`;      

    if( program.dev ) log.info(url);
    */

    var rtrnHit, hit, adr, region, county, display, bounds;

    // Deduplication number 1: Deduplicate consequent 
    // results with same name
    if( hits.length > 1) {
        hits = dedupe( hits );
    }

    //Cycle each hit and reduce uts size
    for (var i = 0; i < hits.length; i++) {

        // Shortcuts
        hit = hits[i];

        bounds = hit.boundingbox;

        adr = hit.address;

        display = hit.display_name.replace(/,.*/,'');

        region = adr.state && adr.state 
                    || ( adr.state_district && adr.state_district ||
                            ( adr.county && adr.county || '' ) );

        county = adr.county && adr.county 
                    || ( adr.state_district && adr.state_district || region );

        // If county is same as title, find 
        // something better         
        if (county === display) {
            county = adr.state_district && adr.state_district || region;
        }

        // Deduplication number 2: Simple process of throwing away hits
        // that have lower importance, and lay in vicinity
        // of previous hit
        if (rtrnHit && layClose(rtrnHit, hit)) continue;

        // Filter out results with low, low low importance
        // but only if there is more results
        if (hit.importance < 0.01 && i > 5) continue;

        // Rewrite these types of regions
        // "Graubnden - Grigioni - Grischun" --> "Graubunder"
        if (new RegExp(/ - /).test( region )) {
            region = region.replace(/ -.*/,'');
        }

        // Should we display bounds instead of dot in a map?            
        if (hit.type === 'archipelago'  || 
            ( hit.type === 'administrative' && 
            (display === adr.country || display === region ))) {            

            // Repair undefined lon values in bounds
            if( bounds[2] === '-180' ) {
                bounds[2] = bounds[3] = hit.lon;
            }

        } else {
            bounds = null;
        }

        // Changes display name in adress querries like "Kopeckeho 27"
        if (display === adr.house_number && adr.road ) {
            display = adr.road;
        }

        rtrnHit = { 
            lat: +hit.lat, 
            lon: +hit.lon,  
            title: display,

            rank: hit.importance,

            // for US we use State as country 
            country: adr.country_code === 'us' ? region : ( adr.country && adr.country.replace(/,.*/,'')  ), 

            display: hit.display_name,
            region: county || '',
            state: region || '',
            cc: adr.country_code,
            type: hit.type, 
            bounds: bounds,
            polygon : hit.polygonpoints || [],
            bbox : hit.boundingbox
        }

        // Calculate distance
        if (hasLocation) {
            rtrnHit.distance = getDistance(lon, lat, rtrnHit.lon, rtrnHit.lat);
        }


        rtrn.push(rtrnHit)
    }

    // Reshake hits by distance
    if (hasLocation) { 
        reshakeHits(rtrn);
    }

    return rtrn;
}   

// return query on reverse search
/*
function geoSearch = ( { lat,lon,zoom,lang } ) => {
    var url = `${ searchServer }reverse.php?format=json&lat=${ lat }&lon=${ lon }&zoom=${ zoom }&addressdetails=1&accept-language=${ lang }`
    return rp.get(url,{ timeout: 3000, json: true })
} 
*/              




/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__search_filter__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_utils_math__ = __webpack_require__(4);







//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];
var vec3 = __WEBPACK_IMPORTED_MODULE_3__core_utils_matrix__["b" /* vec3 */];
var math = __WEBPACK_IMPORTED_MODULE_4__core_utils_math__["a" /* math */];
var utils = __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__["a" /* utils */];
var filterSearch = __WEBPACK_IMPORTED_MODULE_2__search_filter__["a" /* filterSearch */];
var nofilterSearch = __WEBPACK_IMPORTED_MODULE_2__search_filter__["b" /* nofilterSearch */];

var UIControlSearch = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    
    var element = this.browser.config.controlSearchElement;
    if (element) {
        if (typeof element === 'string') {
            element = document.getElementById(element);
        }
    }
    
    this.control = this.ui.addControl('search',
      '<div class="vts-search">'
      + '<div class="vts-search-input"><input type="text" id="vts-search-input" autocomplete="off" spellcheck="false" placeholder="Search location..."></div>'      
      + '<div id="vts-search-list" class="vts-search-list"></div>'      
      + '</div>', visible, visibleLock, element);

    this.input = this.control.getElement('vts-search-input');
    
    //this.input.on("change", this.onChange.bind(this));
    this.input.on('input', this.onChange.bind(this));
    this.input.on('keydown', this.onKeyUp.bind(this));
    this.input.on('focus', this.onFocus.bind(this));
    this.input.on('mousedown', this.onDrag2.bind(this));
    this.input.on('mousewheel', this.onDrag.bind(this));
    this.input.on('dblclick', this.onDoNothing.bind(this));

    this.list = this.control.getElement('vts-search-list');
    this.list.on('mousedown', this.onDrag2.bind(this));
    this.list.on('mousewheel', this.onDrag.bind(this));

    this.mapControl = this.ui.getMapControl();
    this.mapElement = this.mapControl.getMapElement();
    this.mapElement.on('mousedown', this.onDrag.bind(this), window);
    this.mapElement.on('mousewheel', this.onDrag.bind(this), window);

    this.ignoreDrag = false; 

    this.urlTemplate = '//cdn.melown.com/vtsapi/geocode?q={value}&format=json&lang=en-US&addressdetails=1&limit=20';
    this.urlTemplate2 = this.urlTemplate;
    this.data = [];
    this.lastSearch = '';
    this.itemIndex = -1;
    this.searchCounter = 0;
    this.coordsSrs = '+proj=longlat +datum=WGS84 +nodefs';

    this.initialValueUsed = false;

    if (this.browser.config.controlSearchValue) {
        this.initialValueUsed = true;
        this.input.getElement().value = this.browser.config.controlSearchValue;
        this.onChange();
    }
};


UIControlSearch.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);    
    dom.stopPropagation(event);    
};


UIControlSearch.prototype.processTemplate = function(str, obj) {
    return str.replace(/\{([$a-zA-Z0-9][$a-zA-Z0-9]*)\}/g, function(s, match) {
        return (match in obj ? obj[match] : s);
    });
};


UIControlSearch.prototype.showList = function() {
    this.list.setStyle('display', 'block');
};


UIControlSearch.prototype.hideList = function() {
    //this.data = {};
    this.list.setStyle('display', 'none');
};


UIControlSearch.prototype.moveSelector = function(delta) {
    //this.data = {};
    this.itemIndex += delta;

    if (this.itemIndex >= this.data.length) {
        this.itemIndex = this.data.length - 1;
    }
    
    if (this.itemIndex < 0) {
        this.itemIndex = 0;
    }
    
    this.updateList(this.data);
};


UIControlSearch.prototype.updateList = function(json) {
    if (Array.isArray(json)) {
        var data = json, item, list = '';
        data = data.slice(0,10);
        this.data = data;

        for (var i = 0, li = data.length; i < li; i++) {
            item = data[i];

            var title = '';

            if (this.coords && i == 0) {
                title = 'location: ';
            }

            title += item['title'] + '<small>';

            if (item['region'] && item['title'] != item['region']) {
                title += ', ' + item['region'];
            }

            if (item['country'] && item['title'] != item['country'] && item['region'] != item['country']) {
                title += (item['region'] ? ', ' : '') + item['country'];
            }

            title += '</small>';

            if (this.itemIndex == i) {
                list += '<div id="vts-search-item' + i + '"'+ ' class="vts-search-listitem-selected">' + title + '</div>';
            } else {
                list += '<div id="vts-search-item' + i + '"'+ ' class="vts-search-listitem">' + title + '</div>';
            }
                
        }
        
        this.list.setHtml(list);

        for (i = 0, li = data.length; i < li; i++) {
            var id = 'vts-search-item' + i;
            item = this.control.getElement(id);
            
            if (item) {
                item.on('click', this.onSelectItem.bind(this, i));
                item.on('mouseenter', this.onHoverItem.bind(this, i));
            }
        }

        if (!this.initialValueUsed) {
            this.showList();
        }
    } else {
        this.hideList();
    }
};

UIControlSearch.prototype.solveSRS = function(srs) {
    if (srs.indexOf('+proj=') == -1) { //no proj4 string
        srs = map.getSrsInfo(srs);
        if (srs && srs['srsDef']) {
            srs = srs['srsDef'];
        } else {
            srs = this.coordsSrs;            
        }
    }

    return srs;
};

UIControlSearch.prototype.onSelectItem = function(index) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }
    
    //sort list with polygons
    var pos = map.getPosition();
    var refFrame = map.getReferenceFrame();
    var navigationSrsId = refFrame['navigationSrs'];
    var navigationSrs = map.getSrsInfo(navigationSrsId);
    var physicalSrsId = refFrame['physicalSrs'];
    var physicalSrs = map.getSrsInfo(physicalSrsId);

    var proj4 = this.browser.getProj4();
    var srs = this.browser.config.controlSearchSrs || this.coordsSrs;
    srs = this.solveSRS(srs);

    var coords = proj4(navigationSrs['srsDef'], srs, pos.getCoords());

    pos = map.convertPositionHeightMode(pos, "float", true);

    var item = this.data[index];
    if (item) {
        var coords = [item['lon'], item['lat']];
        
        //conver coords from location srs to map navigation srs         
        coords = proj4(srs, navigationSrs['srsDef'], coords);
        coords[2] = 0;

        pos.setCoords(coords);

        var viewExtent = 6667;                

        if (item.bbox) {
            var lat1 = parseFloat(item.bbox[0]);
            var lat2 = parseFloat(item.bbox[1]);
            var lon1 = parseFloat(item.bbox[2]);
            var lon2 = parseFloat(item.bbox[3]);

            item.polygon = [
                [lon1, lat1], [(lon2+lon1)*0.5, lat1], [lon2, lat1],
                [lon1, (lat2+lat1)*0.5],  [lon2, (lat2+lat1)*0.5],
                [lon1, lat2], [(lon2+lon1)*0.5, lat2], [lon2, lat2]
            ];
        }

        if (item.polygon && item.type != 'continent') {
            var points = item.polygon;

            //convert point to physical coords
            var cameraPosition = proj4(srs, physicalSrs['srsDef'], coords);
            var cameraVector = [-cameraPosition[0], -cameraPosition[1], -cameraPosition[2]];
            vec3.normalize(cameraVector);

            for (var i = 0, li = points.length; i < li; i++) {
                //convert point to physical coords
                coords = proj4(srs, physicalSrs['srsDef'], [points[i][0], points[i][1], 0]);

                var ab = cameraVector;
                var av = [coords[0] - cameraPosition[0], coords[1] - cameraPosition[1], coords[2] - cameraPosition[2]];

                //final R3 bv  = v.sub( b ) ;
                var b = [cameraPosition[0] + cameraVector[0], cameraPosition[1] + cameraVector[1], cameraPosition[2] + cameraVector[2]];
                var bv = [coords[0] - b[0], coords[1] - b[1], coords[2] - b[2]];

                var af = [0,0,0];
                vec3.cross(ab, av, af);

                var d = (vec3.length(bv) / vec3.length(ab)) * 2;

                if (d > viewExtent) {
                    viewExtent = d;
                }
            }

            if (navigationSrs['type'] != 'projected') {
                if (viewExtent > navigationSrs['a']*1.4) {
                    viewExtent = navigationSrs['a']*1.4;
                }
            }
        } else {
            //try to guess view extent from location type
            switch(item.type) {
            case 'peak':        viewExtent = 20000;   break;
            case 'city':        viewExtent = 30000;   break;                
            case 'street':      viewExtent = 4000;    break;
            case 'residential': viewExtent = 3000;    break;
            case 'continent':   viewExtent = 8550000; break;             
            case 'pos':         viewExtent = 150000;  break;             
            }
        }
        
        pos.setViewExtent(viewExtent);                

        var orientation = [0,-60,0];

        //reduce tilt when you are far off the planet
        if (pos.getViewMode() == 'obj') {
            if (navigationSrs['a']) {
                var distance = (pos.getViewExtent()*0.5) / Math.tan(math.radians(pos.getFov()*0.5));
                var factor = Math.min(distance / (navigationSrs['a']*0.5), 1.0);
                var maxTilt = 20 + ((-90) - 20) * factor; 
                var minTilt = -90; 
                
                if (orientation[1] > maxTilt) {
                    orientation[1] = maxTilt;
                }
        
                if (orientation[1] < minTilt) {
                    orientation[1] = minTilt;
                }
            }
        }

        pos.setOrientation(orientation);
        map.setPosition(pos);
        
        this.itemIndex = index;
        this.lastSearch = item['title'];
        
        var element = this.input.getElement();  
        element.value = this.lastSearch;
        element.blur(); //defocus 
    }

    this.hideList();
};


UIControlSearch.prototype.onHoverItem = function(index) {
    if (this.itemIndex == index) {
        return;
    }

    this.itemIndex = index;
    this.updateList(this.data);
};


UIControlSearch.prototype.onListLoaded = function(counter, data) {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.searchCounter == counter) {

        var pos = map.getPosition();
        var refFrame = map.getReferenceFrame();
        var navigationSrsId = refFrame['navigationSrs'];
        var navigationSrs = map.getSrsInfo(navigationSrsId);

        var proj4 = this.browser.getProj4();
        var srs = this.browser.config.controlSearchSrs || this.coordsSrs;
        srs = this.solveSRS(srs);

        var coords = proj4(navigationSrs['srsDef'], srs, pos.getCoords());

        if (this.browser.config.controlSearchFilter) {
            data = filterSearch(data, coords[0], coords[1]);
        } else {
            data = nofilterSearch(data, coords[0], coords[1]);
        }

        if (this.coords) {
            data.unshift({
                'title' : ('' + this.coords[0].toFixed(6) + ' ' + this.coords[1].toFixed(6)),
                'lat' : this.coords[0],
                'lon' : this.coords[1],
                'type': 'pos'
            });
        }

        this.updateList(data);
    }
};


UIControlSearch.prototype.onListLoadError = function() {
};


UIControlSearch.prototype.onFocus = function() {
    this.lastSearch = '';
    var element = this.input.getElement();  
    element.value = this.lastSearch;
    this.hideList();
};


UIControlSearch.prototype.onKeyPress = function(event) {
    //console.log('press');

    this.onKeyUp(event);
};


UIControlSearch.prototype.onKeyUp = function(event) {
    var code = event.getKeyCode();
    
    switch(code) {
    case 38:  //up
        this.moveSelector(-1);
        dom.preventDefault(event);
        dom.stopPropagation(event);    
        break;

    case 40:  //down
        this.moveSelector(1); 
        dom.preventDefault(event);
        dom.stopPropagation(event);    
        break;

    case 9:  //tab
    case 13: //enter
        
        this.onSelectItem(Math.max(0,this.itemIndex), null); 
        break;
    }
};


UIControlSearch.prototype.parseLatLon = function(value) {
    if (value.replace(/\d+/, '') == value) {
        return null;
    }

    value = value.replace(',',' ');
    value = (value.replace(/  +/g, ' ')).trim().toLowerCase();
    var words = value.split(' '), lat, lon, i;
    var lastChar, lastChar2, skip, part, numbers, num;

    //simple case of two numbers
    if (words.length == 2 && value.indexOf('n') == -1 && value.indexOf('s') == -1 &&
        value.indexOf('w') == -1 && value.indexOf('e') == -1 ) {

        lastChar = words[0].charAt(words[0].length - 1);
        lastChar2 = words[1].charAt(words[1].length - 1);
        skip = false;

        //are numbers in degrees? 
        if (lastChar == '' || lastChar == "'" || lastChar == '"') {
            if (lastChar2 == '' || lastChar2 == "'" || lastChar2 == '"') {
                words[0] = words[0] + 'n';
                words[1] = words[1] + 'e';
                value = words.join();
            }
        }

        if (!skip) {
            if (!isNaN(words[0]) && !isNaN(words[1])) {
                lat = parseFloat(words[0]);
                lon = parseFloat(words[1]);

                if (!isNaN(lat) && !isNaN(lon)) {

                    if (lat > 90 || lat < -90) {
                        return null;
                    }

                    if (lon > 360 || lon < -360) {
                        return null;
                    }

                    return[lat, lon];
                }
            }
        }

       return null;
    }

    var parts = value.split(/['"]+/).join(' ').split(/[^\w\S]+/);

    //check wheteher it make sence to pase it further
    lat = 0, lon = 0, numbers = 0;

    var lengthCheck = false;

    for (i in parts) {
        part = parts[i];

        if (isNaN(part)) {
            num = parseFloat(part);
            lengthCheck = true;
            lastChar = part.charAt(part.length - 1);

            if (!isNaN(num)) {
                numbers++;
                lengthCheck = false;
            } 

            if (!lengthCheck || (part.length == 1)) {
                if (lastChar == 'w' || lastChar == 'e') {
                    lat++;
                }

                if (lastChar == 'n' || lastChar == 's') {
                    lon++;
                }
            }

        } else {
            numbers++;
        }
    }

    if (!(lat == 1 && lon ==1)) {
        return null;
    }

    // parse complex lat lon in degrees with directions
    var directions = [];
    var coords = [];
    var dd = 0;
    var pow = 0;
    var numberCount = 0;

    for (i in parts) {

        // we end on a direction
        if (isNaN(parts[i])) {
            var direction = parts[i];
            num = parseFloat(parts[i]);

            if (!isNaN(num)) {
                dd += ( num / Math.pow( 60, pow++ ) );
                direction = parts[i].replace( num, '' );
                numberCount++;
            }

            direction = direction[0];

            if (direction == 's' || direction == 'w') {
                dd *= -1;
            }

            directions[directions.length] = direction;
            coords[coords.length] = dd;
            dd = pow = 0;

        } else {
            num = parseFloat(parts[i]);

            if (!isNaN(num)) {
                dd += ( num / Math.pow( 60, pow++ ) );
                numberCount++;
            }
        }
    }

    if (coords.length != 2 || numberCount < 2 || isNaN(coords[0]) || isNaN(coords[1])) {
        return null;
    }

    if (directions[0] == 'w' || directions[0] == 'e') {
        var tmp = coords[0];
        coords[0] = coords[1];
        coords[1] = tmp;
    }

    if (coords[0] > 90 || coords[0] < -90) {
        return null;
    }

    if (coords[1] > 360 || coords[1] < -360) {
        return null;
    }

    return coords;
}

UIControlSearch.prototype.onChange = function() {
    var value = this.input.getElement().value;
    value = value.trim();

    //console.log("value: " + value + "  last-value: " + this.lastSearch);

    if (value == this.lastSearch) {
        //console.log("value-same");
        return;        
    }
    
    this.lastSearch = value;
    
    if (value == '') {
        //console.log("value-null");
        this.hideList();        
    }

    this.coords = this.parseLatLon(value);
   
    var url = this.processTemplate(this.browser.config.controlSearchUrl || this.urlTemplate, { 'value' : value });
    //console.log(url);
    this.searchCounter++;
    this.itemIndex = -1;
   
    utils.loadJSON(url, this.onListLoaded.bind(this, this.searchCounter), this.onListLoadError.bind(this));
};


UIControlSearch.prototype.onDrag2 = function() {
    this.ignoreDrag = true; 
    //var element = this.input.getElement();  
};


UIControlSearch.prototype.onDrag = function() {
    if (this.ignoreDrag) {
        this.ignoreDrag = false;
        return; 
    } 

    var element = this.input.getElement();  
    element.value = this.lastSearch;
    element.blur(); //defocus'
    this.hideList(); 
};


UIControlSearch.prototype.update = function() {
    if (this.initialValueUsed && this.browser.mapLoaded) {
        this.initialValueUsed = false;
        this.onSelectItem(0);
    }
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlSearch);


/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__control_mode_map_observer__ = __webpack_require__(170);


var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];


var constrainMapPosition = __WEBPACK_IMPORTED_MODULE_1__control_mode_map_observer__["b" /* constrainMapPosition */];


var UIControlSpace = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('space',
      '<div id="vts-space"'
      + ' class="vts-space">'

        + '<img id="vts-space-2d"'
          + ' class="vts-space-button"'
          + ' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAABqElEQVRIx+2UsWoUURSGv3Nn1sIiaKMBSbD0AdRBdmbdB7DMA0gaSSVRbFRYiGAaUWJhEAQVEey10yacO/gAwqZNSKWwhShs4ew9NtewTDI6sRCE/at7h8P/nfnvuRdmmum/lkxvut1u5pwbAOfNrAMMzWy9LMt3v2qKorCaRwC+A9vApqq+bITkeX4Z+CAiab3IzJa9988bIPXaR977G9Pf3NT6joikZvYmSZL5JElOAPcBRORu3UxVRVVlNBodCyEsmtkAMBFZjQ3va79rETluZl+rqrrpvf8c41t3zt0GFpo6Hw6HP4A9YK0oinlgRUSuAVsHIKqaH8hSJIsR7LQ54KqqNtI0XTGzS01xURuCBeBZhD1pAzGz3Vh/+o+QXq93zjnnReSsmb1W1Y0jTm3yW0ie5xdDCB5YNLMX4/H4KmAtzc/EP/py6MHH8bwAvAfmgDXv/eAo7Xc6nSsxro+HQrIsO2Vmb0VkDrilqg9aert+v39yMpksAfciZLPpMj4UkdUmJ1WVNpcReKyq15viWvrLp8mAb8CnEMLTsixfzV7rmf6dfgKmzKAWE7bqxgAAAABJRU5ErkJggg==">'

        + '<img id="vts-space-3d"'
          + ' class="vts-space-button"'
          + ' src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAB8klEQVRIx+1Uv4sTQRT+3mRygyDInYXFabaxsRNOIiG7mEPQxsJCLQVF8AeiaCNWigrWiniCVfA/0Eo4ONnZ4P4FURAL9yyCEMQfRMzs7LOZk2HZxNgIQr7qzbw373t838wAc8zxX4P8RbvdPimEuMLM+4loAcAmM3eTJLkHgAEgiiIu9SgAfAfwBsCa1rpbJqltBWEYXhBCdAE0HEENwBIRrQZBQFmWvQKAIAhuVwyqAOwGcLzRaOzIsuylXyB+VxKdc+FTY8yyMWZbURSn3N7l8nRaa9Ja03A4XCiKosHMtwAwEV0Lw/BQJYnW+oAxZu9oNLqUpulASrmdiPa49GCS3v1+3/R6vc0kSe4AeOIGPu/XSH+Rpul7J906ER0GAGYeADgzi8F5nj+QUl5k5tZEEk+6fV6sfO+mgZk/uDO7KuUqYcUYswTgGYBFAPf/8tbW/kiitR6kafqZma+7CVdmbL7s6j9VyhVF0QtmbuV5fnDLm/F4rJRSICKehaFerx9zcr2uJGHmn0S0U0r5uNlsnlVKWQCPXG5jSm/R6XQWrbUnANx1JGuTjL/JzEeJ6IhS6qNH/kUIcaPc2X/51lo/9TCO441KT5IkeWetXQWwDuAHgG/M/BxAK47jt9MuFYCvAHpFUZzWWl+d/9Zz/Dv8ApJPyD0fWCwOAAAAAElFTkSuQmCC">'

     + ' </div>', visible, visibleLock);
     
    this.button2D = this.control.getElement('vts-space-2d');
    this.button2D.on('click', this.onSwitch.bind(this));
    this.button2D.on('dblclick', this.onDoNothing.bind(this));

    this.button3D = this.control.getElement('vts-space-3d');
    this.button3D.on('click', this.onSwitch.bind(this));
    this.button3D.on('dblclick', this.onDoNothing.bind(this));

    this.space3D = true;
    this.display3D = this.space3D;

    if (this.space3D) {
        this.button2D.setStyle('display', 'block');
        this.button3D.setStyle('display', 'none');
    } else {
        this.button2D.setStyle('display', 'none');
        this.button3D.setStyle('display', 'block');
    }
};


UIControlSpace.prototype.onDoNothing = function(event) {
    dom.stopPropagation(event);    
};


UIControlSpace.prototype.onSwitch = function() {
    this.space3D = !this.space3D;

    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }

    var pos = map.getPosition();
    var orientation = pos.getOrientation();

    if (this.space3D) {
        orientation[0] = 45;
        orientation[1] = -60;
        //pos = map.setPositionFov(pos, 90);
        pos.setOrientation(orientation);
    } else {
        orientation[0] = 0;
        orientation[1] = -90;
        //pos = map.setPositionFov(pos, 5);
        pos.setOrientation(orientation);
    }

    pos = constrainMapPosition(this.browser, pos);
    map.setPosition(pos);
    
    this.update();
};


UIControlSpace.prototype.update = function() {
    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    var pos = map.getPosition();
    var orientation = pos.getOrientation();

    var space3D = (Math.abs(orientation[1]+90) > 0.1);

    if (space3D != this.display3D) {
        if (space3D) {
            this.button2D.setStyle('display', 'block');
            this.button3D.setStyle('display', 'none');
        } else {
            this.button2D.setStyle('display', 'none');
            this.button3D.setStyle('display', 'block');
        }

        this.space3D = space3D;
        this.display3D = space3D;
    }
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlSpace);


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);



//get rid of compiler mess
var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];


var UIControlZoom = function(ui, visible, visibleLock) {
    this.ui = ui;
    this.browser = ui.browser;
    this.control = this.ui.addControl('zoom',
      '<div id="vts-zoom"'
      + ' class="vts-zoom">'

        + '<div id="vts-zoom-plus" class="vts-zoom-plus">'
            + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAASUlEQVRIx+2Tyw0AIAhDq0d2KsMzFFddQBO9+En6rqR5kFBAiBVINpJtJ1NPLCbJe5IyG7j78IMyEwBgZsNcRJQrl6gnkgjxIx12Cg3wDaLBUAAAAABJRU5ErkJggg==">'
        + '</div>'

        + '<div id="vts-zoom-minus" class="vts-zoom-minus">'
          + '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAZCAYAAADE6YVjAAAALUlEQVRIx2NgGAWjYBSMAqoCRlwSdnZ2/8kx8NChQxhmMo2G8ygYBaNgFGAHAElYBARpOBYqAAAAAElFTkSuQmCC">'
        + '</div>'

     + ' </div>', visible, visibleLock);

    var plus = this.control.getElement('vts-zoom-plus');
    plus.on('click', this.onZoomIn.bind(this));
    plus.on('dblclick', this.onDoNothing.bind(this));

    var minus = this.control.getElement('vts-zoom-minus');
    minus.on('click', this.onZoomOut.bind(this));
    minus.on('dblclick', this.onDoNothing.bind(this));
};


UIControlZoom.prototype.onDoNothing = function(event) {
    dom.preventDefault(event);    
    dom.stopPropagation(event);    
};


UIControlZoom.prototype.onZoomIn = function() {
    this.repeat(7, 0.96, 50);
};


UIControlZoom.prototype.onZoomOut = function() {
    this.repeat(7, 1.04, 50);
};


UIControlZoom.prototype.repeat = function(count, factor, delay) {
    if (count <= 0) {
        return;
    }

    var map = this.browser.getMap();
    if (!map) {
        return;
    }

    if (this.browser.autopilot) { //stop autorotation
        this.browser.autopilot.setAutorotate(0);
        this.browser.autopilot.setAutopan(0,0);
    }
    
    var controller = this.browser.controlMode.getCurrentController();
    
    if (controller.viewExtentDeltas) {
        controller.viewExtentDeltas.push(factor);
    }

    setTimeout(this.repeat.bind(this, --count, factor, delay), delay);
};


/* harmony default export */ __webpack_exports__["a"] = (UIControlZoom);


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utility_dom__ = __webpack_require__(9);




//get rid of compiler mess
var UIEvent = __WEBPACK_IMPORTED_MODULE_0__event__["a" /* default */];
var dom = __WEBPACK_IMPORTED_MODULE_1__utility_dom__["a" /* default */];


var UIElement = function(control, element) {
    this.control = control;
    this.ui = this.control.ui;
    this.element = element;
    this.events = [];
    this.dragBeginCall = this.onDragBegin.bind(this, false);
    this.dragBeginCallTouch = this.onDragBegin.bind(this, true);
    this.dragMoveCall = this.onDragMove.bind(this, false);
    this.dragMoveCallTouch = this.onDragMove.bind(this, true);
    this.dragEndCall = this.onDragEnd.bind(this, false);
    this.dragEndCallTouch = this.onDragEnd.bind(this, true);
    this.firstDragDistance = 0;
    this.lastDragDistance = 0;
    this.dragStartPos = [0,0];
    this.dragCurrentPos = [0,0];
    this.dragLastPos = [0,0];
    this.dragAbsMoved = [0,0];
    this.zoomDrag = false;
};


UIElement.prototype.setStyle = function(key, value) {
    this.element.style[key] = value;
};


UIElement.prototype.getStyle = function(key) {
    return this.element.style[key];
};


UIElement.prototype.setClass = function(name) {
    dom.setClass(this.element, name);
    return this;
};


UIElement.prototype.getClass = function() {
    dom.getClass(this.element);
    return this;
};


UIElement.prototype.hasClass = function(name) {
    return dom.hasClass(this.element, name);
};


UIElement.prototype.addClass = function(name) {
    dom.addClass(this.element, name);
    return this;
};


UIElement.prototype.removeClass = function(name) {
    dom.removeClass(this.element, name);
    return this;
};


UIElement.prototype.getRect = function() {
    var rect = this.element.getBoundingClientRect();
    var rect2 = this.ui.map.getMapElement().element.getBoundingClientRect();
    var offsetX = window.pageXOffset || 0;
    var offsetY = window.pageYOffset || 0;
    return {
        'left' : (rect.left + offsetX) - (rect2.left + offsetX), 
        'top' : (rect.top + offsetY) - (rect2.top + offsetY), 
        'fromRight' : rect2.right - ((rect.left + offsetX) - (rect2.left + offsetX)), 
        'fromBottom' : rect2.height - ((rect.top + offsetY) - (rect2.top + offsetY)),
        'width' : rect.width, 
        'height' : rect.height 
    };
};


UIElement.prototype.getPageRect = function() {
    var rect = this.element.getBoundingClientRect();
    var offsetX = window.pageXOffset || 0;
    var offsetY = window.pageYOffset || 0;
    return {
        'left' : (rect.left + offsetX), 
        'top' : (rect.top + offsetY), 
        'width' : rect.width, 
        'height' : rect.height 
    };
};


UIElement.prototype.setHtml = function(html) {
    this.element.innerHTML = html;
    
    var allElements = this.element.getElementsByTagName('*');

    //store all elements with id attribute to the table
    for (var i = 0, li = allElements.length; i < li; i++) {
        var id = allElements[i].getAttribute('id');

        if (id !== null) {
            //store element to the table
            this.control.elementsById[id] = new UIElement(this, allElements[i]);
        }
    }    
};


UIElement.prototype.getHtml = function() {
    return this.element.innerHTML;
};


UIElement.prototype.getElement = function() {
    return this.element;
};


UIElement.prototype.on = function(type, call, externalElement) {
    this.addEvent(type, call, externalElement);
};


UIElement.prototype.once = function(type, call, externalElement) {
    var removeEventCall = (function() {
        this.removeEvent(type, call, externalElement);
    }).bind(this);

    var handler = function(e) {
        call(e);
        removeEventCall();
    };

    this.addEvent(type, handler, externalElement);
};


UIElement.prototype.off = function(type, call, externalElement) {
    this.removeEvent(type, call, externalElement);
};


UIElement.prototype.fire = function(type, event) {
    var hooks = this.events[type];

    if (hooks != null) {
        for (var hook in hooks) {
            hooks[hook](event);
        }
    }
};


UIElement.prototype.addEvent = function(type, call, externalElement) {
    var id = type + '-' + dom.stamp(call)
              + (externalElement ? ('-' + dom.stamp(externalElement)) : '');

    var handler = (function(e) {
        if (this.ui.killed) {
            return; //todo remove event
        }

//        function.call(new UIEvent(type, this, e || window.event));
        call(new UIEvent(type, this, e || window.event));
    }).bind(this);

    var element =  externalElement || this.element;
    element.addEventListener(this.getEventName(type), handler, false);

    if (type == 'mousewheel') {
        element.addEventListener('DOMMouseScroll', handler, false);
    }

    this.events[type] = this.events[type] || [];
    this.events[type][id] = handler;
};


UIElement.prototype.removeEvent = function(type, call, externalElement) {
    var id = type + '-' + dom.stamp(call)
              + (externalElement ? ('-' + dom.stamp(externalElement)) : '');

    var handler = this.events[type] && this.events[type][id];

    if (handler != null) {
        delete this.events[type][id];

        var element =  externalElement || this.element;
        element.removeEventListener(this.getEventName(type), handler, false);
    }
};


UIElement.prototype.getEventName = function(type) {
    return type;
};


UIElement.prototype.setDraggableState = function(state) {
    if (state) {
        this.on('mousedown', this.dragBeginCall);
        this.on('touchstart', this.dragBeginCallTouch);
    } else if (this.dragable){
        this.off('mousedown', this.dragBeginCall);
        this.off('mousemove', this.dragMoveCall, document);
        //this.off("mouseup", this.onDragEnd.bind(this));
        this.off('mouseup', this.dragEndCall, document);
        
        this.off('touchstart', this.dragBeginCallTouch);
        this.off('touchmove', this.dragMoveCallTouch, document);
        this.off('touchend', this.dragEndCallTouch, document);
        
        this.dragging = false;
    }
    
    this.dragStartPos = [0,0];
    this.dragCurrentPos = [0,0];
    this.dragLastPos = [0,0];
    this.dragAbsMoved = [0,0];
    this.dragTouchCount = 0;
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.resetPos = false;
    
    this.dragable = state;
    this.dragButtons = {
        'left' : false,
        'right' : false,
        'middle' : false
    };
};


UIElement.prototype.getDraggableState = function() {
    return this.dragable;
};


UIElement.prototype.getDraggingState = function() {
    return {
        'dragging' : this.dragging,
        'buttonLeft' : this.dragButtons['left'],
        'buttonRight' : this.dragButtons['right'],
        'buttonMiddle' : this.dragButtons['middle'],
        'startPos' : this.dragStartPos.slice(), 
        'lastPos' : this.dragLastPos.slice(), 
        'currentPos' : this.dragCurrentPos.slice(), 
        'absMoved' : this.dragAbsMoved.slice() 
    };
};


UIElement.prototype.onDragBegin = function(touchUsed, event) {
    //console.log("bergin: 1#:  " + JSON.stringify(this.dragButtons));

    this.dragButtons[event.getMouseButton()] = true;

    //console.log("bergin: 2#:  " + JSON.stringify(this.dragButtons));

    //if (event.getTouchesCount() == 2) {
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.dragTouches.push(event.getTouchCoords(0));            
    this.dragTouches2.push(event.getTouchCoords(1));            
    //}

    if (touchUsed) {
        this.resetPos = true;
        this.firstDragDistance = 0;
        this.lastDragDistance = 0;
        this.zoomDrag = false;
    }

    if (!this.dragging) {
        this.dragging = true;
        var pos = event.getMouseCoords();//true);
        this.dragStartPos = [pos[0], pos[1]];
        this.dragCurrentPos = [pos[0], pos[1]];
        this.dragLastPos = [pos[0], pos[1]];
        this.dragAbsMoved = [0,0];

        this.on('mousemove', this.dragMoveCall, document);
        this.on('mouseup', this.dragEndCall, document);
        //this.on("mouseup", this.onDragEnd.bind(this), document);

        this.on('touchmove', this.dragMoveCallTouch, document);
        this.on('touchend', this.dragEndCallTouch, document);

        dom.disableTextSelection();
        dom.disableImageDrag();
        //dom.disableContexMenu();
        dom.preventDefault(event);

        this.dragLastPos[0] = pos[0];
        this.dragLastPos[1] = pos[1];

        this.fire('dragstart', {
            'clientX' : pos[0],
            'clientY' : pos[1],
            'pageX' : pos[0],
            'pageY' : pos[1]
        });
    } else {
        this.dragLastPos = event.getMouseCoords();
    }
};


UIElement.prototype.onDragMove = function(touchUsed, event) {
    var pos = event.getMouseCoords();

    if (event.getTouchesCount() != -1) {
        this.updateDragButtonsState(event, true);
    }

    dom.preventDefault(event);

    var mode = '';
    var zoom = 0;
    var rotateDelta = 0;
    var panDelta = [0,0];
    var distanceDelta = 0;

    //var el = document.getElementById("debug123");

    if (touchUsed) {

        var touchCount = event.getTouchesCount();
        if (touchCount != this.dragTouchCount) {
            this.dragLastPos[0] = pos[0];
            this.dragLastPos[1] = pos[1];
            this.dragTouchCount = touchCount; 
        }

        if (this.resetPos) {
            this.dragCurrentPos = [pos[0], pos[1]];
            this.dragLastPos[0] = pos[0];
            this.dragLastPos[1] = pos[1];
            this.resetPos = false;
        }

        if (touchCount == 2) {
            this.dragTouches.push(event.getTouchCoords(0));            
            this.dragTouches2.push(event.getTouchCoords(1));            

            if (this.dragTouches.length >= 7) {
                this.dragTouches.shift();
                this.dragTouches2.shift();
            }

            if (this.dragTouches.length == 6) {

                //get vector for touch #1
                var t = this.dragTouches;
                var v1x = (t[5][0] - t[4][0]) + (t[4][0] - t[3][0]) + (t[3][0] - t[2][0]) + (t[2][0] - t[1][0]) + (t[1][0] - t[0][0]);
                var v1y = (t[5][1] - t[4][1]) + (t[4][1] - t[3][1]) + (t[3][1] - t[2][1]) + (t[2][1] - t[1][1]) + (t[1][1] - t[0][1]);

                //get vector for touch #2
                var t2 = this.dragTouches2;
                var v2x = (t2[5][0] - t2[4][0]) + (t2[4][0] - t2[3][0]) + (t2[3][0] - t2[2][0]) + (t2[2][0] - t2[1][0]) + (t2[1][0] - t2[0][0]);
                var v2y = (t2[5][1] - t2[4][1]) + (t2[4][1] - t2[3][1]) + (t2[3][1] - t2[2][1]) + (t2[2][1] - t2[1][1]) + (t2[1][1] - t2[0][1]);
                
                //get distance of each vector
                var d1 = Math.sqrt(v1x * v1x + v1y * v1y);
                var d2 = Math.sqrt(v2x * v2x + v2y * v2y);
                var cosAngle, cosAngle2; 

                mode = 'pan';

                if (d1 > d2 * 5 || d2 > d1 * 5) { //dectec situation where only one finger is closing to another

                    var p1, p2, p3;
                    
                    //make first vector from non moving point to beginnig position of moving point
                    //make seconf vector from non moving point to ending position of moving point
                    if (d1 > d2 * 5) {
                        p1 = t2[0];
                        p2 = t[0];
                        p3 = t[5];
                    } else {
                        p1 = t[0];
                        p2 = t2[0];
                        p3 = t2[5];
                    }
                    
                    var v1 = [p2[0] - p1[0], p2[1] - p1[1]];
                    var v2 = [p3[0] - p1[0], p3[1] - p1[1]];

                    //normalize vectors                
                    var d =  Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
                    v1[0] /= d;
                    v1[1] /= d;
                    
                    d =  Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
                    v2[0] /= d;
                    v2[1] /= d;

                    //measure angle between vectors
                    cosAngle = v1[0] * v2[0] + v1[1] * v2[1];
                    cosAngle2 = -v1[1] * v2[0] + v1[0] * v2[1]; //v1 is rotated by 90deg
                    
                    rotateDelta = (Math.acos(cosAngle2) * (180.0/Math.PI)) - 90;

                    if (cosAngle > 0.9999) { //are vectors in same line?
                        mode = 'zoom';
                    } else {
                        panDelta = [(v1x + v2x) *0.5, (v1y + v2y) *0.5];
                    }

                } else if (d1 > 1 && d2 > 1) { //are bouth vectors in motion

                    //normalize vectors
                    var nv1x = v1x / d1;
                    var nv1y = v1y / d1;

                    var nv2x = v2x / d2;
                    var nv2y = v2y / d2;
                    
                    //do vectors move in same direction
                    cosAngle = nv1x * nv2x + nv1y * nv2y;
                    
                    if (cosAngle < 0.2) {
                        mode = 'zoom';
                    } else {
                        panDelta = [(v1x + v2x) *0.5, (v1y + v2y) *0.5];
                    } 
                }
                
                //if (mode == "zoom") {
                t = this.dragTouches;
                t2 = this.dragTouches2;

                //get distance between points at the beginig
                var dx = (t2[0][0] - t[0][0]);
                var dy = (t2[0][1] - t[0][1]);
                d1 = Math.sqrt(dx * dx + dy * dy);

                /*
                //get distance between points at the end
                dx = (t2[5][0] - t[5][0]);
                dy = (t2[5][1] - t[5][1]);
                d2 = Math.sqrt(dx * dx + dy * dy);
                
                //get delta betwwen distances
                distanceDelta = d2 - d1;   
                */

                distanceDelta = 0;   

                for (var i = 1; i < 6; i++) {

                    //get distance between points at the end
                    dx = (t2[i][0] - t[i][0]);
                    dy = (t2[i][1] - t[i][1]);
                    d2 = Math.sqrt(dx * dx + dy * dy);
                    
                    //get delta between distances
                    distanceDelta += d2 - d1;
                    d1 = d2;
                }

                //}  
            }
        }
    }

    this.fire('drag', {
        'clientX' : pos[0],
        'clientY' : pos[1],
        'pageX' : pos[0],
        'pageY' : pos[1],
        'deltaX' : pos[0] - this.dragLastPos[0],
        'deltaY' : pos[1] - this.dragLastPos[1],
        'left' : this.dragButtons['left'],
        'right' : this.dragButtons['right'],
        'middle' : this.dragButtons['middle'],
        'zoom' : zoom,
        'touchMode' : mode,
        'touchPanDelta' : panDelta,
        'touchRotateDelta' : rotateDelta,
        'touchDistanceDelta' : distanceDelta,
        'touches' : (touchUsed) ? touchCount : 0
    });

    //
    //el.innerHTML = "rotDelta" + rotateDelta;

    this.dragLastPos = this.dragCurrentPos;
    this.dragCurrentPos = [pos[0], pos[1]];
    this.dragAbsMoved[0] += Math.abs(pos[0] - this.dragLastPos[0]);
    this.dragAbsMoved[1] += Math.abs(pos[1] - this.dragLastPos[1]);
};

//var debugCoutner = 0;

UIElement.prototype.onDragEnd = function(touchUsed, event) {
    //this.dragButtons[event.getMouseButton()] = false;
    //console.log("end: 1#:  " + JSON.stringify(this.dragButtons));

    var left = this.dragButtons['left'];
    var right = this.dragButtons['right'];
    var middle = this.dragButtons['middle'];

    this.updateDragButtonsState(event, false);

    //if (event.getTouchesCount() == 2) {
    this.dragTouches = [];
    this.dragTouches2 = [];
    this.dragTouches.push(event.getTouchCoords(0));            
    this.dragTouches2.push(event.getTouchCoords(1));            
    //}

    //console.log("end: 2#:  " + JSON.stringify(this.dragButtons));

    if (touchUsed) {
        this.resetPos = true;
        this.firstDragDistance = 0;
        this.lastDragDistance = 0;
        this.zoomDrag = false;
    }

    if (this.dragging) {
        var pos = event.getMouseCoords();
        this.dragLastPos = pos;

        if (!this.dragButtons['left'] &&
            !this.dragButtons['right'] &&
            !this.dragButtons['middle'] ) {

            this.dragging = false;
            pos = this.dragCurrentPos;//event.getMouseCoords();
            this.off('mousemove', this.dragMoveCall, document);
            this.off('mouseup', this.dragEndCall, document);
            //this.off("mouseup", this.onDragEnd.bind(this), document);

            this.off('touchmove', this.dragMoveCallTouch, document);
            this.off('touchend', this.dragEndCallTouch, document);

            dom.enableTextSelection();
            dom.enableImageDrag();
            //dom.enableContexMenu();
            dom.preventDefault(event);

            this.fire('dragend', {
                'clientX' : pos[0],
                'clientY' : pos[1],
                'pageX' : pos[0],
                'pageY' : pos[1],
                'left' : left,
                'right' : right,
                'middle' : middle
            });
        }
    }
};


UIElement.prototype.updateDragButtonsState = function(event, state) {
    switch(event.getTouchesCount()) {
    case -1: this.dragButtons[event.getMouseButton()] = state; break;
    case 0: this.dragButtons = { 'left' : false, 'right' : false, 'middle' : false }; break;
    case 1: this.dragButtons = { 'left' : true, 'right' : false, 'middle' : false }; break;
    case 2: this.dragButtons = { 'left' : false, 'right' : true, 'middle' : false }; break;
    case 3: this.dragButtons = { 'left' : false, 'right' : false, 'middle' : true }; break;
    }        
};



/* harmony default export */ __webpack_exports__["a"] = (UIElement);



/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utility_dom__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__control_holder__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__control_map__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__control_compass__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__control_credits__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__control_fullscreen__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__control_zoom__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__control_space__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__control_search__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__control_link__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__control_github__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__control_layers__ = __webpack_require__(192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__control_fallback__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__control_popup__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__control_loading__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__control_measure__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__control_measure_lite__ = __webpack_require__(196);


var dom = __WEBPACK_IMPORTED_MODULE_0__utility_dom__["a" /* default */];


var utils = __WEBPACK_IMPORTED_MODULE_1__core_utils_utils__["a" /* utils */];


var UIControlHolder = __WEBPACK_IMPORTED_MODULE_2__control_holder__["a" /* default */];


var UIControlMap = __WEBPACK_IMPORTED_MODULE_3__control_map__["a" /* default */];
















//get rid of compiler mess
var UIControlCompass = __WEBPACK_IMPORTED_MODULE_4__control_compass__["a" /* default */];
var UIControlCredits = __WEBPACK_IMPORTED_MODULE_5__control_credits__["a" /* default */];
var UIControlFullscreen = __WEBPACK_IMPORTED_MODULE_6__control_fullscreen__["a" /* default */];
var UIControlZoom = __WEBPACK_IMPORTED_MODULE_7__control_zoom__["a" /* default */];
var UIControlSpace = __WEBPACK_IMPORTED_MODULE_8__control_space__["a" /* default */];
var UIControlSearch = __WEBPACK_IMPORTED_MODULE_9__control_search__["a" /* default */];
var UIControlLink = __WEBPACK_IMPORTED_MODULE_10__control_link__["a" /* default */];
var UIControlGithub = __WEBPACK_IMPORTED_MODULE_11__control_github__["a" /* default */];
var UIControlMeasure = __WEBPACK_IMPORTED_MODULE_16__control_measure__["a" /* UIControlMeasure */];
var UIControlMeasureLite = __WEBPACK_IMPORTED_MODULE_17__control_measure_lite__["a" /* default */];
var UIControlLayers = __WEBPACK_IMPORTED_MODULE_12__control_layers__["a" /* default */];
var UIControlFallback = __WEBPACK_IMPORTED_MODULE_13__control_fallback__["a" /* default */];
var UIControlPopup = __WEBPACK_IMPORTED_MODULE_14__control_popup__["a" /* default */];
var UIControlLoading = __WEBPACK_IMPORTED_MODULE_15__control_loading__["a" /* default */];


var UI = function(browser, element) {
    this.browser = browser;
    this.config = browser.config;
    this.rootElement = element;
    this.element = null;
    this.controls = [];
    this.killed = false;
    this.init();
    this.instanceId = utils.instanceCounter++;

    Object.defineProperty(this, 'dom', {
        get: function() {
            if (this.killed) return;
            return dom;
        }
    });    
};


UI.prototype.init = function() {
    //create browser wrapper
    this.element = document.createElement('div');
    this.element.className = 'vts-browser';
    this.rootElement.appendChild(this.element);

    //create map cotrol
    this.map = new UIControlMap(this);
   
    //create other ui controls
    var loading = this.config.controlLoading;
    this.compass = new UIControlCompass(this, (!loading && this.config.controlCompass), loading);
    this.credits = new UIControlCredits(this, (!loading && this.config.controlCredits), loading);
    //this.logo = new UIControlLogo(this, this.config.controlLogo);
    this.fullscreen = new UIControlFullscreen(this, (!loading && this.config.controlFullscreen), loading);
    this.zoom = new UIControlZoom(this, (!loading && this.config.controlZoom), loading);
    this.space = new UIControlSpace(this, (!loading && this.config.controlSpace), loading);
    this.search = new UIControlSearch(this, (!loading && this.config.controlSearch), loading);
    this.link = new UIControlLink(this, (!loading && this.config.controlLink), loading);
    this.github = new UIControlGithub(this, (!loading && this.config.controlGithub), loading);
    this.measure = new UIControlMeasure(this, (!loading && this.config.controlMeasure), loading);
    this.measure2 = new UIControlMeasureLite(this, (!loading && this.config.controlMeasureLite), loading);
    //this.navigator = new UIControlNavigation(this, this.config.controlNavigator);
    this.layers = new UIControlLayers(this, (!loading && this.config.controlLayers), loading);
    this.fallback = new UIControlFallback(this);
    this.popup = new UIControlPopup(this, false);
    this.loading = new UIControlLoading(this, this.config.controlLoading);

    dom.disableContexMenu(this.element);
};


UI.prototype.kill = function() {
    this.killed = true;

    for (var key in this.controls) {
        delete this.controls[key];
    }

    this.rootElement.removeChild(this.element);
    delete this.element;
    this.element = null;
};


UI.prototype.addControl = function(id, html, visible, visibleLock, parentElement) {
    var control = new UIControlHolder(this, html, visible, visibleLock, parentElement);
    this.controls[id] = control;
    return control;
};


UI.prototype.removeControl = function(id) {
    if (this.controls[id] != null) {
        delete this.controls[id];
    }
};


UI.prototype.setControlHtml = function(id, html) {
    if (this.controls[id] != null) {
        this.controls[id].setHTML(html);
    }
};


UI.prototype.setControlVisible = function(id, state, lockState) {
    if (this.controls[id] != null) {
        if (typeof lockState !== 'undefined') {
            this.controls[id].setVisibleLock(lockState);
        }

        var renderer = this.browser.getRenderer();
        var flags = renderer.getMarginFlags();

        if (id == 'compass') flags |= 1;
        if (id == 'search') flags |= 2;

        if (this.config.bigScreenMargins) {
            flags |= 4096;            
        }

        renderer.setMarginFlags(flags);
       
        this.controls[id].setVisible(state);
    }
};


UI.prototype.getControlVisible = function(id) {
    if (this.controls[id] != null) {
        this.controls[id].getVisible();
    }
};


UI.prototype.getControl = function(id) {
    return this.controls[id];
};


UI.prototype.getMapControl = function() {
    return this.map;
};


UI.prototype.getMapElement = function() {
    return this.map.getMapElement();
};


UI.prototype.setParam = function(key) {
    switch (key) {
    case 'controlCompass':     this.setControlVisible('compass', this.config.controlCompass); break;
    case 'controlZoom':        this.setControlVisible('zoom', this.config.controlZoom); break;
        //case "controlMeasure":     this.setControlVisible(this.config.controlCompass); break;
    case 'controlScale':       this.setControlVisible('scale', this.config.controlScale); break;
    case 'controlLayers':      this.setControlVisible('layers', this.config.controlLayers); break;
    case 'controlSpace':       this.setControlVisible('space', this.config.controlSpace); break;
    case 'controlSearch':      this.setControlVisible('search', this.config.controlSearch); break;
    case 'controlLink':        this.setControlVisible('link', this.config.controlLink); break;
    case 'controlMeasure':     this.setControlVisible('measure', this.config.controlMeasure); break;
    case 'controlLogo':        this.setControlVisible('logo', this.config.controlLogo); break;
    case 'controlFullscreen':  this.setControlVisible('fullscreeen', this.config.controlFullscreen); break;
    case 'controlCredits':     this.setControlVisible('credits', this.config.controlCredits); break;
        //case "controlLoading":     this.setControlVisible("loading", this.config.controlLogo); break;
    }
};


UI.prototype.tick = function(dirty) {
    if (dirty) {
        this.compass.update();
        this.space.update();
        this.credits.update();
        this.link.updateLink();                
        this.search.update();
    }

    if (this.loading.control.getVisible()) {
        this.loading.update();
    }
};


/* harmony default export */ __webpack_exports__["a"] = (UI);




/***/ })
/******/ ]);
//# sourceMappingURL=vts-browser.js.map